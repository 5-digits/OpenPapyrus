/* vetisamsC.cpp
   Generated by gSOAP 2.8.8 from vetisams.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "slib.h"
#include "vetisamsH.h"
#pragma hdrstop

SOAP_SOURCE_STAMP("@(#) vetisamsC.cpp ver 2.8.8 2017-12-02 16:42:21 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void FASTCALL soap_serializeheader(struct soap *soap)
{
	if(soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int FASTCALL soap_putheader(struct soap *soap)
{
	if(soap->header) {
		soap->part = SOAP_IN_HEADER;
		if(soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if(!soap->header) {
		if((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void FASTCALL soap_fault(struct soap *soap)
{
	if(!soap->fault) {
		soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if(!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if(soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if(soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if(soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	return soap->fault ? soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL) : SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2) {
		if(!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode) {
			soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2) {
		if(soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 1) {
		if(!soap->fault->detail) {
			soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if(!soap->fault->SOAP_ENV__Detail) {
		soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if(soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int FASTCALL soap_getindependent(struct soap *soap)
{
	int t;
	if(soap->version == 1) {
		for(;;) {
			if(!soap_getelement(soap, &t))
				if(soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if(oneof2(soap->error, SOAP_NO_TAG, SOAP_EOF))
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	(void)type;
	if(soap_peek_element(soap))
		return NULL;
	if(!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch(*type) {
	case SOAP_TYPE_byte: return soap_in_byte(soap, 0, 0, "xsd:byte");
	case SOAP_TYPE_ns6__Minute: return soap_in_ns6__Minute(soap, 0, 0, "ns6:Minute");
	case SOAP_TYPE_ns6__Hour: return soap_in_ns6__Hour(soap, 0, 0, "ns6:Hour");
	case SOAP_TYPE_ns6__Day: return soap_in_ns6__Day(soap, 0, 0, "ns6:Day");
	case SOAP_TYPE_ns6__Month: return soap_in_ns6__Month(soap, 0, 0, "ns6:Month");
	case SOAP_TYPE_ns6__Year: return soap_in_ns6__Year(soap, 0, 0, "ns6:Year");
	case SOAP_TYPE_int: return soap_in_int(soap, 0, 0, "xsd:int");
	case SOAP_TYPE_LONG64: return soap_in_LONG64(soap, 0, 0, "xsd:long");
	case SOAP_TYPE_unsignedByte: return soap_in_unsignedByte(soap, 0, 0, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt: return soap_in_unsignedInt(soap, 0, 0, "xsd:unsignedInt");
	case SOAP_TYPE_time: return soap_in_time(soap, 0, 0, "xsd:dateTime");
	case SOAP_TYPE_bool: return soap_in_bool(soap, 0, 0, "xsd:boolean");
	case SOAP_TYPE_ns7__AnimalSpentPeriod: return soap_in_ns7__AnimalSpentPeriod(soap, 0, 0, "ns7:AnimalSpentPeriod");
	case SOAP_TYPE_ns7__VetDocumentStatus: return soap_in_ns7__VetDocumentStatus(soap, 0, 0, "ns7:VetDocumentStatus");
	case SOAP_TYPE_ns7__VetDocumentType: return soap_in_ns7__VetDocumentType(soap, 0, 0, "ns7:VetDocumentType");
	case SOAP_TYPE_ns7__VetDocumentForm: return soap_in_ns7__VetDocumentForm(soap, 0, 0, "ns7:VetDocumentForm");
	case SOAP_TYPE_ns7__DeliveryInspectionResult: return soap_in_ns7__DeliveryInspectionResult(soap, 0, 0, "ns7:DeliveryInspectionResult");
	case SOAP_TYPE_ns7__DeliveryDecision: return soap_in_ns7__DeliveryDecision(soap, 0, 0, "ns7:DeliveryDecision");
	case SOAP_TYPE_ns6__ProductMarkingClass: return soap_in_ns6__ProductMarkingClass(soap, 0, 0, "ns6:ProductMarkingClass");
	case SOAP_TYPE_ns6__TransportationStorageType: return soap_in_ns6__TransportationStorageType(soap, 0, 0, "ns6:TransportationStorageType");
	case SOAP_TYPE_ns6__DocumentNature: return soap_in_ns6__DocumentNature(soap, 0, 0, "ns6:DocumentNature");
	case SOAP_TYPE_ns6__EnterpriseRole: return soap_in_ns6__EnterpriseRole(soap, 0, 0, "ns6:EnterpriseRole");
	case SOAP_TYPE_ns7__ProcessingProcedureType: return soap_in_ns7__ProcessingProcedureType(soap, 0, 0, "ns7:ProcessingProcedureType");
	case SOAP_TYPE_ns7__VeterinaryEventType: return soap_in_ns7__VeterinaryEventType(soap, 0, 0, "ns7:VeterinaryEventType");
	case SOAP_TYPE_ns7__StockEntryBlankFilter: return soap_in_ns7__StockEntryBlankFilter(soap, 0, 0, "ns7:StockEntryBlankFilter");
	case SOAP_TYPE_ns6__VaccinationType: return soap_in_ns6__VaccinationType(soap, 0, 0, "ns6:VaccinationType");
	case SOAP_TYPE_ns6__ProsperityType: return soap_in_ns6__ProsperityType(soap, 0, 0, "ns6:ProsperityType");
	case SOAP_TYPE_ns6__RegionalizationDecision: return soap_in_ns6__RegionalizationDecision(soap, 0, 0, "ns6:RegionalizationDecision");
	case SOAP_TYPE_ns6__ResearchResult: return soap_in_ns6__ResearchResult(soap, 0, 0, "ns6:ResearchResult");
	case SOAP_TYPE_ns6__TransportType: return soap_in_ns6__TransportType(soap, 0, 0, "ns6:TransportType");
	case SOAP_TYPE_ns6__ReferenceType: return soap_in_ns6__ReferenceType(soap, 0, 0, "ns6:ReferenceType");
	case SOAP_TYPE_ns6__DocumentType: return soap_in_ns6__DocumentType(soap, 0, 0, "ns6:DocumentType");
	case SOAP_TYPE_ns6__ProductType: return soap_in_ns6__ProductType(soap, 0, 0, "ns6:ProductType");
	case SOAP_TYPE_ns6__BusinessEntityType: return soap_in_ns6__BusinessEntityType(soap, 0, 0, "ns6:BusinessEntityType");
	case SOAP_TYPE_ns6__EnterpriseGroup: return soap_in_ns6__EnterpriseGroup(soap, 0, 0, "ns6:EnterpriseGroup");
	case SOAP_TYPE_ns6__PackingCodeType: return soap_in_ns6__PackingCodeType(soap, 0, 0, "ns6:PackingCodeType");
	case SOAP_TYPE_ns6__PackageLevelType: return soap_in_ns6__PackageLevelType(soap, 0, 0, "ns6:PackageLevelType");
	case SOAP_TYPE_ns4__ContentEncoding: return soap_in_ns4__ContentEncoding(soap, 0, 0, "ns4:ContentEncoding");
	case SOAP_TYPE_ns4__ApplicationStatus: return soap_in_ns4__ApplicationStatus(soap, 0, 0, "ns4:ApplicationStatus");
	case SOAP_TYPE_ns3__RegisterModificationType: return soap_in_ns3__RegisterModificationType(soap, 0, 0, "ns3:RegisterModificationType");
	case SOAP_TYPE_ns4__BinaryContent: return soap_in_ns4__BinaryContent(soap, 0, 0, "ns4:BinaryContent");
	case SOAP_TYPE_ns7__WorkingArea: return soap_in_ns7__WorkingArea(soap, 0, 0, "ns7:WorkingArea");
	case SOAP_TYPE_ns7__UserAuthority: return soap_in_ns7__UserAuthority(soap, 0, 0, "ns7:UserAuthority");
	case SOAP_TYPE_ns7__WorkingAreaList: return soap_in_ns7__WorkingAreaList(soap, 0, 0, "ns7:WorkingAreaList");
	case SOAP_TYPE_ns7__AuthorityList: return soap_in_ns7__AuthorityList(soap, 0, 0, "ns7:AuthorityList");
	case SOAP_TYPE_ns7__UserList: return soap_in_ns7__UserList(soap, 0, 0, "ns7:UserList");
	case SOAP_TYPE_ns7__User: return soap_in_ns7__User(soap, 0, 0, "ns7:User");
	case SOAP_TYPE_ns7__ProcessingProcedure: return soap_in_ns7__ProcessingProcedure(soap, 0, 0, "ns7:ProcessingProcedure");
	case SOAP_TYPE_ns7__RouteSectionR13nRules: return soap_in_ns7__RouteSectionR13nRules(soap, 0, 0, "ns7:RouteSectionR13nRules");
	case SOAP_TYPE_ns7__RegionalizationClause: return soap_in_ns7__RegionalizationClause(soap, 0, 0, "ns7:RegionalizationClause");
	case SOAP_TYPE_ns7__VetDocumentStatusChange: return soap_in_ns7__VetDocumentStatusChange(soap, 0, 0, "ns7:VetDocumentStatusChange");
	case SOAP_TYPE_ns7__StockEntryEventList: return soap_in_ns7__StockEntryEventList(soap, 0, 0, "ns7:StockEntryEventList");
	case SOAP_TYPE_ns7__BatchOrigin: return soap_in_ns7__BatchOrigin(soap, 0, 0, "ns7:BatchOrigin");
	case SOAP_TYPE_ns7__VeterinaryAuthentication: return soap_in_ns7__VeterinaryAuthentication(soap, 0, 0, "ns7:VeterinaryAuthentication");
	case SOAP_TYPE_ns7__QuarantineEvent: return soap_in_ns7__QuarantineEvent(soap, 0, 0, "ns7:QuarantineEvent");
	case SOAP_TYPE_ns7__AnimalMedicationEvent: return soap_in_ns7__AnimalMedicationEvent(soap, 0, 0, "ns7:AnimalMedicationEvent");
	case SOAP_TYPE_ns7__LaboratoryResearchEvent: return soap_in_ns7__LaboratoryResearchEvent(soap, 0, 0, "ns7:LaboratoryResearchEvent");
	case SOAP_TYPE_ns7__VeterinaryEvent: return soap_in_ns7__VeterinaryEvent(soap, 0, 0, "ns7:VeterinaryEvent");
	case SOAP_TYPE_ns7__ReferencedDocument: return soap_in_ns7__ReferencedDocument(soap, 0, 0, "ns7:ReferencedDocument");
	case SOAP_TYPE_ns7__CertifiedConsignment: return soap_in_ns7__CertifiedConsignment(soap, 0, 0, "ns7:CertifiedConsignment");
	case SOAP_TYPE_ns7__CertifiedBatch: return soap_in_ns7__CertifiedBatch(soap, 0, 0, "ns7:CertifiedBatch");
	case SOAP_TYPE_ns7__ENTModificationOperation: return soap_in_ns7__ENTModificationOperation(soap, 0, 0, "ns7:ENTModificationOperation");
	case SOAP_TYPE_ns7__BEActivityLocationsModificationOperation: return soap_in_ns7__BEActivityLocationsModificationOperation(soap, 0, 0, "ns7:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_ns7__BEModificationOperation: return soap_in_ns7__BEModificationOperation(soap, 0, 0, "ns7:BEModificationOperation");
	case SOAP_TYPE_ns7__PSLModificationOperation: return soap_in_ns7__PSLModificationOperation(soap, 0, 0, "ns7:PSLModificationOperation");
	case SOAP_TYPE_ns7__MergeStockEntriesOperation: return soap_in_ns7__MergeStockEntriesOperation(soap, 0, 0, "ns7:MergeStockEntriesOperation");
	case SOAP_TYPE_ns7__ProductionOperation: return soap_in_ns7__ProductionOperation(soap, 0, 0, "ns7:ProductionOperation");
	case SOAP_TYPE_ns7__ShipmentRoute: return soap_in_ns7__ShipmentRoute(soap, 0, 0, "ns7:ShipmentRoute");
	case SOAP_TYPE_ns7__ShipmentRoutePoint: return soap_in_ns7__ShipmentRoutePoint(soap, 0, 0, "ns7:ShipmentRoutePoint");
	case SOAP_TYPE_ns7__TransportNumber: return soap_in_ns7__TransportNumber(soap, 0, 0, "ns7:TransportNumber");
	case SOAP_TYPE_ns7__TransportInfo: return soap_in_ns7__TransportInfo(soap, 0, 0, "ns7:TransportInfo");
	case SOAP_TYPE_ns7__Waybill: return soap_in_ns7__Waybill(soap, 0, 0, "ns7:Waybill");
	case SOAP_TYPE_ns7__Document: return soap_in_ns7__Document(soap, 0, 0, "ns7:Document");
	case SOAP_TYPE_ns7__StockEntrySearchPattern: return soap_in_ns7__StockEntrySearchPattern(soap, 0, 0, "ns7:StockEntrySearchPattern");
	case SOAP_TYPE_ns7__StockDiscrepancy: return soap_in_ns7__StockDiscrepancy(soap, 0, 0, "ns7:StockDiscrepancy");
	case SOAP_TYPE_ns7__StockEntryList: return soap_in_ns7__StockEntryList(soap, 0, 0, "ns7:StockEntryList");
	case SOAP_TYPE_ns7__StockEntry: return soap_in_ns7__StockEntry(soap, 0, 0, "ns7:StockEntry");
	case SOAP_TYPE_ns7__DiscrepancyReason: return soap_in_ns7__DiscrepancyReason(soap, 0, 0, "ns7:DiscrepancyReason");
	case SOAP_TYPE_ns7__DiscrepancyReport: return soap_in_ns7__DiscrepancyReport(soap, 0, 0, "ns7:DiscrepancyReport");
	case SOAP_TYPE_ns7__VetDocumentList: return soap_in_ns7__VetDocumentList(soap, 0, 0, "ns7:VetDocumentList");
	case SOAP_TYPE_ns7__GoodsDate: return soap_in_ns7__GoodsDate(soap, 0, 0, "ns7:GoodsDate");
	case SOAP_TYPE_ns7__ConsignmentDocumentList: return soap_in_ns7__ConsignmentDocumentList(soap, 0, 0, "ns7:ConsignmentDocumentList");
	case SOAP_TYPE_ns7__DeliveryInspection: return soap_in_ns7__DeliveryInspection(soap, 0, 0, "ns7:DeliveryInspection");
	case SOAP_TYPE_ns7__DeliveryFactList: return soap_in_ns7__DeliveryFactList(soap, 0, 0, "ns7:DeliveryFactList");
	case SOAP_TYPE_ns7__Delivery: return soap_in_ns7__Delivery(soap, 0, 0, "ns7:Delivery");
	case SOAP_TYPE_ns7__ProductiveBatch: return soap_in_ns7__ProductiveBatch(soap, 0, 0, "ns7:ProductiveBatch");
	case SOAP_TYPE_ns7__RawBatch: return soap_in_ns7__RawBatch(soap, 0, 0, "ns7:RawBatch");
	case SOAP_TYPE_ns7__Consignment: return soap_in_ns7__Consignment(soap, 0, 0, "ns7:Consignment");
	case SOAP_TYPE_ns7__Batch: return soap_in_ns7__Batch(soap, 0, 0, "ns7:Batch");
	case SOAP_TYPE_ns7__VetDocument: return soap_in_ns7__VetDocument(soap, 0, 0, "ns7:VetDocument");
	case SOAP_TYPE_ns6__ActivityLocationList: return soap_in_ns6__ActivityLocationList(soap, 0, 0, "ns6:ActivityLocationList");
	case SOAP_TYPE_ns6__ResearchMethodList: return soap_in_ns6__ResearchMethodList(soap, 0, 0, "ns6:ResearchMethodList");
	case SOAP_TYPE_ns6__AnimalDiseaseList: return soap_in_ns6__AnimalDiseaseList(soap, 0, 0, "ns6:AnimalDiseaseList");
	case SOAP_TYPE_ns6__RegionalizationShippingRuleList: return soap_in_ns6__RegionalizationShippingRuleList(soap, 0, 0, "ns6:RegionalizationShippingRuleList");
	case SOAP_TYPE_ns6__RegionalizationRegionStatusList: return soap_in_ns6__RegionalizationRegionStatusList(soap, 0, 0, "ns6:RegionalizationRegionStatusList");
	case SOAP_TYPE_ns6__RegionalizationConditionList: return soap_in_ns6__RegionalizationConditionList(soap, 0, 0, "ns6:RegionalizationConditionList");
	case SOAP_TYPE_ns6__Area: return soap_in_ns6__Area(soap, 0, 0, "ns6:Area");
	case SOAP_TYPE_ns6__RegionalizationRegionStatus: return soap_in_ns6__RegionalizationRegionStatus(soap, 0, 0, "ns6:RegionalizationRegionStatus");
	case SOAP_TYPE_ns6__RegionalizationStatus: return soap_in_ns6__RegionalizationStatus(soap, 0, 0, "ns6:RegionalizationStatus");
	case SOAP_TYPE_ns6__RegionalizationShippingRule: return soap_in_ns6__RegionalizationShippingRule(soap, 0, 0, "ns6:RegionalizationShippingRule");
	case SOAP_TYPE_ns6__RegionalizationRequirement: return soap_in_ns6__RegionalizationRequirement(soap, 0, 0, "ns6:RegionalizationRequirement");
	case SOAP_TYPE_ns6__RegionalizationConditionGroup: return soap_in_ns6__RegionalizationConditionGroup(soap, 0, 0, "ns6:RegionalizationConditionGroup");
	case SOAP_TYPE_ns6__RegionalizationCondition: return soap_in_ns6__RegionalizationCondition(soap, 0, 0, "ns6:RegionalizationCondition");
	case SOAP_TYPE_ns6__MedicinalDrug: return soap_in_ns6__MedicinalDrug(soap, 0, 0, "ns6:MedicinalDrug");
	case SOAP_TYPE_ns6__ResearchMethod: return soap_in_ns6__ResearchMethod(soap, 0, 0, "ns6:ResearchMethod");
	case SOAP_TYPE_ns6__AnimalDisease: return soap_in_ns6__AnimalDisease(soap, 0, 0, "ns6:AnimalDisease");
	case SOAP_TYPE_ns6__Indicator: return soap_in_ns6__Indicator(soap, 0, 0, "ns6:Indicator");
	case SOAP_TYPE_ns6__Organization: return soap_in_ns6__Organization(soap, 0, 0, "ns6:Organization");
	case SOAP_TYPE_ns6__EnterpriseOfficialRegistration: return soap_in_ns6__EnterpriseOfficialRegistration(soap, 0, 0, "ns6:EnterpriseOfficialRegistration");
	case SOAP_TYPE_ns6__Location: return soap_in_ns6__Location(soap, 0, 0, "ns6:Location");
	case SOAP_TYPE_ns6__Packaging: return soap_in_ns6__Packaging(soap, 0, 0, "ns6:Packaging");
	case SOAP_TYPE_ns6__ProductItemProducing: return soap_in_ns6__ProductItemProducing(soap, 0, 0, "ns6:ProductItemProducing");
	case SOAP_TYPE_ns6__ComplexDate: return soap_in_ns6__ComplexDate(soap, 0, 0, "ns6:ComplexDate");
	case SOAP_TYPE_ns6__PackageList: return soap_in_ns6__PackageList(soap, 0, 0, "ns6:PackageList");
	case SOAP_TYPE_ns6__Package: return soap_in_ns6__Package(soap, 0, 0, "ns6:Package");
	case SOAP_TYPE_ns6__ProductMarks: return soap_in_ns6__ProductMarks(soap, 0, 0, "ns6:ProductMarks");
	case SOAP_TYPE_ns6__ProductItemList: return soap_in_ns6__ProductItemList(soap, 0, 0, "ns6:ProductItemList");
	case SOAP_TYPE_ns6__SubProductList: return soap_in_ns6__SubProductList(soap, 0, 0, "ns6:SubProductList");
	case SOAP_TYPE_ns6__ProductList: return soap_in_ns6__ProductList(soap, 0, 0, "ns6:ProductList");
	case SOAP_TYPE_ns6__SubProduct: return soap_in_ns6__SubProduct(soap, 0, 0, "ns6:SubProduct");
	case SOAP_TYPE_ns6__Product: return soap_in_ns6__Product(soap, 0, 0, "ns6:Product");
	case SOAP_TYPE_ns6__ProductItem: return soap_in_ns6__ProductItem(soap, 0, 0, "ns6:ProductItem");
	case SOAP_TYPE_ns6__BusinessEntityList: return soap_in_ns6__BusinessEntityList(soap, 0, 0, "ns6:BusinessEntityList");
	case SOAP_TYPE_ns6__IncorporationForm: return soap_in_ns6__IncorporationForm(soap, 0, 0, "ns6:IncorporationForm");
	case SOAP_TYPE_ns6__BusinessEntity: return soap_in_ns6__BusinessEntity(soap, 0, 0, "ns6:BusinessEntity");
	case SOAP_TYPE_ns6__BusinessMember: return soap_in_ns6__BusinessMember(soap, 0, 0, "ns6:BusinessMember");
	case SOAP_TYPE_ns6__EnterpriseList: return soap_in_ns6__EnterpriseList(soap, 0, 0, "ns6:EnterpriseList");
	case SOAP_TYPE_ns6__EnterpriseNumberList: return soap_in_ns6__EnterpriseNumberList(soap, 0, 0, "ns6:EnterpriseNumberList");
	case SOAP_TYPE_ns6__ProducerList: return soap_in_ns6__ProducerList(soap, 0, 0, "ns6:ProducerList");
	case SOAP_TYPE_ns6__Producer: return soap_in_ns6__Producer(soap, 0, 0, "ns6:Producer");
	case SOAP_TYPE_ns6__EnterpriseActivity: return soap_in_ns6__EnterpriseActivity(soap, 0, 0, "ns6:EnterpriseActivity");
	case SOAP_TYPE_ns6__EnterpriseActivityList: return soap_in_ns6__EnterpriseActivityList(soap, 0, 0, "ns6:EnterpriseActivityList");
	case SOAP_TYPE_ns6__Enterprise: return soap_in_ns6__Enterprise(soap, 0, 0, "ns6:Enterprise");
	case SOAP_TYPE_ns6__StreetList: return soap_in_ns6__StreetList(soap, 0, 0, "ns6:StreetList");
	case SOAP_TYPE_ns6__LocalityList: return soap_in_ns6__LocalityList(soap, 0, 0, "ns6:LocalityList");
	case SOAP_TYPE_ns6__DistrictList: return soap_in_ns6__DistrictList(soap, 0, 0, "ns6:DistrictList");
	case SOAP_TYPE_ns6__RegionList: return soap_in_ns6__RegionList(soap, 0, 0, "ns6:RegionList");
	case SOAP_TYPE_ns6__CountryList: return soap_in_ns6__CountryList(soap, 0, 0, "ns6:CountryList");
	case SOAP_TYPE_ns6__Address: return soap_in_ns6__Address(soap, 0, 0, "ns6:Address");
	case SOAP_TYPE_ns6__Street: return soap_in_ns6__Street(soap, 0, 0, "ns6:Street");
	case SOAP_TYPE_ns6__Locality: return soap_in_ns6__Locality(soap, 0, 0, "ns6:Locality");
	case SOAP_TYPE_ns6__District: return soap_in_ns6__District(soap, 0, 0, "ns6:District");
	case SOAP_TYPE_ns6__Region: return soap_in_ns6__Region(soap, 0, 0, "ns6:Region");
	case SOAP_TYPE_ns6__AddressObjectView: return soap_in_ns6__AddressObjectView(soap, 0, 0, "ns6:AddressObjectView");
	case SOAP_TYPE_ns6__FederalDistrict: return soap_in_ns6__FederalDistrict(soap, 0, 0, "ns6:FederalDistrict");
	case SOAP_TYPE_ns6__Country: return soap_in_ns6__Country(soap, 0, 0, "ns6:Country");
	case SOAP_TYPE_ns6__UnitList: return soap_in_ns6__UnitList(soap, 0, 0, "ns6:UnitList");
	case SOAP_TYPE_ns6__PurposeList: return soap_in_ns6__PurposeList(soap, 0, 0, "ns6:PurposeList");
	case SOAP_TYPE_ns6__PackingType: return soap_in_ns6__PackingType(soap, 0, 0, "ns6:PackingType");
	case SOAP_TYPE_ns6__Unit: return soap_in_ns6__Unit(soap, 0, 0, "ns6:Unit");
	case SOAP_TYPE_ns6__Purpose: return soap_in_ns6__Purpose(soap, 0, 0, "ns6:Purpose");
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse: return soap_in_ns5__GetAppliedUserAuthorityListResponse(soap, 0, 0, "ns5:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest: return soap_in_ns5__GetAppliedUserAuthorityListRequest(soap, 0, 0, "ns5:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse: return soap_in_ns5__UnbindBusinessEntityUserResponse(soap, 0, 0, "ns5:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest: return soap_in_ns5__UnbindBusinessEntityUserRequest(soap, 0, 0, "ns5:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse: return soap_in_ns5__UpdateUserWorkingAreasResponse(soap, 0, 0, "ns5:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest: return soap_in_ns5__UpdateUserWorkingAreasRequest(soap, 0, 0, "ns5:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse: return soap_in_ns5__UpdateUserAuthoritiesResponse(soap, 0, 0, "ns5:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest: return soap_in_ns5__UpdateUserAuthoritiesRequest(soap, 0, 0, "ns5:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_ns5__GetBusinessEntityUserResponse: return soap_in_ns5__GetBusinessEntityUserResponse(soap, 0, 0, "ns5:GetBusinessEntityUserResponse");
	case SOAP_TYPE_ns5__GetBusinessEntityUserRequest: return soap_in_ns5__GetBusinessEntityUserRequest(soap, 0, 0, "ns5:GetBusinessEntityUserRequest");
	case SOAP_TYPE_ns5__GetBusinessEntityUserListResponse: return soap_in_ns5__GetBusinessEntityUserListResponse(soap, 0, 0, "ns5:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_ns5__GetBusinessEntityUserListRequest: return soap_in_ns5__GetBusinessEntityUserListRequest(soap, 0, 0, "ns5:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_ns5__AddBusinessEntityUserResponse: return soap_in_ns5__AddBusinessEntityUserResponse(soap, 0, 0, "ns5:AddBusinessEntityUserResponse");
	case SOAP_TYPE_ns5__AddBusinessEntityUserRequest: return soap_in_ns5__AddBusinessEntityUserRequest(soap, 0, 0, "ns5:AddBusinessEntityUserRequest");
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse: return soap_in_ns5__CheckShipmentRegionalizationResponse(soap, 0, 0, "ns5:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest: return soap_in_ns5__CheckShipmentRegionalizationRequest(soap, 0, 0, "ns5:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse: return soap_in_ns5__UpdateVeterinaryEventsResponse(soap, 0, 0, "ns5:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest: return soap_in_ns5__UpdateVeterinaryEventsRequest(soap, 0, 0, "ns5:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse: return soap_in_ns5__UpdateTransportMovementDetailsResponse(soap, 0, 0, "ns5:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest: return soap_in_ns5__UpdateTransportMovementDetailsRequest(soap, 0, 0, "ns5:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_ns5__GetStockEntryVersionListResponse: return soap_in_ns5__GetStockEntryVersionListResponse(soap, 0, 0, "ns5:GetStockEntryVersionListResponse");
	case SOAP_TYPE_ns5__GetStockEntryVersionListRequest: return soap_in_ns5__GetStockEntryVersionListRequest(soap, 0, 0, "ns5:GetStockEntryVersionListRequest");
	case SOAP_TYPE_ns5__GetStockEntryListResponse: return soap_in_ns5__GetStockEntryListResponse(soap, 0, 0, "ns5:GetStockEntryListResponse");
	case SOAP_TYPE_ns5__GetStockEntryListRequest: return soap_in_ns5__GetStockEntryListRequest(soap, 0, 0, "ns5:GetStockEntryListRequest");
	case SOAP_TYPE_ns5__GetStockEntryChangesListResponse: return soap_in_ns5__GetStockEntryChangesListResponse(soap, 0, 0, "ns5:GetStockEntryChangesListResponse");
	case SOAP_TYPE_ns5__GetStockEntryChangesListRequest: return soap_in_ns5__GetStockEntryChangesListRequest(soap, 0, 0, "ns5:GetStockEntryChangesListRequest");
	case SOAP_TYPE_ns5__GetStockEntryByUuidResponse: return soap_in_ns5__GetStockEntryByUuidResponse(soap, 0, 0, "ns5:GetStockEntryByUuidResponse");
	case SOAP_TYPE_ns5__GetStockEntryByUuidRequest: return soap_in_ns5__GetStockEntryByUuidRequest(soap, 0, 0, "ns5:GetStockEntryByUuidRequest");
	case SOAP_TYPE_ns5__GetStockEntryByGuidResponse: return soap_in_ns5__GetStockEntryByGuidResponse(soap, 0, 0, "ns5:GetStockEntryByGuidResponse");
	case SOAP_TYPE_ns5__GetStockEntryByGuidRequest: return soap_in_ns5__GetStockEntryByGuidRequest(soap, 0, 0, "ns5:GetStockEntryByGuidRequest");
	case SOAP_TYPE_ns5__GetVetDocumentChangesListResponse: return soap_in_ns5__GetVetDocumentChangesListResponse(soap, 0, 0, "ns5:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_ns5__GetVetDocumentChangesListRequest: return soap_in_ns5__GetVetDocumentChangesListRequest(soap, 0, 0, "ns5:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_ns5__GetVetDocumentListResponse: return soap_in_ns5__GetVetDocumentListResponse(soap, 0, 0, "ns5:GetVetDocumentListResponse");
	case SOAP_TYPE_ns5__GetVetDocumentListRequest: return soap_in_ns5__GetVetDocumentListRequest(soap, 0, 0, "ns5:GetVetDocumentListRequest");
	case SOAP_TYPE_ns5__GetVetDocumentByUuidResponse: return soap_in_ns5__GetVetDocumentByUuidResponse(soap, 0, 0, "ns5:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_ns5__GetVetDocumentByUuidRequest: return soap_in_ns5__GetVetDocumentByUuidRequest(soap, 0, 0, "ns5:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_ns5__ModifyProducerStockListResponse: return soap_in_ns5__ModifyProducerStockListResponse(soap, 0, 0, "ns5:ModifyProducerStockListResponse");
	case SOAP_TYPE_ns5__ModifyProducerStockListRequest: return soap_in_ns5__ModifyProducerStockListRequest(soap, 0, 0, "ns5:ModifyProducerStockListRequest");
	case SOAP_TYPE_ns5__ResolveDiscrepancyResponse: return soap_in_ns5__ResolveDiscrepancyResponse(soap, 0, 0, "ns5:ResolveDiscrepancyResponse");
	case SOAP_TYPE_ns5__ResolveDiscrepancyRequest: return soap_in_ns5__ResolveDiscrepancyRequest(soap, 0, 0, "ns5:ResolveDiscrepancyRequest");
	case SOAP_TYPE_ns5__ModifyActivityLocationsResponse: return soap_in_ns5__ModifyActivityLocationsResponse(soap, 0, 0, "ns5:ModifyActivityLocationsResponse");
	case SOAP_TYPE_ns5__ModifyActivityLocationsRequest: return soap_in_ns5__ModifyActivityLocationsRequest(soap, 0, 0, "ns5:ModifyActivityLocationsRequest");
	case SOAP_TYPE_ns5__ModifyEnterpriseResponse: return soap_in_ns5__ModifyEnterpriseResponse(soap, 0, 0, "ns5:ModifyEnterpriseResponse");
	case SOAP_TYPE_ns5__ModifyEnterpriseRequest: return soap_in_ns5__ModifyEnterpriseRequest(soap, 0, 0, "ns5:ModifyEnterpriseRequest");
	case SOAP_TYPE_ns5__ModifyBusinessEntityResponse: return soap_in_ns5__ModifyBusinessEntityResponse(soap, 0, 0, "ns5:ModifyBusinessEntityResponse");
	case SOAP_TYPE_ns5__ModifyBusinessEntityRequest: return soap_in_ns5__ModifyBusinessEntityRequest(soap, 0, 0, "ns5:ModifyBusinessEntityRequest");
	case SOAP_TYPE_ns5__WithdrawVetDocumentResponse: return soap_in_ns5__WithdrawVetDocumentResponse(soap, 0, 0, "ns5:WithdrawVetDocumentResponse");
	case SOAP_TYPE_ns5__WithdrawVetDocumentRequest: return soap_in_ns5__WithdrawVetDocumentRequest(soap, 0, 0, "ns5:WithdrawVetDocumentRequest");
	case SOAP_TYPE_ns5__MergeStockEntriesResponse: return soap_in_ns5__MergeStockEntriesResponse(soap, 0, 0, "ns5:MergeStockEntriesResponse");
	case SOAP_TYPE_ns5__MergeStockEntriesRequest: return soap_in_ns5__MergeStockEntriesRequest(soap, 0, 0, "ns5:MergeStockEntriesRequest");
	case SOAP_TYPE_ns5__RegisterProductionOperationResponse: return soap_in_ns5__RegisterProductionOperationResponse(soap, 0, 0, "ns5:RegisterProductionOperationResponse");
	case SOAP_TYPE_ns5__RegisterProductionOperationRequest: return soap_in_ns5__RegisterProductionOperationRequest(soap, 0, 0, "ns5:RegisterProductionOperationRequest");
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse: return soap_in_ns5__PrepareOutgoingConsignmentResponse(soap, 0, 0, "ns5:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest: return soap_in_ns5__PrepareOutgoingConsignmentRequest(soap, 0, 0, "ns5:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse: return soap_in_ns5__ProcessIncomingConsignmentResponse(soap, 0, 0, "ns5:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest: return soap_in_ns5__ProcessIncomingConsignmentRequest(soap, 0, 0, "ns5:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_ns5__MercuryApplicationRequest: return soap_in_ns5__MercuryApplicationRequest(soap, 0, 0, "ns5:MercuryApplicationRequest");
	case SOAP_TYPE_ns4__BusinessError: return soap_in_ns4__BusinessError(soap, 0, 0, "ns4:BusinessError");
	case SOAP_TYPE_ns4__BusinessErrorList: return soap_in_ns4__BusinessErrorList(soap, 0, 0, "ns4:BusinessErrorList");
	case SOAP_TYPE_ns4__ApplicationResultData: return soap_in_ns4__ApplicationResultData(soap, 0, 0, "ns4:ApplicationResultData");
	case SOAP_TYPE_ns4__ApplicationData: return soap_in_ns4__ApplicationData(soap, 0, 0, "ns4:ApplicationData");
	case SOAP_TYPE_ns4__ApplicationResultWrapper: return soap_in_ns4__ApplicationResultWrapper(soap, 0, 0, "ns4:ApplicationResultWrapper");
	case SOAP_TYPE_ns4__ApplicationDataWrapper: return soap_in_ns4__ApplicationDataWrapper(soap, 0, 0, "ns4:ApplicationDataWrapper");
	case SOAP_TYPE_ns4__Application: return soap_in_ns4__Application(soap, 0, 0, "ns4:Application");
	case SOAP_TYPE_ns3__Error: return soap_in_ns3__Error(soap, 0, 0, "ns3:Error");
	case SOAP_TYPE_ns3__FaultInfo: return soap_in_ns3__FaultInfo(soap, 0, 0, "ns3:FaultInfo");
	case SOAP_TYPE_ns3__EntityList: return soap_in_ns3__EntityList(soap, 0, 0, "ns3:EntityList");
	case SOAP_TYPE_ns3__DateInterval: return soap_in_ns3__DateInterval(soap, 0, 0, "ns3:DateInterval");
	case SOAP_TYPE_ns3__ListOptions: return soap_in_ns3__ListOptions(soap, 0, 0, "ns3:ListOptions");
	case SOAP_TYPE_ns3__GenericVersioningEntity: return soap_in_ns3__GenericVersioningEntity(soap, 0, 0, "ns3:GenericVersioningEntity");
	case SOAP_TYPE_ns3__GenericEntity: return soap_in_ns3__GenericEntity(soap, 0, 0, "ns3:GenericEntity");
	case SOAP_TYPE_xsd__base64Binary: return soap_in_xsd__base64Binary(soap, 0, 0, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse: return soap_in_PointerTo_ns8__getActivityLocationListResponse(soap, 0, 0, "ns8:getActivityLocationListResponse");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest: return soap_in_PointerTo_ns8__getActivityLocationListRequest(soap, 0, 0, "ns8:getActivityLocationListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse: return soap_in_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, 0, 0, "ns8:getBusinessMemberByGLNResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest: return soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, 0, 0, "ns8:getBusinessMemberByGLNRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse: return soap_in_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, 0, 0, "ns8:getRussianEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest: return soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, 0, 0, "ns8:getRussianEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse: return soap_in_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, 0, 0, "ns8:getForeignEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest: return soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, 0, 0, "ns8:getForeignEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse: return soap_in_PointerTo_ns8__getRussianEnterpriseListResponse(soap, 0, 0, "ns8:getRussianEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest: return soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(soap, 0, 0, "ns8:getRussianEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse: return soap_in_PointerTo_ns8__getForeignEnterpriseListResponse(soap, 0, 0, "ns8:getForeignEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest: return soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(soap, 0, 0, "ns8:getForeignEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse: return soap_in_PointerTo_ns8__getEnterpriseByUuidResponse(soap, 0, 0, "ns8:getEnterpriseByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest: return soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(soap, 0, 0, "ns8:getEnterpriseByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse: return soap_in_PointerTo_ns8__getEnterpriseByGuidResponse(soap, 0, 0, "ns8:getEnterpriseByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest: return soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(soap, 0, 0, "ns8:getEnterpriseByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse: return soap_in_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, 0, 0, "ns8:getBusinessEntityChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest: return soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, 0, 0, "ns8:getBusinessEntityChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse: return soap_in_PointerTo_ns8__getBusinessEntityListResponse(soap, 0, 0, "ns8:getBusinessEntityListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest: return soap_in_PointerTo_ns8__getBusinessEntityListRequest(soap, 0, 0, "ns8:getBusinessEntityListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse: return soap_in_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, 0, 0, "ns8:getBusinessEntityByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest: return soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, 0, 0, "ns8:getBusinessEntityByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse: return soap_in_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, 0, 0, "ns8:getBusinessEntityByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest: return soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, 0, 0, "ns8:getBusinessEntityByGuidRequest");
	case SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListResponse: return soap_in_PointerTons5__GetAppliedUserAuthorityListResponse(soap, 0, 0, "ns5:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListRequest: return soap_in_PointerTons5__GetAppliedUserAuthorityListRequest(soap, 0, 0, "ns5:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserResponse: return soap_in_PointerTons5__UnbindBusinessEntityUserResponse(soap, 0, 0, "ns5:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserRequest: return soap_in_PointerTons5__UnbindBusinessEntityUserRequest(soap, 0, 0, "ns5:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasResponse: return soap_in_PointerTons5__UpdateUserWorkingAreasResponse(soap, 0, 0, "ns5:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasRequest: return soap_in_PointerTons5__UpdateUserWorkingAreasRequest(soap, 0, 0, "ns5:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesResponse: return soap_in_PointerTons5__UpdateUserAuthoritiesResponse(soap, 0, 0, "ns5:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesRequest: return soap_in_PointerTons5__UpdateUserAuthoritiesRequest(soap, 0, 0, "ns5:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserResponse: return soap_in_PointerTons5__GetBusinessEntityUserResponse(soap, 0, 0, "ns5:GetBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserRequest: return soap_in_PointerTons5__GetBusinessEntityUserRequest(soap, 0, 0, "ns5:GetBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserListResponse: return soap_in_PointerTons5__GetBusinessEntityUserListResponse(soap, 0, 0, "ns5:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserListRequest: return soap_in_PointerTons5__GetBusinessEntityUserListRequest(soap, 0, 0, "ns5:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_PointerTons5__AddBusinessEntityUserResponse: return soap_in_PointerTons5__AddBusinessEntityUserResponse(soap, 0, 0, "ns5:AddBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTons5__AddBusinessEntityUserRequest: return soap_in_PointerTons5__AddBusinessEntityUserRequest(soap, 0, 0, "ns5:AddBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationResponse: return soap_in_PointerTons5__CheckShipmentRegionalizationResponse(soap, 0, 0, "ns5:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationRequest: return soap_in_PointerTons5__CheckShipmentRegionalizationRequest(soap, 0, 0, "ns5:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsResponse: return soap_in_PointerTons5__UpdateVeterinaryEventsResponse(soap, 0, 0, "ns5:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsRequest: return soap_in_PointerTons5__UpdateVeterinaryEventsRequest(soap, 0, 0, "ns5:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsResponse: return soap_in_PointerTons5__UpdateTransportMovementDetailsResponse(soap, 0, 0, "ns5:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsRequest: return soap_in_PointerTons5__UpdateTransportMovementDetailsRequest(soap, 0, 0, "ns5:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryVersionListResponse: return soap_in_PointerTons5__GetStockEntryVersionListResponse(soap, 0, 0, "ns5:GetStockEntryVersionListResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryVersionListRequest: return soap_in_PointerTons5__GetStockEntryVersionListRequest(soap, 0, 0, "ns5:GetStockEntryVersionListRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryChangesListResponse: return soap_in_PointerTons5__GetStockEntryChangesListResponse(soap, 0, 0, "ns5:GetStockEntryChangesListResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryChangesListRequest: return soap_in_PointerTons5__GetStockEntryChangesListRequest(soap, 0, 0, "ns5:GetStockEntryChangesListRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryListResponse: return soap_in_PointerTons5__GetStockEntryListResponse(soap, 0, 0, "ns5:GetStockEntryListResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryListRequest: return soap_in_PointerTons5__GetStockEntryListRequest(soap, 0, 0, "ns5:GetStockEntryListRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryByUuidResponse: return soap_in_PointerTons5__GetStockEntryByUuidResponse(soap, 0, 0, "ns5:GetStockEntryByUuidResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryByUuidRequest: return soap_in_PointerTons5__GetStockEntryByUuidRequest(soap, 0, 0, "ns5:GetStockEntryByUuidRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryByGuidResponse: return soap_in_PointerTons5__GetStockEntryByGuidResponse(soap, 0, 0, "ns5:GetStockEntryByGuidResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryByGuidRequest: return soap_in_PointerTons5__GetStockEntryByGuidRequest(soap, 0, 0, "ns5:GetStockEntryByGuidRequest");
	case SOAP_TYPE_PointerTons5__GetVetDocumentChangesListResponse: return soap_in_PointerTons5__GetVetDocumentChangesListResponse(soap, 0, 0, "ns5:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_PointerTons5__GetVetDocumentChangesListRequest: return soap_in_PointerTons5__GetVetDocumentChangesListRequest(soap, 0, 0, "ns5:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_PointerTons5__GetVetDocumentListResponse: return soap_in_PointerTons5__GetVetDocumentListResponse(soap, 0, 0, "ns5:GetVetDocumentListResponse");
	case SOAP_TYPE_PointerTons5__GetVetDocumentListRequest: return soap_in_PointerTons5__GetVetDocumentListRequest(soap, 0, 0, "ns5:GetVetDocumentListRequest");
	case SOAP_TYPE_PointerTons5__GetVetDocumentByUuidResponse: return soap_in_PointerTons5__GetVetDocumentByUuidResponse(soap, 0, 0, "ns5:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_PointerTons5__GetVetDocumentByUuidRequest: return soap_in_PointerTons5__GetVetDocumentByUuidRequest(soap, 0, 0, "ns5:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_PointerTons5__ModifyProducerStockListResponse: return soap_in_PointerTons5__ModifyProducerStockListResponse(soap, 0, 0, "ns5:ModifyProducerStockListResponse");
	case SOAP_TYPE_PointerTons5__ModifyProducerStockListRequest: return soap_in_PointerTons5__ModifyProducerStockListRequest(soap, 0, 0, "ns5:ModifyProducerStockListRequest");
	case SOAP_TYPE_PointerTons5__ResolveDiscrepancyResponse: return soap_in_PointerTons5__ResolveDiscrepancyResponse(soap, 0, 0, "ns5:ResolveDiscrepancyResponse");
	case SOAP_TYPE_PointerTons5__ResolveDiscrepancyRequest: return soap_in_PointerTons5__ResolveDiscrepancyRequest(soap, 0, 0, "ns5:ResolveDiscrepancyRequest");
	case SOAP_TYPE_PointerTons5__ModifyActivityLocationsResponse: return soap_in_PointerTons5__ModifyActivityLocationsResponse(soap, 0, 0, "ns5:ModifyActivityLocationsResponse");
	case SOAP_TYPE_PointerTons5__ModifyActivityLocationsRequest: return soap_in_PointerTons5__ModifyActivityLocationsRequest(soap, 0, 0, "ns5:ModifyActivityLocationsRequest");
	case SOAP_TYPE_PointerTons5__ModifyEnterpriseResponse: return soap_in_PointerTons5__ModifyEnterpriseResponse(soap, 0, 0, "ns5:ModifyEnterpriseResponse");
	case SOAP_TYPE_PointerTons5__ModifyEnterpriseRequest: return soap_in_PointerTons5__ModifyEnterpriseRequest(soap, 0, 0, "ns5:ModifyEnterpriseRequest");
	case SOAP_TYPE_PointerTons5__ModifyBusinessEntityResponse: return soap_in_PointerTons5__ModifyBusinessEntityResponse(soap, 0, 0, "ns5:ModifyBusinessEntityResponse");
	case SOAP_TYPE_PointerTons5__ModifyBusinessEntityRequest: return soap_in_PointerTons5__ModifyBusinessEntityRequest(soap, 0, 0, "ns5:ModifyBusinessEntityRequest");
	case SOAP_TYPE_PointerTons5__WithdrawVetDocumentResponse: return soap_in_PointerTons5__WithdrawVetDocumentResponse(soap, 0, 0, "ns5:WithdrawVetDocumentResponse");
	case SOAP_TYPE_PointerTons5__WithdrawVetDocumentRequest: return soap_in_PointerTons5__WithdrawVetDocumentRequest(soap, 0, 0, "ns5:WithdrawVetDocumentRequest");
	case SOAP_TYPE_PointerTons5__MergeStockEntriesResponse: return soap_in_PointerTons5__MergeStockEntriesResponse(soap, 0, 0, "ns5:MergeStockEntriesResponse");
	case SOAP_TYPE_PointerTons5__MergeStockEntriesRequest: return soap_in_PointerTons5__MergeStockEntriesRequest(soap, 0, 0, "ns5:MergeStockEntriesRequest");
	case SOAP_TYPE_PointerTons5__RegisterProductionOperationResponse: return soap_in_PointerTons5__RegisterProductionOperationResponse(soap, 0, 0, "ns5:RegisterProductionOperationResponse");
	case SOAP_TYPE_PointerTons5__RegisterProductionOperationRequest: return soap_in_PointerTons5__RegisterProductionOperationRequest(soap, 0, 0, "ns5:RegisterProductionOperationRequest");
	case SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentResponse: return soap_in_PointerTons5__PrepareOutgoingConsignmentResponse(soap, 0, 0, "ns5:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentRequest: return soap_in_PointerTons5__PrepareOutgoingConsignmentRequest(soap, 0, 0, "ns5:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentResponse: return soap_in_PointerTons5__ProcessIncomingConsignmentResponse(soap, 0, 0, "ns5:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentRequest: return soap_in_PointerTons5__ProcessIncomingConsignmentRequest(soap, 0, 0, "ns5:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_PointerTo_ns1__receiveApplicationResultResponse: return soap_in_PointerTo_ns1__receiveApplicationResultResponse(soap, 0, 0, "ns1:receiveApplicationResultResponse");
	case SOAP_TYPE_PointerTo_ns1__receiveApplicationResultRequest: return soap_in_PointerTo_ns1__receiveApplicationResultRequest(soap, 0, 0, "ns1:receiveApplicationResultRequest");
	case SOAP_TYPE_PointerTo_ns1__submitApplicationResponse: return soap_in_PointerTo_ns1__submitApplicationResponse(soap, 0, 0, "ns1:submitApplicationResponse");
	case SOAP_TYPE_PointerTo_ns1__submitApplicationRequest: return soap_in_PointerTo_ns1__submitApplicationRequest(soap, 0, 0, "ns1:submitApplicationRequest");
	case SOAP_TYPE_PointerTons3__FaultInfo: return soap_in_PointerTons3__FaultInfo(soap, 0, 0, "ns3:FaultInfo");
	case SOAP_TYPE_PointerTons7__StockEntryBlankFilter: return soap_in_PointerTons7__StockEntryBlankFilter(soap, 0, 0, "ns7:StockEntryBlankFilter");
	case SOAP_TYPE_PointerTons7__StockEntryEventList: return soap_in_PointerTons7__StockEntryEventList(soap, 0, 0, "ns7:StockEntryEventList");
	case SOAP_TYPE_PointerTons7__DiscrepancyReason: return soap_in_PointerTons7__DiscrepancyReason(soap, 0, 0, "ns7:DiscrepancyReason");
	case SOAP_TYPE_PointerToPointerTons7__VetDocumentStatusChange: return soap_in_PointerToPointerTons7__VetDocumentStatusChange(soap, 0, 0, "ns7:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTons7__VetDocumentStatusChange: return soap_in_PointerTons7__VetDocumentStatusChange(soap, 0, 0, "ns7:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTons7__VeterinaryAuthentication: return soap_in_PointerTons7__VeterinaryAuthentication(soap, 0, 0, "ns7:VeterinaryAuthentication");
	case SOAP_TYPE_PointerTons7__CertifiedConsignment: return soap_in_PointerTons7__CertifiedConsignment(soap, 0, 0, "ns7:CertifiedConsignment");
	case SOAP_TYPE_PointerTons7__CertifiedBatch: return soap_in_PointerTons7__CertifiedBatch(soap, 0, 0, "ns7:CertifiedBatch");
	case SOAP_TYPE_PointerTons7__VetDocumentForm: return soap_in_PointerTons7__VetDocumentForm(soap, 0, 0, "ns7:VetDocumentForm");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationStatus: return soap_in_PointerToPointerTons6__RegionalizationStatus(soap, 0, 0, "ns6:RegionalizationStatus");
	case SOAP_TYPE_PointerToPointerTons6__Area: return soap_in_PointerToPointerTons6__Area(soap, 0, 0, "ns6:Area");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationRequirement: return soap_in_PointerToPointerTons6__RegionalizationRequirement(soap, 0, 0, "ns6:RegionalizationRequirement");
	case SOAP_TYPE_PointerTons6__RegionalizationRequirement: return soap_in_PointerTons6__RegionalizationRequirement(soap, 0, 0, "ns6:RegionalizationRequirement");
	case SOAP_TYPE_PointerTons6__RegionalizationDecision: return soap_in_PointerTons6__RegionalizationDecision(soap, 0, 0, "ns6:RegionalizationDecision");
	case SOAP_TYPE_PointerTons6__RegionalizationStatus: return soap_in_PointerTons6__RegionalizationStatus(soap, 0, 0, "ns6:RegionalizationStatus");
	case SOAP_TYPE_PointerTons6__Packaging: return soap_in_PointerTons6__Packaging(soap, 0, 0, "ns6:Packaging");
	case SOAP_TYPE_PointerToPointerTons6__ProductItemProducing: return soap_in_PointerToPointerTons6__ProductItemProducing(soap, 0, 0, "ns6:ProductItemProducing");
	case SOAP_TYPE_PointerTons6__ProductItemProducing: return soap_in_PointerTons6__ProductItemProducing(soap, 0, 0, "ns6:ProductItemProducing");
	case SOAP_TYPE_PointerTo_ns6__BusinessEntity_activityLocation: return soap_in_PointerTo_ns6__BusinessEntity_activityLocation(soap, 0, 0, "ns6:BusinessEntity-activityLocation");
	case SOAP_TYPE_PointerTons6__IncorporationForm: return soap_in_PointerTons6__IncorporationForm(soap, 0, 0, "ns6:IncorporationForm");
	case SOAP_TYPE_PointerTons6__BusinessEntityType: return soap_in_PointerTons6__BusinessEntityType(soap, 0, 0, "ns6:BusinessEntityType");
	case SOAP_TYPE_PointerToPointerTons6__EnterpriseOfficialRegistration: return soap_in_PointerToPointerTons6__EnterpriseOfficialRegistration(soap, 0, 0, "ns6:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration: return soap_in_PointerTons6__EnterpriseOfficialRegistration(soap, 0, 0, "ns6:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTons6__EnterpriseActivityList: return soap_in_PointerTons6__EnterpriseActivityList(soap, 0, 0, "ns6:EnterpriseActivityList");
	case SOAP_TYPE_PointerTons6__EnterpriseNumberList: return soap_in_PointerTons6__EnterpriseNumberList(soap, 0, 0, "ns6:EnterpriseNumberList");
	case SOAP_TYPE_PointerTons6__EnterpriseType: return soap_in_PointerTons6__EnterpriseType(soap, 0, 0, "ns6:EnterpriseType");
	case SOAP_TYPE_PointerTons6__PackingCodeType: return soap_in_PointerTons6__PackingCodeType(soap, 0, 0, "ns6:PackingCodeType");
	case SOAP_TYPE_PointerTons3__UUID: return soap_in_PointerTons3__UUID(soap, 0, 0, "ns3:UUID");
	case SOAP_TYPE_PointerTons7__StockEntrySearchPattern: return soap_in_PointerTons7__StockEntrySearchPattern(soap, 0, 0, "ns7:StockEntrySearchPattern");
	case SOAP_TYPE_PointerTons7__VetDocumentStatus: return soap_in_PointerTons7__VetDocumentStatus(soap, 0, 0, "ns7:VetDocumentStatus");
	case SOAP_TYPE_PointerTons7__VetDocumentType: return soap_in_PointerTons7__VetDocumentType(soap, 0, 0, "ns7:VetDocumentType");
	case SOAP_TYPE_PointerTons7__PSLModificationOperation: return soap_in_PointerTons7__PSLModificationOperation(soap, 0, 0, "ns7:PSLModificationOperation");
	case SOAP_TYPE_PointerToPointerTons7__StockDiscrepancy: return soap_in_PointerToPointerTons7__StockDiscrepancy(soap, 0, 0, "ns7:StockDiscrepancy");
	case SOAP_TYPE_PointerTons7__StockDiscrepancy: return soap_in_PointerTons7__StockDiscrepancy(soap, 0, 0, "ns7:StockDiscrepancy");
	case SOAP_TYPE_PointerTons7__BEActivityLocationsModificationOperation: return soap_in_PointerTons7__BEActivityLocationsModificationOperation(soap, 0, 0, "ns7:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_PointerTons7__ENTModificationOperation: return soap_in_PointerTons7__ENTModificationOperation(soap, 0, 0, "ns7:ENTModificationOperation");
	case SOAP_TYPE_PointerTons7__BEModificationOperation: return soap_in_PointerTons7__BEModificationOperation(soap, 0, 0, "ns7:BEModificationOperation");
	case SOAP_TYPE_PointerTons7__MergeStockEntriesOperation: return soap_in_PointerTons7__MergeStockEntriesOperation(soap, 0, 0, "ns7:MergeStockEntriesOperation");
	case SOAP_TYPE_PointerTons7__ProductionOperation: return soap_in_PointerTons7__ProductionOperation(soap, 0, 0, "ns7:ProductionOperation");
	case SOAP_TYPE_PointerToPointerTons7__Delivery: return soap_in_PointerToPointerTons7__Delivery(soap, 0, 0, "ns7:Delivery");
	case SOAP_TYPE_PointerToPointerTons7__DiscrepancyReport: return soap_in_PointerToPointerTons7__DiscrepancyReport(soap, 0, 0, "ns7:DiscrepancyReport");
	case SOAP_TYPE_PointerTons7__DiscrepancyReport: return soap_in_PointerTons7__DiscrepancyReport(soap, 0, 0, "ns7:DiscrepancyReport");
	case SOAP_TYPE_PointerTons7__DeliveryFactList: return soap_in_PointerTons7__DeliveryFactList(soap, 0, 0, "ns7:DeliveryFactList");
	case SOAP_TYPE_PointerTons7__Delivery: return soap_in_PointerTons7__Delivery(soap, 0, 0, "ns7:Delivery");
	case SOAP_TYPE_PointerToPointerTons7__WorkingArea: return soap_in_PointerToPointerTons7__WorkingArea(soap, 0, 0, "ns7:WorkingArea");
	case SOAP_TYPE_PointerTons7__WorkingArea: return soap_in_PointerTons7__WorkingArea(soap, 0, 0, "ns7:WorkingArea");
	case SOAP_TYPE_PointerTons7__WorkingAreaList: return soap_in_PointerTons7__WorkingAreaList(soap, 0, 0, "ns7:WorkingAreaList");
	case SOAP_TYPE_PointerTons7__SNILSType: return soap_in_PointerTons7__SNILSType(soap, 0, 0, "ns7:SNILSType");
	case SOAP_TYPE_PointerTons6__MedicinalDrug: return soap_in_PointerTons6__MedicinalDrug(soap, 0, 0, "ns6:MedicinalDrug");
	case SOAP_TYPE_PointerTons6__Indicator: return soap_in_PointerTons6__Indicator(soap, 0, 0, "ns6:Indicator");
	case SOAP_TYPE_PointerTons6__DocumentType: return soap_in_PointerTons6__DocumentType(soap, 0, 0, "ns6:DocumentType");
	case SOAP_TYPE_PointerTons7__ConsignmentDocumentList: return soap_in_PointerTons7__ConsignmentDocumentList(soap, 0, 0, "ns7:ConsignmentDocumentList");
	case SOAP_TYPE_PointerToPointerTons7__Consignment: return soap_in_PointerToPointerTons7__Consignment(soap, 0, 0, "ns7:Consignment");
	case SOAP_TYPE_PointerTons7__Consignment: return soap_in_PointerTons7__Consignment(soap, 0, 0, "ns7:Consignment");
	case SOAP_TYPE_PointerToPointerTons6__BusinessMember: return soap_in_PointerToPointerTons6__BusinessMember(soap, 0, 0, "ns6:BusinessMember");
	case SOAP_TYPE_PointerToPointerTons6__ResearchMethod: return soap_in_PointerToPointerTons6__ResearchMethod(soap, 0, 0, "ns6:ResearchMethod");
	case SOAP_TYPE_PointerToPointerTons6__AnimalDisease: return soap_in_PointerToPointerTons6__AnimalDisease(soap, 0, 0, "ns6:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationRegionStatus: return soap_in_PointerToPointerTons6__RegionalizationRegionStatus(soap, 0, 0, "ns6:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerTons6__RegionalizationRegionStatus: return soap_in_PointerTons6__RegionalizationRegionStatus(soap, 0, 0, "ns6:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToPointerTons6__ProductItem: return soap_in_PointerToPointerTons6__ProductItem(soap, 0, 0, "ns6:ProductItem");
	case SOAP_TYPE_PointerToPointerTons6__SubProduct: return soap_in_PointerToPointerTons6__SubProduct(soap, 0, 0, "ns6:SubProduct");
	case SOAP_TYPE_PointerToPointerTons6__Product: return soap_in_PointerToPointerTons6__Product(soap, 0, 0, "ns6:Product");
	case SOAP_TYPE_PointerToPointerTons6__EnterpriseActivity: return soap_in_PointerToPointerTons6__EnterpriseActivity(soap, 0, 0, "ns6:EnterpriseActivity");
	case SOAP_TYPE_PointerTons6__EnterpriseActivity: return soap_in_PointerTons6__EnterpriseActivity(soap, 0, 0, "ns6:EnterpriseActivity");
	case SOAP_TYPE_PointerToPointerTons6__Street: return soap_in_PointerToPointerTons6__Street(soap, 0, 0, "ns6:Street");
	case SOAP_TYPE_PointerToPointerTons6__Locality: return soap_in_PointerToPointerTons6__Locality(soap, 0, 0, "ns6:Locality");
	case SOAP_TYPE_PointerToPointerTons6__District: return soap_in_PointerToPointerTons6__District(soap, 0, 0, "ns6:District");
	case SOAP_TYPE_PointerToPointerTons6__Region: return soap_in_PointerToPointerTons6__Region(soap, 0, 0, "ns6:Region");
	case SOAP_TYPE_PointerToPointerTons6__Country: return soap_in_PointerToPointerTons6__Country(soap, 0, 0, "ns6:Country");
	case SOAP_TYPE_PointerToPointerTons6__Unit: return soap_in_PointerToPointerTons6__Unit(soap, 0, 0, "ns6:Unit");
	case SOAP_TYPE_PointerToPointerTons6__Purpose: return soap_in_PointerToPointerTons6__Purpose(soap, 0, 0, "ns6:Purpose");
	case SOAP_TYPE_PointerTons7__AuthorityList: return soap_in_PointerTons7__AuthorityList(soap, 0, 0, "ns7:AuthorityList");
	case SOAP_TYPE_PointerTons7__UserList: return soap_in_PointerTons7__UserList(soap, 0, 0, "ns7:UserList");
	case SOAP_TYPE_PointerToPointerTons7__User: return soap_in_PointerToPointerTons7__User(soap, 0, 0, "ns7:User");
	case SOAP_TYPE_PointerToPointerTons7__RouteSectionR13nRules: return soap_in_PointerToPointerTons7__RouteSectionR13nRules(soap, 0, 0, "ns7:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTons7__RouteSectionR13nRules: return soap_in_PointerTons7__RouteSectionR13nRules(soap, 0, 0, "ns7:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTons7__VetDocumentList: return soap_in_PointerTons7__VetDocumentList(soap, 0, 0, "ns7:VetDocumentList");
	case SOAP_TYPE_PointerToPointerTons6__Enterprise: return soap_in_PointerToPointerTons6__Enterprise(soap, 0, 0, "ns6:Enterprise");
	case SOAP_TYPE_PointerToPointerTons6__BusinessEntity: return soap_in_PointerToPointerTons6__BusinessEntity(soap, 0, 0, "ns6:BusinessEntity");
	case SOAP_TYPE_PointerTons6__OTPToken: return soap_in_PointerTons6__OTPToken(soap, 0, 0, "ns6:OTPToken");
	case SOAP_TYPE_PointerTons3__VersionStatus: return soap_in_PointerTons3__VersionStatus(soap, 0, 0, "ns3:VersionStatus");
	case SOAP_TYPE_PointerTons6__ResearchMethodList: return soap_in_PointerTons6__ResearchMethodList(soap, 0, 0, "ns6:ResearchMethodList");
	case SOAP_TYPE_PointerTons6__ResearchMethod: return soap_in_PointerTons6__ResearchMethod(soap, 0, 0, "ns6:ResearchMethod");
	case SOAP_TYPE_PointerTons6__AnimalDiseaseList: return soap_in_PointerTons6__AnimalDiseaseList(soap, 0, 0, "ns6:AnimalDiseaseList");
	case SOAP_TYPE_PointerTons6__RegionalizationShippingRuleList: return soap_in_PointerTons6__RegionalizationShippingRuleList(soap, 0, 0, "ns6:RegionalizationShippingRuleList");
	case SOAP_TYPE_PointerTons6__RegionalizationRegionStatusList: return soap_in_PointerTons6__RegionalizationRegionStatusList(soap, 0, 0, "ns6:RegionalizationRegionStatusList");
	case SOAP_TYPE_PointerTons6__RegionalizationConditionList: return soap_in_PointerTons6__RegionalizationConditionList(soap, 0, 0, "ns6:RegionalizationConditionList");
	case SOAP_TYPE_PointerTons6__ActivityLocationList: return soap_in_PointerTons6__ActivityLocationList(soap, 0, 0, "ns6:ActivityLocationList");
	case SOAP_TYPE_PointerTons6__EnterpriseGroup: return soap_in_PointerTons6__EnterpriseGroup(soap, 0, 0, "ns6:EnterpriseGroup");
	case SOAP_TYPE_PointerTons6__StreetList: return soap_in_PointerTons6__StreetList(soap, 0, 0, "ns6:StreetList");
	case SOAP_TYPE_PointerTons6__LocalityList: return soap_in_PointerTons6__LocalityList(soap, 0, 0, "ns6:LocalityList");
	case SOAP_TYPE_PointerTons6__DistrictList: return soap_in_PointerTons6__DistrictList(soap, 0, 0, "ns6:DistrictList");
	case SOAP_TYPE_PointerTons6__RegionList: return soap_in_PointerTons6__RegionList(soap, 0, 0, "ns6:RegionList");
	case SOAP_TYPE_PointerTons6__CountryList: return soap_in_PointerTons6__CountryList(soap, 0, 0, "ns6:CountryList");
	case SOAP_TYPE_PointerTons6__SubProductList: return soap_in_PointerTons6__SubProductList(soap, 0, 0, "ns6:SubProductList");
	case SOAP_TYPE_PointerTons6__ProductList: return soap_in_PointerTons6__ProductList(soap, 0, 0, "ns6:ProductList");
	case SOAP_TYPE_PointerTons6__UnitList: return soap_in_PointerTons6__UnitList(soap, 0, 0, "ns6:UnitList");
	case SOAP_TYPE_PointerTons3__DateInterval: return soap_in_PointerTons3__DateInterval(soap, 0, 0, "ns3:DateInterval");
	case SOAP_TYPE_PointerTons6__PurposeList: return soap_in_PointerTons6__PurposeList(soap, 0, 0, "ns6:PurposeList");
	case SOAP_TYPE_PointerTons3__ListOptions: return soap_in_PointerTons3__ListOptions(soap, 0, 0, "ns3:ListOptions");
	case SOAP_TYPE_PointerTons6__Area: return soap_in_PointerTons6__Area(soap, 0, 0, "ns6:Area");
	case SOAP_TYPE_PointerToPointerTons7__UserAuthority: return soap_in_PointerToPointerTons7__UserAuthority(soap, 0, 0, "ns7:UserAuthority");
	case SOAP_TYPE_PointerTons7__UserAuthority: return soap_in_PointerTons7__UserAuthority(soap, 0, 0, "ns7:UserAuthority");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationShippingRule: return soap_in_PointerToPointerTons6__RegionalizationShippingRule(soap, 0, 0, "ns6:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTons6__RegionalizationShippingRule: return soap_in_PointerTons6__RegionalizationShippingRule(soap, 0, 0, "ns6:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTons3__SequenceNumber: return soap_in_PointerTons3__SequenceNumber(soap, 0, 0, "ns3:SequenceNumber");
	case SOAP_TYPE_PointerToPointerTons7__QuarantineEvent: return soap_in_PointerToPointerTons7__QuarantineEvent(soap, 0, 0, "ns7:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTons7__RegionalizationClause: return soap_in_PointerToPointerTons7__RegionalizationClause(soap, 0, 0, "ns7:RegionalizationClause");
	case SOAP_TYPE_PointerTons7__RegionalizationClause: return soap_in_PointerTons7__RegionalizationClause(soap, 0, 0, "ns7:RegionalizationClause");
	case SOAP_TYPE_PointerToPointerTons7__VeterinaryEvent: return soap_in_PointerToPointerTons7__VeterinaryEvent(soap, 0, 0, "ns7:VeterinaryEvent");
	case SOAP_TYPE_PointerTons7__VeterinaryEvent: return soap_in_PointerTons7__VeterinaryEvent(soap, 0, 0, "ns7:VeterinaryEvent");
	case SOAP_TYPE_PointerToPointerTons7__AnimalMedicationEvent: return soap_in_PointerToPointerTons7__AnimalMedicationEvent(soap, 0, 0, "ns7:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTons7__AnimalMedicationEvent: return soap_in_PointerTons7__AnimalMedicationEvent(soap, 0, 0, "ns7:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTons7__QuarantineEvent: return soap_in_PointerTons7__QuarantineEvent(soap, 0, 0, "ns7:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTons7__LaboratoryResearchEvent: return soap_in_PointerToPointerTons7__LaboratoryResearchEvent(soap, 0, 0, "ns7:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTons7__LaboratoryResearchEvent: return soap_in_PointerTons7__LaboratoryResearchEvent(soap, 0, 0, "ns7:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTons7__AnimalSpentPeriod: return soap_in_PointerTons7__AnimalSpentPeriod(soap, 0, 0, "ns7:AnimalSpentPeriod");
	case SOAP_TYPE_PointerTons6__ResearchResult: return soap_in_PointerTons6__ResearchResult(soap, 0, 0, "ns6:ResearchResult");
	case SOAP_TYPE_PointerTons6__Purpose: return soap_in_PointerTons6__Purpose(soap, 0, 0, "ns6:Purpose");
	case SOAP_TYPE_PointerToPointerTons7__Document: return soap_in_PointerToPointerTons7__Document(soap, 0, 0, "ns7:Document");
	case SOAP_TYPE_PointerTons7__Document: return soap_in_PointerTons7__Document(soap, 0, 0, "ns7:Document");
	case SOAP_TYPE_PointerTons6__Organization: return soap_in_PointerTons6__Organization(soap, 0, 0, "ns6:Organization");
	case SOAP_TYPE_PointerTons6__Location: return soap_in_PointerTons6__Location(soap, 0, 0, "ns6:Location");
	case SOAP_TYPE_PointerTons7__VeterinaryEventType: return soap_in_PointerTons7__VeterinaryEventType(soap, 0, 0, "ns7:VeterinaryEventType");
	case SOAP_TYPE_PointerTons7__ShipmentRoute: return soap_in_PointerTons7__ShipmentRoute(soap, 0, 0, "ns7:ShipmentRoute");
	case SOAP_TYPE_PointerTons6__TransportationStorageType: return soap_in_PointerTons6__TransportationStorageType(soap, 0, 0, "ns6:TransportationStorageType");
	case SOAP_TYPE_PointerTons7__TransportInfo: return soap_in_PointerTons7__TransportInfo(soap, 0, 0, "ns7:TransportInfo");
	case SOAP_TYPE_PointerTons7__Batch: return soap_in_PointerTons7__Batch(soap, 0, 0, "ns7:Batch");
	case SOAP_TYPE_PointerTons6__EnterpriseList: return soap_in_PointerTons6__EnterpriseList(soap, 0, 0, "ns6:EnterpriseList");
	case SOAP_TYPE_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation: return soap_in_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(soap, 0, 0, "ns7:BEActivityLocationsModificationOperation-activityLocation");
	case SOAP_TYPE_PointerTons6__GLNType: return soap_in_PointerTons6__GLNType(soap, 0, 0, "ns6:GLNType");
	case SOAP_TYPE_PointerTons6__BusinessEntityList: return soap_in_PointerTons6__BusinessEntityList(soap, 0, 0, "ns6:BusinessEntityList");
	case SOAP_TYPE_PointerTons6__ProductItemList: return soap_in_PointerTons6__ProductItemList(soap, 0, 0, "ns6:ProductItemList");
	case SOAP_TYPE_PointerToPointerTons7__StockEntry: return soap_in_PointerToPointerTons7__StockEntry(soap, 0, 0, "ns7:StockEntry");
	case SOAP_TYPE_PointerTons3__RegisterModificationType: return soap_in_PointerTons3__RegisterModificationType(soap, 0, 0, "ns3:RegisterModificationType");
	case SOAP_TYPE_PointerToPointerTons7__ProcessingProcedure: return soap_in_PointerToPointerTons7__ProcessingProcedure(soap, 0, 0, "ns7:ProcessingProcedure");
	case SOAP_TYPE_PointerTons7__ProcessingProcedure: return soap_in_PointerTons7__ProcessingProcedure(soap, 0, 0, "ns7:ProcessingProcedure");
	case SOAP_TYPE_PointerToPointerTons7__ProductiveBatch: return soap_in_PointerToPointerTons7__ProductiveBatch(soap, 0, 0, "ns7:ProductiveBatch");
	case SOAP_TYPE_PointerTons7__ProductiveBatch: return soap_in_PointerTons7__ProductiveBatch(soap, 0, 0, "ns7:ProductiveBatch");
	case SOAP_TYPE_PointerToPointerTons7__RawBatch: return soap_in_PointerToPointerTons7__RawBatch(soap, 0, 0, "ns7:RawBatch");
	case SOAP_TYPE_PointerTons7__RawBatch: return soap_in_PointerTons7__RawBatch(soap, 0, 0, "ns7:RawBatch");
	case SOAP_TYPE_PointerToPointerTons7__ShipmentRoutePoint: return soap_in_PointerToPointerTons7__ShipmentRoutePoint(soap, 0, 0, "ns7:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTons7__ShipmentRoutePoint: return soap_in_PointerTons7__ShipmentRoutePoint(soap, 0, 0, "ns7:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTons7__TransportNumber: return soap_in_PointerTons7__TransportNumber(soap, 0, 0, "ns7:TransportNumber");
	case SOAP_TYPE_PointerTons6__TransportType: return soap_in_PointerTons6__TransportType(soap, 0, 0, "ns6:TransportType");
	case SOAP_TYPE_PointerTons7__StockEntryList: return soap_in_PointerTons7__StockEntryList(soap, 0, 0, "ns7:StockEntryList");
	case SOAP_TYPE_PointerTons6__ComplexDate: return soap_in_PointerTons6__ComplexDate(soap, 0, 0, "ns6:ComplexDate");
	case SOAP_TYPE_PointerToPointerTons7__ReferencedDocument: return soap_in_PointerToPointerTons7__ReferencedDocument(soap, 0, 0, "ns7:ReferencedDocument");
	case SOAP_TYPE_PointerTons7__ReferencedDocument: return soap_in_PointerTons7__ReferencedDocument(soap, 0, 0, "ns7:ReferencedDocument");
	case SOAP_TYPE_PointerToPointerTons7__VetDocument: return soap_in_PointerToPointerTons7__VetDocument(soap, 0, 0, "ns7:VetDocument");
	case SOAP_TYPE_PointerTons7__VetDocument: return soap_in_PointerTons7__VetDocument(soap, 0, 0, "ns7:VetDocument");
	case SOAP_TYPE_PointerTons7__Waybill: return soap_in_PointerTons7__Waybill(soap, 0, 0, "ns7:Waybill");
	case SOAP_TYPE_PointerTons7__User: return soap_in_PointerTons7__User(soap, 0, 0, "ns7:User");
	case SOAP_TYPE_PointerTons7__DeliveryInspection: return soap_in_PointerTons7__DeliveryInspection(soap, 0, 0, "ns7:DeliveryInspection");
	case SOAP_TYPE_PointerTons7__StockEntry: return soap_in_PointerTons7__StockEntry(soap, 0, 0, "ns7:StockEntry");
	case SOAP_TYPE_PointerTons6__PackageList: return soap_in_PointerTons6__PackageList(soap, 0, 0, "ns6:PackageList");
	case SOAP_TYPE_PointerTons7__BatchOrigin: return soap_in_PointerTons7__BatchOrigin(soap, 0, 0, "ns7:BatchOrigin");
	case SOAP_TYPE_PointerTons7__GoodsDate: return soap_in_PointerTons7__GoodsDate(soap, 0, 0, "ns7:GoodsDate");
	case SOAP_TYPE_PointerTons6__ProductItem: return soap_in_PointerTons6__ProductItem(soap, 0, 0, "ns6:ProductItem");
	case SOAP_TYPE_PointerTons6__SubProduct: return soap_in_PointerTons6__SubProduct(soap, 0, 0, "ns6:SubProduct");
	case SOAP_TYPE_PointerTons6__Product: return soap_in_PointerTons6__Product(soap, 0, 0, "ns6:Product");
	case SOAP_TYPE_PointerTons6__ProductType: return soap_in_PointerTons6__ProductType(soap, 0, 0, "ns6:ProductType");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationConditionGroup: return soap_in_PointerToPointerTons6__RegionalizationConditionGroup(soap, 0, 0, "ns6:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTons6__RegionalizationConditionGroup: return soap_in_PointerTons6__RegionalizationConditionGroup(soap, 0, 0, "ns6:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTons6__AnimalDisease: return soap_in_PointerTons6__AnimalDisease(soap, 0, 0, "ns6:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationCondition: return soap_in_PointerToPointerTons6__RegionalizationCondition(soap, 0, 0, "ns6:RegionalizationCondition");
	case SOAP_TYPE_PointerTons6__RegionalizationCondition: return soap_in_PointerTons6__RegionalizationCondition(soap, 0, 0, "ns6:RegionalizationCondition");
	case SOAP_TYPE_PointerTons6__BusinessMember: return soap_in_PointerTons6__BusinessMember(soap, 0, 0, "ns6:BusinessMember");
	case SOAP_TYPE_PointerTons3__Identifier: return soap_in_PointerTons3__Identifier(soap, 0, 0, "ns3:Identifier");
	case SOAP_TYPE_PointerTons6__Address: return soap_in_PointerTons6__Address(soap, 0, 0, "ns6:Address");
	case SOAP_TYPE_PointerTons6__Unit: return soap_in_PointerTons6__Unit(soap, 0, 0, "ns6:Unit");
	case SOAP_TYPE_PointerTons3__Decimal: return soap_in_PointerTons3__Decimal(soap, 0, 0, "ns3:Decimal");
	case SOAP_TYPE_PointerTons6__Minute: return soap_in_PointerTons6__Minute(soap, 0, 0, "ns6:Minute");
	case SOAP_TYPE_PointerTons6__Hour: return soap_in_PointerTons6__Hour(soap, 0, 0, "ns6:Hour");
	case SOAP_TYPE_PointerTons6__Day: return soap_in_PointerTons6__Day(soap, 0, 0, "ns6:Day");
	case SOAP_TYPE_PointerTons6__Month: return soap_in_PointerTons6__Month(soap, 0, 0, "ns6:Month");
	case SOAP_TYPE_PointerTons6__Year: return soap_in_PointerTons6__Year(soap, 0, 0, "ns6:Year");
	case SOAP_TYPE_PointerToPointerTons6__Package: return soap_in_PointerToPointerTons6__Package(soap, 0, 0, "ns6:Package");
	case SOAP_TYPE_PointerTons6__Package: return soap_in_PointerTons6__Package(soap, 0, 0, "ns6:Package");
	case SOAP_TYPE_PointerToPointerTons6__ProductMarks: return soap_in_PointerToPointerTons6__ProductMarks(soap, 0, 0, "ns6:ProductMarks");
	case SOAP_TYPE_PointerTons6__ProductMarks: return soap_in_PointerTons6__ProductMarks(soap, 0, 0, "ns6:ProductMarks");
	case SOAP_TYPE_PointerTons6__PackingType: return soap_in_PointerTons6__PackingType(soap, 0, 0, "ns6:PackingType");
	case SOAP_TYPE_PointerTons6__BusinessEntity: return soap_in_PointerTons6__BusinessEntity(soap, 0, 0, "ns6:BusinessEntity");
	case SOAP_TYPE_PointerTons3__String255: return soap_in_PointerTons3__String255(soap, 0, 0, "ns3:String255");
	case SOAP_TYPE_PointerToPointerTons6__Producer: return soap_in_PointerToPointerTons6__Producer(soap, 0, 0, "ns6:Producer");
	case SOAP_TYPE_PointerTons6__Producer: return soap_in_PointerTons6__Producer(soap, 0, 0, "ns6:Producer");
	case SOAP_TYPE_PointerTons6__EnterpriseRole: return soap_in_PointerTons6__EnterpriseRole(soap, 0, 0, "ns6:EnterpriseRole");
	case SOAP_TYPE_PointerTons6__Enterprise: return soap_in_PointerTons6__Enterprise(soap, 0, 0, "ns6:Enterprise");
	case SOAP_TYPE_PointerTons3__NText: return soap_in_PointerTons3__NText(soap, 0, 0, "ns3:NText");
	case SOAP_TYPE_PointerTons6__Street: return soap_in_PointerTons6__Street(soap, 0, 0, "ns6:Street");
	case SOAP_TYPE_PointerTons6__Locality: return soap_in_PointerTons6__Locality(soap, 0, 0, "ns6:Locality");
	case SOAP_TYPE_PointerTons6__District: return soap_in_PointerTons6__District(soap, 0, 0, "ns6:District");
	case SOAP_TYPE_PointerTons6__Region: return soap_in_PointerTons6__Region(soap, 0, 0, "ns6:Region");
	case SOAP_TYPE_PointerTons6__FederalDistrict: return soap_in_PointerTons6__FederalDistrict(soap, 0, 0, "ns6:FederalDistrict");
	case SOAP_TYPE_PointerTons6__Country: return soap_in_PointerTons6__Country(soap, 0, 0, "ns6:Country");
	case SOAP_TYPE_PointerToPointerTons4__BusinessError: return soap_in_PointerToPointerTons4__BusinessError(soap, 0, 0, "ns4:BusinessError");
	case SOAP_TYPE_PointerTons4__BusinessError: return soap_in_PointerTons4__BusinessError(soap, 0, 0, "ns4:BusinessError");
	case SOAP_TYPE_PointerTons4__ContentEncoding: return soap_in_PointerTons4__ContentEncoding(soap, 0, 0, "ns4:ContentEncoding");
	case SOAP_TYPE_PointerTons4__BusinessErrorList: return soap_in_PointerTons4__BusinessErrorList(soap, 0, 0, "ns4:BusinessErrorList");
	case SOAP_TYPE_PointerTons4__ApplicationResultWrapper: return soap_in_PointerTons4__ApplicationResultWrapper(soap, 0, 0, "ns4:ApplicationResultWrapper");
	case SOAP_TYPE_PointerTons4__ApplicationDataWrapper: return soap_in_PointerTons4__ApplicationDataWrapper(soap, 0, 0, "ns4:ApplicationDataWrapper");
	case SOAP_TYPE_PointerTons4__ApplicationStatus: return soap_in_PointerTons4__ApplicationStatus(soap, 0, 0, "ns4:ApplicationStatus");
	case SOAP_TYPE_PointerToPointerTons3__Error: return soap_in_PointerToPointerTons3__Error(soap, 0, 0, "ns3:Error");
	case SOAP_TYPE_PointerTons3__Error: return soap_in_PointerTons3__Error(soap, 0, 0, "ns3:Error");
	case SOAP_TYPE_PointerTobool: return soap_in_PointerTobool(soap, 0, 0, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64: return soap_in_PointerToLONG64(soap, 0, 0, "xsd:long");
	case SOAP_TYPE_PointerToint: return soap_in_PointerToint(soap, 0, 0, "xsd:int");
	case SOAP_TYPE_PointerTotime: return soap_in_PointerTotime(soap, 0, 0, "xsd:dateTime");
	case SOAP_TYPE_PointerTons4__Application: return soap_in_PointerTons4__Application(soap, 0, 0, "ns4:Application");
	case SOAP_TYPE_ns7__VetDocumentStatusChangeReason:
	{
		char ** s = soap_in_ns7__VetDocumentStatusChangeReason(soap, 0, 0, "ns7:VetDocumentStatusChangeReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__GRNType:
	{
		char ** s = soap_in_ns6__GRNType(soap, 0, 0, "ns6:GRNType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns7__SNILSType:
	{
		char ** s = soap_in_ns7__SNILSType(soap, 0, 0, "ns7:SNILSType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns7__StockEntryNumber:
	{
		char ** s = soap_in_ns7__StockEntryNumber(soap, 0, 0, "ns7:StockEntryNumber");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__OTPToken:
	{
		char ** s = soap_in_ns6__OTPToken(soap, 0, 0, "ns6:OTPToken");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__GTINType:
	{
		char ** s = soap_in_ns6__GTINType(soap, 0, 0, "ns6:GTINType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__GLNType:
	{
		char ** s = soap_in_ns6__GLNType(soap, 0, 0, "ns6:GLNType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__ENTModificationReason:
	{
		char ** s = soap_in_ns6__ENTModificationReason(soap, 0, 0, "ns6:ENTModificationReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__BEModificationReason:
	{
		char ** s = soap_in_ns6__BEModificationReason(soap, 0, 0, "ns6:BEModificationReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__EnterpriseType:
	{
		char ** s = soap_in_ns6__EnterpriseType(soap, 0, 0, "ns6:EnterpriseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__Code3:
	{
		char ** s = soap_in_ns6__Code3(soap, 0, 0, "ns6:Code3");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns6__Code:
	{
		char ** s = soap_in_ns6__Code(soap, 0, 0, "ns6:Code");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns4__APIKey:
	{
		char ** s = soap_in_ns4__APIKey(soap, 0, 0, "ns4:APIKey");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__SequenceNumber:
	{
		char ** s = soap_in_ns3__SequenceNumber(soap, 0, 0, "ns3:SequenceNumber");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__Identifier:
	{
		char ** s = soap_in_ns3__Identifier(soap, 0, 0, "ns3:Identifier");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__VersionStatus:
	{
		char ** s = soap_in_ns3__VersionStatus(soap, 0, 0, "ns3:VersionStatus");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__Decimal:
	{
		char ** s = soap_in_ns3__Decimal(soap, 0, 0, "ns3:Decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__String32:
	{
		char ** s = soap_in_ns3__String32(soap, 0, 0, "ns3:String32");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__String255:
	{
		char ** s = soap_in_ns3__String255(soap, 0, 0, "ns3:String255");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__NText:
	{
		char ** s = soap_in_ns3__NText(soap, 0, 0, "ns3:NText");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__Text:
	{
		char ** s = soap_in_ns3__Text(soap, 0, 0, "ns3:Text");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__UUID:
	{
		char ** s = soap_in_ns3__UUID(soap, 0, 0, "ns3:UUID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{
		char ** s = soap_in_xsd__token(soap, 0, 0, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__positiveInteger:
	{
		char ** s = soap_in_xsd__positiveInteger(soap, 0, 0, "xsd:positiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{
		char ** s = soap_in_xsd__nonNegativeInteger(soap, 0, 0, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{
		char ** s = soap_in_xsd__integer(soap, 0, 0, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{
		char ** s = soap_in_xsd__decimal(soap, 0, 0, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{
		char ** s = soap_in_xsd__date(soap, 0, 0, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte: return soap_in_PointerTounsignedByte(soap, 0, 0, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__Name:
	{
		char ** s = soap_in_xsd__Name(soap, 0, 0, "xsd:Name");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{
		char ** s = soap_in_xsd__NCName(soap, 0, 0, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__IDREF:
	{
		char ** s = soap_in_xsd__IDREF(soap, 0, 0, "xsd:IDREF");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{
		char ** s = soap_in_xsd__ID(soap, 0, 0, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{
		char ** s = soap_in__QName(soap, 0, 0, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{
		char ** s = soap_in_string(soap, 0, 0, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if(!*t)
			t = soap->tag;
		if(!soap_match_tag(soap, t, "ns4:BinaryContent")) { *type = SOAP_TYPE_ns4__BinaryContent; return soap_in_ns4__BinaryContent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:WorkingArea")) { *type = SOAP_TYPE_ns7__WorkingArea; return soap_in_ns7__WorkingArea(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:UserAuthority")) { *type = SOAP_TYPE_ns7__UserAuthority; return soap_in_ns7__UserAuthority(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:WorkingAreaList")) { *type = SOAP_TYPE_ns7__WorkingAreaList; return soap_in_ns7__WorkingAreaList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:AuthorityList")) { *type = SOAP_TYPE_ns7__AuthorityList; return soap_in_ns7__AuthorityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:UserList")) { *type = SOAP_TYPE_ns7__UserList; return soap_in_ns7__UserList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:User")) { *type = SOAP_TYPE_ns7__User; return soap_in_ns7__User(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ProcessingProcedure")) { *type = SOAP_TYPE_ns7__ProcessingProcedure; return soap_in_ns7__ProcessingProcedure(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:RouteSectionR13nRules")) { *type = SOAP_TYPE_ns7__RouteSectionR13nRules; return soap_in_ns7__RouteSectionR13nRules(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:RegionalizationClause")) { *type = SOAP_TYPE_ns7__RegionalizationClause; return soap_in_ns7__RegionalizationClause(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocumentStatusChange")) { *type = SOAP_TYPE_ns7__VetDocumentStatusChange; return soap_in_ns7__VetDocumentStatusChange(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:StockEntryEventList")) { *type = SOAP_TYPE_ns7__StockEntryEventList; return soap_in_ns7__StockEntryEventList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:BatchOrigin")) { *type = SOAP_TYPE_ns7__BatchOrigin; return soap_in_ns7__BatchOrigin(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VeterinaryAuthentication")) { *type = SOAP_TYPE_ns7__VeterinaryAuthentication; return soap_in_ns7__VeterinaryAuthentication(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:QuarantineEvent")) { *type = SOAP_TYPE_ns7__QuarantineEvent; return soap_in_ns7__QuarantineEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:AnimalMedicationEvent")) { *type = SOAP_TYPE_ns7__AnimalMedicationEvent; return soap_in_ns7__AnimalMedicationEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:LaboratoryResearchEvent")) { *type = SOAP_TYPE_ns7__LaboratoryResearchEvent; return soap_in_ns7__LaboratoryResearchEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VeterinaryEvent")) { *type = SOAP_TYPE_ns7__VeterinaryEvent; return soap_in_ns7__VeterinaryEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ReferencedDocument")) { *type = SOAP_TYPE_ns7__ReferencedDocument; return soap_in_ns7__ReferencedDocument(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:CertifiedConsignment")) { *type = SOAP_TYPE_ns7__CertifiedConsignment; return soap_in_ns7__CertifiedConsignment(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:CertifiedBatch")) { *type = SOAP_TYPE_ns7__CertifiedBatch; return soap_in_ns7__CertifiedBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ENTModificationOperation")) { *type = SOAP_TYPE_ns7__ENTModificationOperation; return soap_in_ns7__ENTModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:BEActivityLocationsModificationOperation")) { *type = SOAP_TYPE_ns7__BEActivityLocationsModificationOperation; return soap_in_ns7__BEActivityLocationsModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:BEModificationOperation")) { *type = SOAP_TYPE_ns7__BEModificationOperation; return soap_in_ns7__BEModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:PSLModificationOperation")) { *type = SOAP_TYPE_ns7__PSLModificationOperation; return soap_in_ns7__PSLModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:MergeStockEntriesOperation")) { *type = SOAP_TYPE_ns7__MergeStockEntriesOperation; return soap_in_ns7__MergeStockEntriesOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ProductionOperation")) { *type = SOAP_TYPE_ns7__ProductionOperation; return soap_in_ns7__ProductionOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ShipmentRoute")) { *type = SOAP_TYPE_ns7__ShipmentRoute; return soap_in_ns7__ShipmentRoute(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ShipmentRoutePoint")) { *type = SOAP_TYPE_ns7__ShipmentRoutePoint; return soap_in_ns7__ShipmentRoutePoint(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:TransportNumber")) { *type = SOAP_TYPE_ns7__TransportNumber; return soap_in_ns7__TransportNumber(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:TransportInfo")) { *type = SOAP_TYPE_ns7__TransportInfo; return soap_in_ns7__TransportInfo(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:Waybill")) { *type = SOAP_TYPE_ns7__Waybill; return soap_in_ns7__Waybill(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:Document")) { *type = SOAP_TYPE_ns7__Document; return soap_in_ns7__Document(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:StockEntrySearchPattern")) { *type = SOAP_TYPE_ns7__StockEntrySearchPattern; return soap_in_ns7__StockEntrySearchPattern(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:StockDiscrepancy")) { *type = SOAP_TYPE_ns7__StockDiscrepancy; return soap_in_ns7__StockDiscrepancy(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:StockEntryList")) { *type = SOAP_TYPE_ns7__StockEntryList; return soap_in_ns7__StockEntryList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:StockEntry")) { *type = SOAP_TYPE_ns7__StockEntry; return soap_in_ns7__StockEntry(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:DiscrepancyReason")) { *type = SOAP_TYPE_ns7__DiscrepancyReason; return soap_in_ns7__DiscrepancyReason(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:DiscrepancyReport")) { *type = SOAP_TYPE_ns7__DiscrepancyReport; return soap_in_ns7__DiscrepancyReport(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocumentList")) { *type = SOAP_TYPE_ns7__VetDocumentList; return soap_in_ns7__VetDocumentList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:GoodsDate")) { *type = SOAP_TYPE_ns7__GoodsDate; return soap_in_ns7__GoodsDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ConsignmentDocumentList")) { *type = SOAP_TYPE_ns7__ConsignmentDocumentList; return soap_in_ns7__ConsignmentDocumentList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:DeliveryInspection")) { *type = SOAP_TYPE_ns7__DeliveryInspection; return soap_in_ns7__DeliveryInspection(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:DeliveryFactList")) { *type = SOAP_TYPE_ns7__DeliveryFactList; return soap_in_ns7__DeliveryFactList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:Delivery")) { *type = SOAP_TYPE_ns7__Delivery; return soap_in_ns7__Delivery(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ProductiveBatch")) { *type = SOAP_TYPE_ns7__ProductiveBatch; return soap_in_ns7__ProductiveBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:RawBatch")) { *type = SOAP_TYPE_ns7__RawBatch; return soap_in_ns7__RawBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:Consignment")) { *type = SOAP_TYPE_ns7__Consignment; return soap_in_ns7__Consignment(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:Batch")) { *type = SOAP_TYPE_ns7__Batch; return soap_in_ns7__Batch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocument")) { *type = SOAP_TYPE_ns7__VetDocument; return soap_in_ns7__VetDocument(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ActivityLocationList")) { *type = SOAP_TYPE_ns6__ActivityLocationList; return soap_in_ns6__ActivityLocationList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ResearchMethodList")) { *type = SOAP_TYPE_ns6__ResearchMethodList; return soap_in_ns6__ResearchMethodList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:AnimalDiseaseList")) { *type = SOAP_TYPE_ns6__AnimalDiseaseList; return soap_in_ns6__AnimalDiseaseList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationShippingRuleList")) { *type = SOAP_TYPE_ns6__RegionalizationShippingRuleList; return soap_in_ns6__RegionalizationShippingRuleList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationRegionStatusList")) { *type = SOAP_TYPE_ns6__RegionalizationRegionStatusList; return soap_in_ns6__RegionalizationRegionStatusList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationConditionList")) { *type = SOAP_TYPE_ns6__RegionalizationConditionList; return soap_in_ns6__RegionalizationConditionList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Area")) { *type = SOAP_TYPE_ns6__Area; return soap_in_ns6__Area(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationRegionStatus")) { *type = SOAP_TYPE_ns6__RegionalizationRegionStatus; return soap_in_ns6__RegionalizationRegionStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationStatus")) { *type = SOAP_TYPE_ns6__RegionalizationStatus; return soap_in_ns6__RegionalizationStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationShippingRule")) { *type = SOAP_TYPE_ns6__RegionalizationShippingRule; return soap_in_ns6__RegionalizationShippingRule(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationRequirement")) { *type = SOAP_TYPE_ns6__RegionalizationRequirement; return soap_in_ns6__RegionalizationRequirement(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationConditionGroup")) { *type = SOAP_TYPE_ns6__RegionalizationConditionGroup; return soap_in_ns6__RegionalizationConditionGroup(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationCondition")) { *type = SOAP_TYPE_ns6__RegionalizationCondition; return soap_in_ns6__RegionalizationCondition(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:MedicinalDrug")) { *type = SOAP_TYPE_ns6__MedicinalDrug; return soap_in_ns6__MedicinalDrug(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ResearchMethod")) { *type = SOAP_TYPE_ns6__ResearchMethod; return soap_in_ns6__ResearchMethod(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:AnimalDisease")) { *type = SOAP_TYPE_ns6__AnimalDisease; return soap_in_ns6__AnimalDisease(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Indicator")) { *type = SOAP_TYPE_ns6__Indicator; return soap_in_ns6__Indicator(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Organization")) { *type = SOAP_TYPE_ns6__Organization; return soap_in_ns6__Organization(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseOfficialRegistration")) { *type = SOAP_TYPE_ns6__EnterpriseOfficialRegistration; return soap_in_ns6__EnterpriseOfficialRegistration(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Location")) { *type = SOAP_TYPE_ns6__Location; return soap_in_ns6__Location(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Packaging")) { *type = SOAP_TYPE_ns6__Packaging; return soap_in_ns6__Packaging(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductItemProducing")) { *type = SOAP_TYPE_ns6__ProductItemProducing; return soap_in_ns6__ProductItemProducing(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ComplexDate")) { *type = SOAP_TYPE_ns6__ComplexDate; return soap_in_ns6__ComplexDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:PackageList")) { *type = SOAP_TYPE_ns6__PackageList; return soap_in_ns6__PackageList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Package")) { *type = SOAP_TYPE_ns6__Package; return soap_in_ns6__Package(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductMarks")) { *type = SOAP_TYPE_ns6__ProductMarks; return soap_in_ns6__ProductMarks(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductItemList")) { *type = SOAP_TYPE_ns6__ProductItemList; return soap_in_ns6__ProductItemList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:SubProductList")) { *type = SOAP_TYPE_ns6__SubProductList; return soap_in_ns6__SubProductList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductList")) { *type = SOAP_TYPE_ns6__ProductList; return soap_in_ns6__ProductList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:SubProduct")) { *type = SOAP_TYPE_ns6__SubProduct; return soap_in_ns6__SubProduct(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Product")) { *type = SOAP_TYPE_ns6__Product; return soap_in_ns6__Product(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductItem")) { *type = SOAP_TYPE_ns6__ProductItem; return soap_in_ns6__ProductItem(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:BusinessEntityList")) { *type = SOAP_TYPE_ns6__BusinessEntityList; return soap_in_ns6__BusinessEntityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:IncorporationForm")) { *type = SOAP_TYPE_ns6__IncorporationForm; return soap_in_ns6__IncorporationForm(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:BusinessEntity")) { *type = SOAP_TYPE_ns6__BusinessEntity; return soap_in_ns6__BusinessEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:BusinessMember")) { *type = SOAP_TYPE_ns6__BusinessMember; return soap_in_ns6__BusinessMember(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseList")) { *type = SOAP_TYPE_ns6__EnterpriseList; return soap_in_ns6__EnterpriseList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseNumberList")) { *type = SOAP_TYPE_ns6__EnterpriseNumberList; return soap_in_ns6__EnterpriseNumberList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProducerList")) { *type = SOAP_TYPE_ns6__ProducerList; return soap_in_ns6__ProducerList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Producer")) { *type = SOAP_TYPE_ns6__Producer; return soap_in_ns6__Producer(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseActivity")) { *type = SOAP_TYPE_ns6__EnterpriseActivity; return soap_in_ns6__EnterpriseActivity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseActivityList")) { *type = SOAP_TYPE_ns6__EnterpriseActivityList; return soap_in_ns6__EnterpriseActivityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Enterprise")) { *type = SOAP_TYPE_ns6__Enterprise; return soap_in_ns6__Enterprise(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:StreetList")) { *type = SOAP_TYPE_ns6__StreetList; return soap_in_ns6__StreetList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:LocalityList")) { *type = SOAP_TYPE_ns6__LocalityList; return soap_in_ns6__LocalityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:DistrictList")) { *type = SOAP_TYPE_ns6__DistrictList; return soap_in_ns6__DistrictList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionList")) { *type = SOAP_TYPE_ns6__RegionList; return soap_in_ns6__RegionList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:CountryList")) { *type = SOAP_TYPE_ns6__CountryList; return soap_in_ns6__CountryList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Address")) { *type = SOAP_TYPE_ns6__Address; return soap_in_ns6__Address(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Street")) { *type = SOAP_TYPE_ns6__Street; return soap_in_ns6__Street(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Locality")) { *type = SOAP_TYPE_ns6__Locality; return soap_in_ns6__Locality(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:District")) { *type = SOAP_TYPE_ns6__District; return soap_in_ns6__District(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Region")) { *type = SOAP_TYPE_ns6__Region; return soap_in_ns6__Region(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:AddressObjectView")) { *type = SOAP_TYPE_ns6__AddressObjectView; return soap_in_ns6__AddressObjectView(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:FederalDistrict")) { *type = SOAP_TYPE_ns6__FederalDistrict; return soap_in_ns6__FederalDistrict(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Country")) { *type = SOAP_TYPE_ns6__Country; return soap_in_ns6__Country(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:UnitList")) { *type = SOAP_TYPE_ns6__UnitList; return soap_in_ns6__UnitList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:PurposeList")) { *type = SOAP_TYPE_ns6__PurposeList; return soap_in_ns6__PurposeList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:PackingType")) { *type = SOAP_TYPE_ns6__PackingType; return soap_in_ns6__PackingType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Unit")) { *type = SOAP_TYPE_ns6__Unit; return soap_in_ns6__Unit(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Purpose")) { *type = SOAP_TYPE_ns6__Purpose; return soap_in_ns6__Purpose(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetAppliedUserAuthorityListResponse")) { *type = SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse; return soap_in_ns5__GetAppliedUserAuthorityListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetAppliedUserAuthorityListRequest")) { *type = SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest; return soap_in_ns5__GetAppliedUserAuthorityListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UnbindBusinessEntityUserResponse")) { *type = SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse; return soap_in_ns5__UnbindBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UnbindBusinessEntityUserRequest")) { *type = SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest; return soap_in_ns5__UnbindBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateUserWorkingAreasResponse")) { *type = SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse; return soap_in_ns5__UpdateUserWorkingAreasResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateUserWorkingAreasRequest")) { *type = SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest; return soap_in_ns5__UpdateUserWorkingAreasRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateUserAuthoritiesResponse")) { *type = SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse; return soap_in_ns5__UpdateUserAuthoritiesResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateUserAuthoritiesRequest")) { *type = SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest; return soap_in_ns5__UpdateUserAuthoritiesRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetBusinessEntityUserResponse")) { *type = SOAP_TYPE_ns5__GetBusinessEntityUserResponse; return soap_in_ns5__GetBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetBusinessEntityUserRequest")) { *type = SOAP_TYPE_ns5__GetBusinessEntityUserRequest; return soap_in_ns5__GetBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetBusinessEntityUserListResponse")) { *type = SOAP_TYPE_ns5__GetBusinessEntityUserListResponse; return soap_in_ns5__GetBusinessEntityUserListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetBusinessEntityUserListRequest")) { *type = SOAP_TYPE_ns5__GetBusinessEntityUserListRequest; return soap_in_ns5__GetBusinessEntityUserListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:AddBusinessEntityUserResponse")) { *type = SOAP_TYPE_ns5__AddBusinessEntityUserResponse; return soap_in_ns5__AddBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:AddBusinessEntityUserRequest")) { *type = SOAP_TYPE_ns5__AddBusinessEntityUserRequest; return soap_in_ns5__AddBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:CheckShipmentRegionalizationResponse")) { *type = SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse; return soap_in_ns5__CheckShipmentRegionalizationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:CheckShipmentRegionalizationRequest")) { *type = SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest; return soap_in_ns5__CheckShipmentRegionalizationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateVeterinaryEventsResponse")) { *type = SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse; return soap_in_ns5__UpdateVeterinaryEventsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateVeterinaryEventsRequest")) { *type = SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest; return soap_in_ns5__UpdateVeterinaryEventsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateTransportMovementDetailsResponse")) { *type = SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse; return soap_in_ns5__UpdateTransportMovementDetailsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:UpdateTransportMovementDetailsRequest")) { *type = SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest; return soap_in_ns5__UpdateTransportMovementDetailsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryVersionListResponse")) { *type = SOAP_TYPE_ns5__GetStockEntryVersionListResponse; return soap_in_ns5__GetStockEntryVersionListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryVersionListRequest")) { *type = SOAP_TYPE_ns5__GetStockEntryVersionListRequest; return soap_in_ns5__GetStockEntryVersionListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryListResponse")) { *type = SOAP_TYPE_ns5__GetStockEntryListResponse; return soap_in_ns5__GetStockEntryListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryListRequest")) { *type = SOAP_TYPE_ns5__GetStockEntryListRequest; return soap_in_ns5__GetStockEntryListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryChangesListResponse")) { *type = SOAP_TYPE_ns5__GetStockEntryChangesListResponse; return soap_in_ns5__GetStockEntryChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryChangesListRequest")) { *type = SOAP_TYPE_ns5__GetStockEntryChangesListRequest; return soap_in_ns5__GetStockEntryChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryByUuidResponse")) { *type = SOAP_TYPE_ns5__GetStockEntryByUuidResponse; return soap_in_ns5__GetStockEntryByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryByUuidRequest")) { *type = SOAP_TYPE_ns5__GetStockEntryByUuidRequest; return soap_in_ns5__GetStockEntryByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryByGuidResponse")) { *type = SOAP_TYPE_ns5__GetStockEntryByGuidResponse; return soap_in_ns5__GetStockEntryByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetStockEntryByGuidRequest")) { *type = SOAP_TYPE_ns5__GetStockEntryByGuidRequest; return soap_in_ns5__GetStockEntryByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetVetDocumentChangesListResponse")) { *type = SOAP_TYPE_ns5__GetVetDocumentChangesListResponse; return soap_in_ns5__GetVetDocumentChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetVetDocumentChangesListRequest")) { *type = SOAP_TYPE_ns5__GetVetDocumentChangesListRequest; return soap_in_ns5__GetVetDocumentChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetVetDocumentListResponse")) { *type = SOAP_TYPE_ns5__GetVetDocumentListResponse; return soap_in_ns5__GetVetDocumentListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetVetDocumentListRequest")) { *type = SOAP_TYPE_ns5__GetVetDocumentListRequest; return soap_in_ns5__GetVetDocumentListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetVetDocumentByUuidResponse")) { *type = SOAP_TYPE_ns5__GetVetDocumentByUuidResponse; return soap_in_ns5__GetVetDocumentByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:GetVetDocumentByUuidRequest")) { *type = SOAP_TYPE_ns5__GetVetDocumentByUuidRequest; return soap_in_ns5__GetVetDocumentByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyProducerStockListResponse")) { *type = SOAP_TYPE_ns5__ModifyProducerStockListResponse; return soap_in_ns5__ModifyProducerStockListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyProducerStockListRequest")) { *type = SOAP_TYPE_ns5__ModifyProducerStockListRequest; return soap_in_ns5__ModifyProducerStockListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ResolveDiscrepancyResponse")) { *type = SOAP_TYPE_ns5__ResolveDiscrepancyResponse; return soap_in_ns5__ResolveDiscrepancyResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ResolveDiscrepancyRequest")) { *type = SOAP_TYPE_ns5__ResolveDiscrepancyRequest; return soap_in_ns5__ResolveDiscrepancyRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyActivityLocationsResponse")) { *type = SOAP_TYPE_ns5__ModifyActivityLocationsResponse; return soap_in_ns5__ModifyActivityLocationsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyActivityLocationsRequest")) { *type = SOAP_TYPE_ns5__ModifyActivityLocationsRequest; return soap_in_ns5__ModifyActivityLocationsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyEnterpriseResponse")) { *type = SOAP_TYPE_ns5__ModifyEnterpriseResponse; return soap_in_ns5__ModifyEnterpriseResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyEnterpriseRequest")) { *type = SOAP_TYPE_ns5__ModifyEnterpriseRequest; return soap_in_ns5__ModifyEnterpriseRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyBusinessEntityResponse")) { *type = SOAP_TYPE_ns5__ModifyBusinessEntityResponse; return soap_in_ns5__ModifyBusinessEntityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ModifyBusinessEntityRequest")) { *type = SOAP_TYPE_ns5__ModifyBusinessEntityRequest; return soap_in_ns5__ModifyBusinessEntityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:WithdrawVetDocumentResponse")) { *type = SOAP_TYPE_ns5__WithdrawVetDocumentResponse; return soap_in_ns5__WithdrawVetDocumentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:WithdrawVetDocumentRequest")) { *type = SOAP_TYPE_ns5__WithdrawVetDocumentRequest; return soap_in_ns5__WithdrawVetDocumentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:MergeStockEntriesResponse")) { *type = SOAP_TYPE_ns5__MergeStockEntriesResponse; return soap_in_ns5__MergeStockEntriesResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:MergeStockEntriesRequest")) { *type = SOAP_TYPE_ns5__MergeStockEntriesRequest; return soap_in_ns5__MergeStockEntriesRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:RegisterProductionOperationResponse")) { *type = SOAP_TYPE_ns5__RegisterProductionOperationResponse; return soap_in_ns5__RegisterProductionOperationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:RegisterProductionOperationRequest")) { *type = SOAP_TYPE_ns5__RegisterProductionOperationRequest; return soap_in_ns5__RegisterProductionOperationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:PrepareOutgoingConsignmentResponse")) { *type = SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse; return soap_in_ns5__PrepareOutgoingConsignmentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:PrepareOutgoingConsignmentRequest")) { *type = SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest; return soap_in_ns5__PrepareOutgoingConsignmentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ProcessIncomingConsignmentResponse")) { *type = SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse; return soap_in_ns5__ProcessIncomingConsignmentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:ProcessIncomingConsignmentRequest")) { *type = SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest; return soap_in_ns5__ProcessIncomingConsignmentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns5:MercuryApplicationRequest")) { *type = SOAP_TYPE_ns5__MercuryApplicationRequest; return soap_in_ns5__MercuryApplicationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:BusinessError")) { *type = SOAP_TYPE_ns4__BusinessError; return soap_in_ns4__BusinessError(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:BusinessErrorList")) { *type = SOAP_TYPE_ns4__BusinessErrorList; return soap_in_ns4__BusinessErrorList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:ApplicationResultData")) { *type = SOAP_TYPE_ns4__ApplicationResultData; return soap_in_ns4__ApplicationResultData(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:ApplicationData")) { *type = SOAP_TYPE_ns4__ApplicationData; return soap_in_ns4__ApplicationData(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:ApplicationResultWrapper")) { *type = SOAP_TYPE_ns4__ApplicationResultWrapper; return soap_in_ns4__ApplicationResultWrapper(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:ApplicationDataWrapper")) { *type = SOAP_TYPE_ns4__ApplicationDataWrapper; return soap_in_ns4__ApplicationDataWrapper(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:Application")) { *type = SOAP_TYPE_ns4__Application; return soap_in_ns4__Application(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:Error")) { *type = SOAP_TYPE_ns3__Error; return soap_in_ns3__Error(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:FaultInfo")) { *type = SOAP_TYPE_ns3__FaultInfo; return soap_in_ns3__FaultInfo(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:EntityList")) { *type = SOAP_TYPE_ns3__EntityList; return soap_in_ns3__EntityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:DateInterval")) { *type = SOAP_TYPE_ns3__DateInterval; return soap_in_ns3__DateInterval(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:ListOptions")) { *type = SOAP_TYPE_ns3__ListOptions; return soap_in_ns3__ListOptions(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:GenericVersioningEntity")) { *type = SOAP_TYPE_ns3__GenericVersioningEntity; return soap_in_ns3__GenericVersioningEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:GenericEntity")) { *type = SOAP_TYPE_ns3__GenericEntity; return soap_in_ns3__GenericEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:base64Binary")) { *type = SOAP_TYPE_xsd__base64Binary; return soap_in_xsd__base64Binary(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:byte")) { *type = SOAP_TYPE_byte; return soap_in_byte(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Minute")) { *type = SOAP_TYPE_ns6__Minute; return soap_in_ns6__Minute(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Hour")) { *type = SOAP_TYPE_ns6__Hour; return soap_in_ns6__Hour(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Day")) { *type = SOAP_TYPE_ns6__Day; return soap_in_ns6__Day(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Month")) { *type = SOAP_TYPE_ns6__Month; return soap_in_ns6__Month(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:Year")) { *type = SOAP_TYPE_ns6__Year; return soap_in_ns6__Year(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:int")) { *type = SOAP_TYPE_int; return soap_in_int(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:long")) { *type = SOAP_TYPE_LONG64; return soap_in_LONG64(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:unsignedByte")) { *type = SOAP_TYPE_unsignedByte; return soap_in_unsignedByte(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:unsignedInt")) { *type = SOAP_TYPE_unsignedInt; return soap_in_unsignedInt(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:dateTime")) { *type = SOAP_TYPE_time; return soap_in_time(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:boolean")) { *type = SOAP_TYPE_bool; return soap_in_bool(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:AnimalSpentPeriod")) { *type = SOAP_TYPE_ns7__AnimalSpentPeriod; return soap_in_ns7__AnimalSpentPeriod(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocumentStatus")) { *type = SOAP_TYPE_ns7__VetDocumentStatus; return soap_in_ns7__VetDocumentStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocumentType")) { *type = SOAP_TYPE_ns7__VetDocumentType; return soap_in_ns7__VetDocumentType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocumentForm")) { *type = SOAP_TYPE_ns7__VetDocumentForm; return soap_in_ns7__VetDocumentForm(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:DeliveryInspectionResult")) { *type = SOAP_TYPE_ns7__DeliveryInspectionResult; return soap_in_ns7__DeliveryInspectionResult(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:DeliveryDecision")) { *type = SOAP_TYPE_ns7__DeliveryDecision; return soap_in_ns7__DeliveryDecision(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductMarkingClass")) { *type = SOAP_TYPE_ns6__ProductMarkingClass; return soap_in_ns6__ProductMarkingClass(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:TransportationStorageType")) { *type = SOAP_TYPE_ns6__TransportationStorageType; return soap_in_ns6__TransportationStorageType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:DocumentNature")) { *type = SOAP_TYPE_ns6__DocumentNature; return soap_in_ns6__DocumentNature(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseRole")) { *type = SOAP_TYPE_ns6__EnterpriseRole; return soap_in_ns6__EnterpriseRole(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:ProcessingProcedureType")) { *type = SOAP_TYPE_ns7__ProcessingProcedureType; return soap_in_ns7__ProcessingProcedureType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VeterinaryEventType")) { *type = SOAP_TYPE_ns7__VeterinaryEventType; return soap_in_ns7__VeterinaryEventType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:StockEntryBlankFilter")) { *type = SOAP_TYPE_ns7__StockEntryBlankFilter; return soap_in_ns7__StockEntryBlankFilter(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:VaccinationType")) { *type = SOAP_TYPE_ns6__VaccinationType; return soap_in_ns6__VaccinationType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProsperityType")) { *type = SOAP_TYPE_ns6__ProsperityType; return soap_in_ns6__ProsperityType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:RegionalizationDecision")) { *type = SOAP_TYPE_ns6__RegionalizationDecision; return soap_in_ns6__RegionalizationDecision(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ResearchResult")) { *type = SOAP_TYPE_ns6__ResearchResult; return soap_in_ns6__ResearchResult(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:TransportType")) { *type = SOAP_TYPE_ns6__TransportType; return soap_in_ns6__TransportType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ReferenceType")) { *type = SOAP_TYPE_ns6__ReferenceType; return soap_in_ns6__ReferenceType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:DocumentType")) { *type = SOAP_TYPE_ns6__DocumentType; return soap_in_ns6__DocumentType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:ProductType")) { *type = SOAP_TYPE_ns6__ProductType; return soap_in_ns6__ProductType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:BusinessEntityType")) { *type = SOAP_TYPE_ns6__BusinessEntityType; return soap_in_ns6__BusinessEntityType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:EnterpriseGroup")) { *type = SOAP_TYPE_ns6__EnterpriseGroup; return soap_in_ns6__EnterpriseGroup(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:PackingCodeType")) { *type = SOAP_TYPE_ns6__PackingCodeType; return soap_in_ns6__PackingCodeType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns6:PackageLevelType")) { *type = SOAP_TYPE_ns6__PackageLevelType; return soap_in_ns6__PackageLevelType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:ContentEncoding")) { *type = SOAP_TYPE_ns4__ContentEncoding; return soap_in_ns4__ContentEncoding(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns4:ApplicationStatus")) { *type = SOAP_TYPE_ns4__ApplicationStatus; return soap_in_ns4__ApplicationStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns3:RegisterModificationType")) { *type = SOAP_TYPE_ns3__RegisterModificationType; return soap_in_ns3__RegisterModificationType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:VetDocumentStatusChangeReason")) {
			*type = SOAP_TYPE_ns7__VetDocumentStatusChangeReason;
			char ** s = soap_in_ns7__VetDocumentStatusChangeReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:GRNType")) {
			*type = SOAP_TYPE_ns6__GRNType;
			char ** s = soap_in_ns6__GRNType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns7:SNILSType")) {
			*type = SOAP_TYPE_ns7__SNILSType;
			char ** s = soap_in_ns7__SNILSType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns7:StockEntryNumber")) {
			*type = SOAP_TYPE_ns7__StockEntryNumber;
			char ** s = soap_in_ns7__StockEntryNumber(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:OTPToken")) {
			*type = SOAP_TYPE_ns6__OTPToken;
			char ** s = soap_in_ns6__OTPToken(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:GTINType")) {
			*type = SOAP_TYPE_ns6__GTINType;
			char ** s = soap_in_ns6__GTINType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:GLNType")) {
			*type = SOAP_TYPE_ns6__GLNType;
			char ** s = soap_in_ns6__GLNType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:ENTModificationReason")) {
			*type = SOAP_TYPE_ns6__ENTModificationReason;
			char ** s = soap_in_ns6__ENTModificationReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:BEModificationReason")) {
			*type = SOAP_TYPE_ns6__BEModificationReason;
			char ** s = soap_in_ns6__BEModificationReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:EnterpriseType")) {
			*type = SOAP_TYPE_ns6__EnterpriseType;
			char ** s = soap_in_ns6__EnterpriseType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:Code3")) {
			*type = SOAP_TYPE_ns6__Code3;
			char ** s = soap_in_ns6__Code3(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns6:Code")) {
			*type = SOAP_TYPE_ns6__Code;
			char ** s = soap_in_ns6__Code(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns4:APIKey")) {
			*type = SOAP_TYPE_ns4__APIKey;
			char ** s = soap_in_ns4__APIKey(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:SequenceNumber")) {
			*type = SOAP_TYPE_ns3__SequenceNumber;
			char ** s = soap_in_ns3__SequenceNumber(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:Identifier")) {
			*type = SOAP_TYPE_ns3__Identifier;
			char ** s = soap_in_ns3__Identifier(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:VersionStatus")) {
			*type = SOAP_TYPE_ns3__VersionStatus;
			char ** s = soap_in_ns3__VersionStatus(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:Decimal")) {
			*type = SOAP_TYPE_ns3__Decimal;
			char ** s = soap_in_ns3__Decimal(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:String32")) {
			*type = SOAP_TYPE_ns3__String32;
			char ** s = soap_in_ns3__String32(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:String255")) {
			*type = SOAP_TYPE_ns3__String255;
			char ** s = soap_in_ns3__String255(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:NText")) {
			*type = SOAP_TYPE_ns3__NText;
			char ** s = soap_in_ns3__NText(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:Text")) {
			*type = SOAP_TYPE_ns3__Text;
			char ** s = soap_in_ns3__Text(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ns3:UUID")) {
			*type = SOAP_TYPE_ns3__UUID;
			char ** s = soap_in_ns3__UUID(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:token")) {
			*type = SOAP_TYPE_xsd__token;
			char ** s = soap_in_xsd__token(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:positiveInteger")) {
			*type = SOAP_TYPE_xsd__positiveInteger;
			char ** s = soap_in_xsd__positiveInteger(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:nonNegativeInteger")) {
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			char ** s = soap_in_xsd__nonNegativeInteger(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:integer")) {
			*type = SOAP_TYPE_xsd__integer;
			char ** s = soap_in_xsd__integer(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:decimal")) {
			*type = SOAP_TYPE_xsd__decimal;
			char ** s = soap_in_xsd__decimal(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:date")) {
			*type = SOAP_TYPE_xsd__date;
			char ** s = soap_in_xsd__date(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:Name")) {
			*type = SOAP_TYPE_xsd__Name;
			char ** s = soap_in_xsd__Name(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:NCName")) {
			*type = SOAP_TYPE_xsd__NCName;
			char ** s = soap_in_xsd__NCName(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:IDREF")) {
			*type = SOAP_TYPE_xsd__IDREF;
			char ** s = soap_in_xsd__IDREF(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:ID")) {
			*type = SOAP_TYPE_xsd__ID;
			char ** s = soap_in_xsd__ID(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:QName")) {
			*type = SOAP_TYPE__QName;
			char ** s = soap_in__QName(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:string")) {
			*type = SOAP_TYPE_string;
			char ** s = soap_in_string(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if(!soap_match_tag(soap, t, "ns6:BusinessEntity-activityLocation")) { *type = SOAP_TYPE__ns6__BusinessEntity_activityLocation; return soap_in__ns6__BusinessEntity_activityLocation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns7:BEActivityLocationsModificationOperation-activityLocation")) { *type = SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation; return soap_in__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodChangesListResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodChangesListResponse; return soap_in__ns8__getResearchMethodChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodChangesListRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodChangesListRequest; return soap_in__ns8__getResearchMethodChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodListResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodListResponse; return soap_in__ns8__getResearchMethodListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodListRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodListRequest; return soap_in__ns8__getResearchMethodListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByUuidResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodByUuidResponse; return soap_in__ns8__getResearchMethodByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByUuidRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodByUuidRequest; return soap_in__ns8__getResearchMethodByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByGuidResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodByGuidResponse; return soap_in__ns8__getResearchMethodByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByGuidRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodByGuidRequest; return soap_in__ns8__getResearchMethodByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseChangesListResponse")) { *type = SOAP_TYPE__ns8__getDiseaseChangesListResponse; return soap_in__ns8__getDiseaseChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseChangesListRequest")) { *type = SOAP_TYPE__ns8__getDiseaseChangesListRequest; return soap_in__ns8__getDiseaseChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseListResponse")) { *type = SOAP_TYPE__ns8__getDiseaseListResponse; return soap_in__ns8__getDiseaseListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseListRequest")) { *type = SOAP_TYPE__ns8__getDiseaseListRequest; return soap_in__ns8__getDiseaseListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByUuidResponse")) { *type = SOAP_TYPE__ns8__getDiseaseByUuidResponse; return soap_in__ns8__getDiseaseByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByUuidRequest")) { *type = SOAP_TYPE__ns8__getDiseaseByUuidRequest; return soap_in__ns8__getDiseaseByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByGuidResponse")) { *type = SOAP_TYPE__ns8__getDiseaseByGuidResponse; return soap_in__ns8__getDiseaseByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByGuidRequest")) { *type = SOAP_TYPE__ns8__getDiseaseByGuidRequest; return soap_in__ns8__getDiseaseByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nShippingRuleListResponse")) { *type = SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse; return soap_in__ns8__getActualR13nShippingRuleListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nShippingRuleListRequest")) { *type = SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest; return soap_in__ns8__getActualR13nShippingRuleListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nRegionStatusListResponse")) { *type = SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse; return soap_in__ns8__getActualR13nRegionStatusListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nRegionStatusListRequest")) { *type = SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest; return soap_in__ns8__getActualR13nRegionStatusListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getR13nConditionListResponse")) { *type = SOAP_TYPE__ns8__getR13nConditionListResponse; return soap_in__ns8__getR13nConditionListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getR13nConditionListRequest")) { *type = SOAP_TYPE__ns8__getR13nConditionListRequest; return soap_in__ns8__getR13nConditionListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActivityLocationListResponse")) { *type = SOAP_TYPE__ns8__getActivityLocationListResponse; return soap_in__ns8__getActivityLocationListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActivityLocationListRequest")) { *type = SOAP_TYPE__ns8__getActivityLocationListRequest; return soap_in__ns8__getActivityLocationListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessMemberByGLNResponse")) { *type = SOAP_TYPE__ns8__getBusinessMemberByGLNResponse; return soap_in__ns8__getBusinessMemberByGLNResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessMemberByGLNRequest")) { *type = SOAP_TYPE__ns8__getBusinessMemberByGLNRequest; return soap_in__ns8__getBusinessMemberByGLNRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityChangesListResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityChangesListResponse; return soap_in__ns8__getBusinessEntityChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityChangesListRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityChangesListRequest; return soap_in__ns8__getBusinessEntityChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityListResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityListResponse; return soap_in__ns8__getBusinessEntityListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityListRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityListRequest; return soap_in__ns8__getBusinessEntityListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByUuidResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityByUuidResponse; return soap_in__ns8__getBusinessEntityByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByUuidRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityByUuidRequest; return soap_in__ns8__getBusinessEntityByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByGuidResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityByGuidResponse; return soap_in__ns8__getBusinessEntityByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByGuidRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityByGuidRequest; return soap_in__ns8__getBusinessEntityByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseChangesListResponse")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse; return soap_in__ns8__getRussianEnterpriseChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseChangesListRequest")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest; return soap_in__ns8__getRussianEnterpriseChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseChangesListResponse")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse; return soap_in__ns8__getForeignEnterpriseChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseChangesListRequest")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest; return soap_in__ns8__getForeignEnterpriseChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseListResponse")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseListResponse; return soap_in__ns8__getRussianEnterpriseListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseListRequest")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseListRequest; return soap_in__ns8__getRussianEnterpriseListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseListResponse")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseListResponse; return soap_in__ns8__getForeignEnterpriseListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseListRequest")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseListRequest; return soap_in__ns8__getForeignEnterpriseListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByUuidResponse")) { *type = SOAP_TYPE__ns8__getEnterpriseByUuidResponse; return soap_in__ns8__getEnterpriseByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByUuidRequest")) { *type = SOAP_TYPE__ns8__getEnterpriseByUuidRequest; return soap_in__ns8__getEnterpriseByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByGuidResponse")) { *type = SOAP_TYPE__ns8__getEnterpriseByGuidResponse; return soap_in__ns8__getEnterpriseByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByGuidRequest")) { *type = SOAP_TYPE__ns8__getEnterpriseByGuidRequest; return soap_in__ns8__getEnterpriseByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findStreetListByNameResponse")) { *type = SOAP_TYPE__ns8__findStreetListByNameResponse; return soap_in__ns8__findStreetListByNameResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findStreetListByNameRequest")) { *type = SOAP_TYPE__ns8__findStreetListByNameRequest; return soap_in__ns8__findStreetListByNameRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findLocalityListByNameResponse")) { *type = SOAP_TYPE__ns8__findLocalityListByNameResponse; return soap_in__ns8__findLocalityListByNameResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findLocalityListByNameRequest")) { *type = SOAP_TYPE__ns8__findLocalityListByNameRequest; return soap_in__ns8__findLocalityListByNameRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getStreetListByLocalityResponse")) { *type = SOAP_TYPE__ns8__getStreetListByLocalityResponse; return soap_in__ns8__getStreetListByLocalityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getStreetListByLocalityRequest")) { *type = SOAP_TYPE__ns8__getStreetListByLocalityRequest; return soap_in__ns8__getStreetListByLocalityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByLocalityResponse")) { *type = SOAP_TYPE__ns8__getLocalityListByLocalityResponse; return soap_in__ns8__getLocalityListByLocalityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByLocalityRequest")) { *type = SOAP_TYPE__ns8__getLocalityListByLocalityRequest; return soap_in__ns8__getLocalityListByLocalityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByDistrictResponse")) { *type = SOAP_TYPE__ns8__getLocalityListByDistrictResponse; return soap_in__ns8__getLocalityListByDistrictResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByDistrictRequest")) { *type = SOAP_TYPE__ns8__getLocalityListByDistrictRequest; return soap_in__ns8__getLocalityListByDistrictRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByRegionResponse")) { *type = SOAP_TYPE__ns8__getLocalityListByRegionResponse; return soap_in__ns8__getLocalityListByRegionResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByRegionRequest")) { *type = SOAP_TYPE__ns8__getLocalityListByRegionRequest; return soap_in__ns8__getLocalityListByRegionRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictChangesListResponse")) { *type = SOAP_TYPE__ns8__getDistrictChangesListResponse; return soap_in__ns8__getDistrictChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictChangesListRequest")) { *type = SOAP_TYPE__ns8__getDistrictChangesListRequest; return soap_in__ns8__getDistrictChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByUuidResponse")) { *type = SOAP_TYPE__ns8__getDistrictByUuidResponse; return soap_in__ns8__getDistrictByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByUuidRequest")) { *type = SOAP_TYPE__ns8__getDistrictByUuidRequest; return soap_in__ns8__getDistrictByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByGuidResponse")) { *type = SOAP_TYPE__ns8__getDistrictByGuidResponse; return soap_in__ns8__getDistrictByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByGuidRequest")) { *type = SOAP_TYPE__ns8__getDistrictByGuidRequest; return soap_in__ns8__getDistrictByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictListByRegionResponse")) { *type = SOAP_TYPE__ns8__getDistrictListByRegionResponse; return soap_in__ns8__getDistrictListByRegionResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictListByRegionRequest")) { *type = SOAP_TYPE__ns8__getDistrictListByRegionRequest; return soap_in__ns8__getDistrictListByRegionRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionChangesListResponse")) { *type = SOAP_TYPE__ns8__getRegionChangesListResponse; return soap_in__ns8__getRegionChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionChangesListRequest")) { *type = SOAP_TYPE__ns8__getRegionChangesListRequest; return soap_in__ns8__getRegionChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByUuidResponse")) { *type = SOAP_TYPE__ns8__getRegionByUuidResponse; return soap_in__ns8__getRegionByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByUuidRequest")) { *type = SOAP_TYPE__ns8__getRegionByUuidRequest; return soap_in__ns8__getRegionByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByGuidResponse")) { *type = SOAP_TYPE__ns8__getRegionByGuidResponse; return soap_in__ns8__getRegionByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByGuidRequest")) { *type = SOAP_TYPE__ns8__getRegionByGuidRequest; return soap_in__ns8__getRegionByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionListByCountryResponse")) { *type = SOAP_TYPE__ns8__getRegionListByCountryResponse; return soap_in__ns8__getRegionListByCountryResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionListByCountryRequest")) { *type = SOAP_TYPE__ns8__getRegionListByCountryRequest; return soap_in__ns8__getRegionListByCountryRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryChangesListResponse")) { *type = SOAP_TYPE__ns8__getCountryChangesListResponse; return soap_in__ns8__getCountryChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryChangesListRequest")) { *type = SOAP_TYPE__ns8__getCountryChangesListRequest; return soap_in__ns8__getCountryChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByUuidResponse")) { *type = SOAP_TYPE__ns8__getCountryByUuidResponse; return soap_in__ns8__getCountryByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByUuidRequest")) { *type = SOAP_TYPE__ns8__getCountryByUuidRequest; return soap_in__ns8__getCountryByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByGuidResponse")) { *type = SOAP_TYPE__ns8__getCountryByGuidResponse; return soap_in__ns8__getCountryByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByGuidRequest")) { *type = SOAP_TYPE__ns8__getCountryByGuidRequest; return soap_in__ns8__getCountryByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getAllCountryListResponse")) { *type = SOAP_TYPE__ns8__getAllCountryListResponse; return soap_in__ns8__getAllCountryListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getAllCountryListRequest")) { *type = SOAP_TYPE__ns8__getAllCountryListRequest; return soap_in__ns8__getAllCountryListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemChangesListResponse")) { *type = SOAP_TYPE__ns8__getProductItemChangesListResponse; return soap_in__ns8__getProductItemChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemChangesListRequest")) { *type = SOAP_TYPE__ns8__getProductItemChangesListRequest; return soap_in__ns8__getProductItemChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemListResponse")) { *type = SOAP_TYPE__ns8__getProductItemListResponse; return soap_in__ns8__getProductItemListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemListRequest")) { *type = SOAP_TYPE__ns8__getProductItemListRequest; return soap_in__ns8__getProductItemListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByUuidResponse")) { *type = SOAP_TYPE__ns8__getProductItemByUuidResponse; return soap_in__ns8__getProductItemByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByUuidRequest")) { *type = SOAP_TYPE__ns8__getProductItemByUuidRequest; return soap_in__ns8__getProductItemByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByGuidResponse")) { *type = SOAP_TYPE__ns8__getProductItemByGuidResponse; return soap_in__ns8__getProductItemByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByGuidRequest")) { *type = SOAP_TYPE__ns8__getProductItemByGuidRequest; return soap_in__ns8__getProductItemByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductChangesListResponse")) { *type = SOAP_TYPE__ns8__getSubProductChangesListResponse; return soap_in__ns8__getSubProductChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductChangesListRequest")) { *type = SOAP_TYPE__ns8__getSubProductChangesListRequest; return soap_in__ns8__getSubProductChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByProductListResponse")) { *type = SOAP_TYPE__ns8__getSubProductByProductListResponse; return soap_in__ns8__getSubProductByProductListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByProductListRequest")) { *type = SOAP_TYPE__ns8__getSubProductByProductListRequest; return soap_in__ns8__getSubProductByProductListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByUuidResponse")) { *type = SOAP_TYPE__ns8__getSubProductByUuidResponse; return soap_in__ns8__getSubProductByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByUuidRequest")) { *type = SOAP_TYPE__ns8__getSubProductByUuidRequest; return soap_in__ns8__getSubProductByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByGuidResponse")) { *type = SOAP_TYPE__ns8__getSubProductByGuidResponse; return soap_in__ns8__getSubProductByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByGuidRequest")) { *type = SOAP_TYPE__ns8__getSubProductByGuidRequest; return soap_in__ns8__getSubProductByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductChangesListResponse")) { *type = SOAP_TYPE__ns8__getProductChangesListResponse; return soap_in__ns8__getProductChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductChangesListRequest")) { *type = SOAP_TYPE__ns8__getProductChangesListRequest; return soap_in__ns8__getProductChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByTypeListResponse")) { *type = SOAP_TYPE__ns8__getProductByTypeListResponse; return soap_in__ns8__getProductByTypeListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByTypeListRequest")) { *type = SOAP_TYPE__ns8__getProductByTypeListRequest; return soap_in__ns8__getProductByTypeListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByUuidResponse")) { *type = SOAP_TYPE__ns8__getProductByUuidResponse; return soap_in__ns8__getProductByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByUuidRequest")) { *type = SOAP_TYPE__ns8__getProductByUuidRequest; return soap_in__ns8__getProductByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByGuidResponse")) { *type = SOAP_TYPE__ns8__getProductByGuidResponse; return soap_in__ns8__getProductByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByGuidRequest")) { *type = SOAP_TYPE__ns8__getProductByGuidRequest; return soap_in__ns8__getProductByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitChangesListResponse")) { *type = SOAP_TYPE__ns8__getUnitChangesListResponse; return soap_in__ns8__getUnitChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitChangesListRequest")) { *type = SOAP_TYPE__ns8__getUnitChangesListRequest; return soap_in__ns8__getUnitChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitListResponse")) { *type = SOAP_TYPE__ns8__getUnitListResponse; return soap_in__ns8__getUnitListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitListRequest")) { *type = SOAP_TYPE__ns8__getUnitListRequest; return soap_in__ns8__getUnitListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByUuidResponse")) { *type = SOAP_TYPE__ns8__getUnitByUuidResponse; return soap_in__ns8__getUnitByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByUuidRequest")) { *type = SOAP_TYPE__ns8__getUnitByUuidRequest; return soap_in__ns8__getUnitByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByGuidResponse")) { *type = SOAP_TYPE__ns8__getUnitByGuidResponse; return soap_in__ns8__getUnitByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByGuidRequest")) { *type = SOAP_TYPE__ns8__getUnitByGuidRequest; return soap_in__ns8__getUnitByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeChangesListResponse")) { *type = SOAP_TYPE__ns8__getPurposeChangesListResponse; return soap_in__ns8__getPurposeChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeChangesListRequest")) { *type = SOAP_TYPE__ns8__getPurposeChangesListRequest; return soap_in__ns8__getPurposeChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeListResponse")) { *type = SOAP_TYPE__ns8__getPurposeListResponse; return soap_in__ns8__getPurposeListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeListRequest")) { *type = SOAP_TYPE__ns8__getPurposeListRequest; return soap_in__ns8__getPurposeListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByUuidResponse")) { *type = SOAP_TYPE__ns8__getPurposeByUuidResponse; return soap_in__ns8__getPurposeByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByUuidRequest")) { *type = SOAP_TYPE__ns8__getPurposeByUuidRequest; return soap_in__ns8__getPurposeByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByGuidResponse")) { *type = SOAP_TYPE__ns8__getPurposeByGuidResponse; return soap_in__ns8__getPurposeByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByGuidRequest")) { *type = SOAP_TYPE__ns8__getPurposeByGuidRequest; return soap_in__ns8__getPurposeByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns1:receiveApplicationResultResponse")) { *type = SOAP_TYPE__ns1__receiveApplicationResultResponse; return soap_in__ns1__receiveApplicationResultResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns1:receiveApplicationResultRequest")) { *type = SOAP_TYPE__ns1__receiveApplicationResultRequest; return soap_in__ns1__receiveApplicationResultRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns1:submitApplicationResponse")) { *type = SOAP_TYPE__ns1__submitApplicationResponse; return soap_in__ns1__submitApplicationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns1:submitApplicationRequest")) { *type = SOAP_TYPE__ns1__submitApplicationRequest; return soap_in__ns1__submitApplicationRequest(soap, 0, 0, 0); }
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if(!soap_peek_element(soap)) {
		int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if(soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if(((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if(!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			soap->error = soap->fignore ? soap->fignore(soap, soap->tag) : SOAP_OK;
			DBGLOG(TEST, if(!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if(!soap->error && soap->body)
			{	soap->level++;
				while(!soap_ignore_element(soap))
					;
				if(soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int FASTCALL soap_putindependent(struct soap *soap)
{
	if(soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for(int i = 0; i < SOAP_PTRHASH; i++)
			for(struct soap_plist * pp = soap->pht[i]; pp; pp = pp->next)
				if(pp->mark1 == 2 || pp->mark2 == 2)
					if(soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	(void)tag;
	switch(type) {
	case SOAP_TYPE_byte: return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns6__Minute: return soap_out_ns6__Minute(soap, tag, id, (const int *)ptr, "ns6:Minute");
	case SOAP_TYPE_ns6__Hour: return soap_out_ns6__Hour(soap, tag, id, (const int *)ptr, "ns6:Hour");
	case SOAP_TYPE_ns6__Day: return soap_out_ns6__Day(soap, tag, id, (const int *)ptr, "ns6:Day");
	case SOAP_TYPE_ns6__Month: return soap_out_ns6__Month(soap, tag, id, (const int *)ptr, "ns6:Month");
	case SOAP_TYPE_ns6__Year: return soap_out_ns6__Year(soap, tag, id, (const int *)ptr, "ns6:Year");
	case SOAP_TYPE_int: return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64: return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte: return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt: return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time: return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool: return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns7__AnimalSpentPeriod: return soap_out_ns7__AnimalSpentPeriod(soap, tag, id, (const enum ns7__AnimalSpentPeriod *)ptr, "ns7:AnimalSpentPeriod");
	case SOAP_TYPE_ns7__VetDocumentStatus: return soap_out_ns7__VetDocumentStatus(soap, tag, id, (const enum ns7__VetDocumentStatus *)ptr, "ns7:VetDocumentStatus");
	case SOAP_TYPE_ns7__VetDocumentType: return soap_out_ns7__VetDocumentType(soap, tag, id, (const enum ns7__VetDocumentType *)ptr, "ns7:VetDocumentType");
	case SOAP_TYPE_ns7__VetDocumentForm: return soap_out_ns7__VetDocumentForm(soap, tag, id, (const enum ns7__VetDocumentForm *)ptr, "ns7:VetDocumentForm");
	case SOAP_TYPE_ns7__DeliveryInspectionResult: return soap_out_ns7__DeliveryInspectionResult(soap, tag, id, (const enum ns7__DeliveryInspectionResult *)ptr, "ns7:DeliveryInspectionResult");
	case SOAP_TYPE_ns7__DeliveryDecision: return soap_out_ns7__DeliveryDecision(soap, tag, id, (const enum ns7__DeliveryDecision *)ptr, "ns7:DeliveryDecision");
	case SOAP_TYPE_ns6__ProductMarkingClass: return soap_out_ns6__ProductMarkingClass(soap, tag, id, (const enum ns6__ProductMarkingClass *)ptr, "ns6:ProductMarkingClass");
	case SOAP_TYPE_ns6__TransportationStorageType: return soap_out_ns6__TransportationStorageType(soap, tag, id, (const enum ns6__TransportationStorageType *)ptr, "ns6:TransportationStorageType");
	case SOAP_TYPE_ns6__DocumentNature: return soap_out_ns6__DocumentNature(soap, tag, id, (const enum ns6__DocumentNature *)ptr, "ns6:DocumentNature");
	case SOAP_TYPE_ns6__EnterpriseRole: return soap_out_ns6__EnterpriseRole(soap, tag, id, (const enum ns6__EnterpriseRole *)ptr, "ns6:EnterpriseRole");
	case SOAP_TYPE_ns7__ProcessingProcedureType: return soap_out_ns7__ProcessingProcedureType(soap, tag, id, (const enum ns7__ProcessingProcedureType *)ptr, "ns7:ProcessingProcedureType");
	case SOAP_TYPE_ns7__VeterinaryEventType: return soap_out_ns7__VeterinaryEventType(soap, tag, id, (const enum ns7__VeterinaryEventType *)ptr, "ns7:VeterinaryEventType");
	case SOAP_TYPE_ns7__StockEntryBlankFilter: return soap_out_ns7__StockEntryBlankFilter(soap, tag, id, (const enum ns7__StockEntryBlankFilter *)ptr, "ns7:StockEntryBlankFilter");
	case SOAP_TYPE_ns6__VaccinationType: return soap_out_ns6__VaccinationType(soap, tag, id, (const enum ns6__VaccinationType *)ptr, "ns6:VaccinationType");
	case SOAP_TYPE_ns6__ProsperityType: return soap_out_ns6__ProsperityType(soap, tag, id, (const enum ns6__ProsperityType *)ptr, "ns6:ProsperityType");
	case SOAP_TYPE_ns6__RegionalizationDecision: return soap_out_ns6__RegionalizationDecision(soap, tag, id, (const enum ns6__RegionalizationDecision *)ptr, "ns6:RegionalizationDecision");
	case SOAP_TYPE_ns6__ResearchResult: return soap_out_ns6__ResearchResult(soap, tag, id, (const enum ns6__ResearchResult *)ptr, "ns6:ResearchResult");
	case SOAP_TYPE_ns6__TransportType: return soap_out_ns6__TransportType(soap, tag, id, (const enum ns6__TransportType *)ptr, "ns6:TransportType");
	case SOAP_TYPE_ns6__ReferenceType: return soap_out_ns6__ReferenceType(soap, tag, id, (const enum ns6__ReferenceType *)ptr, "ns6:ReferenceType");
	case SOAP_TYPE_ns6__DocumentType: return soap_out_ns6__DocumentType(soap, tag, id, (const enum ns6__DocumentType *)ptr, "ns6:DocumentType");
	case SOAP_TYPE_ns6__ProductType: return soap_out_ns6__ProductType(soap, tag, id, (const enum ns6__ProductType *)ptr, "ns6:ProductType");
	case SOAP_TYPE_ns6__BusinessEntityType: return soap_out_ns6__BusinessEntityType(soap, tag, id, (const enum ns6__BusinessEntityType *)ptr, "ns6:BusinessEntityType");
	case SOAP_TYPE_ns6__EnterpriseGroup: return soap_out_ns6__EnterpriseGroup(soap, tag, id, (const enum ns6__EnterpriseGroup *)ptr, "ns6:EnterpriseGroup");
	case SOAP_TYPE_ns6__PackingCodeType: return soap_out_ns6__PackingCodeType(soap, tag, id, (const enum ns6__PackingCodeType *)ptr, "ns6:PackingCodeType");
	case SOAP_TYPE_ns6__PackageLevelType: return soap_out_ns6__PackageLevelType(soap, tag, id, (const enum ns6__PackageLevelType *)ptr, "ns6:PackageLevelType");
	case SOAP_TYPE_ns4__ContentEncoding: return soap_out_ns4__ContentEncoding(soap, tag, id, (const enum ns4__ContentEncoding *)ptr, "ns4:ContentEncoding");
	case SOAP_TYPE_ns4__ApplicationStatus: return soap_out_ns4__ApplicationStatus(soap, tag, id, (const enum ns4__ApplicationStatus *)ptr, "ns4:ApplicationStatus");
	case SOAP_TYPE_ns3__RegisterModificationType: return soap_out_ns3__RegisterModificationType(soap, tag, id, (const enum ns3__RegisterModificationType *)ptr, "ns3:RegisterModificationType");
	case SOAP_TYPE__ns6__BusinessEntity_activityLocation: return ((_ns6__BusinessEntity_activityLocation *)ptr)->soap_out(soap, "ns6:BusinessEntity-activityLocation", id, NULL);
	case SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation: return ((_ns7__BEActivityLocationsModificationOperation_activityLocation *)ptr)->soap_out(soap, "ns7:BEActivityLocationsModificationOperation-activityLocation", id, NULL);
	case SOAP_TYPE_ns4__BinaryContent: return soap_out_ns4__BinaryContent(soap, tag, id, (const xsd__base64Binary *)ptr, "ns4:BinaryContent");
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse: return ((_ns8__getResearchMethodChangesListResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest: return ((_ns8__getResearchMethodChangesListRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodListResponse: return ((_ns8__getResearchMethodListResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodListResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodListRequest: return ((_ns8__getResearchMethodListRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodListRequest", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse: return ((_ns8__getResearchMethodByUuidResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest: return ((_ns8__getResearchMethodByUuidRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse: return ((_ns8__getResearchMethodByGuidResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest: return ((_ns8__getResearchMethodByGuidRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse: return ((_ns8__getDiseaseChangesListResponse *)ptr)->soap_out(soap, "ns8:getDiseaseChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest: return ((_ns8__getDiseaseChangesListRequest *)ptr)->soap_out(soap, "ns8:getDiseaseChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseListResponse: return ((_ns8__getDiseaseListResponse *)ptr)->soap_out(soap, "ns8:getDiseaseListResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseListRequest: return ((_ns8__getDiseaseListRequest *)ptr)->soap_out(soap, "ns8:getDiseaseListRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse: return ((_ns8__getDiseaseByUuidResponse *)ptr)->soap_out(soap, "ns8:getDiseaseByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest: return ((_ns8__getDiseaseByUuidRequest *)ptr)->soap_out(soap, "ns8:getDiseaseByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse: return ((_ns8__getDiseaseByGuidResponse *)ptr)->soap_out(soap, "ns8:getDiseaseByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest: return ((_ns8__getDiseaseByGuidRequest *)ptr)->soap_out(soap, "ns8:getDiseaseByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse: return ((_ns8__getActualR13nShippingRuleListResponse *)ptr)->soap_out(soap, "ns8:getActualR13nShippingRuleListResponse", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest: return ((_ns8__getActualR13nShippingRuleListRequest *)ptr)->soap_out(soap, "ns8:getActualR13nShippingRuleListRequest", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse: return ((_ns8__getActualR13nRegionStatusListResponse *)ptr)->soap_out(soap, "ns8:getActualR13nRegionStatusListResponse", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest: return ((_ns8__getActualR13nRegionStatusListRequest *)ptr)->soap_out(soap, "ns8:getActualR13nRegionStatusListRequest", id, NULL);
	case SOAP_TYPE__ns8__getR13nConditionListResponse: return ((_ns8__getR13nConditionListResponse *)ptr)->soap_out(soap, "ns8:getR13nConditionListResponse", id, NULL);
	case SOAP_TYPE__ns8__getR13nConditionListRequest: return ((_ns8__getR13nConditionListRequest *)ptr)->soap_out(soap, "ns8:getR13nConditionListRequest", id, NULL);
	case SOAP_TYPE__ns8__getActivityLocationListResponse: return ((_ns8__getActivityLocationListResponse *)ptr)->soap_out(soap, "ns8:getActivityLocationListResponse", id, NULL);
	case SOAP_TYPE__ns8__getActivityLocationListRequest: return ((_ns8__getActivityLocationListRequest *)ptr)->soap_out(soap, "ns8:getActivityLocationListRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse: return ((_ns8__getBusinessMemberByGLNResponse *)ptr)->soap_out(soap, "ns8:getBusinessMemberByGLNResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest: return ((_ns8__getBusinessMemberByGLNRequest *)ptr)->soap_out(soap, "ns8:getBusinessMemberByGLNRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse: return ((_ns8__getBusinessEntityChangesListResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest: return ((_ns8__getBusinessEntityChangesListRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityListResponse: return ((_ns8__getBusinessEntityListResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityListResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityListRequest: return ((_ns8__getBusinessEntityListRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityListRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse: return ((_ns8__getBusinessEntityByUuidResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest: return ((_ns8__getBusinessEntityByUuidRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse: return ((_ns8__getBusinessEntityByGuidResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest: return ((_ns8__getBusinessEntityByGuidRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse: return ((_ns8__getRussianEnterpriseChangesListResponse *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest: return ((_ns8__getRussianEnterpriseChangesListRequest *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse: return ((_ns8__getForeignEnterpriseChangesListResponse *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest: return ((_ns8__getForeignEnterpriseChangesListRequest *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse: return ((_ns8__getRussianEnterpriseListResponse *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseListResponse", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest: return ((_ns8__getRussianEnterpriseListRequest *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseListRequest", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse: return ((_ns8__getForeignEnterpriseListResponse *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseListResponse", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest: return ((_ns8__getForeignEnterpriseListRequest *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseListRequest", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse: return ((_ns8__getEnterpriseByUuidResponse *)ptr)->soap_out(soap, "ns8:getEnterpriseByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest: return ((_ns8__getEnterpriseByUuidRequest *)ptr)->soap_out(soap, "ns8:getEnterpriseByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse: return ((_ns8__getEnterpriseByGuidResponse *)ptr)->soap_out(soap, "ns8:getEnterpriseByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest: return ((_ns8__getEnterpriseByGuidRequest *)ptr)->soap_out(soap, "ns8:getEnterpriseByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__findStreetListByNameResponse: return ((_ns8__findStreetListByNameResponse *)ptr)->soap_out(soap, "ns8:findStreetListByNameResponse", id, NULL);
	case SOAP_TYPE__ns8__findStreetListByNameRequest: return ((_ns8__findStreetListByNameRequest *)ptr)->soap_out(soap, "ns8:findStreetListByNameRequest", id, NULL);
	case SOAP_TYPE__ns8__findLocalityListByNameResponse: return ((_ns8__findLocalityListByNameResponse *)ptr)->soap_out(soap, "ns8:findLocalityListByNameResponse", id, NULL);
	case SOAP_TYPE__ns8__findLocalityListByNameRequest: return ((_ns8__findLocalityListByNameRequest *)ptr)->soap_out(soap, "ns8:findLocalityListByNameRequest", id, NULL);
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse: return ((_ns8__getStreetListByLocalityResponse *)ptr)->soap_out(soap, "ns8:getStreetListByLocalityResponse", id, NULL);
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest: return ((_ns8__getStreetListByLocalityRequest *)ptr)->soap_out(soap, "ns8:getStreetListByLocalityRequest", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse: return ((_ns8__getLocalityListByLocalityResponse *)ptr)->soap_out(soap, "ns8:getLocalityListByLocalityResponse", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest: return ((_ns8__getLocalityListByLocalityRequest *)ptr)->soap_out(soap, "ns8:getLocalityListByLocalityRequest", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse: return ((_ns8__getLocalityListByDistrictResponse *)ptr)->soap_out(soap, "ns8:getLocalityListByDistrictResponse", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest: return ((_ns8__getLocalityListByDistrictRequest *)ptr)->soap_out(soap, "ns8:getLocalityListByDistrictRequest", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse: return ((_ns8__getLocalityListByRegionResponse *)ptr)->soap_out(soap, "ns8:getLocalityListByRegionResponse", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest: return ((_ns8__getLocalityListByRegionRequest *)ptr)->soap_out(soap, "ns8:getLocalityListByRegionRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictChangesListResponse: return ((_ns8__getDistrictChangesListResponse *)ptr)->soap_out(soap, "ns8:getDistrictChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictChangesListRequest: return ((_ns8__getDistrictChangesListRequest *)ptr)->soap_out(soap, "ns8:getDistrictChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByUuidResponse: return ((_ns8__getDistrictByUuidResponse *)ptr)->soap_out(soap, "ns8:getDistrictByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByUuidRequest: return ((_ns8__getDistrictByUuidRequest *)ptr)->soap_out(soap, "ns8:getDistrictByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByGuidResponse: return ((_ns8__getDistrictByGuidResponse *)ptr)->soap_out(soap, "ns8:getDistrictByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByGuidRequest: return ((_ns8__getDistrictByGuidRequest *)ptr)->soap_out(soap, "ns8:getDistrictByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse: return ((_ns8__getDistrictListByRegionResponse *)ptr)->soap_out(soap, "ns8:getDistrictListByRegionResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest: return ((_ns8__getDistrictListByRegionRequest *)ptr)->soap_out(soap, "ns8:getDistrictListByRegionRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionChangesListResponse: return ((_ns8__getRegionChangesListResponse *)ptr)->soap_out(soap, "ns8:getRegionChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionChangesListRequest: return ((_ns8__getRegionChangesListRequest *)ptr)->soap_out(soap, "ns8:getRegionChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionByUuidResponse: return ((_ns8__getRegionByUuidResponse *)ptr)->soap_out(soap, "ns8:getRegionByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionByUuidRequest: return ((_ns8__getRegionByUuidRequest *)ptr)->soap_out(soap, "ns8:getRegionByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionByGuidResponse: return ((_ns8__getRegionByGuidResponse *)ptr)->soap_out(soap, "ns8:getRegionByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionByGuidRequest: return ((_ns8__getRegionByGuidRequest *)ptr)->soap_out(soap, "ns8:getRegionByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionListByCountryResponse: return ((_ns8__getRegionListByCountryResponse *)ptr)->soap_out(soap, "ns8:getRegionListByCountryResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionListByCountryRequest: return ((_ns8__getRegionListByCountryRequest *)ptr)->soap_out(soap, "ns8:getRegionListByCountryRequest", id, NULL);
	case SOAP_TYPE__ns8__getCountryChangesListResponse: return ((_ns8__getCountryChangesListResponse *)ptr)->soap_out(soap, "ns8:getCountryChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getCountryChangesListRequest: return ((_ns8__getCountryChangesListRequest *)ptr)->soap_out(soap, "ns8:getCountryChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getCountryByUuidResponse: return ((_ns8__getCountryByUuidResponse *)ptr)->soap_out(soap, "ns8:getCountryByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getCountryByUuidRequest: return ((_ns8__getCountryByUuidRequest *)ptr)->soap_out(soap, "ns8:getCountryByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getCountryByGuidResponse: return ((_ns8__getCountryByGuidResponse *)ptr)->soap_out(soap, "ns8:getCountryByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getCountryByGuidRequest: return ((_ns8__getCountryByGuidRequest *)ptr)->soap_out(soap, "ns8:getCountryByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getAllCountryListResponse: return ((_ns8__getAllCountryListResponse *)ptr)->soap_out(soap, "ns8:getAllCountryListResponse", id, NULL);
	case SOAP_TYPE__ns8__getAllCountryListRequest: return ((_ns8__getAllCountryListRequest *)ptr)->soap_out(soap, "ns8:getAllCountryListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemChangesListResponse: return ((_ns8__getProductItemChangesListResponse *)ptr)->soap_out(soap, "ns8:getProductItemChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemChangesListRequest: return ((_ns8__getProductItemChangesListRequest *)ptr)->soap_out(soap, "ns8:getProductItemChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemListResponse: return ((_ns8__getProductItemListResponse *)ptr)->soap_out(soap, "ns8:getProductItemListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemListRequest: return ((_ns8__getProductItemListRequest *)ptr)->soap_out(soap, "ns8:getProductItemListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByUuidResponse: return ((_ns8__getProductItemByUuidResponse *)ptr)->soap_out(soap, "ns8:getProductItemByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByUuidRequest: return ((_ns8__getProductItemByUuidRequest *)ptr)->soap_out(soap, "ns8:getProductItemByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByGuidResponse: return ((_ns8__getProductItemByGuidResponse *)ptr)->soap_out(soap, "ns8:getProductItemByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByGuidRequest: return ((_ns8__getProductItemByGuidRequest *)ptr)->soap_out(soap, "ns8:getProductItemByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductChangesListResponse: return ((_ns8__getSubProductChangesListResponse *)ptr)->soap_out(soap, "ns8:getSubProductChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductChangesListRequest: return ((_ns8__getSubProductChangesListRequest *)ptr)->soap_out(soap, "ns8:getSubProductChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByProductListResponse: return ((_ns8__getSubProductByProductListResponse *)ptr)->soap_out(soap, "ns8:getSubProductByProductListResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByProductListRequest: return ((_ns8__getSubProductByProductListRequest *)ptr)->soap_out(soap, "ns8:getSubProductByProductListRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByUuidResponse: return ((_ns8__getSubProductByUuidResponse *)ptr)->soap_out(soap, "ns8:getSubProductByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByUuidRequest: return ((_ns8__getSubProductByUuidRequest *)ptr)->soap_out(soap, "ns8:getSubProductByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByGuidResponse: return ((_ns8__getSubProductByGuidResponse *)ptr)->soap_out(soap, "ns8:getSubProductByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByGuidRequest: return ((_ns8__getSubProductByGuidRequest *)ptr)->soap_out(soap, "ns8:getSubProductByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductChangesListResponse: return ((_ns8__getProductChangesListResponse *)ptr)->soap_out(soap, "ns8:getProductChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductChangesListRequest: return ((_ns8__getProductChangesListRequest *)ptr)->soap_out(soap, "ns8:getProductChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductByTypeListResponse: return ((_ns8__getProductByTypeListResponse *)ptr)->soap_out(soap, "ns8:getProductByTypeListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductByTypeListRequest: return ((_ns8__getProductByTypeListRequest *)ptr)->soap_out(soap, "ns8:getProductByTypeListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductByUuidResponse: return ((_ns8__getProductByUuidResponse *)ptr)->soap_out(soap, "ns8:getProductByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductByUuidRequest: return ((_ns8__getProductByUuidRequest *)ptr)->soap_out(soap, "ns8:getProductByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductByGuidResponse: return ((_ns8__getProductByGuidResponse *)ptr)->soap_out(soap, "ns8:getProductByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductByGuidRequest: return ((_ns8__getProductByGuidRequest *)ptr)->soap_out(soap, "ns8:getProductByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitChangesListResponse: return ((_ns8__getUnitChangesListResponse *)ptr)->soap_out(soap, "ns8:getUnitChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitChangesListRequest: return ((_ns8__getUnitChangesListRequest *)ptr)->soap_out(soap, "ns8:getUnitChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitListResponse: return ((_ns8__getUnitListResponse *)ptr)->soap_out(soap, "ns8:getUnitListResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitListRequest: return ((_ns8__getUnitListRequest *)ptr)->soap_out(soap, "ns8:getUnitListRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitByUuidResponse: return ((_ns8__getUnitByUuidResponse *)ptr)->soap_out(soap, "ns8:getUnitByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitByUuidRequest: return ((_ns8__getUnitByUuidRequest *)ptr)->soap_out(soap, "ns8:getUnitByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitByGuidResponse: return ((_ns8__getUnitByGuidResponse *)ptr)->soap_out(soap, "ns8:getUnitByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitByGuidRequest: return ((_ns8__getUnitByGuidRequest *)ptr)->soap_out(soap, "ns8:getUnitByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeChangesListResponse: return ((_ns8__getPurposeChangesListResponse *)ptr)->soap_out(soap, "ns8:getPurposeChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeChangesListRequest: return ((_ns8__getPurposeChangesListRequest *)ptr)->soap_out(soap, "ns8:getPurposeChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeListResponse: return ((_ns8__getPurposeListResponse *)ptr)->soap_out(soap, "ns8:getPurposeListResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeListRequest: return ((_ns8__getPurposeListRequest *)ptr)->soap_out(soap, "ns8:getPurposeListRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByUuidResponse: return ((_ns8__getPurposeByUuidResponse *)ptr)->soap_out(soap, "ns8:getPurposeByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByUuidRequest: return ((_ns8__getPurposeByUuidRequest *)ptr)->soap_out(soap, "ns8:getPurposeByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByGuidResponse: return ((_ns8__getPurposeByGuidResponse *)ptr)->soap_out(soap, "ns8:getPurposeByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByGuidRequest: return ((_ns8__getPurposeByGuidRequest *)ptr)->soap_out(soap, "ns8:getPurposeByGuidRequest", id, NULL);
	case SOAP_TYPE_ns7__WorkingArea: return ((ns7__WorkingArea *)ptr)->soap_out(soap, tag, id, "ns7:WorkingArea");
	case SOAP_TYPE_ns7__UserAuthority: return ((ns7__UserAuthority *)ptr)->soap_out(soap, tag, id, "ns7:UserAuthority");
	case SOAP_TYPE_ns7__WorkingAreaList: return ((ns7__WorkingAreaList *)ptr)->soap_out(soap, tag, id, "ns7:WorkingAreaList");
	case SOAP_TYPE_ns7__AuthorityList: return ((ns7__AuthorityList *)ptr)->soap_out(soap, tag, id, "ns7:AuthorityList");
	case SOAP_TYPE_ns7__UserList: return ((ns7__UserList *)ptr)->soap_out(soap, tag, id, "ns7:UserList");
	case SOAP_TYPE_ns7__User: return ((ns7__User *)ptr)->soap_out(soap, tag, id, "ns7:User");
	case SOAP_TYPE_ns7__ProcessingProcedure: return ((ns7__ProcessingProcedure *)ptr)->soap_out(soap, tag, id, "ns7:ProcessingProcedure");
	case SOAP_TYPE_ns7__RouteSectionR13nRules: return ((ns7__RouteSectionR13nRules *)ptr)->soap_out(soap, tag, id, "ns7:RouteSectionR13nRules");
	case SOAP_TYPE_ns7__RegionalizationClause: return ((ns7__RegionalizationClause *)ptr)->soap_out(soap, tag, id, "ns7:RegionalizationClause");
	case SOAP_TYPE_ns7__VetDocumentStatusChange: return ((ns7__VetDocumentStatusChange *)ptr)->soap_out(soap, tag, id, "ns7:VetDocumentStatusChange");
	case SOAP_TYPE_ns7__StockEntryEventList: return ((ns7__StockEntryEventList *)ptr)->soap_out(soap, tag, id, "ns7:StockEntryEventList");
	case SOAP_TYPE_ns7__BatchOrigin: return ((ns7__BatchOrigin *)ptr)->soap_out(soap, tag, id, "ns7:BatchOrigin");
	case SOAP_TYPE_ns7__VeterinaryAuthentication: return ((ns7__VeterinaryAuthentication *)ptr)->soap_out(soap, tag, id, "ns7:VeterinaryAuthentication");
	case SOAP_TYPE_ns7__QuarantineEvent: return ((ns7__QuarantineEvent *)ptr)->soap_out(soap, tag, id, "ns7:QuarantineEvent");
	case SOAP_TYPE_ns7__AnimalMedicationEvent: return ((ns7__AnimalMedicationEvent *)ptr)->soap_out(soap, tag, id, "ns7:AnimalMedicationEvent");
	case SOAP_TYPE_ns7__LaboratoryResearchEvent: return ((ns7__LaboratoryResearchEvent *)ptr)->soap_out(soap, tag, id, "ns7:LaboratoryResearchEvent");
	case SOAP_TYPE_ns7__VeterinaryEvent: return ((ns7__VeterinaryEvent *)ptr)->soap_out(soap, tag, id, "ns7:VeterinaryEvent");
	case SOAP_TYPE_ns7__ReferencedDocument: return ((ns7__ReferencedDocument *)ptr)->soap_out(soap, tag, id, "ns7:ReferencedDocument");
	case SOAP_TYPE_ns7__CertifiedConsignment: return ((ns7__CertifiedConsignment *)ptr)->soap_out(soap, tag, id, "ns7:CertifiedConsignment");
	case SOAP_TYPE_ns7__CertifiedBatch: return ((ns7__CertifiedBatch *)ptr)->soap_out(soap, tag, id, "ns7:CertifiedBatch");
	case SOAP_TYPE_ns7__ENTModificationOperation: return ((ns7__ENTModificationOperation *)ptr)->soap_out(soap, tag, id, "ns7:ENTModificationOperation");
	case SOAP_TYPE_ns7__BEActivityLocationsModificationOperation: return ((ns7__BEActivityLocationsModificationOperation *)ptr)->soap_out(soap, tag, id, "ns7:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_ns7__BEModificationOperation: return ((ns7__BEModificationOperation *)ptr)->soap_out(soap, tag, id, "ns7:BEModificationOperation");
	case SOAP_TYPE_ns7__PSLModificationOperation: return ((ns7__PSLModificationOperation *)ptr)->soap_out(soap, tag, id, "ns7:PSLModificationOperation");
	case SOAP_TYPE_ns7__MergeStockEntriesOperation: return ((ns7__MergeStockEntriesOperation *)ptr)->soap_out(soap, tag, id, "ns7:MergeStockEntriesOperation");
	case SOAP_TYPE_ns7__ProductionOperation: return ((ns7__ProductionOperation *)ptr)->soap_out(soap, tag, id, "ns7:ProductionOperation");
	case SOAP_TYPE_ns7__ShipmentRoute: return ((ns7__ShipmentRoute *)ptr)->soap_out(soap, tag, id, "ns7:ShipmentRoute");
	case SOAP_TYPE_ns7__ShipmentRoutePoint: return ((ns7__ShipmentRoutePoint *)ptr)->soap_out(soap, tag, id, "ns7:ShipmentRoutePoint");
	case SOAP_TYPE_ns7__TransportNumber: return ((ns7__TransportNumber *)ptr)->soap_out(soap, tag, id, "ns7:TransportNumber");
	case SOAP_TYPE_ns7__TransportInfo: return ((ns7__TransportInfo *)ptr)->soap_out(soap, tag, id, "ns7:TransportInfo");
	case SOAP_TYPE_ns7__Waybill: return ((ns7__Waybill *)ptr)->soap_out(soap, tag, id, "ns7:Waybill");
	case SOAP_TYPE_ns7__Document: return ((ns7__Document *)ptr)->soap_out(soap, tag, id, "ns7:Document");
	case SOAP_TYPE_ns7__StockEntrySearchPattern: return ((ns7__StockEntrySearchPattern *)ptr)->soap_out(soap, tag, id, "ns7:StockEntrySearchPattern");
	case SOAP_TYPE_ns7__StockDiscrepancy: return ((ns7__StockDiscrepancy *)ptr)->soap_out(soap, tag, id, "ns7:StockDiscrepancy");
	case SOAP_TYPE_ns7__StockEntryList: return ((ns7__StockEntryList *)ptr)->soap_out(soap, tag, id, "ns7:StockEntryList");
	case SOAP_TYPE_ns7__StockEntry: return ((ns7__StockEntry *)ptr)->soap_out(soap, tag, id, "ns7:StockEntry");
	case SOAP_TYPE_ns7__DiscrepancyReason: return ((ns7__DiscrepancyReason *)ptr)->soap_out(soap, tag, id, "ns7:DiscrepancyReason");
	case SOAP_TYPE_ns7__DiscrepancyReport: return ((ns7__DiscrepancyReport *)ptr)->soap_out(soap, tag, id, "ns7:DiscrepancyReport");
	case SOAP_TYPE_ns7__VetDocumentList: return ((ns7__VetDocumentList *)ptr)->soap_out(soap, tag, id, "ns7:VetDocumentList");
	case SOAP_TYPE_ns7__GoodsDate: return ((ns7__GoodsDate *)ptr)->soap_out(soap, tag, id, "ns7:GoodsDate");
	case SOAP_TYPE_ns7__ConsignmentDocumentList: return ((ns7__ConsignmentDocumentList *)ptr)->soap_out(soap, tag, id, "ns7:ConsignmentDocumentList");
	case SOAP_TYPE_ns7__DeliveryInspection: return ((ns7__DeliveryInspection *)ptr)->soap_out(soap, tag, id, "ns7:DeliveryInspection");
	case SOAP_TYPE_ns7__DeliveryFactList: return ((ns7__DeliveryFactList *)ptr)->soap_out(soap, tag, id, "ns7:DeliveryFactList");
	case SOAP_TYPE_ns7__Delivery: return ((ns7__Delivery *)ptr)->soap_out(soap, tag, id, "ns7:Delivery");
	case SOAP_TYPE_ns7__ProductiveBatch: return ((ns7__ProductiveBatch *)ptr)->soap_out(soap, tag, id, "ns7:ProductiveBatch");
	case SOAP_TYPE_ns7__RawBatch: return ((ns7__RawBatch *)ptr)->soap_out(soap, tag, id, "ns7:RawBatch");
	case SOAP_TYPE_ns7__Consignment: return ((ns7__Consignment *)ptr)->soap_out(soap, tag, id, "ns7:Consignment");
	case SOAP_TYPE_ns7__Batch: return ((ns7__Batch *)ptr)->soap_out(soap, tag, id, "ns7:Batch");
	case SOAP_TYPE_ns7__VetDocument: return ((ns7__VetDocument *)ptr)->soap_out(soap, tag, id, "ns7:VetDocument");
	case SOAP_TYPE_ns6__ActivityLocationList: return ((ns6__ActivityLocationList *)ptr)->soap_out(soap, tag, id, "ns6:ActivityLocationList");
	case SOAP_TYPE_ns6__ResearchMethodList: return ((ns6__ResearchMethodList *)ptr)->soap_out(soap, tag, id, "ns6:ResearchMethodList");
	case SOAP_TYPE_ns6__AnimalDiseaseList: return ((ns6__AnimalDiseaseList *)ptr)->soap_out(soap, tag, id, "ns6:AnimalDiseaseList");
	case SOAP_TYPE_ns6__RegionalizationShippingRuleList: return ((ns6__RegionalizationShippingRuleList *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationShippingRuleList");
	case SOAP_TYPE_ns6__RegionalizationRegionStatusList: return ((ns6__RegionalizationRegionStatusList *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationRegionStatusList");
	case SOAP_TYPE_ns6__RegionalizationConditionList: return ((ns6__RegionalizationConditionList *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationConditionList");
	case SOAP_TYPE_ns6__Area: return ((ns6__Area *)ptr)->soap_out(soap, tag, id, "ns6:Area");
	case SOAP_TYPE_ns6__RegionalizationRegionStatus: return ((ns6__RegionalizationRegionStatus *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationRegionStatus");
	case SOAP_TYPE_ns6__RegionalizationStatus: return ((ns6__RegionalizationStatus *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationStatus");
	case SOAP_TYPE_ns6__RegionalizationShippingRule: return ((ns6__RegionalizationShippingRule *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationShippingRule");
	case SOAP_TYPE_ns6__RegionalizationRequirement: return ((ns6__RegionalizationRequirement *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationRequirement");
	case SOAP_TYPE_ns6__RegionalizationConditionGroup: return ((ns6__RegionalizationConditionGroup *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationConditionGroup");
	case SOAP_TYPE_ns6__RegionalizationCondition: return ((ns6__RegionalizationCondition *)ptr)->soap_out(soap, tag, id, "ns6:RegionalizationCondition");
	case SOAP_TYPE_ns6__MedicinalDrug: return ((ns6__MedicinalDrug *)ptr)->soap_out(soap, tag, id, "ns6:MedicinalDrug");
	case SOAP_TYPE_ns6__ResearchMethod: return ((ns6__ResearchMethod *)ptr)->soap_out(soap, tag, id, "ns6:ResearchMethod");
	case SOAP_TYPE_ns6__AnimalDisease: return ((ns6__AnimalDisease *)ptr)->soap_out(soap, tag, id, "ns6:AnimalDisease");
	case SOAP_TYPE_ns6__Indicator: return ((ns6__Indicator *)ptr)->soap_out(soap, tag, id, "ns6:Indicator");
	case SOAP_TYPE_ns6__Organization: return ((ns6__Organization *)ptr)->soap_out(soap, tag, id, "ns6:Organization");
	case SOAP_TYPE_ns6__EnterpriseOfficialRegistration: return ((ns6__EnterpriseOfficialRegistration *)ptr)->soap_out(soap, tag, id, "ns6:EnterpriseOfficialRegistration");
	case SOAP_TYPE_ns6__Location: return ((ns6__Location *)ptr)->soap_out(soap, tag, id, "ns6:Location");
	case SOAP_TYPE_ns6__Packaging: return ((ns6__Packaging *)ptr)->soap_out(soap, tag, id, "ns6:Packaging");
	case SOAP_TYPE_ns6__ProductItemProducing: return ((ns6__ProductItemProducing *)ptr)->soap_out(soap, tag, id, "ns6:ProductItemProducing");
	case SOAP_TYPE_ns6__ComplexDate: return ((ns6__ComplexDate *)ptr)->soap_out(soap, tag, id, "ns6:ComplexDate");
	case SOAP_TYPE_ns6__PackageList: return ((ns6__PackageList *)ptr)->soap_out(soap, tag, id, "ns6:PackageList");
	case SOAP_TYPE_ns6__Package: return ((ns6__Package *)ptr)->soap_out(soap, tag, id, "ns6:Package");
	case SOAP_TYPE_ns6__ProductMarks: return ((ns6__ProductMarks *)ptr)->soap_out(soap, tag, id, "ns6:ProductMarks");
	case SOAP_TYPE_ns6__ProductItemList: return ((ns6__ProductItemList *)ptr)->soap_out(soap, tag, id, "ns6:ProductItemList");
	case SOAP_TYPE_ns6__SubProductList: return ((ns6__SubProductList *)ptr)->soap_out(soap, tag, id, "ns6:SubProductList");
	case SOAP_TYPE_ns6__ProductList: return ((ns6__ProductList *)ptr)->soap_out(soap, tag, id, "ns6:ProductList");
	case SOAP_TYPE_ns6__SubProduct: return ((ns6__SubProduct *)ptr)->soap_out(soap, tag, id, "ns6:SubProduct");
	case SOAP_TYPE_ns6__Product: return ((ns6__Product *)ptr)->soap_out(soap, tag, id, "ns6:Product");
	case SOAP_TYPE_ns6__ProductItem: return ((ns6__ProductItem *)ptr)->soap_out(soap, tag, id, "ns6:ProductItem");
	case SOAP_TYPE_ns6__BusinessEntityList: return ((ns6__BusinessEntityList *)ptr)->soap_out(soap, tag, id, "ns6:BusinessEntityList");
	case SOAP_TYPE_ns6__IncorporationForm: return ((ns6__IncorporationForm *)ptr)->soap_out(soap, tag, id, "ns6:IncorporationForm");
	case SOAP_TYPE_ns6__BusinessEntity: return ((ns6__BusinessEntity *)ptr)->soap_out(soap, tag, id, "ns6:BusinessEntity");
	case SOAP_TYPE_ns6__BusinessMember: return ((ns6__BusinessMember *)ptr)->soap_out(soap, tag, id, "ns6:BusinessMember");
	case SOAP_TYPE_ns6__EnterpriseList: return ((ns6__EnterpriseList *)ptr)->soap_out(soap, tag, id, "ns6:EnterpriseList");
	case SOAP_TYPE_ns6__EnterpriseNumberList: return ((ns6__EnterpriseNumberList *)ptr)->soap_out(soap, tag, id, "ns6:EnterpriseNumberList");
	case SOAP_TYPE_ns6__ProducerList: return ((ns6__ProducerList *)ptr)->soap_out(soap, tag, id, "ns6:ProducerList");
	case SOAP_TYPE_ns6__Producer: return ((ns6__Producer *)ptr)->soap_out(soap, tag, id, "ns6:Producer");
	case SOAP_TYPE_ns6__EnterpriseActivity: return ((ns6__EnterpriseActivity *)ptr)->soap_out(soap, tag, id, "ns6:EnterpriseActivity");
	case SOAP_TYPE_ns6__EnterpriseActivityList: return ((ns6__EnterpriseActivityList *)ptr)->soap_out(soap, tag, id, "ns6:EnterpriseActivityList");
	case SOAP_TYPE_ns6__Enterprise: return ((ns6__Enterprise *)ptr)->soap_out(soap, tag, id, "ns6:Enterprise");
	case SOAP_TYPE_ns6__StreetList: return ((ns6__StreetList *)ptr)->soap_out(soap, tag, id, "ns6:StreetList");
	case SOAP_TYPE_ns6__LocalityList: return ((ns6__LocalityList *)ptr)->soap_out(soap, tag, id, "ns6:LocalityList");
	case SOAP_TYPE_ns6__DistrictList: return ((ns6__DistrictList *)ptr)->soap_out(soap, tag, id, "ns6:DistrictList");
	case SOAP_TYPE_ns6__RegionList: return ((ns6__RegionList *)ptr)->soap_out(soap, tag, id, "ns6:RegionList");
	case SOAP_TYPE_ns6__CountryList: return ((ns6__CountryList *)ptr)->soap_out(soap, tag, id, "ns6:CountryList");
	case SOAP_TYPE_ns6__Address: return ((ns6__Address *)ptr)->soap_out(soap, tag, id, "ns6:Address");
	case SOAP_TYPE_ns6__Street: return ((ns6__Street *)ptr)->soap_out(soap, tag, id, "ns6:Street");
	case SOAP_TYPE_ns6__Locality: return ((ns6__Locality *)ptr)->soap_out(soap, tag, id, "ns6:Locality");
	case SOAP_TYPE_ns6__District: return ((ns6__District *)ptr)->soap_out(soap, tag, id, "ns6:District");
	case SOAP_TYPE_ns6__Region: return ((ns6__Region *)ptr)->soap_out(soap, tag, id, "ns6:Region");
	case SOAP_TYPE_ns6__AddressObjectView: return ((ns6__AddressObjectView *)ptr)->soap_out(soap, tag, id, "ns6:AddressObjectView");
	case SOAP_TYPE_ns6__FederalDistrict: return ((ns6__FederalDistrict *)ptr)->soap_out(soap, tag, id, "ns6:FederalDistrict");
	case SOAP_TYPE_ns6__Country: return ((ns6__Country *)ptr)->soap_out(soap, tag, id, "ns6:Country");
	case SOAP_TYPE_ns6__UnitList: return ((ns6__UnitList *)ptr)->soap_out(soap, tag, id, "ns6:UnitList");
	case SOAP_TYPE_ns6__PurposeList: return ((ns6__PurposeList *)ptr)->soap_out(soap, tag, id, "ns6:PurposeList");
	case SOAP_TYPE_ns6__PackingType: return ((ns6__PackingType *)ptr)->soap_out(soap, tag, id, "ns6:PackingType");
	case SOAP_TYPE_ns6__Unit: return ((ns6__Unit *)ptr)->soap_out(soap, tag, id, "ns6:Unit");
	case SOAP_TYPE_ns6__Purpose: return ((ns6__Purpose *)ptr)->soap_out(soap, tag, id, "ns6:Purpose");
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse: return ((ns5__GetAppliedUserAuthorityListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest: return ((ns5__GetAppliedUserAuthorityListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse: return ((ns5__UnbindBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "ns5:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest: return ((ns5__UnbindBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "ns5:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse: return ((ns5__UpdateUserWorkingAreasResponse *)ptr)->soap_out(soap, tag, id, "ns5:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest: return ((ns5__UpdateUserWorkingAreasRequest *)ptr)->soap_out(soap, tag, id, "ns5:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse: return ((ns5__UpdateUserAuthoritiesResponse *)ptr)->soap_out(soap, tag, id, "ns5:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest: return ((ns5__UpdateUserAuthoritiesRequest *)ptr)->soap_out(soap, tag, id, "ns5:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_ns5__GetBusinessEntityUserResponse: return ((ns5__GetBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetBusinessEntityUserResponse");
	case SOAP_TYPE_ns5__GetBusinessEntityUserRequest: return ((ns5__GetBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetBusinessEntityUserRequest");
	case SOAP_TYPE_ns5__GetBusinessEntityUserListResponse: return ((ns5__GetBusinessEntityUserListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_ns5__GetBusinessEntityUserListRequest: return ((ns5__GetBusinessEntityUserListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_ns5__AddBusinessEntityUserResponse: return ((ns5__AddBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "ns5:AddBusinessEntityUserResponse");
	case SOAP_TYPE_ns5__AddBusinessEntityUserRequest: return ((ns5__AddBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "ns5:AddBusinessEntityUserRequest");
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse: return ((ns5__CheckShipmentRegionalizationResponse *)ptr)->soap_out(soap, tag, id, "ns5:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest: return ((ns5__CheckShipmentRegionalizationRequest *)ptr)->soap_out(soap, tag, id, "ns5:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse: return ((ns5__UpdateVeterinaryEventsResponse *)ptr)->soap_out(soap, tag, id, "ns5:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest: return ((ns5__UpdateVeterinaryEventsRequest *)ptr)->soap_out(soap, tag, id, "ns5:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse: return ((ns5__UpdateTransportMovementDetailsResponse *)ptr)->soap_out(soap, tag, id, "ns5:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest: return ((ns5__UpdateTransportMovementDetailsRequest *)ptr)->soap_out(soap, tag, id, "ns5:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_ns5__GetStockEntryVersionListResponse: return ((ns5__GetStockEntryVersionListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryVersionListResponse");
	case SOAP_TYPE_ns5__GetStockEntryVersionListRequest: return ((ns5__GetStockEntryVersionListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryVersionListRequest");
	case SOAP_TYPE_ns5__GetStockEntryListResponse: return ((ns5__GetStockEntryListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryListResponse");
	case SOAP_TYPE_ns5__GetStockEntryListRequest: return ((ns5__GetStockEntryListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryListRequest");
	case SOAP_TYPE_ns5__GetStockEntryChangesListResponse: return ((ns5__GetStockEntryChangesListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryChangesListResponse");
	case SOAP_TYPE_ns5__GetStockEntryChangesListRequest: return ((ns5__GetStockEntryChangesListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryChangesListRequest");
	case SOAP_TYPE_ns5__GetStockEntryByUuidResponse: return ((ns5__GetStockEntryByUuidResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryByUuidResponse");
	case SOAP_TYPE_ns5__GetStockEntryByUuidRequest: return ((ns5__GetStockEntryByUuidRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryByUuidRequest");
	case SOAP_TYPE_ns5__GetStockEntryByGuidResponse: return ((ns5__GetStockEntryByGuidResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryByGuidResponse");
	case SOAP_TYPE_ns5__GetStockEntryByGuidRequest: return ((ns5__GetStockEntryByGuidRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetStockEntryByGuidRequest");
	case SOAP_TYPE_ns5__GetVetDocumentChangesListResponse: return ((ns5__GetVetDocumentChangesListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_ns5__GetVetDocumentChangesListRequest: return ((ns5__GetVetDocumentChangesListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_ns5__GetVetDocumentListResponse: return ((ns5__GetVetDocumentListResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetVetDocumentListResponse");
	case SOAP_TYPE_ns5__GetVetDocumentListRequest: return ((ns5__GetVetDocumentListRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetVetDocumentListRequest");
	case SOAP_TYPE_ns5__GetVetDocumentByUuidResponse: return ((ns5__GetVetDocumentByUuidResponse *)ptr)->soap_out(soap, tag, id, "ns5:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_ns5__GetVetDocumentByUuidRequest: return ((ns5__GetVetDocumentByUuidRequest *)ptr)->soap_out(soap, tag, id, "ns5:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_ns5__ModifyProducerStockListResponse: return ((ns5__ModifyProducerStockListResponse *)ptr)->soap_out(soap, tag, id, "ns5:ModifyProducerStockListResponse");
	case SOAP_TYPE_ns5__ModifyProducerStockListRequest: return ((ns5__ModifyProducerStockListRequest *)ptr)->soap_out(soap, tag, id, "ns5:ModifyProducerStockListRequest");
	case SOAP_TYPE_ns5__ResolveDiscrepancyResponse: return ((ns5__ResolveDiscrepancyResponse *)ptr)->soap_out(soap, tag, id, "ns5:ResolveDiscrepancyResponse");
	case SOAP_TYPE_ns5__ResolveDiscrepancyRequest: return ((ns5__ResolveDiscrepancyRequest *)ptr)->soap_out(soap, tag, id, "ns5:ResolveDiscrepancyRequest");
	case SOAP_TYPE_ns5__ModifyActivityLocationsResponse: return ((ns5__ModifyActivityLocationsResponse *)ptr)->soap_out(soap, tag, id, "ns5:ModifyActivityLocationsResponse");
	case SOAP_TYPE_ns5__ModifyActivityLocationsRequest: return ((ns5__ModifyActivityLocationsRequest *)ptr)->soap_out(soap, tag, id, "ns5:ModifyActivityLocationsRequest");
	case SOAP_TYPE_ns5__ModifyEnterpriseResponse: return ((ns5__ModifyEnterpriseResponse *)ptr)->soap_out(soap, tag, id, "ns5:ModifyEnterpriseResponse");
	case SOAP_TYPE_ns5__ModifyEnterpriseRequest: return ((ns5__ModifyEnterpriseRequest *)ptr)->soap_out(soap, tag, id, "ns5:ModifyEnterpriseRequest");
	case SOAP_TYPE_ns5__ModifyBusinessEntityResponse: return ((ns5__ModifyBusinessEntityResponse *)ptr)->soap_out(soap, tag, id, "ns5:ModifyBusinessEntityResponse");
	case SOAP_TYPE_ns5__ModifyBusinessEntityRequest: return ((ns5__ModifyBusinessEntityRequest *)ptr)->soap_out(soap, tag, id, "ns5:ModifyBusinessEntityRequest");
	case SOAP_TYPE_ns5__WithdrawVetDocumentResponse: return ((ns5__WithdrawVetDocumentResponse *)ptr)->soap_out(soap, tag, id, "ns5:WithdrawVetDocumentResponse");
	case SOAP_TYPE_ns5__WithdrawVetDocumentRequest: return ((ns5__WithdrawVetDocumentRequest *)ptr)->soap_out(soap, tag, id, "ns5:WithdrawVetDocumentRequest");
	case SOAP_TYPE_ns5__MergeStockEntriesResponse: return ((ns5__MergeStockEntriesResponse *)ptr)->soap_out(soap, tag, id, "ns5:MergeStockEntriesResponse");
	case SOAP_TYPE_ns5__MergeStockEntriesRequest: return ((ns5__MergeStockEntriesRequest *)ptr)->soap_out(soap, tag, id, "ns5:MergeStockEntriesRequest");
	case SOAP_TYPE_ns5__RegisterProductionOperationResponse: return ((ns5__RegisterProductionOperationResponse *)ptr)->soap_out(soap, tag, id, "ns5:RegisterProductionOperationResponse");
	case SOAP_TYPE_ns5__RegisterProductionOperationRequest: return ((ns5__RegisterProductionOperationRequest *)ptr)->soap_out(soap, tag, id, "ns5:RegisterProductionOperationRequest");
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse: return ((ns5__PrepareOutgoingConsignmentResponse *)ptr)->soap_out(soap, tag, id, "ns5:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest: return ((ns5__PrepareOutgoingConsignmentRequest *)ptr)->soap_out(soap, tag, id, "ns5:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse: return ((ns5__ProcessIncomingConsignmentResponse *)ptr)->soap_out(soap, tag, id, "ns5:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest: return ((ns5__ProcessIncomingConsignmentRequest *)ptr)->soap_out(soap, tag, id, "ns5:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_ns5__MercuryApplicationRequest: return ((ns5__MercuryApplicationRequest *)ptr)->soap_out(soap, tag, id, "ns5:MercuryApplicationRequest");
	case SOAP_TYPE_ns4__BusinessError: return ((ns4__BusinessError *)ptr)->soap_out(soap, tag, id, "ns4:BusinessError");
	case SOAP_TYPE_ns4__BusinessErrorList: return ((ns4__BusinessErrorList *)ptr)->soap_out(soap, tag, id, "ns4:BusinessErrorList");
	case SOAP_TYPE_ns4__ApplicationResultData: return ((ns4__ApplicationResultData *)ptr)->soap_out(soap, tag, id, "ns4:ApplicationResultData");
	case SOAP_TYPE_ns4__ApplicationData: return ((ns4__ApplicationData *)ptr)->soap_out(soap, tag, id, "ns4:ApplicationData");
	case SOAP_TYPE_ns4__ApplicationResultWrapper: return ((ns4__ApplicationResultWrapper *)ptr)->soap_out(soap, tag, id, "ns4:ApplicationResultWrapper");
	case SOAP_TYPE_ns4__ApplicationDataWrapper: return ((ns4__ApplicationDataWrapper *)ptr)->soap_out(soap, tag, id, "ns4:ApplicationDataWrapper");
	case SOAP_TYPE_ns4__Application: return ((ns4__Application *)ptr)->soap_out(soap, tag, id, "ns4:Application");
	case SOAP_TYPE_ns3__Error: return ((ns3__Error *)ptr)->soap_out(soap, tag, id, "ns3:Error");
	case SOAP_TYPE_ns3__FaultInfo: return ((ns3__FaultInfo *)ptr)->soap_out(soap, tag, id, "ns3:FaultInfo");
	case SOAP_TYPE_ns3__EntityList: return ((ns3__EntityList *)ptr)->soap_out(soap, tag, id, "ns3:EntityList");
	case SOAP_TYPE_ns3__DateInterval: return ((ns3__DateInterval *)ptr)->soap_out(soap, tag, id, "ns3:DateInterval");
	case SOAP_TYPE_ns3__ListOptions: return ((ns3__ListOptions *)ptr)->soap_out(soap, tag, id, "ns3:ListOptions");
	case SOAP_TYPE_ns3__GenericVersioningEntity: return ((ns3__GenericVersioningEntity *)ptr)->soap_out(soap, tag, id, "ns3:GenericVersioningEntity");
	case SOAP_TYPE_ns3__GenericEntity: return ((ns3__GenericEntity *)ptr)->soap_out(soap, tag, id, "ns3:GenericEntity");
	case SOAP_TYPE__ns1__receiveApplicationResultResponse: return ((_ns1__receiveApplicationResultResponse *)ptr)->soap_out(soap, "ns1:receiveApplicationResultResponse", id, NULL);
	case SOAP_TYPE__ns1__receiveApplicationResultRequest: return ((_ns1__receiveApplicationResultRequest *)ptr)->soap_out(soap, "ns1:receiveApplicationResultRequest", id, NULL);
	case SOAP_TYPE__ns1__submitApplicationResponse: return ((_ns1__submitApplicationResponse *)ptr)->soap_out(soap, "ns1:submitApplicationResponse", id, NULL);
	case SOAP_TYPE__ns1__submitApplicationRequest: return ((_ns1__submitApplicationRequest *)ptr)->soap_out(soap, "ns1:submitApplicationRequest", id, NULL);
	case SOAP_TYPE_xsd__base64Binary: return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse: return soap_out_PointerTo_ns8__getActivityLocationListResponse(soap, tag, id, (_ns8__getActivityLocationListResponse *const*)ptr, "ns8:getActivityLocationListResponse");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest: return soap_out_PointerTo_ns8__getActivityLocationListRequest(soap, tag, id, (_ns8__getActivityLocationListRequest *const*)ptr, "ns8:getActivityLocationListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse: return soap_out_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, tag, id, (_ns8__getBusinessMemberByGLNResponse *const*)ptr, "ns8:getBusinessMemberByGLNResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest: return soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, tag, id, (_ns8__getBusinessMemberByGLNRequest *const*)ptr, "ns8:getBusinessMemberByGLNRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse: return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, tag, id, (_ns8__getRussianEnterpriseChangesListResponse *const*)ptr, "ns8:getRussianEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest: return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, tag, id, (_ns8__getRussianEnterpriseChangesListRequest *const*)ptr, "ns8:getRussianEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse: return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, tag, id, (_ns8__getForeignEnterpriseChangesListResponse *const*)ptr, "ns8:getForeignEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest: return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, tag, id, (_ns8__getForeignEnterpriseChangesListRequest *const*)ptr, "ns8:getForeignEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse: return soap_out_PointerTo_ns8__getRussianEnterpriseListResponse(soap, tag, id, (_ns8__getRussianEnterpriseListResponse *const*)ptr, "ns8:getRussianEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest: return soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(soap, tag, id, (_ns8__getRussianEnterpriseListRequest *const*)ptr, "ns8:getRussianEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse: return soap_out_PointerTo_ns8__getForeignEnterpriseListResponse(soap, tag, id, (_ns8__getForeignEnterpriseListResponse *const*)ptr, "ns8:getForeignEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest: return soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(soap, tag, id, (_ns8__getForeignEnterpriseListRequest *const*)ptr, "ns8:getForeignEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse: return soap_out_PointerTo_ns8__getEnterpriseByUuidResponse(soap, tag, id, (_ns8__getEnterpriseByUuidResponse *const*)ptr, "ns8:getEnterpriseByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest: return soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(soap, tag, id, (_ns8__getEnterpriseByUuidRequest *const*)ptr, "ns8:getEnterpriseByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse: return soap_out_PointerTo_ns8__getEnterpriseByGuidResponse(soap, tag, id, (_ns8__getEnterpriseByGuidResponse *const*)ptr, "ns8:getEnterpriseByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest: return soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(soap, tag, id, (_ns8__getEnterpriseByGuidRequest *const*)ptr, "ns8:getEnterpriseByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse: return soap_out_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, tag, id, (_ns8__getBusinessEntityChangesListResponse *const*)ptr, "ns8:getBusinessEntityChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest: return soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, tag, id, (_ns8__getBusinessEntityChangesListRequest *const*)ptr, "ns8:getBusinessEntityChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse: return soap_out_PointerTo_ns8__getBusinessEntityListResponse(soap, tag, id, (_ns8__getBusinessEntityListResponse *const*)ptr, "ns8:getBusinessEntityListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest: return soap_out_PointerTo_ns8__getBusinessEntityListRequest(soap, tag, id, (_ns8__getBusinessEntityListRequest *const*)ptr, "ns8:getBusinessEntityListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse: return soap_out_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, tag, id, (_ns8__getBusinessEntityByUuidResponse *const*)ptr, "ns8:getBusinessEntityByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest: return soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, tag, id, (_ns8__getBusinessEntityByUuidRequest *const*)ptr, "ns8:getBusinessEntityByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse: return soap_out_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, tag, id, (_ns8__getBusinessEntityByGuidResponse *const*)ptr, "ns8:getBusinessEntityByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest: return soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, tag, id, (_ns8__getBusinessEntityByGuidRequest *const*)ptr, "ns8:getBusinessEntityByGuidRequest");
	case SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListResponse: return soap_out_PointerTons5__GetAppliedUserAuthorityListResponse(soap, tag, id, (ns5__GetAppliedUserAuthorityListResponse *const*)ptr, "ns5:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListRequest: return soap_out_PointerTons5__GetAppliedUserAuthorityListRequest(soap, tag, id, (ns5__GetAppliedUserAuthorityListRequest *const*)ptr, "ns5:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserResponse: return soap_out_PointerTons5__UnbindBusinessEntityUserResponse(soap, tag, id, (ns5__UnbindBusinessEntityUserResponse *const*)ptr, "ns5:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserRequest: return soap_out_PointerTons5__UnbindBusinessEntityUserRequest(soap, tag, id, (ns5__UnbindBusinessEntityUserRequest *const*)ptr, "ns5:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasResponse: return soap_out_PointerTons5__UpdateUserWorkingAreasResponse(soap, tag, id, (ns5__UpdateUserWorkingAreasResponse *const*)ptr, "ns5:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasRequest: return soap_out_PointerTons5__UpdateUserWorkingAreasRequest(soap, tag, id, (ns5__UpdateUserWorkingAreasRequest *const*)ptr, "ns5:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesResponse: return soap_out_PointerTons5__UpdateUserAuthoritiesResponse(soap, tag, id, (ns5__UpdateUserAuthoritiesResponse *const*)ptr, "ns5:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesRequest: return soap_out_PointerTons5__UpdateUserAuthoritiesRequest(soap, tag, id, (ns5__UpdateUserAuthoritiesRequest *const*)ptr, "ns5:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserResponse: return soap_out_PointerTons5__GetBusinessEntityUserResponse(soap, tag, id, (ns5__GetBusinessEntityUserResponse *const*)ptr, "ns5:GetBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserRequest: return soap_out_PointerTons5__GetBusinessEntityUserRequest(soap, tag, id, (ns5__GetBusinessEntityUserRequest *const*)ptr, "ns5:GetBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserListResponse: return soap_out_PointerTons5__GetBusinessEntityUserListResponse(soap, tag, id, (ns5__GetBusinessEntityUserListResponse *const*)ptr, "ns5:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserListRequest: return soap_out_PointerTons5__GetBusinessEntityUserListRequest(soap, tag, id, (ns5__GetBusinessEntityUserListRequest *const*)ptr, "ns5:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_PointerTons5__AddBusinessEntityUserResponse: return soap_out_PointerTons5__AddBusinessEntityUserResponse(soap, tag, id, (ns5__AddBusinessEntityUserResponse *const*)ptr, "ns5:AddBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTons5__AddBusinessEntityUserRequest: return soap_out_PointerTons5__AddBusinessEntityUserRequest(soap, tag, id, (ns5__AddBusinessEntityUserRequest *const*)ptr, "ns5:AddBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationResponse: return soap_out_PointerTons5__CheckShipmentRegionalizationResponse(soap, tag, id, (ns5__CheckShipmentRegionalizationResponse *const*)ptr, "ns5:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationRequest: return soap_out_PointerTons5__CheckShipmentRegionalizationRequest(soap, tag, id, (ns5__CheckShipmentRegionalizationRequest *const*)ptr, "ns5:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsResponse: return soap_out_PointerTons5__UpdateVeterinaryEventsResponse(soap, tag, id, (ns5__UpdateVeterinaryEventsResponse *const*)ptr, "ns5:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsRequest: return soap_out_PointerTons5__UpdateVeterinaryEventsRequest(soap, tag, id, (ns5__UpdateVeterinaryEventsRequest *const*)ptr, "ns5:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsResponse: return soap_out_PointerTons5__UpdateTransportMovementDetailsResponse(soap, tag, id, (ns5__UpdateTransportMovementDetailsResponse *const*)ptr, "ns5:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsRequest: return soap_out_PointerTons5__UpdateTransportMovementDetailsRequest(soap, tag, id, (ns5__UpdateTransportMovementDetailsRequest *const*)ptr, "ns5:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryVersionListResponse: return soap_out_PointerTons5__GetStockEntryVersionListResponse(soap, tag, id, (ns5__GetStockEntryVersionListResponse *const*)ptr, "ns5:GetStockEntryVersionListResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryVersionListRequest: return soap_out_PointerTons5__GetStockEntryVersionListRequest(soap, tag, id, (ns5__GetStockEntryVersionListRequest *const*)ptr, "ns5:GetStockEntryVersionListRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryChangesListResponse: return soap_out_PointerTons5__GetStockEntryChangesListResponse(soap, tag, id, (ns5__GetStockEntryChangesListResponse *const*)ptr, "ns5:GetStockEntryChangesListResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryChangesListRequest: return soap_out_PointerTons5__GetStockEntryChangesListRequest(soap, tag, id, (ns5__GetStockEntryChangesListRequest *const*)ptr, "ns5:GetStockEntryChangesListRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryListResponse: return soap_out_PointerTons5__GetStockEntryListResponse(soap, tag, id, (ns5__GetStockEntryListResponse *const*)ptr, "ns5:GetStockEntryListResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryListRequest: return soap_out_PointerTons5__GetStockEntryListRequest(soap, tag, id, (ns5__GetStockEntryListRequest *const*)ptr, "ns5:GetStockEntryListRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryByUuidResponse: return soap_out_PointerTons5__GetStockEntryByUuidResponse(soap, tag, id, (ns5__GetStockEntryByUuidResponse *const*)ptr, "ns5:GetStockEntryByUuidResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryByUuidRequest: return soap_out_PointerTons5__GetStockEntryByUuidRequest(soap, tag, id, (ns5__GetStockEntryByUuidRequest *const*)ptr, "ns5:GetStockEntryByUuidRequest");
	case SOAP_TYPE_PointerTons5__GetStockEntryByGuidResponse: return soap_out_PointerTons5__GetStockEntryByGuidResponse(soap, tag, id, (ns5__GetStockEntryByGuidResponse *const*)ptr, "ns5:GetStockEntryByGuidResponse");
	case SOAP_TYPE_PointerTons5__GetStockEntryByGuidRequest: return soap_out_PointerTons5__GetStockEntryByGuidRequest(soap, tag, id, (ns5__GetStockEntryByGuidRequest *const*)ptr, "ns5:GetStockEntryByGuidRequest");
	case SOAP_TYPE_PointerTons5__GetVetDocumentChangesListResponse: return soap_out_PointerTons5__GetVetDocumentChangesListResponse(soap, tag, id, (ns5__GetVetDocumentChangesListResponse *const*)ptr, "ns5:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_PointerTons5__GetVetDocumentChangesListRequest: return soap_out_PointerTons5__GetVetDocumentChangesListRequest(soap, tag, id, (ns5__GetVetDocumentChangesListRequest *const*)ptr, "ns5:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_PointerTons5__GetVetDocumentListResponse: return soap_out_PointerTons5__GetVetDocumentListResponse(soap, tag, id, (ns5__GetVetDocumentListResponse *const*)ptr, "ns5:GetVetDocumentListResponse");
	case SOAP_TYPE_PointerTons5__GetVetDocumentListRequest: return soap_out_PointerTons5__GetVetDocumentListRequest(soap, tag, id, (ns5__GetVetDocumentListRequest *const*)ptr, "ns5:GetVetDocumentListRequest");
	case SOAP_TYPE_PointerTons5__GetVetDocumentByUuidResponse: return soap_out_PointerTons5__GetVetDocumentByUuidResponse(soap, tag, id, (ns5__GetVetDocumentByUuidResponse *const*)ptr, "ns5:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_PointerTons5__GetVetDocumentByUuidRequest: return soap_out_PointerTons5__GetVetDocumentByUuidRequest(soap, tag, id, (ns5__GetVetDocumentByUuidRequest *const*)ptr, "ns5:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_PointerTons5__ModifyProducerStockListResponse: return soap_out_PointerTons5__ModifyProducerStockListResponse(soap, tag, id, (ns5__ModifyProducerStockListResponse *const*)ptr, "ns5:ModifyProducerStockListResponse");
	case SOAP_TYPE_PointerTons5__ModifyProducerStockListRequest: return soap_out_PointerTons5__ModifyProducerStockListRequest(soap, tag, id, (ns5__ModifyProducerStockListRequest *const*)ptr, "ns5:ModifyProducerStockListRequest");
	case SOAP_TYPE_PointerTons5__ResolveDiscrepancyResponse: return soap_out_PointerTons5__ResolveDiscrepancyResponse(soap, tag, id, (ns5__ResolveDiscrepancyResponse *const*)ptr, "ns5:ResolveDiscrepancyResponse");
	case SOAP_TYPE_PointerTons5__ResolveDiscrepancyRequest: return soap_out_PointerTons5__ResolveDiscrepancyRequest(soap, tag, id, (ns5__ResolveDiscrepancyRequest *const*)ptr, "ns5:ResolveDiscrepancyRequest");
	case SOAP_TYPE_PointerTons5__ModifyActivityLocationsResponse: return soap_out_PointerTons5__ModifyActivityLocationsResponse(soap, tag, id, (ns5__ModifyActivityLocationsResponse *const*)ptr, "ns5:ModifyActivityLocationsResponse");
	case SOAP_TYPE_PointerTons5__ModifyActivityLocationsRequest: return soap_out_PointerTons5__ModifyActivityLocationsRequest(soap, tag, id, (ns5__ModifyActivityLocationsRequest *const*)ptr, "ns5:ModifyActivityLocationsRequest");
	case SOAP_TYPE_PointerTons5__ModifyEnterpriseResponse: return soap_out_PointerTons5__ModifyEnterpriseResponse(soap, tag, id, (ns5__ModifyEnterpriseResponse *const*)ptr, "ns5:ModifyEnterpriseResponse");
	case SOAP_TYPE_PointerTons5__ModifyEnterpriseRequest: return soap_out_PointerTons5__ModifyEnterpriseRequest(soap, tag, id, (ns5__ModifyEnterpriseRequest *const*)ptr, "ns5:ModifyEnterpriseRequest");
	case SOAP_TYPE_PointerTons5__ModifyBusinessEntityResponse: return soap_out_PointerTons5__ModifyBusinessEntityResponse(soap, tag, id, (ns5__ModifyBusinessEntityResponse *const*)ptr, "ns5:ModifyBusinessEntityResponse");
	case SOAP_TYPE_PointerTons5__ModifyBusinessEntityRequest: return soap_out_PointerTons5__ModifyBusinessEntityRequest(soap, tag, id, (ns5__ModifyBusinessEntityRequest *const*)ptr, "ns5:ModifyBusinessEntityRequest");
	case SOAP_TYPE_PointerTons5__WithdrawVetDocumentResponse: return soap_out_PointerTons5__WithdrawVetDocumentResponse(soap, tag, id, (ns5__WithdrawVetDocumentResponse *const*)ptr, "ns5:WithdrawVetDocumentResponse");
	case SOAP_TYPE_PointerTons5__WithdrawVetDocumentRequest: return soap_out_PointerTons5__WithdrawVetDocumentRequest(soap, tag, id, (ns5__WithdrawVetDocumentRequest *const*)ptr, "ns5:WithdrawVetDocumentRequest");
	case SOAP_TYPE_PointerTons5__MergeStockEntriesResponse: return soap_out_PointerTons5__MergeStockEntriesResponse(soap, tag, id, (ns5__MergeStockEntriesResponse *const*)ptr, "ns5:MergeStockEntriesResponse");
	case SOAP_TYPE_PointerTons5__MergeStockEntriesRequest: return soap_out_PointerTons5__MergeStockEntriesRequest(soap, tag, id, (ns5__MergeStockEntriesRequest *const*)ptr, "ns5:MergeStockEntriesRequest");
	case SOAP_TYPE_PointerTons5__RegisterProductionOperationResponse: return soap_out_PointerTons5__RegisterProductionOperationResponse(soap, tag, id, (ns5__RegisterProductionOperationResponse *const*)ptr, "ns5:RegisterProductionOperationResponse");
	case SOAP_TYPE_PointerTons5__RegisterProductionOperationRequest: return soap_out_PointerTons5__RegisterProductionOperationRequest(soap, tag, id, (ns5__RegisterProductionOperationRequest *const*)ptr, "ns5:RegisterProductionOperationRequest");
	case SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentResponse: return soap_out_PointerTons5__PrepareOutgoingConsignmentResponse(soap, tag, id, (ns5__PrepareOutgoingConsignmentResponse *const*)ptr, "ns5:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentRequest: return soap_out_PointerTons5__PrepareOutgoingConsignmentRequest(soap, tag, id, (ns5__PrepareOutgoingConsignmentRequest *const*)ptr, "ns5:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentResponse: return soap_out_PointerTons5__ProcessIncomingConsignmentResponse(soap, tag, id, (ns5__ProcessIncomingConsignmentResponse *const*)ptr, "ns5:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentRequest: return soap_out_PointerTons5__ProcessIncomingConsignmentRequest(soap, tag, id, (ns5__ProcessIncomingConsignmentRequest *const*)ptr, "ns5:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_PointerTo_ns1__receiveApplicationResultResponse: return soap_out_PointerTo_ns1__receiveApplicationResultResponse(soap, tag, id, (_ns1__receiveApplicationResultResponse *const*)ptr, "ns1:receiveApplicationResultResponse");
	case SOAP_TYPE_PointerTo_ns1__receiveApplicationResultRequest: return soap_out_PointerTo_ns1__receiveApplicationResultRequest(soap, tag, id, (_ns1__receiveApplicationResultRequest *const*)ptr, "ns1:receiveApplicationResultRequest");
	case SOAP_TYPE_PointerTo_ns1__submitApplicationResponse: return soap_out_PointerTo_ns1__submitApplicationResponse(soap, tag, id, (_ns1__submitApplicationResponse *const*)ptr, "ns1:submitApplicationResponse");
	case SOAP_TYPE_PointerTo_ns1__submitApplicationRequest: return soap_out_PointerTo_ns1__submitApplicationRequest(soap, tag, id, (_ns1__submitApplicationRequest *const*)ptr, "ns1:submitApplicationRequest");
	case SOAP_TYPE_PointerTons3__FaultInfo: return soap_out_PointerTons3__FaultInfo(soap, tag, id, (ns3__FaultInfo *const*)ptr, "ns3:FaultInfo");
	case SOAP_TYPE_PointerTons7__StockEntryBlankFilter: return soap_out_PointerTons7__StockEntryBlankFilter(soap, tag, id, (enum ns7__StockEntryBlankFilter *const*)ptr, "ns7:StockEntryBlankFilter");
	case SOAP_TYPE_PointerTons7__StockEntryEventList: return soap_out_PointerTons7__StockEntryEventList(soap, tag, id, (ns7__StockEntryEventList *const*)ptr, "ns7:StockEntryEventList");
	case SOAP_TYPE_PointerTons7__DiscrepancyReason: return soap_out_PointerTons7__DiscrepancyReason(soap, tag, id, (ns7__DiscrepancyReason *const*)ptr, "ns7:DiscrepancyReason");
	case SOAP_TYPE_PointerToPointerTons7__VetDocumentStatusChange: return soap_out_PointerToPointerTons7__VetDocumentStatusChange(soap, tag, id, (ns7__VetDocumentStatusChange **const*)ptr, "ns7:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTons7__VetDocumentStatusChange: return soap_out_PointerTons7__VetDocumentStatusChange(soap, tag, id, (ns7__VetDocumentStatusChange *const*)ptr, "ns7:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTons7__VeterinaryAuthentication: return soap_out_PointerTons7__VeterinaryAuthentication(soap, tag, id, (ns7__VeterinaryAuthentication *const*)ptr, "ns7:VeterinaryAuthentication");
	case SOAP_TYPE_PointerTons7__CertifiedConsignment: return soap_out_PointerTons7__CertifiedConsignment(soap, tag, id, (ns7__CertifiedConsignment *const*)ptr, "ns7:CertifiedConsignment");
	case SOAP_TYPE_PointerTons7__CertifiedBatch: return soap_out_PointerTons7__CertifiedBatch(soap, tag, id, (ns7__CertifiedBatch *const*)ptr, "ns7:CertifiedBatch");
	case SOAP_TYPE_PointerTons7__VetDocumentForm: return soap_out_PointerTons7__VetDocumentForm(soap, tag, id, (enum ns7__VetDocumentForm *const*)ptr, "ns7:VetDocumentForm");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationStatus: return soap_out_PointerToPointerTons6__RegionalizationStatus(soap, tag, id, (ns6__RegionalizationStatus **const*)ptr, "ns6:RegionalizationStatus");
	case SOAP_TYPE_PointerToPointerTons6__Area: return soap_out_PointerToPointerTons6__Area(soap, tag, id, (ns6__Area **const*)ptr, "ns6:Area");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationRequirement: return soap_out_PointerToPointerTons6__RegionalizationRequirement(soap, tag, id, (ns6__RegionalizationRequirement **const*)ptr, "ns6:RegionalizationRequirement");
	case SOAP_TYPE_PointerTons6__RegionalizationRequirement: return soap_out_PointerTons6__RegionalizationRequirement(soap, tag, id, (ns6__RegionalizationRequirement *const*)ptr, "ns6:RegionalizationRequirement");
	case SOAP_TYPE_PointerTons6__RegionalizationDecision: return soap_out_PointerTons6__RegionalizationDecision(soap, tag, id, (enum ns6__RegionalizationDecision *const*)ptr, "ns6:RegionalizationDecision");
	case SOAP_TYPE_PointerTons6__RegionalizationStatus: return soap_out_PointerTons6__RegionalizationStatus(soap, tag, id, (ns6__RegionalizationStatus *const*)ptr, "ns6:RegionalizationStatus");
	case SOAP_TYPE_PointerTons6__Packaging: return soap_out_PointerTons6__Packaging(soap, tag, id, (ns6__Packaging *const*)ptr, "ns6:Packaging");
	case SOAP_TYPE_PointerToPointerTons6__ProductItemProducing: return soap_out_PointerToPointerTons6__ProductItemProducing(soap, tag, id, (ns6__ProductItemProducing **const*)ptr, "ns6:ProductItemProducing");
	case SOAP_TYPE_PointerTons6__ProductItemProducing: return soap_out_PointerTons6__ProductItemProducing(soap, tag, id, (ns6__ProductItemProducing *const*)ptr, "ns6:ProductItemProducing");
	case SOAP_TYPE_PointerTo_ns6__BusinessEntity_activityLocation: return soap_out_PointerTo_ns6__BusinessEntity_activityLocation(soap, tag, id, (_ns6__BusinessEntity_activityLocation *const*)ptr, "ns6:BusinessEntity-activityLocation");
	case SOAP_TYPE_PointerTons6__IncorporationForm: return soap_out_PointerTons6__IncorporationForm(soap, tag, id, (ns6__IncorporationForm *const*)ptr, "ns6:IncorporationForm");
	case SOAP_TYPE_PointerTons6__BusinessEntityType: return soap_out_PointerTons6__BusinessEntityType(soap, tag, id, (enum ns6__BusinessEntityType *const*)ptr, "ns6:BusinessEntityType");
	case SOAP_TYPE_PointerToPointerTons6__EnterpriseOfficialRegistration: return soap_out_PointerToPointerTons6__EnterpriseOfficialRegistration(soap, tag, id, (ns6__EnterpriseOfficialRegistration **const*)ptr, "ns6:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration: return soap_out_PointerTons6__EnterpriseOfficialRegistration(soap, tag, id, (ns6__EnterpriseOfficialRegistration *const*)ptr, "ns6:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerTons6__EnterpriseActivityList: return soap_out_PointerTons6__EnterpriseActivityList(soap, tag, id, (ns6__EnterpriseActivityList *const*)ptr, "ns6:EnterpriseActivityList");
	case SOAP_TYPE_PointerTons6__EnterpriseNumberList: return soap_out_PointerTons6__EnterpriseNumberList(soap, tag, id, (ns6__EnterpriseNumberList *const*)ptr, "ns6:EnterpriseNumberList");
	case SOAP_TYPE_PointerTons6__EnterpriseType: return soap_out_PointerTons6__EnterpriseType(soap, tag, id, (char **const*)ptr, "ns6:EnterpriseType");
	case SOAP_TYPE_PointerTons6__PackingCodeType: return soap_out_PointerTons6__PackingCodeType(soap, tag, id, (enum ns6__PackingCodeType *const*)ptr, "ns6:PackingCodeType");
	case SOAP_TYPE_PointerTons3__UUID: return soap_out_PointerTons3__UUID(soap, tag, id, (char **const*)ptr, "ns3:UUID");
	case SOAP_TYPE_PointerTons7__StockEntrySearchPattern: return soap_out_PointerTons7__StockEntrySearchPattern(soap, tag, id, (ns7__StockEntrySearchPattern *const*)ptr, "ns7:StockEntrySearchPattern");
	case SOAP_TYPE_PointerTons7__VetDocumentStatus: return soap_out_PointerTons7__VetDocumentStatus(soap, tag, id, (enum ns7__VetDocumentStatus *const*)ptr, "ns7:VetDocumentStatus");
	case SOAP_TYPE_PointerTons7__VetDocumentType: return soap_out_PointerTons7__VetDocumentType(soap, tag, id, (enum ns7__VetDocumentType *const*)ptr, "ns7:VetDocumentType");
	case SOAP_TYPE_PointerTons7__PSLModificationOperation: return soap_out_PointerTons7__PSLModificationOperation(soap, tag, id, (ns7__PSLModificationOperation *const*)ptr, "ns7:PSLModificationOperation");
	case SOAP_TYPE_PointerToPointerTons7__StockDiscrepancy: return soap_out_PointerToPointerTons7__StockDiscrepancy(soap, tag, id, (ns7__StockDiscrepancy **const*)ptr, "ns7:StockDiscrepancy");
	case SOAP_TYPE_PointerTons7__StockDiscrepancy: return soap_out_PointerTons7__StockDiscrepancy(soap, tag, id, (ns7__StockDiscrepancy *const*)ptr, "ns7:StockDiscrepancy");
	case SOAP_TYPE_PointerTons7__BEActivityLocationsModificationOperation: return soap_out_PointerTons7__BEActivityLocationsModificationOperation(soap, tag, id, (ns7__BEActivityLocationsModificationOperation *const*)ptr, "ns7:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_PointerTons7__ENTModificationOperation: return soap_out_PointerTons7__ENTModificationOperation(soap, tag, id, (ns7__ENTModificationOperation *const*)ptr, "ns7:ENTModificationOperation");
	case SOAP_TYPE_PointerTons7__BEModificationOperation: return soap_out_PointerTons7__BEModificationOperation(soap, tag, id, (ns7__BEModificationOperation *const*)ptr, "ns7:BEModificationOperation");
	case SOAP_TYPE_PointerTons7__MergeStockEntriesOperation: return soap_out_PointerTons7__MergeStockEntriesOperation(soap, tag, id, (ns7__MergeStockEntriesOperation *const*)ptr, "ns7:MergeStockEntriesOperation");
	case SOAP_TYPE_PointerTons7__ProductionOperation: return soap_out_PointerTons7__ProductionOperation(soap, tag, id, (ns7__ProductionOperation *const*)ptr, "ns7:ProductionOperation");
	case SOAP_TYPE_PointerToPointerTons7__Delivery: return soap_out_PointerToPointerTons7__Delivery(soap, tag, id, (ns7__Delivery **const*)ptr, "ns7:Delivery");
	case SOAP_TYPE_PointerToPointerTons7__DiscrepancyReport: return soap_out_PointerToPointerTons7__DiscrepancyReport(soap, tag, id, (ns7__DiscrepancyReport **const*)ptr, "ns7:DiscrepancyReport");
	case SOAP_TYPE_PointerTons7__DiscrepancyReport: return soap_out_PointerTons7__DiscrepancyReport(soap, tag, id, (ns7__DiscrepancyReport *const*)ptr, "ns7:DiscrepancyReport");
	case SOAP_TYPE_PointerTons7__DeliveryFactList: return soap_out_PointerTons7__DeliveryFactList(soap, tag, id, (ns7__DeliveryFactList *const*)ptr, "ns7:DeliveryFactList");
	case SOAP_TYPE_PointerTons7__Delivery: return soap_out_PointerTons7__Delivery(soap, tag, id, (ns7__Delivery *const*)ptr, "ns7:Delivery");
	case SOAP_TYPE_PointerToPointerTons7__WorkingArea: return soap_out_PointerToPointerTons7__WorkingArea(soap, tag, id, (ns7__WorkingArea **const*)ptr, "ns7:WorkingArea");
	case SOAP_TYPE_PointerTons7__WorkingArea: return soap_out_PointerTons7__WorkingArea(soap, tag, id, (ns7__WorkingArea *const*)ptr, "ns7:WorkingArea");
	case SOAP_TYPE_PointerTons7__WorkingAreaList: return soap_out_PointerTons7__WorkingAreaList(soap, tag, id, (ns7__WorkingAreaList *const*)ptr, "ns7:WorkingAreaList");
	case SOAP_TYPE_PointerTons7__SNILSType: return soap_out_PointerTons7__SNILSType(soap, tag, id, (char **const*)ptr, "ns7:SNILSType");
	case SOAP_TYPE_PointerTons6__MedicinalDrug: return soap_out_PointerTons6__MedicinalDrug(soap, tag, id, (ns6__MedicinalDrug *const*)ptr, "ns6:MedicinalDrug");
	case SOAP_TYPE_PointerTons6__Indicator: return soap_out_PointerTons6__Indicator(soap, tag, id, (ns6__Indicator *const*)ptr, "ns6:Indicator");
	case SOAP_TYPE_PointerTons6__DocumentType: return soap_out_PointerTons6__DocumentType(soap, tag, id, (enum ns6__DocumentType *const*)ptr, "ns6:DocumentType");
	case SOAP_TYPE_PointerTons7__ConsignmentDocumentList: return soap_out_PointerTons7__ConsignmentDocumentList(soap, tag, id, (ns7__ConsignmentDocumentList *const*)ptr, "ns7:ConsignmentDocumentList");
	case SOAP_TYPE_PointerToPointerTons7__Consignment: return soap_out_PointerToPointerTons7__Consignment(soap, tag, id, (ns7__Consignment **const*)ptr, "ns7:Consignment");
	case SOAP_TYPE_PointerTons7__Consignment: return soap_out_PointerTons7__Consignment(soap, tag, id, (ns7__Consignment *const*)ptr, "ns7:Consignment");
	case SOAP_TYPE_PointerToPointerTons6__BusinessMember: return soap_out_PointerToPointerTons6__BusinessMember(soap, tag, id, (ns6__BusinessMember **const*)ptr, "ns6:BusinessMember");
	case SOAP_TYPE_PointerToPointerTons6__ResearchMethod: return soap_out_PointerToPointerTons6__ResearchMethod(soap, tag, id, (ns6__ResearchMethod **const*)ptr, "ns6:ResearchMethod");
	case SOAP_TYPE_PointerToPointerTons6__AnimalDisease: return soap_out_PointerToPointerTons6__AnimalDisease(soap, tag, id, (ns6__AnimalDisease **const*)ptr, "ns6:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationRegionStatus: return soap_out_PointerToPointerTons6__RegionalizationRegionStatus(soap, tag, id, (ns6__RegionalizationRegionStatus **const*)ptr, "ns6:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerTons6__RegionalizationRegionStatus: return soap_out_PointerTons6__RegionalizationRegionStatus(soap, tag, id, (ns6__RegionalizationRegionStatus *const*)ptr, "ns6:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToPointerTons6__ProductItem: return soap_out_PointerToPointerTons6__ProductItem(soap, tag, id, (ns6__ProductItem **const*)ptr, "ns6:ProductItem");
	case SOAP_TYPE_PointerToPointerTons6__SubProduct: return soap_out_PointerToPointerTons6__SubProduct(soap, tag, id, (ns6__SubProduct **const*)ptr, "ns6:SubProduct");
	case SOAP_TYPE_PointerToPointerTons6__Product: return soap_out_PointerToPointerTons6__Product(soap, tag, id, (ns6__Product **const*)ptr, "ns6:Product");
	case SOAP_TYPE_PointerToPointerTons6__EnterpriseActivity: return soap_out_PointerToPointerTons6__EnterpriseActivity(soap, tag, id, (ns6__EnterpriseActivity **const*)ptr, "ns6:EnterpriseActivity");
	case SOAP_TYPE_PointerTons6__EnterpriseActivity: return soap_out_PointerTons6__EnterpriseActivity(soap, tag, id, (ns6__EnterpriseActivity *const*)ptr, "ns6:EnterpriseActivity");
	case SOAP_TYPE_PointerToPointerTons6__Street: return soap_out_PointerToPointerTons6__Street(soap, tag, id, (ns6__Street **const*)ptr, "ns6:Street");
	case SOAP_TYPE_PointerToPointerTons6__Locality: return soap_out_PointerToPointerTons6__Locality(soap, tag, id, (ns6__Locality **const*)ptr, "ns6:Locality");
	case SOAP_TYPE_PointerToPointerTons6__District: return soap_out_PointerToPointerTons6__District(soap, tag, id, (ns6__District **const*)ptr, "ns6:District");
	case SOAP_TYPE_PointerToPointerTons6__Region: return soap_out_PointerToPointerTons6__Region(soap, tag, id, (ns6__Region **const*)ptr, "ns6:Region");
	case SOAP_TYPE_PointerToPointerTons6__Country: return soap_out_PointerToPointerTons6__Country(soap, tag, id, (ns6__Country **const*)ptr, "ns6:Country");
	case SOAP_TYPE_PointerToPointerTons6__Unit: return soap_out_PointerToPointerTons6__Unit(soap, tag, id, (ns6__Unit **const*)ptr, "ns6:Unit");
	case SOAP_TYPE_PointerToPointerTons6__Purpose: return soap_out_PointerToPointerTons6__Purpose(soap, tag, id, (ns6__Purpose **const*)ptr, "ns6:Purpose");
	case SOAP_TYPE_PointerTons7__AuthorityList: return soap_out_PointerTons7__AuthorityList(soap, tag, id, (ns7__AuthorityList *const*)ptr, "ns7:AuthorityList");
	case SOAP_TYPE_PointerTons7__UserList: return soap_out_PointerTons7__UserList(soap, tag, id, (ns7__UserList *const*)ptr, "ns7:UserList");
	case SOAP_TYPE_PointerToPointerTons7__User: return soap_out_PointerToPointerTons7__User(soap, tag, id, (ns7__User **const*)ptr, "ns7:User");
	case SOAP_TYPE_PointerToPointerTons7__RouteSectionR13nRules: return soap_out_PointerToPointerTons7__RouteSectionR13nRules(soap, tag, id, (ns7__RouteSectionR13nRules **const*)ptr, "ns7:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTons7__RouteSectionR13nRules: return soap_out_PointerTons7__RouteSectionR13nRules(soap, tag, id, (ns7__RouteSectionR13nRules *const*)ptr, "ns7:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTons7__VetDocumentList: return soap_out_PointerTons7__VetDocumentList(soap, tag, id, (ns7__VetDocumentList *const*)ptr, "ns7:VetDocumentList");
	case SOAP_TYPE_PointerToPointerTons6__Enterprise: return soap_out_PointerToPointerTons6__Enterprise(soap, tag, id, (ns6__Enterprise **const*)ptr, "ns6:Enterprise");
	case SOAP_TYPE_PointerToPointerTons6__BusinessEntity: return soap_out_PointerToPointerTons6__BusinessEntity(soap, tag, id, (ns6__BusinessEntity **const*)ptr, "ns6:BusinessEntity");
	case SOAP_TYPE_PointerTons6__OTPToken: return soap_out_PointerTons6__OTPToken(soap, tag, id, (char **const*)ptr, "ns6:OTPToken");
	case SOAP_TYPE_PointerTons3__VersionStatus: return soap_out_PointerTons3__VersionStatus(soap, tag, id, (char **const*)ptr, "ns3:VersionStatus");
	case SOAP_TYPE_PointerTons6__ResearchMethodList: return soap_out_PointerTons6__ResearchMethodList(soap, tag, id, (ns6__ResearchMethodList *const*)ptr, "ns6:ResearchMethodList");
	case SOAP_TYPE_PointerTons6__ResearchMethod: return soap_out_PointerTons6__ResearchMethod(soap, tag, id, (ns6__ResearchMethod *const*)ptr, "ns6:ResearchMethod");
	case SOAP_TYPE_PointerTons6__AnimalDiseaseList: return soap_out_PointerTons6__AnimalDiseaseList(soap, tag, id, (ns6__AnimalDiseaseList *const*)ptr, "ns6:AnimalDiseaseList");
	case SOAP_TYPE_PointerTons6__RegionalizationShippingRuleList: return soap_out_PointerTons6__RegionalizationShippingRuleList(soap, tag, id, (ns6__RegionalizationShippingRuleList *const*)ptr, "ns6:RegionalizationShippingRuleList");
	case SOAP_TYPE_PointerTons6__RegionalizationRegionStatusList: return soap_out_PointerTons6__RegionalizationRegionStatusList(soap, tag, id, (ns6__RegionalizationRegionStatusList *const*)ptr, "ns6:RegionalizationRegionStatusList");
	case SOAP_TYPE_PointerTons6__RegionalizationConditionList: return soap_out_PointerTons6__RegionalizationConditionList(soap, tag, id, (ns6__RegionalizationConditionList *const*)ptr, "ns6:RegionalizationConditionList");
	case SOAP_TYPE_PointerTons6__ActivityLocationList: return soap_out_PointerTons6__ActivityLocationList(soap, tag, id, (ns6__ActivityLocationList *const*)ptr, "ns6:ActivityLocationList");
	case SOAP_TYPE_PointerTons6__EnterpriseGroup: return soap_out_PointerTons6__EnterpriseGroup(soap, tag, id, (enum ns6__EnterpriseGroup *const*)ptr, "ns6:EnterpriseGroup");
	case SOAP_TYPE_PointerTons6__StreetList: return soap_out_PointerTons6__StreetList(soap, tag, id, (ns6__StreetList *const*)ptr, "ns6:StreetList");
	case SOAP_TYPE_PointerTons6__LocalityList: return soap_out_PointerTons6__LocalityList(soap, tag, id, (ns6__LocalityList *const*)ptr, "ns6:LocalityList");
	case SOAP_TYPE_PointerTons6__DistrictList: return soap_out_PointerTons6__DistrictList(soap, tag, id, (ns6__DistrictList *const*)ptr, "ns6:DistrictList");
	case SOAP_TYPE_PointerTons6__RegionList: return soap_out_PointerTons6__RegionList(soap, tag, id, (ns6__RegionList *const*)ptr, "ns6:RegionList");
	case SOAP_TYPE_PointerTons6__CountryList: return soap_out_PointerTons6__CountryList(soap, tag, id, (ns6__CountryList *const*)ptr, "ns6:CountryList");
	case SOAP_TYPE_PointerTons6__SubProductList: return soap_out_PointerTons6__SubProductList(soap, tag, id, (ns6__SubProductList *const*)ptr, "ns6:SubProductList");
	case SOAP_TYPE_PointerTons6__ProductList: return soap_out_PointerTons6__ProductList(soap, tag, id, (ns6__ProductList *const*)ptr, "ns6:ProductList");
	case SOAP_TYPE_PointerTons6__UnitList: return soap_out_PointerTons6__UnitList(soap, tag, id, (ns6__UnitList *const*)ptr, "ns6:UnitList");
	case SOAP_TYPE_PointerTons3__DateInterval: return soap_out_PointerTons3__DateInterval(soap, tag, id, (ns3__DateInterval *const*)ptr, "ns3:DateInterval");
	case SOAP_TYPE_PointerTons6__PurposeList: return soap_out_PointerTons6__PurposeList(soap, tag, id, (ns6__PurposeList *const*)ptr, "ns6:PurposeList");
	case SOAP_TYPE_PointerTons3__ListOptions: return soap_out_PointerTons3__ListOptions(soap, tag, id, (ns3__ListOptions *const*)ptr, "ns3:ListOptions");
	case SOAP_TYPE_PointerTons6__Area: return soap_out_PointerTons6__Area(soap, tag, id, (ns6__Area *const*)ptr, "ns6:Area");
	case SOAP_TYPE_PointerToPointerTons7__UserAuthority: return soap_out_PointerToPointerTons7__UserAuthority(soap, tag, id, (ns7__UserAuthority **const*)ptr, "ns7:UserAuthority");
	case SOAP_TYPE_PointerTons7__UserAuthority: return soap_out_PointerTons7__UserAuthority(soap, tag, id, (ns7__UserAuthority *const*)ptr, "ns7:UserAuthority");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationShippingRule: return soap_out_PointerToPointerTons6__RegionalizationShippingRule(soap, tag, id, (ns6__RegionalizationShippingRule **const*)ptr, "ns6:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTons6__RegionalizationShippingRule: return soap_out_PointerTons6__RegionalizationShippingRule(soap, tag, id, (ns6__RegionalizationShippingRule *const*)ptr, "ns6:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTons3__SequenceNumber: return soap_out_PointerTons3__SequenceNumber(soap, tag, id, (char **const*)ptr, "ns3:SequenceNumber");
	case SOAP_TYPE_PointerToPointerTons7__QuarantineEvent: return soap_out_PointerToPointerTons7__QuarantineEvent(soap, tag, id, (ns7__QuarantineEvent **const*)ptr, "ns7:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTons7__RegionalizationClause: return soap_out_PointerToPointerTons7__RegionalizationClause(soap, tag, id, (ns7__RegionalizationClause **const*)ptr, "ns7:RegionalizationClause");
	case SOAP_TYPE_PointerTons7__RegionalizationClause: return soap_out_PointerTons7__RegionalizationClause(soap, tag, id, (ns7__RegionalizationClause *const*)ptr, "ns7:RegionalizationClause");
	case SOAP_TYPE_PointerToPointerTons7__VeterinaryEvent: return soap_out_PointerToPointerTons7__VeterinaryEvent(soap, tag, id, (ns7__VeterinaryEvent **const*)ptr, "ns7:VeterinaryEvent");
	case SOAP_TYPE_PointerTons7__VeterinaryEvent: return soap_out_PointerTons7__VeterinaryEvent(soap, tag, id, (ns7__VeterinaryEvent *const*)ptr, "ns7:VeterinaryEvent");
	case SOAP_TYPE_PointerToPointerTons7__AnimalMedicationEvent: return soap_out_PointerToPointerTons7__AnimalMedicationEvent(soap, tag, id, (ns7__AnimalMedicationEvent **const*)ptr, "ns7:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTons7__AnimalMedicationEvent: return soap_out_PointerTons7__AnimalMedicationEvent(soap, tag, id, (ns7__AnimalMedicationEvent *const*)ptr, "ns7:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTons7__QuarantineEvent: return soap_out_PointerTons7__QuarantineEvent(soap, tag, id, (ns7__QuarantineEvent *const*)ptr, "ns7:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTons7__LaboratoryResearchEvent: return soap_out_PointerToPointerTons7__LaboratoryResearchEvent(soap, tag, id, (ns7__LaboratoryResearchEvent **const*)ptr, "ns7:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTons7__LaboratoryResearchEvent: return soap_out_PointerTons7__LaboratoryResearchEvent(soap, tag, id, (ns7__LaboratoryResearchEvent *const*)ptr, "ns7:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTons7__AnimalSpentPeriod: return soap_out_PointerTons7__AnimalSpentPeriod(soap, tag, id, (enum ns7__AnimalSpentPeriod *const*)ptr, "ns7:AnimalSpentPeriod");
	case SOAP_TYPE_PointerTons6__ResearchResult: return soap_out_PointerTons6__ResearchResult(soap, tag, id, (enum ns6__ResearchResult *const*)ptr, "ns6:ResearchResult");
	case SOAP_TYPE_PointerTons6__Purpose: return soap_out_PointerTons6__Purpose(soap, tag, id, (ns6__Purpose *const*)ptr, "ns6:Purpose");
	case SOAP_TYPE_PointerToPointerTons7__Document: return soap_out_PointerToPointerTons7__Document(soap, tag, id, (ns7__Document **const*)ptr, "ns7:Document");
	case SOAP_TYPE_PointerTons7__Document: return soap_out_PointerTons7__Document(soap, tag, id, (ns7__Document *const*)ptr, "ns7:Document");
	case SOAP_TYPE_PointerTons6__Organization: return soap_out_PointerTons6__Organization(soap, tag, id, (ns6__Organization *const*)ptr, "ns6:Organization");
	case SOAP_TYPE_PointerTons6__Location: return soap_out_PointerTons6__Location(soap, tag, id, (ns6__Location *const*)ptr, "ns6:Location");
	case SOAP_TYPE_PointerTons7__VeterinaryEventType: return soap_out_PointerTons7__VeterinaryEventType(soap, tag, id, (enum ns7__VeterinaryEventType *const*)ptr, "ns7:VeterinaryEventType");
	case SOAP_TYPE_PointerTons7__ShipmentRoute: return soap_out_PointerTons7__ShipmentRoute(soap, tag, id, (ns7__ShipmentRoute *const*)ptr, "ns7:ShipmentRoute");
	case SOAP_TYPE_PointerTons6__TransportationStorageType: return soap_out_PointerTons6__TransportationStorageType(soap, tag, id, (enum ns6__TransportationStorageType *const*)ptr, "ns6:TransportationStorageType");
	case SOAP_TYPE_PointerTons7__TransportInfo: return soap_out_PointerTons7__TransportInfo(soap, tag, id, (ns7__TransportInfo *const*)ptr, "ns7:TransportInfo");
	case SOAP_TYPE_PointerTons7__Batch: return soap_out_PointerTons7__Batch(soap, tag, id, (ns7__Batch *const*)ptr, "ns7:Batch");
	case SOAP_TYPE_PointerTons6__EnterpriseList: return soap_out_PointerTons6__EnterpriseList(soap, tag, id, (ns6__EnterpriseList *const*)ptr, "ns6:EnterpriseList");
	case SOAP_TYPE_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation: return soap_out_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(soap, tag, id, (_ns7__BEActivityLocationsModificationOperation_activityLocation *const*)ptr, "ns7:BEActivityLocationsModificationOperation-activityLocation");
	case SOAP_TYPE_PointerTons6__GLNType: return soap_out_PointerTons6__GLNType(soap, tag, id, (char **const*)ptr, "ns6:GLNType");
	case SOAP_TYPE_PointerTons6__BusinessEntityList: return soap_out_PointerTons6__BusinessEntityList(soap, tag, id, (ns6__BusinessEntityList *const*)ptr, "ns6:BusinessEntityList");
	case SOAP_TYPE_PointerTons6__ProductItemList: return soap_out_PointerTons6__ProductItemList(soap, tag, id, (ns6__ProductItemList *const*)ptr, "ns6:ProductItemList");
	case SOAP_TYPE_PointerToPointerTons7__StockEntry: return soap_out_PointerToPointerTons7__StockEntry(soap, tag, id, (ns7__StockEntry **const*)ptr, "ns7:StockEntry");
	case SOAP_TYPE_PointerTons3__RegisterModificationType: return soap_out_PointerTons3__RegisterModificationType(soap, tag, id, (enum ns3__RegisterModificationType *const*)ptr, "ns3:RegisterModificationType");
	case SOAP_TYPE_PointerToPointerTons7__ProcessingProcedure: return soap_out_PointerToPointerTons7__ProcessingProcedure(soap, tag, id, (ns7__ProcessingProcedure **const*)ptr, "ns7:ProcessingProcedure");
	case SOAP_TYPE_PointerTons7__ProcessingProcedure: return soap_out_PointerTons7__ProcessingProcedure(soap, tag, id, (ns7__ProcessingProcedure *const*)ptr, "ns7:ProcessingProcedure");
	case SOAP_TYPE_PointerToPointerTons7__ProductiveBatch: return soap_out_PointerToPointerTons7__ProductiveBatch(soap, tag, id, (ns7__ProductiveBatch **const*)ptr, "ns7:ProductiveBatch");
	case SOAP_TYPE_PointerTons7__ProductiveBatch: return soap_out_PointerTons7__ProductiveBatch(soap, tag, id, (ns7__ProductiveBatch *const*)ptr, "ns7:ProductiveBatch");
	case SOAP_TYPE_PointerToPointerTons7__RawBatch: return soap_out_PointerToPointerTons7__RawBatch(soap, tag, id, (ns7__RawBatch **const*)ptr, "ns7:RawBatch");
	case SOAP_TYPE_PointerTons7__RawBatch: return soap_out_PointerTons7__RawBatch(soap, tag, id, (ns7__RawBatch *const*)ptr, "ns7:RawBatch");
	case SOAP_TYPE_PointerToPointerTons7__ShipmentRoutePoint: return soap_out_PointerToPointerTons7__ShipmentRoutePoint(soap, tag, id, (ns7__ShipmentRoutePoint **const*)ptr, "ns7:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTons7__ShipmentRoutePoint: return soap_out_PointerTons7__ShipmentRoutePoint(soap, tag, id, (ns7__ShipmentRoutePoint *const*)ptr, "ns7:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTons7__TransportNumber: return soap_out_PointerTons7__TransportNumber(soap, tag, id, (ns7__TransportNumber *const*)ptr, "ns7:TransportNumber");
	case SOAP_TYPE_PointerTons6__TransportType: return soap_out_PointerTons6__TransportType(soap, tag, id, (enum ns6__TransportType *const*)ptr, "ns6:TransportType");
	case SOAP_TYPE_PointerTons7__StockEntryList: return soap_out_PointerTons7__StockEntryList(soap, tag, id, (ns7__StockEntryList *const*)ptr, "ns7:StockEntryList");
	case SOAP_TYPE_PointerTons6__ComplexDate: return soap_out_PointerTons6__ComplexDate(soap, tag, id, (ns6__ComplexDate *const*)ptr, "ns6:ComplexDate");
	case SOAP_TYPE_PointerToPointerTons7__ReferencedDocument: return soap_out_PointerToPointerTons7__ReferencedDocument(soap, tag, id, (ns7__ReferencedDocument **const*)ptr, "ns7:ReferencedDocument");
	case SOAP_TYPE_PointerTons7__ReferencedDocument: return soap_out_PointerTons7__ReferencedDocument(soap, tag, id, (ns7__ReferencedDocument *const*)ptr, "ns7:ReferencedDocument");
	case SOAP_TYPE_PointerToPointerTons7__VetDocument: return soap_out_PointerToPointerTons7__VetDocument(soap, tag, id, (ns7__VetDocument **const*)ptr, "ns7:VetDocument");
	case SOAP_TYPE_PointerTons7__VetDocument: return soap_out_PointerTons7__VetDocument(soap, tag, id, (ns7__VetDocument *const*)ptr, "ns7:VetDocument");
	case SOAP_TYPE_PointerTons7__Waybill: return soap_out_PointerTons7__Waybill(soap, tag, id, (ns7__Waybill *const*)ptr, "ns7:Waybill");
	case SOAP_TYPE_PointerTons7__User: return soap_out_PointerTons7__User(soap, tag, id, (ns7__User *const*)ptr, "ns7:User");
	case SOAP_TYPE_PointerTons7__DeliveryInspection: return soap_out_PointerTons7__DeliveryInspection(soap, tag, id, (ns7__DeliveryInspection *const*)ptr, "ns7:DeliveryInspection");
	case SOAP_TYPE_PointerTons7__StockEntry: return soap_out_PointerTons7__StockEntry(soap, tag, id, (ns7__StockEntry *const*)ptr, "ns7:StockEntry");
	case SOAP_TYPE_PointerTons6__PackageList: return soap_out_PointerTons6__PackageList(soap, tag, id, (ns6__PackageList *const*)ptr, "ns6:PackageList");
	case SOAP_TYPE_PointerTons7__BatchOrigin: return soap_out_PointerTons7__BatchOrigin(soap, tag, id, (ns7__BatchOrigin *const*)ptr, "ns7:BatchOrigin");
	case SOAP_TYPE_PointerTons7__GoodsDate: return soap_out_PointerTons7__GoodsDate(soap, tag, id, (ns7__GoodsDate *const*)ptr, "ns7:GoodsDate");
	case SOAP_TYPE_PointerTons6__ProductItem: return soap_out_PointerTons6__ProductItem(soap, tag, id, (ns6__ProductItem *const*)ptr, "ns6:ProductItem");
	case SOAP_TYPE_PointerTons6__SubProduct: return soap_out_PointerTons6__SubProduct(soap, tag, id, (ns6__SubProduct *const*)ptr, "ns6:SubProduct");
	case SOAP_TYPE_PointerTons6__Product: return soap_out_PointerTons6__Product(soap, tag, id, (ns6__Product *const*)ptr, "ns6:Product");
	case SOAP_TYPE_PointerTons6__ProductType: return soap_out_PointerTons6__ProductType(soap, tag, id, (enum ns6__ProductType *const*)ptr, "ns6:ProductType");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationConditionGroup: return soap_out_PointerToPointerTons6__RegionalizationConditionGroup(soap, tag, id, (ns6__RegionalizationConditionGroup **const*)ptr, "ns6:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTons6__RegionalizationConditionGroup: return soap_out_PointerTons6__RegionalizationConditionGroup(soap, tag, id, (ns6__RegionalizationConditionGroup *const*)ptr, "ns6:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerTons6__AnimalDisease: return soap_out_PointerTons6__AnimalDisease(soap, tag, id, (ns6__AnimalDisease *const*)ptr, "ns6:AnimalDisease");
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationCondition: return soap_out_PointerToPointerTons6__RegionalizationCondition(soap, tag, id, (ns6__RegionalizationCondition **const*)ptr, "ns6:RegionalizationCondition");
	case SOAP_TYPE_PointerTons6__RegionalizationCondition: return soap_out_PointerTons6__RegionalizationCondition(soap, tag, id, (ns6__RegionalizationCondition *const*)ptr, "ns6:RegionalizationCondition");
	case SOAP_TYPE_PointerTons6__BusinessMember: return soap_out_PointerTons6__BusinessMember(soap, tag, id, (ns6__BusinessMember *const*)ptr, "ns6:BusinessMember");
	case SOAP_TYPE_PointerTons3__Identifier: return soap_out_PointerTons3__Identifier(soap, tag, id, (char **const*)ptr, "ns3:Identifier");
	case SOAP_TYPE_PointerTons6__Address: return soap_out_PointerTons6__Address(soap, tag, id, (ns6__Address *const*)ptr, "ns6:Address");
	case SOAP_TYPE_PointerTons6__Unit: return soap_out_PointerTons6__Unit(soap, tag, id, (ns6__Unit *const*)ptr, "ns6:Unit");
	case SOAP_TYPE_PointerTons3__Decimal: return soap_out_PointerTons3__Decimal(soap, tag, id, (char **const*)ptr, "ns3:Decimal");
	case SOAP_TYPE_PointerTons6__Minute: return soap_out_PointerTons6__Minute(soap, tag, id, (int *const*)ptr, "ns6:Minute");
	case SOAP_TYPE_PointerTons6__Hour: return soap_out_PointerTons6__Hour(soap, tag, id, (int *const*)ptr, "ns6:Hour");
	case SOAP_TYPE_PointerTons6__Day: return soap_out_PointerTons6__Day(soap, tag, id, (int *const*)ptr, "ns6:Day");
	case SOAP_TYPE_PointerTons6__Month: return soap_out_PointerTons6__Month(soap, tag, id, (int *const*)ptr, "ns6:Month");
	case SOAP_TYPE_PointerTons6__Year: return soap_out_PointerTons6__Year(soap, tag, id, (int *const*)ptr, "ns6:Year");
	case SOAP_TYPE_PointerToPointerTons6__Package: return soap_out_PointerToPointerTons6__Package(soap, tag, id, (ns6__Package **const*)ptr, "ns6:Package");
	case SOAP_TYPE_PointerTons6__Package: return soap_out_PointerTons6__Package(soap, tag, id, (ns6__Package *const*)ptr, "ns6:Package");
	case SOAP_TYPE_PointerToPointerTons6__ProductMarks: return soap_out_PointerToPointerTons6__ProductMarks(soap, tag, id, (ns6__ProductMarks **const*)ptr, "ns6:ProductMarks");
	case SOAP_TYPE_PointerTons6__ProductMarks: return soap_out_PointerTons6__ProductMarks(soap, tag, id, (ns6__ProductMarks *const*)ptr, "ns6:ProductMarks");
	case SOAP_TYPE_PointerTons6__PackingType: return soap_out_PointerTons6__PackingType(soap, tag, id, (ns6__PackingType *const*)ptr, "ns6:PackingType");
	case SOAP_TYPE_PointerTons6__BusinessEntity: return soap_out_PointerTons6__BusinessEntity(soap, tag, id, (ns6__BusinessEntity *const*)ptr, "ns6:BusinessEntity");
	case SOAP_TYPE_PointerTons3__String255: return soap_out_PointerTons3__String255(soap, tag, id, (char **const*)ptr, "ns3:String255");
	case SOAP_TYPE_PointerToPointerTons6__Producer: return soap_out_PointerToPointerTons6__Producer(soap, tag, id, (ns6__Producer **const*)ptr, "ns6:Producer");
	case SOAP_TYPE_PointerTons6__Producer: return soap_out_PointerTons6__Producer(soap, tag, id, (ns6__Producer *const*)ptr, "ns6:Producer");
	case SOAP_TYPE_PointerTons6__EnterpriseRole: return soap_out_PointerTons6__EnterpriseRole(soap, tag, id, (enum ns6__EnterpriseRole *const*)ptr, "ns6:EnterpriseRole");
	case SOAP_TYPE_PointerTons6__Enterprise: return soap_out_PointerTons6__Enterprise(soap, tag, id, (ns6__Enterprise *const*)ptr, "ns6:Enterprise");
	case SOAP_TYPE_PointerTons3__NText: return soap_out_PointerTons3__NText(soap, tag, id, (char **const*)ptr, "ns3:NText");
	case SOAP_TYPE_PointerTons6__Street: return soap_out_PointerTons6__Street(soap, tag, id, (ns6__Street *const*)ptr, "ns6:Street");
	case SOAP_TYPE_PointerTons6__Locality: return soap_out_PointerTons6__Locality(soap, tag, id, (ns6__Locality *const*)ptr, "ns6:Locality");
	case SOAP_TYPE_PointerTons6__District: return soap_out_PointerTons6__District(soap, tag, id, (ns6__District *const*)ptr, "ns6:District");
	case SOAP_TYPE_PointerTons6__Region: return soap_out_PointerTons6__Region(soap, tag, id, (ns6__Region *const*)ptr, "ns6:Region");
	case SOAP_TYPE_PointerTons6__FederalDistrict: return soap_out_PointerTons6__FederalDistrict(soap, tag, id, (ns6__FederalDistrict *const*)ptr, "ns6:FederalDistrict");
	case SOAP_TYPE_PointerTons6__Country: return soap_out_PointerTons6__Country(soap, tag, id, (ns6__Country *const*)ptr, "ns6:Country");
	case SOAP_TYPE_PointerToPointerTons4__BusinessError: return soap_out_PointerToPointerTons4__BusinessError(soap, tag, id, (ns4__BusinessError **const*)ptr, "ns4:BusinessError");
	case SOAP_TYPE_PointerTons4__BusinessError: return soap_out_PointerTons4__BusinessError(soap, tag, id, (ns4__BusinessError *const*)ptr, "ns4:BusinessError");
	case SOAP_TYPE_PointerTons4__ContentEncoding: return soap_out_PointerTons4__ContentEncoding(soap, tag, id, (enum ns4__ContentEncoding *const*)ptr, "ns4:ContentEncoding");
	case SOAP_TYPE_PointerTons4__BusinessErrorList: return soap_out_PointerTons4__BusinessErrorList(soap, tag, id, (ns4__BusinessErrorList *const*)ptr, "ns4:BusinessErrorList");
	case SOAP_TYPE_PointerTons4__ApplicationResultWrapper: return soap_out_PointerTons4__ApplicationResultWrapper(soap, tag, id, (ns4__ApplicationResultWrapper *const*)ptr, "ns4:ApplicationResultWrapper");
	case SOAP_TYPE_PointerTons4__ApplicationDataWrapper: return soap_out_PointerTons4__ApplicationDataWrapper(soap, tag, id, (ns4__ApplicationDataWrapper *const*)ptr, "ns4:ApplicationDataWrapper");
	case SOAP_TYPE_PointerTons4__ApplicationStatus: return soap_out_PointerTons4__ApplicationStatus(soap, tag, id, (enum ns4__ApplicationStatus *const*)ptr, "ns4:ApplicationStatus");
	case SOAP_TYPE_PointerToPointerTons3__Error: return soap_out_PointerToPointerTons3__Error(soap, tag, id, (ns3__Error **const*)ptr, "ns3:Error");
	case SOAP_TYPE_PointerTons3__Error: return soap_out_PointerTons3__Error(soap, tag, id, (ns3__Error *const*)ptr, "ns3:Error");
	case SOAP_TYPE_PointerTobool: return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64: return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToint: return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTotime: return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons4__Application: return soap_out_PointerTons4__Application(soap, tag, id, (ns4__Application *const*)ptr, "ns4:Application");
	case SOAP_TYPE_ns7__VetDocumentStatusChangeReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns7:VetDocumentStatusChangeReason");
	case SOAP_TYPE_ns6__GRNType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:GRNType");
	case SOAP_TYPE_ns7__SNILSType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns7:SNILSType");
	case SOAP_TYPE_ns7__StockEntryNumber: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns7:StockEntryNumber");
	case SOAP_TYPE_ns6__OTPToken: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:OTPToken");
	case SOAP_TYPE_ns6__GTINType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:GTINType");
	case SOAP_TYPE_ns6__GLNType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:GLNType");
	case SOAP_TYPE_ns6__ENTModificationReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:ENTModificationReason");
	case SOAP_TYPE_ns6__BEModificationReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:BEModificationReason");
	case SOAP_TYPE_ns6__EnterpriseType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:EnterpriseType");
	case SOAP_TYPE_ns6__Code3: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:Code3");
	case SOAP_TYPE_ns6__Code: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns6:Code");
	case SOAP_TYPE_ns4__APIKey: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns4:APIKey");
	case SOAP_TYPE_ns3__SequenceNumber: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:SequenceNumber");
	case SOAP_TYPE_ns3__Identifier: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:Identifier");
	case SOAP_TYPE_ns3__VersionStatus: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:VersionStatus");
	case SOAP_TYPE_ns3__Decimal: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:Decimal");
	case SOAP_TYPE_ns3__String32: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:String32");
	case SOAP_TYPE_ns3__String255: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:String255");
	case SOAP_TYPE_ns3__NText: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:NText");
	case SOAP_TYPE_ns3__Text: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:Text");
	case SOAP_TYPE_ns3__UUID: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:UUID");
	case SOAP_TYPE_xsd__token: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__positiveInteger: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE_PointerTounsignedByte: return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__Name: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:Name");
	case SOAP_TYPE_xsd__NCName: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__IDREF: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:ID");
	case SOAP_TYPE__QName: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	switch(type) {
	case SOAP_TYPE__ns6__BusinessEntity_activityLocation: ((_ns6__BusinessEntity_activityLocation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation: ((_ns7__BEActivityLocationsModificationOperation_activityLocation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__BinaryContent: soap_serialize_ns4__BinaryContent(soap, (const xsd__base64Binary *)ptr); break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse: ((_ns8__getResearchMethodChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest: ((_ns8__getResearchMethodChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodListResponse: ((_ns8__getResearchMethodListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodListRequest: ((_ns8__getResearchMethodListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse: ((_ns8__getResearchMethodByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest: ((_ns8__getResearchMethodByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse: ((_ns8__getResearchMethodByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest: ((_ns8__getResearchMethodByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse: ((_ns8__getDiseaseChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest: ((_ns8__getDiseaseChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseListResponse: ((_ns8__getDiseaseListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseListRequest: ((_ns8__getDiseaseListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse: ((_ns8__getDiseaseByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest: ((_ns8__getDiseaseByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse: ((_ns8__getDiseaseByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest: ((_ns8__getDiseaseByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse: ((_ns8__getActualR13nShippingRuleListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest: ((_ns8__getActualR13nShippingRuleListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse: ((_ns8__getActualR13nRegionStatusListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest: ((_ns8__getActualR13nRegionStatusListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getR13nConditionListResponse: ((_ns8__getR13nConditionListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getR13nConditionListRequest: ((_ns8__getR13nConditionListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActivityLocationListResponse: ((_ns8__getActivityLocationListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActivityLocationListRequest: ((_ns8__getActivityLocationListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse: ((_ns8__getBusinessMemberByGLNResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest: ((_ns8__getBusinessMemberByGLNRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse: ((_ns8__getBusinessEntityChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest: ((_ns8__getBusinessEntityChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityListResponse: ((_ns8__getBusinessEntityListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityListRequest: ((_ns8__getBusinessEntityListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse: ((_ns8__getBusinessEntityByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest: ((_ns8__getBusinessEntityByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse: ((_ns8__getBusinessEntityByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest: ((_ns8__getBusinessEntityByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse: ((_ns8__getRussianEnterpriseChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest: ((_ns8__getRussianEnterpriseChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse: ((_ns8__getForeignEnterpriseChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest: ((_ns8__getForeignEnterpriseChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse: ((_ns8__getRussianEnterpriseListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest: ((_ns8__getRussianEnterpriseListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse: ((_ns8__getForeignEnterpriseListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest: ((_ns8__getForeignEnterpriseListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse: ((_ns8__getEnterpriseByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest: ((_ns8__getEnterpriseByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse: ((_ns8__getEnterpriseByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest: ((_ns8__getEnterpriseByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findStreetListByNameResponse: ((_ns8__findStreetListByNameResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findStreetListByNameRequest: ((_ns8__findStreetListByNameRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findLocalityListByNameResponse: ((_ns8__findLocalityListByNameResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findLocalityListByNameRequest: ((_ns8__findLocalityListByNameRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse: ((_ns8__getStreetListByLocalityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest: ((_ns8__getStreetListByLocalityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse: ((_ns8__getLocalityListByLocalityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest: ((_ns8__getLocalityListByLocalityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse: ((_ns8__getLocalityListByDistrictResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest: ((_ns8__getLocalityListByDistrictRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse: ((_ns8__getLocalityListByRegionResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest: ((_ns8__getLocalityListByRegionRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictChangesListResponse: ((_ns8__getDistrictChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictChangesListRequest: ((_ns8__getDistrictChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByUuidResponse: ((_ns8__getDistrictByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByUuidRequest: ((_ns8__getDistrictByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByGuidResponse: ((_ns8__getDistrictByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByGuidRequest: ((_ns8__getDistrictByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse: ((_ns8__getDistrictListByRegionResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest: ((_ns8__getDistrictListByRegionRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionChangesListResponse: ((_ns8__getRegionChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionChangesListRequest: ((_ns8__getRegionChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByUuidResponse: ((_ns8__getRegionByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByUuidRequest: ((_ns8__getRegionByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByGuidResponse: ((_ns8__getRegionByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByGuidRequest: ((_ns8__getRegionByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionListByCountryResponse: ((_ns8__getRegionListByCountryResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionListByCountryRequest: ((_ns8__getRegionListByCountryRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryChangesListResponse: ((_ns8__getCountryChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryChangesListRequest: ((_ns8__getCountryChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByUuidResponse: ((_ns8__getCountryByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByUuidRequest: ((_ns8__getCountryByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByGuidResponse: ((_ns8__getCountryByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByGuidRequest: ((_ns8__getCountryByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getAllCountryListResponse: ((_ns8__getAllCountryListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getAllCountryListRequest: ((_ns8__getAllCountryListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemChangesListResponse: ((_ns8__getProductItemChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemChangesListRequest: ((_ns8__getProductItemChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemListResponse: ((_ns8__getProductItemListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemListRequest: ((_ns8__getProductItemListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByUuidResponse: ((_ns8__getProductItemByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByUuidRequest: ((_ns8__getProductItemByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByGuidResponse: ((_ns8__getProductItemByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByGuidRequest: ((_ns8__getProductItemByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductChangesListResponse: ((_ns8__getSubProductChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductChangesListRequest: ((_ns8__getSubProductChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByProductListResponse: ((_ns8__getSubProductByProductListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByProductListRequest: ((_ns8__getSubProductByProductListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByUuidResponse: ((_ns8__getSubProductByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByUuidRequest: ((_ns8__getSubProductByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByGuidResponse: ((_ns8__getSubProductByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByGuidRequest: ((_ns8__getSubProductByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductChangesListResponse: ((_ns8__getProductChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductChangesListRequest: ((_ns8__getProductChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByTypeListResponse: ((_ns8__getProductByTypeListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByTypeListRequest: ((_ns8__getProductByTypeListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByUuidResponse: ((_ns8__getProductByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByUuidRequest: ((_ns8__getProductByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByGuidResponse: ((_ns8__getProductByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByGuidRequest: ((_ns8__getProductByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitChangesListResponse: ((_ns8__getUnitChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitChangesListRequest: ((_ns8__getUnitChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitListResponse: ((_ns8__getUnitListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitListRequest: ((_ns8__getUnitListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByUuidResponse: ((_ns8__getUnitByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByUuidRequest: ((_ns8__getUnitByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByGuidResponse: ((_ns8__getUnitByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByGuidRequest: ((_ns8__getUnitByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeChangesListResponse: ((_ns8__getPurposeChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeChangesListRequest: ((_ns8__getPurposeChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeListResponse: ((_ns8__getPurposeListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeListRequest: ((_ns8__getPurposeListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByUuidResponse: ((_ns8__getPurposeByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByUuidRequest: ((_ns8__getPurposeByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByGuidResponse: ((_ns8__getPurposeByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByGuidRequest: ((_ns8__getPurposeByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__WorkingArea: ((ns7__WorkingArea *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__UserAuthority: ((ns7__UserAuthority *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__WorkingAreaList: ((ns7__WorkingAreaList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__AuthorityList: ((ns7__AuthorityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__UserList: ((ns7__UserList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__User: ((ns7__User *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ProcessingProcedure: ((ns7__ProcessingProcedure *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__RouteSectionR13nRules: ((ns7__RouteSectionR13nRules *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__RegionalizationClause: ((ns7__RegionalizationClause *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__VetDocumentStatusChange: ((ns7__VetDocumentStatusChange *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__StockEntryEventList: ((ns7__StockEntryEventList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__BatchOrigin: ((ns7__BatchOrigin *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__VeterinaryAuthentication: ((ns7__VeterinaryAuthentication *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__QuarantineEvent: ((ns7__QuarantineEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__AnimalMedicationEvent: ((ns7__AnimalMedicationEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__LaboratoryResearchEvent: ((ns7__LaboratoryResearchEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__VeterinaryEvent: ((ns7__VeterinaryEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ReferencedDocument: ((ns7__ReferencedDocument *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__CertifiedConsignment: ((ns7__CertifiedConsignment *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__CertifiedBatch: ((ns7__CertifiedBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ENTModificationOperation: ((ns7__ENTModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__BEActivityLocationsModificationOperation: ((ns7__BEActivityLocationsModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__BEModificationOperation: ((ns7__BEModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__PSLModificationOperation: ((ns7__PSLModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__MergeStockEntriesOperation: ((ns7__MergeStockEntriesOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ProductionOperation: ((ns7__ProductionOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ShipmentRoute: ((ns7__ShipmentRoute *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ShipmentRoutePoint: ((ns7__ShipmentRoutePoint *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__TransportNumber: ((ns7__TransportNumber *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__TransportInfo: ((ns7__TransportInfo *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__Waybill: ((ns7__Waybill *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__Document: ((ns7__Document *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__StockEntrySearchPattern: ((ns7__StockEntrySearchPattern *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__StockDiscrepancy: ((ns7__StockDiscrepancy *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__StockEntryList: ((ns7__StockEntryList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__StockEntry: ((ns7__StockEntry *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__DiscrepancyReason: ((ns7__DiscrepancyReason *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__DiscrepancyReport: ((ns7__DiscrepancyReport *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__VetDocumentList: ((ns7__VetDocumentList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__GoodsDate: ((ns7__GoodsDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ConsignmentDocumentList: ((ns7__ConsignmentDocumentList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__DeliveryInspection: ((ns7__DeliveryInspection *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__DeliveryFactList: ((ns7__DeliveryFactList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__Delivery: ((ns7__Delivery *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__ProductiveBatch: ((ns7__ProductiveBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__RawBatch: ((ns7__RawBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__Consignment: ((ns7__Consignment *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__Batch: ((ns7__Batch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns7__VetDocument: ((ns7__VetDocument *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ActivityLocationList: ((ns6__ActivityLocationList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ResearchMethodList: ((ns6__ResearchMethodList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__AnimalDiseaseList: ((ns6__AnimalDiseaseList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationShippingRuleList: ((ns6__RegionalizationShippingRuleList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationRegionStatusList: ((ns6__RegionalizationRegionStatusList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationConditionList: ((ns6__RegionalizationConditionList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Area: ((ns6__Area *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationRegionStatus: ((ns6__RegionalizationRegionStatus *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationStatus: ((ns6__RegionalizationStatus *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationShippingRule: ((ns6__RegionalizationShippingRule *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationRequirement: ((ns6__RegionalizationRequirement *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationConditionGroup: ((ns6__RegionalizationConditionGroup *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionalizationCondition: ((ns6__RegionalizationCondition *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__MedicinalDrug: ((ns6__MedicinalDrug *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ResearchMethod: ((ns6__ResearchMethod *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__AnimalDisease: ((ns6__AnimalDisease *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Indicator: ((ns6__Indicator *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Organization: ((ns6__Organization *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__EnterpriseOfficialRegistration: ((ns6__EnterpriseOfficialRegistration *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Location: ((ns6__Location *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Packaging: ((ns6__Packaging *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ProductItemProducing: ((ns6__ProductItemProducing *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ComplexDate: ((ns6__ComplexDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__PackageList: ((ns6__PackageList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Package: ((ns6__Package *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ProductMarks: ((ns6__ProductMarks *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ProductItemList: ((ns6__ProductItemList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__SubProductList: ((ns6__SubProductList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ProductList: ((ns6__ProductList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__SubProduct: ((ns6__SubProduct *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Product: ((ns6__Product *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ProductItem: ((ns6__ProductItem *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__BusinessEntityList: ((ns6__BusinessEntityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__IncorporationForm: ((ns6__IncorporationForm *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__BusinessEntity: ((ns6__BusinessEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__BusinessMember: ((ns6__BusinessMember *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__EnterpriseList: ((ns6__EnterpriseList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__EnterpriseNumberList: ((ns6__EnterpriseNumberList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__ProducerList: ((ns6__ProducerList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Producer: ((ns6__Producer *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__EnterpriseActivity: ((ns6__EnterpriseActivity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__EnterpriseActivityList: ((ns6__EnterpriseActivityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Enterprise: ((ns6__Enterprise *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__StreetList: ((ns6__StreetList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__LocalityList: ((ns6__LocalityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__DistrictList: ((ns6__DistrictList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__RegionList: ((ns6__RegionList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__CountryList: ((ns6__CountryList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Address: ((ns6__Address *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Street: ((ns6__Street *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Locality: ((ns6__Locality *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__District: ((ns6__District *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Region: ((ns6__Region *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__AddressObjectView: ((ns6__AddressObjectView *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__FederalDistrict: ((ns6__FederalDistrict *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Country: ((ns6__Country *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__UnitList: ((ns6__UnitList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__PurposeList: ((ns6__PurposeList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__PackingType: ((ns6__PackingType *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Unit: ((ns6__Unit *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns6__Purpose: ((ns6__Purpose *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse: ((ns5__GetAppliedUserAuthorityListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest: ((ns5__GetAppliedUserAuthorityListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse: ((ns5__UnbindBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest: ((ns5__UnbindBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse: ((ns5__UpdateUserWorkingAreasResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest: ((ns5__UpdateUserWorkingAreasRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse: ((ns5__UpdateUserAuthoritiesResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest: ((ns5__UpdateUserAuthoritiesRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserResponse: ((ns5__GetBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserRequest: ((ns5__GetBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserListResponse: ((ns5__GetBusinessEntityUserListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserListRequest: ((ns5__GetBusinessEntityUserListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__AddBusinessEntityUserResponse: ((ns5__AddBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__AddBusinessEntityUserRequest: ((ns5__AddBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse: ((ns5__CheckShipmentRegionalizationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest: ((ns5__CheckShipmentRegionalizationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse: ((ns5__UpdateVeterinaryEventsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest: ((ns5__UpdateVeterinaryEventsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse: ((ns5__UpdateTransportMovementDetailsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest: ((ns5__UpdateTransportMovementDetailsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryVersionListResponse: ((ns5__GetStockEntryVersionListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryVersionListRequest: ((ns5__GetStockEntryVersionListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryListResponse: ((ns5__GetStockEntryListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryListRequest: ((ns5__GetStockEntryListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryChangesListResponse: ((ns5__GetStockEntryChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryChangesListRequest: ((ns5__GetStockEntryChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryByUuidResponse: ((ns5__GetStockEntryByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryByUuidRequest: ((ns5__GetStockEntryByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryByGuidResponse: ((ns5__GetStockEntryByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetStockEntryByGuidRequest: ((ns5__GetStockEntryByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetVetDocumentChangesListResponse: ((ns5__GetVetDocumentChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetVetDocumentChangesListRequest: ((ns5__GetVetDocumentChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetVetDocumentListResponse: ((ns5__GetVetDocumentListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetVetDocumentListRequest: ((ns5__GetVetDocumentListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetVetDocumentByUuidResponse: ((ns5__GetVetDocumentByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__GetVetDocumentByUuidRequest: ((ns5__GetVetDocumentByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyProducerStockListResponse: ((ns5__ModifyProducerStockListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyProducerStockListRequest: ((ns5__ModifyProducerStockListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ResolveDiscrepancyResponse: ((ns5__ResolveDiscrepancyResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ResolveDiscrepancyRequest: ((ns5__ResolveDiscrepancyRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyActivityLocationsResponse: ((ns5__ModifyActivityLocationsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyActivityLocationsRequest: ((ns5__ModifyActivityLocationsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyEnterpriseResponse: ((ns5__ModifyEnterpriseResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyEnterpriseRequest: ((ns5__ModifyEnterpriseRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyBusinessEntityResponse: ((ns5__ModifyBusinessEntityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ModifyBusinessEntityRequest: ((ns5__ModifyBusinessEntityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__WithdrawVetDocumentResponse: ((ns5__WithdrawVetDocumentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__WithdrawVetDocumentRequest: ((ns5__WithdrawVetDocumentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__MergeStockEntriesResponse: ((ns5__MergeStockEntriesResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__MergeStockEntriesRequest: ((ns5__MergeStockEntriesRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__RegisterProductionOperationResponse: ((ns5__RegisterProductionOperationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__RegisterProductionOperationRequest: ((ns5__RegisterProductionOperationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse: ((ns5__PrepareOutgoingConsignmentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest: ((ns5__PrepareOutgoingConsignmentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse: ((ns5__ProcessIncomingConsignmentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest: ((ns5__ProcessIncomingConsignmentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns5__MercuryApplicationRequest: ((ns5__MercuryApplicationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__BusinessError: ((ns4__BusinessError *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__BusinessErrorList: ((ns4__BusinessErrorList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__ApplicationResultData: ((ns4__ApplicationResultData *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__ApplicationData: ((ns4__ApplicationData *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__ApplicationResultWrapper: ((ns4__ApplicationResultWrapper *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__ApplicationDataWrapper: ((ns4__ApplicationDataWrapper *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns4__Application: ((ns4__Application *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__Error: ((ns3__Error *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__FaultInfo: ((ns3__FaultInfo *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__EntityList: ((ns3__EntityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__DateInterval: ((ns3__DateInterval *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__ListOptions: ((ns3__ListOptions *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__GenericVersioningEntity: ((ns3__GenericVersioningEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ns3__GenericEntity: ((ns3__GenericEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns1__receiveApplicationResultResponse: ((_ns1__receiveApplicationResultResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns1__receiveApplicationResultRequest: ((_ns1__receiveApplicationResultRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns1__submitApplicationResponse: ((_ns1__submitApplicationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns1__submitApplicationRequest: ((_ns1__submitApplicationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_xsd__base64Binary: ((xsd__base64Binary *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE___ns9__GetActivityLocationList: soap_serialize___ns9__GetActivityLocationList(soap, (const struct __ns9__GetActivityLocationList *)ptr); break;
	case SOAP_TYPE___ns9__GetBusinessMemberByGLN: soap_serialize___ns9__GetBusinessMemberByGLN(soap, (const struct __ns9__GetBusinessMemberByGLN *)ptr); break;
	case SOAP_TYPE___ns9__GetRussianEnterpriseChangesList: soap_serialize___ns9__GetRussianEnterpriseChangesList(soap, (const struct __ns9__GetRussianEnterpriseChangesList *)ptr); break;
	case SOAP_TYPE___ns9__GetForeignEnterpriseChangesList: soap_serialize___ns9__GetForeignEnterpriseChangesList(soap, (const struct __ns9__GetForeignEnterpriseChangesList *)ptr); break;
	case SOAP_TYPE___ns9__GetRussianEnterpriseList: soap_serialize___ns9__GetRussianEnterpriseList(soap, (const struct __ns9__GetRussianEnterpriseList *)ptr); break;
	case SOAP_TYPE___ns9__GetForeignEnterpriseList: soap_serialize___ns9__GetForeignEnterpriseList(soap, (const struct __ns9__GetForeignEnterpriseList *)ptr); break;
	case SOAP_TYPE___ns9__GetEnterpriseByUuid: soap_serialize___ns9__GetEnterpriseByUuid(soap, (const struct __ns9__GetEnterpriseByUuid *)ptr); break;
	case SOAP_TYPE___ns9__GetEnterpriseByGuid: soap_serialize___ns9__GetEnterpriseByGuid(soap, (const struct __ns9__GetEnterpriseByGuid *)ptr); break;
	case SOAP_TYPE___ns9__GetBusinessEntityChangesList: soap_serialize___ns9__GetBusinessEntityChangesList(soap, (const struct __ns9__GetBusinessEntityChangesList *)ptr); break;
	case SOAP_TYPE___ns9__GetBusinessEntityList: soap_serialize___ns9__GetBusinessEntityList(soap, (const struct __ns9__GetBusinessEntityList *)ptr); break;
	case SOAP_TYPE___ns9__GetBusinessEntityByUuid: soap_serialize___ns9__GetBusinessEntityByUuid(soap, (const struct __ns9__GetBusinessEntityByUuid *)ptr); break;
	case SOAP_TYPE___ns9__GetBusinessEntityByGuid: soap_serialize___ns9__GetBusinessEntityByGuid(soap, (const struct __ns9__GetBusinessEntityByGuid *)ptr); break;
	case SOAP_TYPE___ns11__getAppliedUserAuthorityListRequest: soap_serialize___ns11__getAppliedUserAuthorityListRequest(soap, (const struct __ns11__getAppliedUserAuthorityListRequest *)ptr); break;
	case SOAP_TYPE___ns11__unbindBusinessEntityUserRequest: soap_serialize___ns11__unbindBusinessEntityUserRequest(soap, (const struct __ns11__unbindBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___ns11__updateUserWorkingAreasRequest: soap_serialize___ns11__updateUserWorkingAreasRequest(soap, (const struct __ns11__updateUserWorkingAreasRequest *)ptr); break;
	case SOAP_TYPE___ns11__updateUserAuthoritiesRequest: soap_serialize___ns11__updateUserAuthoritiesRequest(soap, (const struct __ns11__updateUserAuthoritiesRequest *)ptr); break;
	case SOAP_TYPE___ns11__getBusinessEntityUserRequest: soap_serialize___ns11__getBusinessEntityUserRequest(soap, (const struct __ns11__getBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___ns11__getBusinessEntityUserListRequest: soap_serialize___ns11__getBusinessEntityUserListRequest(soap, (const struct __ns11__getBusinessEntityUserListRequest *)ptr); break;
	case SOAP_TYPE___ns11__addBusinessEntityUserRequest: soap_serialize___ns11__addBusinessEntityUserRequest(soap, (const struct __ns11__addBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___ns11__checkShipmentRegionalizationRequest: soap_serialize___ns11__checkShipmentRegionalizationRequest(soap, (const struct __ns11__checkShipmentRegionalizationRequest *)ptr); break;
	case SOAP_TYPE___ns11__updateVeterinaryEventsRequest: soap_serialize___ns11__updateVeterinaryEventsRequest(soap, (const struct __ns11__updateVeterinaryEventsRequest *)ptr); break;
	case SOAP_TYPE___ns11__updateTransportMovementDetailsRequest: soap_serialize___ns11__updateTransportMovementDetailsRequest(soap, (const struct __ns11__updateTransportMovementDetailsRequest *)ptr); break;
	case SOAP_TYPE___ns11__getStockEntryVersionListRequest: soap_serialize___ns11__getStockEntryVersionListRequest(soap, (const struct __ns11__getStockEntryVersionListRequest *)ptr); break;
	case SOAP_TYPE___ns11__getStockEntryChangesListRequest: soap_serialize___ns11__getStockEntryChangesListRequest(soap, (const struct __ns11__getStockEntryChangesListRequest *)ptr); break;
	case SOAP_TYPE___ns11__getStockEntryListRequest: soap_serialize___ns11__getStockEntryListRequest(soap, (const struct __ns11__getStockEntryListRequest *)ptr); break;
	case SOAP_TYPE___ns11__getStockEntryByUuidRequest: soap_serialize___ns11__getStockEntryByUuidRequest(soap, (const struct __ns11__getStockEntryByUuidRequest *)ptr); break;
	case SOAP_TYPE___ns11__getStockEntryByGuidRequest: soap_serialize___ns11__getStockEntryByGuidRequest(soap, (const struct __ns11__getStockEntryByGuidRequest *)ptr); break;
	case SOAP_TYPE___ns11__getVetDocumentChangesListRequest: soap_serialize___ns11__getVetDocumentChangesListRequest(soap, (const struct __ns11__getVetDocumentChangesListRequest *)ptr); break;
	case SOAP_TYPE___ns11__getVetDocumentListRequest: soap_serialize___ns11__getVetDocumentListRequest(soap, (const struct __ns11__getVetDocumentListRequest *)ptr); break;
	case SOAP_TYPE___ns11__getVetDocumentByUuidRequest: soap_serialize___ns11__getVetDocumentByUuidRequest(soap, (const struct __ns11__getVetDocumentByUuidRequest *)ptr); break;
	case SOAP_TYPE___ns11__modifyProducerStockListRequest: soap_serialize___ns11__modifyProducerStockListRequest(soap, (const struct __ns11__modifyProducerStockListRequest *)ptr); break;
	case SOAP_TYPE___ns11__resolveDiscrepancyRequest: soap_serialize___ns11__resolveDiscrepancyRequest(soap, (const struct __ns11__resolveDiscrepancyRequest *)ptr); break;
	case SOAP_TYPE___ns11__modifyActivityLocationsRequest: soap_serialize___ns11__modifyActivityLocationsRequest(soap, (const struct __ns11__modifyActivityLocationsRequest *)ptr); break;
	case SOAP_TYPE___ns11__modifyEnterpriseRequest: soap_serialize___ns11__modifyEnterpriseRequest(soap, (const struct __ns11__modifyEnterpriseRequest *)ptr); break;
	case SOAP_TYPE___ns11__modifyBusinessEntityRequest: soap_serialize___ns11__modifyBusinessEntityRequest(soap, (const struct __ns11__modifyBusinessEntityRequest *)ptr); break;
	case SOAP_TYPE___ns11__withdrawVetDocumentRequest: soap_serialize___ns11__withdrawVetDocumentRequest(soap, (const struct __ns11__withdrawVetDocumentRequest *)ptr); break;
	case SOAP_TYPE___ns11__mergeStockEntriesRequest: soap_serialize___ns11__mergeStockEntriesRequest(soap, (const struct __ns11__mergeStockEntriesRequest *)ptr); break;
	case SOAP_TYPE___ns11__registerProductionOperationRequest: soap_serialize___ns11__registerProductionOperationRequest(soap, (const struct __ns11__registerProductionOperationRequest *)ptr); break;
	case SOAP_TYPE___ns11__prepareOutgoingConsignmentRequest: soap_serialize___ns11__prepareOutgoingConsignmentRequest(soap, (const struct __ns11__prepareOutgoingConsignmentRequest *)ptr); break;
	case SOAP_TYPE___ns11__processIncomingConsignmentRequest: soap_serialize___ns11__processIncomingConsignmentRequest(soap, (const struct __ns11__processIncomingConsignmentRequest *)ptr); break;
	case SOAP_TYPE___ns10__receiveApplicationResult: soap_serialize___ns10__receiveApplicationResult(soap, (const struct __ns10__receiveApplicationResult *)ptr); break;
	case SOAP_TYPE___ns10__submitApplicationRequest: soap_serialize___ns10__submitApplicationRequest(soap, (const struct __ns10__submitApplicationRequest *)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse: soap_serialize_PointerTo_ns8__getActivityLocationListResponse(soap, (_ns8__getActivityLocationListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest: soap_serialize_PointerTo_ns8__getActivityLocationListRequest(soap, (_ns8__getActivityLocationListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse: soap_serialize_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, (_ns8__getBusinessMemberByGLNResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest: soap_serialize_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, (_ns8__getBusinessMemberByGLNRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse: soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, (_ns8__getRussianEnterpriseChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest: soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, (_ns8__getRussianEnterpriseChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse: soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, (_ns8__getForeignEnterpriseChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest: soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, (_ns8__getForeignEnterpriseChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse: soap_serialize_PointerTo_ns8__getRussianEnterpriseListResponse(soap, (_ns8__getRussianEnterpriseListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest: soap_serialize_PointerTo_ns8__getRussianEnterpriseListRequest(soap, (_ns8__getRussianEnterpriseListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse: soap_serialize_PointerTo_ns8__getForeignEnterpriseListResponse(soap, (_ns8__getForeignEnterpriseListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest: soap_serialize_PointerTo_ns8__getForeignEnterpriseListRequest(soap, (_ns8__getForeignEnterpriseListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse: soap_serialize_PointerTo_ns8__getEnterpriseByUuidResponse(soap, (_ns8__getEnterpriseByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest: soap_serialize_PointerTo_ns8__getEnterpriseByUuidRequest(soap, (_ns8__getEnterpriseByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse: soap_serialize_PointerTo_ns8__getEnterpriseByGuidResponse(soap, (_ns8__getEnterpriseByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest: soap_serialize_PointerTo_ns8__getEnterpriseByGuidRequest(soap, (_ns8__getEnterpriseByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse: soap_serialize_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, (_ns8__getBusinessEntityChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest: soap_serialize_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, (_ns8__getBusinessEntityChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse: soap_serialize_PointerTo_ns8__getBusinessEntityListResponse(soap, (_ns8__getBusinessEntityListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest: soap_serialize_PointerTo_ns8__getBusinessEntityListRequest(soap, (_ns8__getBusinessEntityListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse: soap_serialize_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, (_ns8__getBusinessEntityByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest: soap_serialize_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, (_ns8__getBusinessEntityByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse: soap_serialize_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, (_ns8__getBusinessEntityByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest: soap_serialize_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, (_ns8__getBusinessEntityByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListResponse: soap_serialize_PointerTons5__GetAppliedUserAuthorityListResponse(soap, (ns5__GetAppliedUserAuthorityListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListRequest: soap_serialize_PointerTons5__GetAppliedUserAuthorityListRequest(soap, (ns5__GetAppliedUserAuthorityListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserResponse: soap_serialize_PointerTons5__UnbindBusinessEntityUserResponse(soap, (ns5__UnbindBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserRequest: soap_serialize_PointerTons5__UnbindBusinessEntityUserRequest(soap, (ns5__UnbindBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasResponse: soap_serialize_PointerTons5__UpdateUserWorkingAreasResponse(soap, (ns5__UpdateUserWorkingAreasResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasRequest: soap_serialize_PointerTons5__UpdateUserWorkingAreasRequest(soap, (ns5__UpdateUserWorkingAreasRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesResponse: soap_serialize_PointerTons5__UpdateUserAuthoritiesResponse(soap, (ns5__UpdateUserAuthoritiesResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesRequest: soap_serialize_PointerTons5__UpdateUserAuthoritiesRequest(soap, (ns5__UpdateUserAuthoritiesRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserResponse: soap_serialize_PointerTons5__GetBusinessEntityUserResponse(soap, (ns5__GetBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserRequest: soap_serialize_PointerTons5__GetBusinessEntityUserRequest(soap, (ns5__GetBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserListResponse: soap_serialize_PointerTons5__GetBusinessEntityUserListResponse(soap, (ns5__GetBusinessEntityUserListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetBusinessEntityUserListRequest: soap_serialize_PointerTons5__GetBusinessEntityUserListRequest(soap, (ns5__GetBusinessEntityUserListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__AddBusinessEntityUserResponse: soap_serialize_PointerTons5__AddBusinessEntityUserResponse(soap, (ns5__AddBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__AddBusinessEntityUserRequest: soap_serialize_PointerTons5__AddBusinessEntityUserRequest(soap, (ns5__AddBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationResponse: soap_serialize_PointerTons5__CheckShipmentRegionalizationResponse(soap, (ns5__CheckShipmentRegionalizationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationRequest: soap_serialize_PointerTons5__CheckShipmentRegionalizationRequest(soap, (ns5__CheckShipmentRegionalizationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsResponse: soap_serialize_PointerTons5__UpdateVeterinaryEventsResponse(soap, (ns5__UpdateVeterinaryEventsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsRequest: soap_serialize_PointerTons5__UpdateVeterinaryEventsRequest(soap, (ns5__UpdateVeterinaryEventsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsResponse: soap_serialize_PointerTons5__UpdateTransportMovementDetailsResponse(soap, (ns5__UpdateTransportMovementDetailsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsRequest: soap_serialize_PointerTons5__UpdateTransportMovementDetailsRequest(soap, (ns5__UpdateTransportMovementDetailsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryVersionListResponse: soap_serialize_PointerTons5__GetStockEntryVersionListResponse(soap, (ns5__GetStockEntryVersionListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryVersionListRequest: soap_serialize_PointerTons5__GetStockEntryVersionListRequest(soap, (ns5__GetStockEntryVersionListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryChangesListResponse: soap_serialize_PointerTons5__GetStockEntryChangesListResponse(soap, (ns5__GetStockEntryChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryChangesListRequest: soap_serialize_PointerTons5__GetStockEntryChangesListRequest(soap, (ns5__GetStockEntryChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryListResponse: soap_serialize_PointerTons5__GetStockEntryListResponse(soap, (ns5__GetStockEntryListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryListRequest: soap_serialize_PointerTons5__GetStockEntryListRequest(soap, (ns5__GetStockEntryListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryByUuidResponse: soap_serialize_PointerTons5__GetStockEntryByUuidResponse(soap, (ns5__GetStockEntryByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryByUuidRequest: soap_serialize_PointerTons5__GetStockEntryByUuidRequest(soap, (ns5__GetStockEntryByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryByGuidResponse: soap_serialize_PointerTons5__GetStockEntryByGuidResponse(soap, (ns5__GetStockEntryByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetStockEntryByGuidRequest: soap_serialize_PointerTons5__GetStockEntryByGuidRequest(soap, (ns5__GetStockEntryByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetVetDocumentChangesListResponse: soap_serialize_PointerTons5__GetVetDocumentChangesListResponse(soap, (ns5__GetVetDocumentChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetVetDocumentChangesListRequest: soap_serialize_PointerTons5__GetVetDocumentChangesListRequest(soap, (ns5__GetVetDocumentChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetVetDocumentListResponse: soap_serialize_PointerTons5__GetVetDocumentListResponse(soap, (ns5__GetVetDocumentListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetVetDocumentListRequest: soap_serialize_PointerTons5__GetVetDocumentListRequest(soap, (ns5__GetVetDocumentListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetVetDocumentByUuidResponse: soap_serialize_PointerTons5__GetVetDocumentByUuidResponse(soap, (ns5__GetVetDocumentByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__GetVetDocumentByUuidRequest: soap_serialize_PointerTons5__GetVetDocumentByUuidRequest(soap, (ns5__GetVetDocumentByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyProducerStockListResponse: soap_serialize_PointerTons5__ModifyProducerStockListResponse(soap, (ns5__ModifyProducerStockListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyProducerStockListRequest: soap_serialize_PointerTons5__ModifyProducerStockListRequest(soap, (ns5__ModifyProducerStockListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ResolveDiscrepancyResponse: soap_serialize_PointerTons5__ResolveDiscrepancyResponse(soap, (ns5__ResolveDiscrepancyResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ResolveDiscrepancyRequest: soap_serialize_PointerTons5__ResolveDiscrepancyRequest(soap, (ns5__ResolveDiscrepancyRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyActivityLocationsResponse: soap_serialize_PointerTons5__ModifyActivityLocationsResponse(soap, (ns5__ModifyActivityLocationsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyActivityLocationsRequest: soap_serialize_PointerTons5__ModifyActivityLocationsRequest(soap, (ns5__ModifyActivityLocationsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyEnterpriseResponse: soap_serialize_PointerTons5__ModifyEnterpriseResponse(soap, (ns5__ModifyEnterpriseResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyEnterpriseRequest: soap_serialize_PointerTons5__ModifyEnterpriseRequest(soap, (ns5__ModifyEnterpriseRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyBusinessEntityResponse: soap_serialize_PointerTons5__ModifyBusinessEntityResponse(soap, (ns5__ModifyBusinessEntityResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ModifyBusinessEntityRequest: soap_serialize_PointerTons5__ModifyBusinessEntityRequest(soap, (ns5__ModifyBusinessEntityRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__WithdrawVetDocumentResponse: soap_serialize_PointerTons5__WithdrawVetDocumentResponse(soap, (ns5__WithdrawVetDocumentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__WithdrawVetDocumentRequest: soap_serialize_PointerTons5__WithdrawVetDocumentRequest(soap, (ns5__WithdrawVetDocumentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__MergeStockEntriesResponse: soap_serialize_PointerTons5__MergeStockEntriesResponse(soap, (ns5__MergeStockEntriesResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__MergeStockEntriesRequest: soap_serialize_PointerTons5__MergeStockEntriesRequest(soap, (ns5__MergeStockEntriesRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__RegisterProductionOperationResponse: soap_serialize_PointerTons5__RegisterProductionOperationResponse(soap, (ns5__RegisterProductionOperationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__RegisterProductionOperationRequest: soap_serialize_PointerTons5__RegisterProductionOperationRequest(soap, (ns5__RegisterProductionOperationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentResponse: soap_serialize_PointerTons5__PrepareOutgoingConsignmentResponse(soap, (ns5__PrepareOutgoingConsignmentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentRequest: soap_serialize_PointerTons5__PrepareOutgoingConsignmentRequest(soap, (ns5__PrepareOutgoingConsignmentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentResponse: soap_serialize_PointerTons5__ProcessIncomingConsignmentResponse(soap, (ns5__ProcessIncomingConsignmentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentRequest: soap_serialize_PointerTons5__ProcessIncomingConsignmentRequest(soap, (ns5__ProcessIncomingConsignmentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns1__receiveApplicationResultResponse: soap_serialize_PointerTo_ns1__receiveApplicationResultResponse(soap, (_ns1__receiveApplicationResultResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns1__receiveApplicationResultRequest: soap_serialize_PointerTo_ns1__receiveApplicationResultRequest(soap, (_ns1__receiveApplicationResultRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns1__submitApplicationResponse: soap_serialize_PointerTo_ns1__submitApplicationResponse(soap, (_ns1__submitApplicationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns1__submitApplicationRequest: soap_serialize_PointerTo_ns1__submitApplicationRequest(soap, (_ns1__submitApplicationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__FaultInfo: soap_serialize_PointerTons3__FaultInfo(soap, (ns3__FaultInfo *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__StockEntryBlankFilter: soap_serialize_PointerTons7__StockEntryBlankFilter(soap, (enum ns7__StockEntryBlankFilter *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__StockEntryEventList: soap_serialize_PointerTons7__StockEntryEventList(soap, (ns7__StockEntryEventList *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__DiscrepancyReason: soap_serialize_PointerTons7__DiscrepancyReason(soap, (ns7__DiscrepancyReason *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__VetDocumentStatusChange: soap_serialize_PointerToPointerTons7__VetDocumentStatusChange(soap, (ns7__VetDocumentStatusChange **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VetDocumentStatusChange: soap_serialize_PointerTons7__VetDocumentStatusChange(soap, (ns7__VetDocumentStatusChange *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VeterinaryAuthentication: soap_serialize_PointerTons7__VeterinaryAuthentication(soap, (ns7__VeterinaryAuthentication *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__CertifiedConsignment: soap_serialize_PointerTons7__CertifiedConsignment(soap, (ns7__CertifiedConsignment *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__CertifiedBatch: soap_serialize_PointerTons7__CertifiedBatch(soap, (ns7__CertifiedBatch *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VetDocumentForm: soap_serialize_PointerTons7__VetDocumentForm(soap, (enum ns7__VetDocumentForm *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationStatus: soap_serialize_PointerToPointerTons6__RegionalizationStatus(soap, (ns6__RegionalizationStatus **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Area: soap_serialize_PointerToPointerTons6__Area(soap, (ns6__Area **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationRequirement: soap_serialize_PointerToPointerTons6__RegionalizationRequirement(soap, (ns6__RegionalizationRequirement **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationRequirement: soap_serialize_PointerTons6__RegionalizationRequirement(soap, (ns6__RegionalizationRequirement *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationDecision: soap_serialize_PointerTons6__RegionalizationDecision(soap, (enum ns6__RegionalizationDecision *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationStatus: soap_serialize_PointerTons6__RegionalizationStatus(soap, (ns6__RegionalizationStatus *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Packaging: soap_serialize_PointerTons6__Packaging(soap, (ns6__Packaging *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__ProductItemProducing: soap_serialize_PointerToPointerTons6__ProductItemProducing(soap, (ns6__ProductItemProducing **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ProductItemProducing: soap_serialize_PointerTons6__ProductItemProducing(soap, (ns6__ProductItemProducing *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns6__BusinessEntity_activityLocation: soap_serialize_PointerTo_ns6__BusinessEntity_activityLocation(soap, (_ns6__BusinessEntity_activityLocation *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__IncorporationForm: soap_serialize_PointerTons6__IncorporationForm(soap, (ns6__IncorporationForm *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__BusinessEntityType: soap_serialize_PointerTons6__BusinessEntityType(soap, (enum ns6__BusinessEntityType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__EnterpriseOfficialRegistration: soap_serialize_PointerToPointerTons6__EnterpriseOfficialRegistration(soap, (ns6__EnterpriseOfficialRegistration **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration: soap_serialize_PointerTons6__EnterpriseOfficialRegistration(soap, (ns6__EnterpriseOfficialRegistration *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseActivityList: soap_serialize_PointerTons6__EnterpriseActivityList(soap, (ns6__EnterpriseActivityList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseNumberList: soap_serialize_PointerTons6__EnterpriseNumberList(soap, (ns6__EnterpriseNumberList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseType: soap_serialize_PointerTons6__EnterpriseType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__PackingCodeType: soap_serialize_PointerTons6__PackingCodeType(soap, (enum ns6__PackingCodeType *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__UUID: soap_serialize_PointerTons3__UUID(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__StockEntrySearchPattern: soap_serialize_PointerTons7__StockEntrySearchPattern(soap, (ns7__StockEntrySearchPattern *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VetDocumentStatus: soap_serialize_PointerTons7__VetDocumentStatus(soap, (enum ns7__VetDocumentStatus *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VetDocumentType: soap_serialize_PointerTons7__VetDocumentType(soap, (enum ns7__VetDocumentType *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__PSLModificationOperation: soap_serialize_PointerTons7__PSLModificationOperation(soap, (ns7__PSLModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__StockDiscrepancy: soap_serialize_PointerToPointerTons7__StockDiscrepancy(soap, (ns7__StockDiscrepancy **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__StockDiscrepancy: soap_serialize_PointerTons7__StockDiscrepancy(soap, (ns7__StockDiscrepancy *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__BEActivityLocationsModificationOperation: soap_serialize_PointerTons7__BEActivityLocationsModificationOperation(soap, (ns7__BEActivityLocationsModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ENTModificationOperation: soap_serialize_PointerTons7__ENTModificationOperation(soap, (ns7__ENTModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__BEModificationOperation: soap_serialize_PointerTons7__BEModificationOperation(soap, (ns7__BEModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__MergeStockEntriesOperation: soap_serialize_PointerTons7__MergeStockEntriesOperation(soap, (ns7__MergeStockEntriesOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ProductionOperation: soap_serialize_PointerTons7__ProductionOperation(soap, (ns7__ProductionOperation *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__Delivery: soap_serialize_PointerToPointerTons7__Delivery(soap, (ns7__Delivery **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__DiscrepancyReport: soap_serialize_PointerToPointerTons7__DiscrepancyReport(soap, (ns7__DiscrepancyReport **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__DiscrepancyReport: soap_serialize_PointerTons7__DiscrepancyReport(soap, (ns7__DiscrepancyReport *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__DeliveryFactList: soap_serialize_PointerTons7__DeliveryFactList(soap, (ns7__DeliveryFactList *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__Delivery: soap_serialize_PointerTons7__Delivery(soap, (ns7__Delivery *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__WorkingArea: soap_serialize_PointerToPointerTons7__WorkingArea(soap, (ns7__WorkingArea **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__WorkingArea: soap_serialize_PointerTons7__WorkingArea(soap, (ns7__WorkingArea *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__WorkingAreaList: soap_serialize_PointerTons7__WorkingAreaList(soap, (ns7__WorkingAreaList *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__SNILSType: soap_serialize_PointerTons7__SNILSType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__MedicinalDrug: soap_serialize_PointerTons6__MedicinalDrug(soap, (ns6__MedicinalDrug *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Indicator: soap_serialize_PointerTons6__Indicator(soap, (ns6__Indicator *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__DocumentType: soap_serialize_PointerTons6__DocumentType(soap, (enum ns6__DocumentType *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ConsignmentDocumentList: soap_serialize_PointerTons7__ConsignmentDocumentList(soap, (ns7__ConsignmentDocumentList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__Consignment: soap_serialize_PointerToPointerTons7__Consignment(soap, (ns7__Consignment **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__Consignment: soap_serialize_PointerTons7__Consignment(soap, (ns7__Consignment *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__BusinessMember: soap_serialize_PointerToPointerTons6__BusinessMember(soap, (ns6__BusinessMember **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__ResearchMethod: soap_serialize_PointerToPointerTons6__ResearchMethod(soap, (ns6__ResearchMethod **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__AnimalDisease: soap_serialize_PointerToPointerTons6__AnimalDisease(soap, (ns6__AnimalDisease **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationRegionStatus: soap_serialize_PointerToPointerTons6__RegionalizationRegionStatus(soap, (ns6__RegionalizationRegionStatus **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationRegionStatus: soap_serialize_PointerTons6__RegionalizationRegionStatus(soap, (ns6__RegionalizationRegionStatus *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__ProductItem: soap_serialize_PointerToPointerTons6__ProductItem(soap, (ns6__ProductItem **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__SubProduct: soap_serialize_PointerToPointerTons6__SubProduct(soap, (ns6__SubProduct **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Product: soap_serialize_PointerToPointerTons6__Product(soap, (ns6__Product **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__EnterpriseActivity: soap_serialize_PointerToPointerTons6__EnterpriseActivity(soap, (ns6__EnterpriseActivity **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseActivity: soap_serialize_PointerTons6__EnterpriseActivity(soap, (ns6__EnterpriseActivity *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Street: soap_serialize_PointerToPointerTons6__Street(soap, (ns6__Street **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Locality: soap_serialize_PointerToPointerTons6__Locality(soap, (ns6__Locality **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__District: soap_serialize_PointerToPointerTons6__District(soap, (ns6__District **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Region: soap_serialize_PointerToPointerTons6__Region(soap, (ns6__Region **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Country: soap_serialize_PointerToPointerTons6__Country(soap, (ns6__Country **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Unit: soap_serialize_PointerToPointerTons6__Unit(soap, (ns6__Unit **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Purpose: soap_serialize_PointerToPointerTons6__Purpose(soap, (ns6__Purpose **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__AuthorityList: soap_serialize_PointerTons7__AuthorityList(soap, (ns7__AuthorityList *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__UserList: soap_serialize_PointerTons7__UserList(soap, (ns7__UserList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__User: soap_serialize_PointerToPointerTons7__User(soap, (ns7__User **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__RouteSectionR13nRules: soap_serialize_PointerToPointerTons7__RouteSectionR13nRules(soap, (ns7__RouteSectionR13nRules **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__RouteSectionR13nRules: soap_serialize_PointerTons7__RouteSectionR13nRules(soap, (ns7__RouteSectionR13nRules *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VetDocumentList: soap_serialize_PointerTons7__VetDocumentList(soap, (ns7__VetDocumentList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Enterprise: soap_serialize_PointerToPointerTons6__Enterprise(soap, (ns6__Enterprise **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__BusinessEntity: soap_serialize_PointerToPointerTons6__BusinessEntity(soap, (ns6__BusinessEntity **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__OTPToken: soap_serialize_PointerTons6__OTPToken(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons3__VersionStatus: soap_serialize_PointerTons3__VersionStatus(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ResearchMethodList: soap_serialize_PointerTons6__ResearchMethodList(soap, (ns6__ResearchMethodList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ResearchMethod: soap_serialize_PointerTons6__ResearchMethod(soap, (ns6__ResearchMethod *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__AnimalDiseaseList: soap_serialize_PointerTons6__AnimalDiseaseList(soap, (ns6__AnimalDiseaseList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationShippingRuleList: soap_serialize_PointerTons6__RegionalizationShippingRuleList(soap, (ns6__RegionalizationShippingRuleList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationRegionStatusList: soap_serialize_PointerTons6__RegionalizationRegionStatusList(soap, (ns6__RegionalizationRegionStatusList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationConditionList: soap_serialize_PointerTons6__RegionalizationConditionList(soap, (ns6__RegionalizationConditionList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ActivityLocationList: soap_serialize_PointerTons6__ActivityLocationList(soap, (ns6__ActivityLocationList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseGroup: soap_serialize_PointerTons6__EnterpriseGroup(soap, (enum ns6__EnterpriseGroup *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__StreetList: soap_serialize_PointerTons6__StreetList(soap, (ns6__StreetList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__LocalityList: soap_serialize_PointerTons6__LocalityList(soap, (ns6__LocalityList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__DistrictList: soap_serialize_PointerTons6__DistrictList(soap, (ns6__DistrictList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionList: soap_serialize_PointerTons6__RegionList(soap, (ns6__RegionList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__CountryList: soap_serialize_PointerTons6__CountryList(soap, (ns6__CountryList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__SubProductList: soap_serialize_PointerTons6__SubProductList(soap, (ns6__SubProductList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ProductList: soap_serialize_PointerTons6__ProductList(soap, (ns6__ProductList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__UnitList: soap_serialize_PointerTons6__UnitList(soap, (ns6__UnitList *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__DateInterval: soap_serialize_PointerTons3__DateInterval(soap, (ns3__DateInterval *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__PurposeList: soap_serialize_PointerTons6__PurposeList(soap, (ns6__PurposeList *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__ListOptions: soap_serialize_PointerTons3__ListOptions(soap, (ns3__ListOptions *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Area: soap_serialize_PointerTons6__Area(soap, (ns6__Area *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__UserAuthority: soap_serialize_PointerToPointerTons7__UserAuthority(soap, (ns7__UserAuthority **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__UserAuthority: soap_serialize_PointerTons7__UserAuthority(soap, (ns7__UserAuthority *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationShippingRule: soap_serialize_PointerToPointerTons6__RegionalizationShippingRule(soap, (ns6__RegionalizationShippingRule **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationShippingRule: soap_serialize_PointerTons6__RegionalizationShippingRule(soap, (ns6__RegionalizationShippingRule *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__SequenceNumber: soap_serialize_PointerTons3__SequenceNumber(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__QuarantineEvent: soap_serialize_PointerToPointerTons7__QuarantineEvent(soap, (ns7__QuarantineEvent **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__RegionalizationClause: soap_serialize_PointerToPointerTons7__RegionalizationClause(soap, (ns7__RegionalizationClause **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__RegionalizationClause: soap_serialize_PointerTons7__RegionalizationClause(soap, (ns7__RegionalizationClause *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__VeterinaryEvent: soap_serialize_PointerToPointerTons7__VeterinaryEvent(soap, (ns7__VeterinaryEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VeterinaryEvent: soap_serialize_PointerTons7__VeterinaryEvent(soap, (ns7__VeterinaryEvent *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__AnimalMedicationEvent: soap_serialize_PointerToPointerTons7__AnimalMedicationEvent(soap, (ns7__AnimalMedicationEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__AnimalMedicationEvent: soap_serialize_PointerTons7__AnimalMedicationEvent(soap, (ns7__AnimalMedicationEvent *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__QuarantineEvent: soap_serialize_PointerTons7__QuarantineEvent(soap, (ns7__QuarantineEvent *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__LaboratoryResearchEvent: soap_serialize_PointerToPointerTons7__LaboratoryResearchEvent(soap, (ns7__LaboratoryResearchEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__LaboratoryResearchEvent: soap_serialize_PointerTons7__LaboratoryResearchEvent(soap, (ns7__LaboratoryResearchEvent *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__AnimalSpentPeriod: soap_serialize_PointerTons7__AnimalSpentPeriod(soap, (enum ns7__AnimalSpentPeriod *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ResearchResult: soap_serialize_PointerTons6__ResearchResult(soap, (enum ns6__ResearchResult *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Purpose: soap_serialize_PointerTons6__Purpose(soap, (ns6__Purpose *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__Document: soap_serialize_PointerToPointerTons7__Document(soap, (ns7__Document **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__Document: soap_serialize_PointerTons7__Document(soap, (ns7__Document *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Organization: soap_serialize_PointerTons6__Organization(soap, (ns6__Organization *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Location: soap_serialize_PointerTons6__Location(soap, (ns6__Location *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VeterinaryEventType: soap_serialize_PointerTons7__VeterinaryEventType(soap, (enum ns7__VeterinaryEventType *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ShipmentRoute: soap_serialize_PointerTons7__ShipmentRoute(soap, (ns7__ShipmentRoute *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__TransportationStorageType: soap_serialize_PointerTons6__TransportationStorageType(soap, (enum ns6__TransportationStorageType *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__TransportInfo: soap_serialize_PointerTons7__TransportInfo(soap, (ns7__TransportInfo *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__Batch: soap_serialize_PointerTons7__Batch(soap, (ns7__Batch *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseList: soap_serialize_PointerTons6__EnterpriseList(soap, (ns6__EnterpriseList *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation: soap_serialize_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(soap, (_ns7__BEActivityLocationsModificationOperation_activityLocation *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__GLNType: soap_serialize_PointerTons6__GLNType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__BusinessEntityList: soap_serialize_PointerTons6__BusinessEntityList(soap, (ns6__BusinessEntityList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ProductItemList: soap_serialize_PointerTons6__ProductItemList(soap, (ns6__ProductItemList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__StockEntry: soap_serialize_PointerToPointerTons7__StockEntry(soap, (ns7__StockEntry **const*)ptr); break;
	case SOAP_TYPE_PointerTons3__RegisterModificationType: soap_serialize_PointerTons3__RegisterModificationType(soap, (enum ns3__RegisterModificationType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__ProcessingProcedure: soap_serialize_PointerToPointerTons7__ProcessingProcedure(soap, (ns7__ProcessingProcedure **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ProcessingProcedure: soap_serialize_PointerTons7__ProcessingProcedure(soap, (ns7__ProcessingProcedure *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__ProductiveBatch: soap_serialize_PointerToPointerTons7__ProductiveBatch(soap, (ns7__ProductiveBatch **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ProductiveBatch: soap_serialize_PointerTons7__ProductiveBatch(soap, (ns7__ProductiveBatch *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__RawBatch: soap_serialize_PointerToPointerTons7__RawBatch(soap, (ns7__RawBatch **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__RawBatch: soap_serialize_PointerTons7__RawBatch(soap, (ns7__RawBatch *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__ShipmentRoutePoint: soap_serialize_PointerToPointerTons7__ShipmentRoutePoint(soap, (ns7__ShipmentRoutePoint **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ShipmentRoutePoint: soap_serialize_PointerTons7__ShipmentRoutePoint(soap, (ns7__ShipmentRoutePoint *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__TransportNumber: soap_serialize_PointerTons7__TransportNumber(soap, (ns7__TransportNumber *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__TransportType: soap_serialize_PointerTons6__TransportType(soap, (enum ns6__TransportType *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__StockEntryList: soap_serialize_PointerTons7__StockEntryList(soap, (ns7__StockEntryList *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ComplexDate: soap_serialize_PointerTons6__ComplexDate(soap, (ns6__ComplexDate *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__ReferencedDocument: soap_serialize_PointerToPointerTons7__ReferencedDocument(soap, (ns7__ReferencedDocument **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__ReferencedDocument: soap_serialize_PointerTons7__ReferencedDocument(soap, (ns7__ReferencedDocument *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons7__VetDocument: soap_serialize_PointerToPointerTons7__VetDocument(soap, (ns7__VetDocument **const*)ptr); break;
	case SOAP_TYPE_PointerTons7__VetDocument: soap_serialize_PointerTons7__VetDocument(soap, (ns7__VetDocument *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__Waybill: soap_serialize_PointerTons7__Waybill(soap, (ns7__Waybill *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__User: soap_serialize_PointerTons7__User(soap, (ns7__User *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__DeliveryInspection: soap_serialize_PointerTons7__DeliveryInspection(soap, (ns7__DeliveryInspection *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__StockEntry: soap_serialize_PointerTons7__StockEntry(soap, (ns7__StockEntry *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__PackageList: soap_serialize_PointerTons6__PackageList(soap, (ns6__PackageList *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__BatchOrigin: soap_serialize_PointerTons7__BatchOrigin(soap, (ns7__BatchOrigin *const*)ptr); break;
	case SOAP_TYPE_PointerTons7__GoodsDate: soap_serialize_PointerTons7__GoodsDate(soap, (ns7__GoodsDate *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ProductItem: soap_serialize_PointerTons6__ProductItem(soap, (ns6__ProductItem *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__SubProduct: soap_serialize_PointerTons6__SubProduct(soap, (ns6__SubProduct *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Product: soap_serialize_PointerTons6__Product(soap, (ns6__Product *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ProductType: soap_serialize_PointerTons6__ProductType(soap, (enum ns6__ProductType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationConditionGroup: soap_serialize_PointerToPointerTons6__RegionalizationConditionGroup(soap, (ns6__RegionalizationConditionGroup **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationConditionGroup: soap_serialize_PointerTons6__RegionalizationConditionGroup(soap, (ns6__RegionalizationConditionGroup *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__AnimalDisease: soap_serialize_PointerTons6__AnimalDisease(soap, (ns6__AnimalDisease *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__RegionalizationCondition: soap_serialize_PointerToPointerTons6__RegionalizationCondition(soap, (ns6__RegionalizationCondition **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__RegionalizationCondition: soap_serialize_PointerTons6__RegionalizationCondition(soap, (ns6__RegionalizationCondition *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__BusinessMember: soap_serialize_PointerTons6__BusinessMember(soap, (ns6__BusinessMember *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__Identifier: soap_serialize_PointerTons3__Identifier(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Address: soap_serialize_PointerTons6__Address(soap, (ns6__Address *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Unit: soap_serialize_PointerTons6__Unit(soap, (ns6__Unit *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__Decimal: soap_serialize_PointerTons3__Decimal(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Minute: soap_serialize_PointerTons6__Minute(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Hour: soap_serialize_PointerTons6__Hour(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Day: soap_serialize_PointerTons6__Day(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Month: soap_serialize_PointerTons6__Month(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Year: soap_serialize_PointerTons6__Year(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Package: soap_serialize_PointerToPointerTons6__Package(soap, (ns6__Package **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Package: soap_serialize_PointerTons6__Package(soap, (ns6__Package *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__ProductMarks: soap_serialize_PointerToPointerTons6__ProductMarks(soap, (ns6__ProductMarks **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__ProductMarks: soap_serialize_PointerTons6__ProductMarks(soap, (ns6__ProductMarks *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__PackingType: soap_serialize_PointerTons6__PackingType(soap, (ns6__PackingType *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__BusinessEntity: soap_serialize_PointerTons6__BusinessEntity(soap, (ns6__BusinessEntity *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__String255: soap_serialize_PointerTons3__String255(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons6__Producer: soap_serialize_PointerToPointerTons6__Producer(soap, (ns6__Producer **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Producer: soap_serialize_PointerTons6__Producer(soap, (ns6__Producer *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__EnterpriseRole: soap_serialize_PointerTons6__EnterpriseRole(soap, (enum ns6__EnterpriseRole *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Enterprise: soap_serialize_PointerTons6__Enterprise(soap, (ns6__Enterprise *const*)ptr); break;
	case SOAP_TYPE_PointerTons3__NText: soap_serialize_PointerTons3__NText(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Street: soap_serialize_PointerTons6__Street(soap, (ns6__Street *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Locality: soap_serialize_PointerTons6__Locality(soap, (ns6__Locality *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__District: soap_serialize_PointerTons6__District(soap, (ns6__District *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Region: soap_serialize_PointerTons6__Region(soap, (ns6__Region *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__FederalDistrict: soap_serialize_PointerTons6__FederalDistrict(soap, (ns6__FederalDistrict *const*)ptr); break;
	case SOAP_TYPE_PointerTons6__Country: soap_serialize_PointerTons6__Country(soap, (ns6__Country *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons4__BusinessError: soap_serialize_PointerToPointerTons4__BusinessError(soap, (ns4__BusinessError **const*)ptr); break;
	case SOAP_TYPE_PointerTons4__BusinessError: soap_serialize_PointerTons4__BusinessError(soap, (ns4__BusinessError *const*)ptr); break;
	case SOAP_TYPE_PointerTons4__ContentEncoding: soap_serialize_PointerTons4__ContentEncoding(soap, (enum ns4__ContentEncoding *const*)ptr); break;
	case SOAP_TYPE_PointerTons4__BusinessErrorList: soap_serialize_PointerTons4__BusinessErrorList(soap, (ns4__BusinessErrorList *const*)ptr); break;
	case SOAP_TYPE_PointerTons4__ApplicationResultWrapper: soap_serialize_PointerTons4__ApplicationResultWrapper(soap, (ns4__ApplicationResultWrapper *const*)ptr); break;
	case SOAP_TYPE_PointerTons4__ApplicationDataWrapper: soap_serialize_PointerTons4__ApplicationDataWrapper(soap, (ns4__ApplicationDataWrapper *const*)ptr); break;
	case SOAP_TYPE_PointerTons4__ApplicationStatus: soap_serialize_PointerTons4__ApplicationStatus(soap, (enum ns4__ApplicationStatus *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTons3__Error: soap_serialize_PointerToPointerTons3__Error(soap, (ns3__Error **const*)ptr); break;
	case SOAP_TYPE_PointerTons3__Error: soap_serialize_PointerTons3__Error(soap, (ns3__Error *const*)ptr); break;
	case SOAP_TYPE_PointerTobool: soap_serialize_PointerTobool(soap, (bool *const*)ptr); break;
	case SOAP_TYPE_PointerToLONG64: soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr); break;
	case SOAP_TYPE_PointerToint: soap_serialize_PointerToint(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTotime: soap_serialize_PointerTotime(soap, (time_t *const*)ptr); break;
	case SOAP_TYPE_PointerTons4__Application: soap_serialize_PointerTons4__Application(soap, (ns4__Application *const*)ptr); break;
	case SOAP_TYPE_ns7__VetDocumentStatusChangeReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__GRNType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns7__SNILSType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns7__StockEntryNumber: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__OTPToken: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__GTINType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__GLNType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__ENTModificationReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__BEModificationReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__EnterpriseType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__Code3: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns6__Code: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns4__APIKey: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__SequenceNumber: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__Identifier: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__VersionStatus: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__Decimal: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__String32: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__String255: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__NText: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__Text: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ns3__UUID: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__token: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__positiveInteger: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__nonNegativeInteger: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__integer: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__decimal: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__date: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_PointerTounsignedByte: soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr); break;
	case SOAP_TYPE_xsd__Name: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__NCName: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__IDREF: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__ID: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE__QName: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_string: soap_serialize_string(soap, (char*const*)&ptr); break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 vetisams_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	(void)type;
	switch(t) {
	case SOAP_TYPE_xsd__base64Binary: return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__submitApplicationRequest: return (void*)soap_instantiate__ns1__submitApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__submitApplicationResponse: return (void*)soap_instantiate__ns1__submitApplicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__receiveApplicationResultRequest: return (void*)soap_instantiate__ns1__receiveApplicationResultRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__receiveApplicationResultResponse: return (void*)soap_instantiate__ns1__receiveApplicationResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__GenericEntity: return (void*)soap_instantiate_ns3__GenericEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ListOptions: return (void*)soap_instantiate_ns3__ListOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__DateInterval: return (void*)soap_instantiate_ns3__DateInterval(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__EntityList: return (void*)soap_instantiate_ns3__EntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__FaultInfo: return (void*)soap_instantiate_ns3__FaultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__Application: return (void*)soap_instantiate_ns4__Application(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ApplicationDataWrapper: return (void*)soap_instantiate_ns4__ApplicationDataWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ApplicationResultWrapper: return (void*)soap_instantiate_ns4__ApplicationResultWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ApplicationData: return (void*)soap_instantiate_ns4__ApplicationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ApplicationResultData: return (void*)soap_instantiate_ns4__ApplicationResultData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__BusinessErrorList: return (void*)soap_instantiate_ns4__BusinessErrorList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Address: return (void*)soap_instantiate_ns6__Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Producer: return (void*)soap_instantiate_ns6__Producer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProducerList: return (void*)soap_instantiate_ns6__ProducerList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EnterpriseNumberList: return (void*)soap_instantiate_ns6__EnterpriseNumberList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__BusinessMember: return (void*)soap_instantiate_ns6__BusinessMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Package: return (void*)soap_instantiate_ns6__Package(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__PackageList: return (void*)soap_instantiate_ns6__PackageList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ComplexDate: return (void*)soap_instantiate_ns6__ComplexDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProductItemProducing: return (void*)soap_instantiate_ns6__ProductItemProducing(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Packaging: return (void*)soap_instantiate_ns6__Packaging(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Location: return (void*)soap_instantiate_ns6__Location(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EnterpriseOfficialRegistration: return (void*)soap_instantiate_ns6__EnterpriseOfficialRegistration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Organization: return (void*)soap_instantiate_ns6__Organization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__MedicinalDrug: return (void*)soap_instantiate_ns6__MedicinalDrug(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationConditionGroup: return (void*)soap_instantiate_ns6__RegionalizationConditionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationRequirement: return (void*)soap_instantiate_ns6__RegionalizationRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationStatus: return (void*)soap_instantiate_ns6__RegionalizationStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Batch: return (void*)soap_instantiate_ns7__Batch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__RawBatch: return (void*)soap_instantiate_ns7__RawBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__DeliveryFactList: return (void*)soap_instantiate_ns7__DeliveryFactList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__DeliveryInspection: return (void*)soap_instantiate_ns7__DeliveryInspection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ConsignmentDocumentList: return (void*)soap_instantiate_ns7__ConsignmentDocumentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__GoodsDate: return (void*)soap_instantiate_ns7__GoodsDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__StockDiscrepancy: return (void*)soap_instantiate_ns7__StockDiscrepancy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__TransportInfo: return (void*)soap_instantiate_ns7__TransportInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__TransportNumber: return (void*)soap_instantiate_ns7__TransportNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ShipmentRoute: return (void*)soap_instantiate_ns7__ShipmentRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ProductionOperation: return (void*)soap_instantiate_ns7__ProductionOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__MergeStockEntriesOperation: return (void*)soap_instantiate_ns7__MergeStockEntriesOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__PSLModificationOperation: return (void*)soap_instantiate_ns7__PSLModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__BEModificationOperation: return (void*)soap_instantiate_ns7__BEModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation: return (void*)soap_instantiate__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__BEActivityLocationsModificationOperation: return (void*)soap_instantiate_ns7__BEActivityLocationsModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ENTModificationOperation: return (void*)soap_instantiate_ns7__ENTModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__CertifiedBatch: return (void*)soap_instantiate_ns7__CertifiedBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__CertifiedConsignment: return (void*)soap_instantiate_ns7__CertifiedConsignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__VeterinaryEvent: return (void*)soap_instantiate_ns7__VeterinaryEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__VeterinaryAuthentication: return (void*)soap_instantiate_ns7__VeterinaryAuthentication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__BatchOrigin: return (void*)soap_instantiate_ns7__BatchOrigin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__StockEntryEventList: return (void*)soap_instantiate_ns7__StockEntryEventList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__VetDocumentStatusChange: return (void*)soap_instantiate_ns7__VetDocumentStatusChange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__RegionalizationClause: return (void*)soap_instantiate_ns7__RegionalizationClause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__RouteSectionR13nRules: return (void*)soap_instantiate_ns7__RouteSectionR13nRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ProcessingProcedure: return (void*)soap_instantiate_ns7__ProcessingProcedure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__AuthorityList: return (void*)soap_instantiate_ns7__AuthorityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__UserAuthority: return (void*)soap_instantiate_ns7__UserAuthority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__WorkingArea: return (void*)soap_instantiate_ns7__WorkingArea(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByGuidRequest: return (void*)soap_instantiate__ns8__getPurposeByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByGuidResponse: return (void*)soap_instantiate__ns8__getPurposeByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByUuidRequest: return (void*)soap_instantiate__ns8__getPurposeByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByUuidResponse: return (void*)soap_instantiate__ns8__getPurposeByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeListRequest: return (void*)soap_instantiate__ns8__getPurposeListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeListResponse: return (void*)soap_instantiate__ns8__getPurposeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeChangesListRequest: return (void*)soap_instantiate__ns8__getPurposeChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeChangesListResponse: return (void*)soap_instantiate__ns8__getPurposeChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByGuidRequest: return (void*)soap_instantiate__ns8__getUnitByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByGuidResponse: return (void*)soap_instantiate__ns8__getUnitByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByUuidRequest: return (void*)soap_instantiate__ns8__getUnitByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByUuidResponse: return (void*)soap_instantiate__ns8__getUnitByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitListRequest: return (void*)soap_instantiate__ns8__getUnitListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitListResponse: return (void*)soap_instantiate__ns8__getUnitListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitChangesListRequest: return (void*)soap_instantiate__ns8__getUnitChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitChangesListResponse: return (void*)soap_instantiate__ns8__getUnitChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByGuidRequest: return (void*)soap_instantiate__ns8__getProductByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByGuidResponse: return (void*)soap_instantiate__ns8__getProductByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByUuidRequest: return (void*)soap_instantiate__ns8__getProductByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByUuidResponse: return (void*)soap_instantiate__ns8__getProductByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByTypeListRequest: return (void*)soap_instantiate__ns8__getProductByTypeListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByTypeListResponse: return (void*)soap_instantiate__ns8__getProductByTypeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductChangesListRequest: return (void*)soap_instantiate__ns8__getProductChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductChangesListResponse: return (void*)soap_instantiate__ns8__getProductChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByGuidRequest: return (void*)soap_instantiate__ns8__getSubProductByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByGuidResponse: return (void*)soap_instantiate__ns8__getSubProductByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByUuidRequest: return (void*)soap_instantiate__ns8__getSubProductByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByUuidResponse: return (void*)soap_instantiate__ns8__getSubProductByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByProductListRequest: return (void*)soap_instantiate__ns8__getSubProductByProductListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByProductListResponse: return (void*)soap_instantiate__ns8__getSubProductByProductListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductChangesListRequest: return (void*)soap_instantiate__ns8__getSubProductChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductChangesListResponse: return (void*)soap_instantiate__ns8__getSubProductChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByGuidRequest: return (void*)soap_instantiate__ns8__getProductItemByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByGuidResponse: return (void*)soap_instantiate__ns8__getProductItemByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByUuidRequest: return (void*)soap_instantiate__ns8__getProductItemByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByUuidResponse: return (void*)soap_instantiate__ns8__getProductItemByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemListRequest: return (void*)soap_instantiate__ns8__getProductItemListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemListResponse: return (void*)soap_instantiate__ns8__getProductItemListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemChangesListRequest: return (void*)soap_instantiate__ns8__getProductItemChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemChangesListResponse: return (void*)soap_instantiate__ns8__getProductItemChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getAllCountryListRequest: return (void*)soap_instantiate__ns8__getAllCountryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getAllCountryListResponse: return (void*)soap_instantiate__ns8__getAllCountryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByGuidRequest: return (void*)soap_instantiate__ns8__getCountryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByGuidResponse: return (void*)soap_instantiate__ns8__getCountryByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByUuidRequest: return (void*)soap_instantiate__ns8__getCountryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByUuidResponse: return (void*)soap_instantiate__ns8__getCountryByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryChangesListRequest: return (void*)soap_instantiate__ns8__getCountryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryChangesListResponse: return (void*)soap_instantiate__ns8__getCountryChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionListByCountryRequest: return (void*)soap_instantiate__ns8__getRegionListByCountryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionListByCountryResponse: return (void*)soap_instantiate__ns8__getRegionListByCountryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByGuidRequest: return (void*)soap_instantiate__ns8__getRegionByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByGuidResponse: return (void*)soap_instantiate__ns8__getRegionByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByUuidRequest: return (void*)soap_instantiate__ns8__getRegionByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByUuidResponse: return (void*)soap_instantiate__ns8__getRegionByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionChangesListRequest: return (void*)soap_instantiate__ns8__getRegionChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionChangesListResponse: return (void*)soap_instantiate__ns8__getRegionChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest: return (void*)soap_instantiate__ns8__getDistrictListByRegionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse: return (void*)soap_instantiate__ns8__getDistrictListByRegionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByGuidRequest: return (void*)soap_instantiate__ns8__getDistrictByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByGuidResponse: return (void*)soap_instantiate__ns8__getDistrictByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByUuidRequest: return (void*)soap_instantiate__ns8__getDistrictByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByUuidResponse: return (void*)soap_instantiate__ns8__getDistrictByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictChangesListRequest: return (void*)soap_instantiate__ns8__getDistrictChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictChangesListResponse: return (void*)soap_instantiate__ns8__getDistrictChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest: return (void*)soap_instantiate__ns8__getLocalityListByRegionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse: return (void*)soap_instantiate__ns8__getLocalityListByRegionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest: return (void*)soap_instantiate__ns8__getLocalityListByDistrictRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse: return (void*)soap_instantiate__ns8__getLocalityListByDistrictResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest: return (void*)soap_instantiate__ns8__getLocalityListByLocalityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse: return (void*)soap_instantiate__ns8__getLocalityListByLocalityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest: return (void*)soap_instantiate__ns8__getStreetListByLocalityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse: return (void*)soap_instantiate__ns8__getStreetListByLocalityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findLocalityListByNameRequest: return (void*)soap_instantiate__ns8__findLocalityListByNameRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findLocalityListByNameResponse: return (void*)soap_instantiate__ns8__findLocalityListByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findStreetListByNameRequest: return (void*)soap_instantiate__ns8__findStreetListByNameRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findStreetListByNameResponse: return (void*)soap_instantiate__ns8__findStreetListByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest: return (void*)soap_instantiate__ns8__getEnterpriseByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse: return (void*)soap_instantiate__ns8__getEnterpriseByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest: return (void*)soap_instantiate__ns8__getEnterpriseByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse: return (void*)soap_instantiate__ns8__getEnterpriseByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest: return (void*)soap_instantiate__ns8__getForeignEnterpriseListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse: return (void*)soap_instantiate__ns8__getForeignEnterpriseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest: return (void*)soap_instantiate__ns8__getRussianEnterpriseListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse: return (void*)soap_instantiate__ns8__getRussianEnterpriseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest: return (void*)soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse: return (void*)soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest: return (void*)soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse: return (void*)soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest: return (void*)soap_instantiate__ns8__getBusinessEntityByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse: return (void*)soap_instantiate__ns8__getBusinessEntityByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest: return (void*)soap_instantiate__ns8__getBusinessEntityByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse: return (void*)soap_instantiate__ns8__getBusinessEntityByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityListRequest: return (void*)soap_instantiate__ns8__getBusinessEntityListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityListResponse: return (void*)soap_instantiate__ns8__getBusinessEntityListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest: return (void*)soap_instantiate__ns8__getBusinessEntityChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse: return (void*)soap_instantiate__ns8__getBusinessEntityChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest: return (void*)soap_instantiate__ns8__getBusinessMemberByGLNRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse: return (void*)soap_instantiate__ns8__getBusinessMemberByGLNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActivityLocationListRequest: return (void*)soap_instantiate__ns8__getActivityLocationListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActivityLocationListResponse: return (void*)soap_instantiate__ns8__getActivityLocationListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getR13nConditionListRequest: return (void*)soap_instantiate__ns8__getR13nConditionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getR13nConditionListResponse: return (void*)soap_instantiate__ns8__getR13nConditionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest: return (void*)soap_instantiate__ns8__getActualR13nRegionStatusListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse: return (void*)soap_instantiate__ns8__getActualR13nRegionStatusListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest: return (void*)soap_instantiate__ns8__getActualR13nShippingRuleListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse: return (void*)soap_instantiate__ns8__getActualR13nShippingRuleListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest: return (void*)soap_instantiate__ns8__getDiseaseByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse: return (void*)soap_instantiate__ns8__getDiseaseByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest: return (void*)soap_instantiate__ns8__getDiseaseByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse: return (void*)soap_instantiate__ns8__getDiseaseByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseListRequest: return (void*)soap_instantiate__ns8__getDiseaseListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseListResponse: return (void*)soap_instantiate__ns8__getDiseaseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest: return (void*)soap_instantiate__ns8__getDiseaseChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse: return (void*)soap_instantiate__ns8__getDiseaseChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest: return (void*)soap_instantiate__ns8__getResearchMethodByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse: return (void*)soap_instantiate__ns8__getResearchMethodByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest: return (void*)soap_instantiate__ns8__getResearchMethodByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse: return (void*)soap_instantiate__ns8__getResearchMethodByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodListRequest: return (void*)soap_instantiate__ns8__getResearchMethodListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodListResponse: return (void*)soap_instantiate__ns8__getResearchMethodListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest: return (void*)soap_instantiate__ns8__getResearchMethodChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse: return (void*)soap_instantiate__ns8__getResearchMethodChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__GenericVersioningEntity: return (void*)soap_instantiate_ns3__GenericVersioningEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__Error: return (void*)soap_instantiate_ns3__Error(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__MercuryApplicationRequest: return (void*)soap_instantiate_ns5__MercuryApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse: return (void*)soap_instantiate_ns5__ProcessIncomingConsignmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse: return (void*)soap_instantiate_ns5__PrepareOutgoingConsignmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__RegisterProductionOperationResponse: return (void*)soap_instantiate_ns5__RegisterProductionOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__MergeStockEntriesResponse: return (void*)soap_instantiate_ns5__MergeStockEntriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__WithdrawVetDocumentResponse: return (void*)soap_instantiate_ns5__WithdrawVetDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyBusinessEntityResponse: return (void*)soap_instantiate_ns5__ModifyBusinessEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyEnterpriseResponse: return (void*)soap_instantiate_ns5__ModifyEnterpriseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyActivityLocationsResponse: return (void*)soap_instantiate_ns5__ModifyActivityLocationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ResolveDiscrepancyResponse: return (void*)soap_instantiate_ns5__ResolveDiscrepancyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyProducerStockListResponse: return (void*)soap_instantiate_ns5__ModifyProducerStockListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetVetDocumentByUuidResponse: return (void*)soap_instantiate_ns5__GetVetDocumentByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetVetDocumentListResponse: return (void*)soap_instantiate_ns5__GetVetDocumentListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetVetDocumentChangesListResponse: return (void*)soap_instantiate_ns5__GetVetDocumentChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryByGuidResponse: return (void*)soap_instantiate_ns5__GetStockEntryByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryByUuidResponse: return (void*)soap_instantiate_ns5__GetStockEntryByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryChangesListResponse: return (void*)soap_instantiate_ns5__GetStockEntryChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryListResponse: return (void*)soap_instantiate_ns5__GetStockEntryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryVersionListResponse: return (void*)soap_instantiate_ns5__GetStockEntryVersionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse: return (void*)soap_instantiate_ns5__UpdateTransportMovementDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse: return (void*)soap_instantiate_ns5__UpdateVeterinaryEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse: return (void*)soap_instantiate_ns5__CheckShipmentRegionalizationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__AddBusinessEntityUserResponse: return (void*)soap_instantiate_ns5__AddBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetBusinessEntityUserListResponse: return (void*)soap_instantiate_ns5__GetBusinessEntityUserListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetBusinessEntityUserResponse: return (void*)soap_instantiate_ns5__GetBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse: return (void*)soap_instantiate_ns5__UpdateUserAuthoritiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse: return (void*)soap_instantiate_ns5__UpdateUserWorkingAreasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse: return (void*)soap_instantiate_ns5__UnbindBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse: return (void*)soap_instantiate_ns5__GetAppliedUserAuthorityListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__PurposeList: return (void*)soap_instantiate_ns6__PurposeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UnitList: return (void*)soap_instantiate_ns6__UnitList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__CountryList: return (void*)soap_instantiate_ns6__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionList: return (void*)soap_instantiate_ns6__RegionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DistrictList: return (void*)soap_instantiate_ns6__DistrictList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__LocalityList: return (void*)soap_instantiate_ns6__LocalityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__StreetList: return (void*)soap_instantiate_ns6__StreetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EnterpriseActivityList: return (void*)soap_instantiate_ns6__EnterpriseActivityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EnterpriseActivity: return (void*)soap_instantiate_ns6__EnterpriseActivity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__EnterpriseList: return (void*)soap_instantiate_ns6__EnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__IncorporationForm: return (void*)soap_instantiate_ns6__IncorporationForm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__BusinessEntityList: return (void*)soap_instantiate_ns6__BusinessEntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProductList: return (void*)soap_instantiate_ns6__ProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SubProductList: return (void*)soap_instantiate_ns6__SubProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProductItemList: return (void*)soap_instantiate_ns6__ProductItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Area: return (void*)soap_instantiate_ns6__Area(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationConditionList: return (void*)soap_instantiate_ns6__RegionalizationConditionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationRegionStatusList: return (void*)soap_instantiate_ns6__RegionalizationRegionStatusList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationShippingRuleList: return (void*)soap_instantiate_ns6__RegionalizationShippingRuleList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AnimalDiseaseList: return (void*)soap_instantiate_ns6__AnimalDiseaseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ResearchMethodList: return (void*)soap_instantiate_ns6__ResearchMethodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ActivityLocationList: return (void*)soap_instantiate_ns6__ActivityLocationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Consignment: return (void*)soap_instantiate_ns7__Consignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ProductiveBatch: return (void*)soap_instantiate_ns7__ProductiveBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Delivery: return (void*)soap_instantiate_ns7__Delivery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__VetDocumentList: return (void*)soap_instantiate_ns7__VetDocumentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__DiscrepancyReason: return (void*)soap_instantiate_ns7__DiscrepancyReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__StockEntryList: return (void*)soap_instantiate_ns7__StockEntryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Document: return (void*)soap_instantiate_ns7__Document(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ShipmentRoutePoint: return (void*)soap_instantiate_ns7__ShipmentRoutePoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__LaboratoryResearchEvent: return (void*)soap_instantiate_ns7__LaboratoryResearchEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__AnimalMedicationEvent: return (void*)soap_instantiate_ns7__AnimalMedicationEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__QuarantineEvent: return (void*)soap_instantiate_ns7__QuarantineEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__User: return (void*)soap_instantiate_ns7__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__UserList: return (void*)soap_instantiate_ns7__UserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__WorkingAreaList: return (void*)soap_instantiate_ns7__WorkingAreaList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__BusinessError: return (void*)soap_instantiate_ns4__BusinessError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest: return (void*)soap_instantiate_ns5__ProcessIncomingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest: return (void*)soap_instantiate_ns5__PrepareOutgoingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__RegisterProductionOperationRequest: return (void*)soap_instantiate_ns5__RegisterProductionOperationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__MergeStockEntriesRequest: return (void*)soap_instantiate_ns5__MergeStockEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__WithdrawVetDocumentRequest: return (void*)soap_instantiate_ns5__WithdrawVetDocumentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyBusinessEntityRequest: return (void*)soap_instantiate_ns5__ModifyBusinessEntityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyEnterpriseRequest: return (void*)soap_instantiate_ns5__ModifyEnterpriseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyActivityLocationsRequest: return (void*)soap_instantiate_ns5__ModifyActivityLocationsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ResolveDiscrepancyRequest: return (void*)soap_instantiate_ns5__ResolveDiscrepancyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ModifyProducerStockListRequest: return (void*)soap_instantiate_ns5__ModifyProducerStockListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetVetDocumentByUuidRequest: return (void*)soap_instantiate_ns5__GetVetDocumentByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetVetDocumentListRequest: return (void*)soap_instantiate_ns5__GetVetDocumentListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetVetDocumentChangesListRequest: return (void*)soap_instantiate_ns5__GetVetDocumentChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryByGuidRequest: return (void*)soap_instantiate_ns5__GetStockEntryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryByUuidRequest: return (void*)soap_instantiate_ns5__GetStockEntryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryChangesListRequest: return (void*)soap_instantiate_ns5__GetStockEntryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryListRequest: return (void*)soap_instantiate_ns5__GetStockEntryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetStockEntryVersionListRequest: return (void*)soap_instantiate_ns5__GetStockEntryVersionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest: return (void*)soap_instantiate_ns5__UpdateTransportMovementDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest: return (void*)soap_instantiate_ns5__UpdateVeterinaryEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest: return (void*)soap_instantiate_ns5__CheckShipmentRegionalizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__AddBusinessEntityUserRequest: return (void*)soap_instantiate_ns5__AddBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetBusinessEntityUserListRequest: return (void*)soap_instantiate_ns5__GetBusinessEntityUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetBusinessEntityUserRequest: return (void*)soap_instantiate_ns5__GetBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest: return (void*)soap_instantiate_ns5__UpdateUserAuthoritiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest: return (void*)soap_instantiate_ns5__UpdateUserWorkingAreasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest: return (void*)soap_instantiate_ns5__UnbindBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest: return (void*)soap_instantiate_ns5__GetAppliedUserAuthorityListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Purpose: return (void*)soap_instantiate_ns6__Purpose(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Unit: return (void*)soap_instantiate_ns6__Unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__PackingType: return (void*)soap_instantiate_ns6__PackingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Country: return (void*)soap_instantiate_ns6__Country(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__FederalDistrict: return (void*)soap_instantiate_ns6__FederalDistrict(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AddressObjectView: return (void*)soap_instantiate_ns6__AddressObjectView(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Enterprise: return (void*)soap_instantiate_ns6__Enterprise(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__BusinessEntity_activityLocation: return (void*)soap_instantiate__ns6__BusinessEntity_activityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__BusinessEntity: return (void*)soap_instantiate_ns6__BusinessEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProductItem: return (void*)soap_instantiate_ns6__ProductItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Product: return (void*)soap_instantiate_ns6__Product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__SubProduct: return (void*)soap_instantiate_ns6__SubProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ProductMarks: return (void*)soap_instantiate_ns6__ProductMarks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Indicator: return (void*)soap_instantiate_ns6__Indicator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AnimalDisease: return (void*)soap_instantiate_ns6__AnimalDisease(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ResearchMethod: return (void*)soap_instantiate_ns6__ResearchMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationCondition: return (void*)soap_instantiate_ns6__RegionalizationCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationShippingRule: return (void*)soap_instantiate_ns6__RegionalizationShippingRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RegionalizationRegionStatus: return (void*)soap_instantiate_ns6__RegionalizationRegionStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__VetDocument: return (void*)soap_instantiate_ns7__VetDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__DiscrepancyReport: return (void*)soap_instantiate_ns7__DiscrepancyReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__StockEntry: return (void*)soap_instantiate_ns7__StockEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Waybill: return (void*)soap_instantiate_ns7__Waybill(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__ReferencedDocument: return (void*)soap_instantiate_ns7__ReferencedDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Region: return (void*)soap_instantiate_ns6__Region(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__District: return (void*)soap_instantiate_ns6__District(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Locality: return (void*)soap_instantiate_ns6__Locality(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Street: return (void*)soap_instantiate_ns6__Street(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__StockEntrySearchPattern: return (void*)soap_instantiate_ns7__StockEntrySearchPattern(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail: return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns10__submitApplicationRequest: return (void*)soap_instantiate___ns10__submitApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns10__receiveApplicationResult: return (void*)soap_instantiate___ns10__receiveApplicationResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__processIncomingConsignmentRequest: return (void*)soap_instantiate___ns11__processIncomingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__prepareOutgoingConsignmentRequest: return (void*)soap_instantiate___ns11__prepareOutgoingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__registerProductionOperationRequest: return (void*)soap_instantiate___ns11__registerProductionOperationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__mergeStockEntriesRequest: return (void*)soap_instantiate___ns11__mergeStockEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__withdrawVetDocumentRequest: return (void*)soap_instantiate___ns11__withdrawVetDocumentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__modifyBusinessEntityRequest: return (void*)soap_instantiate___ns11__modifyBusinessEntityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__modifyEnterpriseRequest: return (void*)soap_instantiate___ns11__modifyEnterpriseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__modifyActivityLocationsRequest: return (void*)soap_instantiate___ns11__modifyActivityLocationsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__resolveDiscrepancyRequest: return (void*)soap_instantiate___ns11__resolveDiscrepancyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__modifyProducerStockListRequest: return (void*)soap_instantiate___ns11__modifyProducerStockListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getVetDocumentByUuidRequest: return (void*)soap_instantiate___ns11__getVetDocumentByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getVetDocumentListRequest: return (void*)soap_instantiate___ns11__getVetDocumentListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getVetDocumentChangesListRequest: return (void*)soap_instantiate___ns11__getVetDocumentChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getStockEntryByGuidRequest: return (void*)soap_instantiate___ns11__getStockEntryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getStockEntryByUuidRequest: return (void*)soap_instantiate___ns11__getStockEntryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getStockEntryListRequest: return (void*)soap_instantiate___ns11__getStockEntryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getStockEntryChangesListRequest: return (void*)soap_instantiate___ns11__getStockEntryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getStockEntryVersionListRequest: return (void*)soap_instantiate___ns11__getStockEntryVersionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__updateTransportMovementDetailsRequest: return (void*)soap_instantiate___ns11__updateTransportMovementDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__updateVeterinaryEventsRequest: return (void*)soap_instantiate___ns11__updateVeterinaryEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__checkShipmentRegionalizationRequest: return (void*)soap_instantiate___ns11__checkShipmentRegionalizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__addBusinessEntityUserRequest: return (void*)soap_instantiate___ns11__addBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getBusinessEntityUserListRequest: return (void*)soap_instantiate___ns11__getBusinessEntityUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getBusinessEntityUserRequest: return (void*)soap_instantiate___ns11__getBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__updateUserAuthoritiesRequest: return (void*)soap_instantiate___ns11__updateUserAuthoritiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__updateUserWorkingAreasRequest: return (void*)soap_instantiate___ns11__updateUserWorkingAreasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__unbindBusinessEntityUserRequest: return (void*)soap_instantiate___ns11__unbindBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns11__getAppliedUserAuthorityListRequest: return (void*)soap_instantiate___ns11__getAppliedUserAuthorityListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetBusinessEntityByGuid: return (void*)soap_instantiate___ns9__GetBusinessEntityByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetBusinessEntityByUuid: return (void*)soap_instantiate___ns9__GetBusinessEntityByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetBusinessEntityList: return (void*)soap_instantiate___ns9__GetBusinessEntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetBusinessEntityChangesList: return (void*)soap_instantiate___ns9__GetBusinessEntityChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetEnterpriseByGuid: return (void*)soap_instantiate___ns9__GetEnterpriseByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetEnterpriseByUuid: return (void*)soap_instantiate___ns9__GetEnterpriseByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetForeignEnterpriseList: return (void*)soap_instantiate___ns9__GetForeignEnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetRussianEnterpriseList: return (void*)soap_instantiate___ns9__GetRussianEnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetForeignEnterpriseChangesList: return (void*)soap_instantiate___ns9__GetForeignEnterpriseChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetRussianEnterpriseChangesList: return (void*)soap_instantiate___ns9__GetRussianEnterpriseChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetBusinessMemberByGLN: return (void*)soap_instantiate___ns9__GetBusinessMemberByGLN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns9__GetActivityLocationList: return (void*)soap_instantiate___ns9__GetActivityLocationList(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header: return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code: return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason: return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault: return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ns4__BinaryContent: return (void*)soap_instantiate_ns4__BinaryContent(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 vetisams_fdelete(struct soap_clist *p)
{
	switch(p->type) {
	case SOAP_TYPE_xsd__base64Binary:
		if(p->size < 0) SOAP_DELETE((xsd__base64Binary*)p->ptr); else SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE__ns1__submitApplicationRequest:
		if(p->size < 0) SOAP_DELETE((_ns1__submitApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns1__submitApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__submitApplicationResponse:
		if(p->size < 0) SOAP_DELETE((_ns1__submitApplicationResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns1__submitApplicationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__receiveApplicationResultRequest:
		if(p->size < 0) SOAP_DELETE((_ns1__receiveApplicationResultRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns1__receiveApplicationResultRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__receiveApplicationResultResponse:
		if(p->size < 0) SOAP_DELETE((_ns1__receiveApplicationResultResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns1__receiveApplicationResultResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns3__GenericEntity:
		if(p->size < 0) SOAP_DELETE((ns3__GenericEntity*)p->ptr); else SOAP_DELETE_ARRAY((ns3__GenericEntity*)p->ptr);
		break;
	case SOAP_TYPE_ns3__ListOptions:
		if(p->size < 0) SOAP_DELETE((ns3__ListOptions*)p->ptr); else SOAP_DELETE_ARRAY((ns3__ListOptions*)p->ptr);
		break;
	case SOAP_TYPE_ns3__DateInterval:
		if(p->size < 0) SOAP_DELETE((ns3__DateInterval*)p->ptr); else SOAP_DELETE_ARRAY((ns3__DateInterval*)p->ptr);
		break;
	case SOAP_TYPE_ns3__EntityList:
		if(p->size < 0) SOAP_DELETE((ns3__EntityList*)p->ptr); else SOAP_DELETE_ARRAY((ns3__EntityList*)p->ptr);
		break;
	case SOAP_TYPE_ns3__FaultInfo:
		if(p->size < 0) SOAP_DELETE((ns3__FaultInfo*)p->ptr); else SOAP_DELETE_ARRAY((ns3__FaultInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns4__Application:
		if(p->size < 0) SOAP_DELETE((ns4__Application*)p->ptr); else SOAP_DELETE_ARRAY((ns4__Application*)p->ptr);
		break;
	case SOAP_TYPE_ns4__ApplicationDataWrapper:
		if(p->size < 0) SOAP_DELETE((ns4__ApplicationDataWrapper*)p->ptr); else SOAP_DELETE_ARRAY((ns4__ApplicationDataWrapper*)p->ptr);
		break;
	case SOAP_TYPE_ns4__ApplicationResultWrapper:
		if(p->size < 0) SOAP_DELETE((ns4__ApplicationResultWrapper*)p->ptr); else SOAP_DELETE_ARRAY((ns4__ApplicationResultWrapper*)p->ptr);
		break;
	case SOAP_TYPE_ns4__ApplicationData:
		if(p->size < 0) SOAP_DELETE((ns4__ApplicationData*)p->ptr); else SOAP_DELETE_ARRAY((ns4__ApplicationData*)p->ptr);
		break;
	case SOAP_TYPE_ns4__ApplicationResultData:
		if(p->size < 0) SOAP_DELETE((ns4__ApplicationResultData*)p->ptr); else SOAP_DELETE_ARRAY((ns4__ApplicationResultData*)p->ptr);
		break;
	case SOAP_TYPE_ns4__BusinessErrorList:
		if(p->size < 0) SOAP_DELETE((ns4__BusinessErrorList*)p->ptr); else SOAP_DELETE_ARRAY((ns4__BusinessErrorList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Address:
		if(p->size < 0) SOAP_DELETE((ns6__Address*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Address*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Producer:
		if(p->size < 0) SOAP_DELETE((ns6__Producer*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Producer*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ProducerList:
		if(p->size < 0) SOAP_DELETE((ns6__ProducerList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ProducerList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__EnterpriseNumberList:
		if(p->size < 0) SOAP_DELETE((ns6__EnterpriseNumberList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__EnterpriseNumberList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__BusinessMember:
		if(p->size < 0) SOAP_DELETE((ns6__BusinessMember*)p->ptr); else SOAP_DELETE_ARRAY((ns6__BusinessMember*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Package:
		if(p->size < 0) SOAP_DELETE((ns6__Package*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Package*)p->ptr);
		break;
	case SOAP_TYPE_ns6__PackageList:
		if(p->size < 0) SOAP_DELETE((ns6__PackageList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__PackageList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ComplexDate:
		if(p->size < 0) SOAP_DELETE((ns6__ComplexDate*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ComplexDate*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ProductItemProducing:
		if(p->size < 0) SOAP_DELETE((ns6__ProductItemProducing*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ProductItemProducing*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Packaging:
		if(p->size < 0) SOAP_DELETE((ns6__Packaging*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Packaging*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Location:
		if(p->size < 0) SOAP_DELETE((ns6__Location*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Location*)p->ptr);
		break;
	case SOAP_TYPE_ns6__EnterpriseOfficialRegistration:
		if(p->size < 0) SOAP_DELETE((ns6__EnterpriseOfficialRegistration*)p->ptr); else SOAP_DELETE_ARRAY((ns6__EnterpriseOfficialRegistration*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Organization:
		if(p->size < 0) SOAP_DELETE((ns6__Organization*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Organization*)p->ptr);
		break;
	case SOAP_TYPE_ns6__MedicinalDrug:
		if(p->size < 0) SOAP_DELETE((ns6__MedicinalDrug*)p->ptr); else SOAP_DELETE_ARRAY((ns6__MedicinalDrug*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationConditionGroup:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationConditionGroup*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationConditionGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationRequirement:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationRequirement*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationStatus:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationStatus*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns7__Batch:
		if(p->size < 0) SOAP_DELETE((ns7__Batch*)p->ptr); else SOAP_DELETE_ARRAY((ns7__Batch*)p->ptr);
		break;
	case SOAP_TYPE_ns7__RawBatch:
		if(p->size < 0) SOAP_DELETE((ns7__RawBatch*)p->ptr); else SOAP_DELETE_ARRAY((ns7__RawBatch*)p->ptr);
		break;
	case SOAP_TYPE_ns7__DeliveryFactList:
		if(p->size < 0) SOAP_DELETE((ns7__DeliveryFactList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__DeliveryFactList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__DeliveryInspection:
		if(p->size < 0) SOAP_DELETE((ns7__DeliveryInspection*)p->ptr); else SOAP_DELETE_ARRAY((ns7__DeliveryInspection*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ConsignmentDocumentList:
		if(p->size < 0) SOAP_DELETE((ns7__ConsignmentDocumentList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ConsignmentDocumentList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__GoodsDate:
		if(p->size < 0) SOAP_DELETE((ns7__GoodsDate*)p->ptr); else SOAP_DELETE_ARRAY((ns7__GoodsDate*)p->ptr);
		break;
	case SOAP_TYPE_ns7__StockDiscrepancy:
		if(p->size < 0) SOAP_DELETE((ns7__StockDiscrepancy*)p->ptr); else SOAP_DELETE_ARRAY((ns7__StockDiscrepancy*)p->ptr);
		break;
	case SOAP_TYPE_ns7__TransportInfo:
		if(p->size < 0) SOAP_DELETE((ns7__TransportInfo*)p->ptr); else SOAP_DELETE_ARRAY((ns7__TransportInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns7__TransportNumber:
		if(p->size < 0) SOAP_DELETE((ns7__TransportNumber*)p->ptr); else SOAP_DELETE_ARRAY((ns7__TransportNumber*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ShipmentRoute:
		if(p->size < 0) SOAP_DELETE((ns7__ShipmentRoute*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ShipmentRoute*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ProductionOperation:
		if(p->size < 0) SOAP_DELETE((ns7__ProductionOperation*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ProductionOperation*)p->ptr);
		break;
	case SOAP_TYPE_ns7__MergeStockEntriesOperation:
		if(p->size < 0) SOAP_DELETE((ns7__MergeStockEntriesOperation*)p->ptr); else SOAP_DELETE_ARRAY((ns7__MergeStockEntriesOperation*)p->ptr);
		break;
	case SOAP_TYPE_ns7__PSLModificationOperation:
		if(p->size < 0) SOAP_DELETE((ns7__PSLModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((ns7__PSLModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_ns7__BEModificationOperation:
		if(p->size < 0) SOAP_DELETE((ns7__BEModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((ns7__BEModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation:
		if(p->size < 0) SOAP_DELETE((_ns7__BEActivityLocationsModificationOperation_activityLocation*)p->ptr); else SOAP_DELETE_ARRAY((_ns7__BEActivityLocationsModificationOperation_activityLocation*)p->ptr);
		break;
	case SOAP_TYPE_ns7__BEActivityLocationsModificationOperation:
		if(p->size < 0) SOAP_DELETE((ns7__BEActivityLocationsModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((ns7__BEActivityLocationsModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ENTModificationOperation:
		if(p->size < 0) SOAP_DELETE((ns7__ENTModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ENTModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_ns7__CertifiedBatch:
		if(p->size < 0) SOAP_DELETE((ns7__CertifiedBatch*)p->ptr); else SOAP_DELETE_ARRAY((ns7__CertifiedBatch*)p->ptr);
		break;
	case SOAP_TYPE_ns7__CertifiedConsignment:
		if(p->size < 0) SOAP_DELETE((ns7__CertifiedConsignment*)p->ptr); else SOAP_DELETE_ARRAY((ns7__CertifiedConsignment*)p->ptr);
		break;
	case SOAP_TYPE_ns7__VeterinaryEvent:
		if(p->size < 0) SOAP_DELETE((ns7__VeterinaryEvent*)p->ptr); else SOAP_DELETE_ARRAY((ns7__VeterinaryEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns7__VeterinaryAuthentication:
		if(p->size < 0) SOAP_DELETE((ns7__VeterinaryAuthentication*)p->ptr); else SOAP_DELETE_ARRAY((ns7__VeterinaryAuthentication*)p->ptr);
		break;
	case SOAP_TYPE_ns7__BatchOrigin:
		if(p->size < 0) SOAP_DELETE((ns7__BatchOrigin*)p->ptr); else SOAP_DELETE_ARRAY((ns7__BatchOrigin*)p->ptr);
		break;
	case SOAP_TYPE_ns7__StockEntryEventList:
		if(p->size < 0) SOAP_DELETE((ns7__StockEntryEventList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__StockEntryEventList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__VetDocumentStatusChange:
		if(p->size < 0) SOAP_DELETE((ns7__VetDocumentStatusChange*)p->ptr); else SOAP_DELETE_ARRAY((ns7__VetDocumentStatusChange*)p->ptr);
		break;
	case SOAP_TYPE_ns7__RegionalizationClause:
		if(p->size < 0) SOAP_DELETE((ns7__RegionalizationClause*)p->ptr); else SOAP_DELETE_ARRAY((ns7__RegionalizationClause*)p->ptr);
		break;
	case SOAP_TYPE_ns7__RouteSectionR13nRules:
		if(p->size < 0) SOAP_DELETE((ns7__RouteSectionR13nRules*)p->ptr); else SOAP_DELETE_ARRAY((ns7__RouteSectionR13nRules*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ProcessingProcedure:
		if(p->size < 0) SOAP_DELETE((ns7__ProcessingProcedure*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ProcessingProcedure*)p->ptr);
		break;
	case SOAP_TYPE_ns7__AuthorityList:
		if(p->size < 0) SOAP_DELETE((ns7__AuthorityList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__AuthorityList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__UserAuthority:
		if(p->size < 0) SOAP_DELETE((ns7__UserAuthority*)p->ptr); else SOAP_DELETE_ARRAY((ns7__UserAuthority*)p->ptr);
		break;
	case SOAP_TYPE_ns7__WorkingArea:
		if(p->size < 0) SOAP_DELETE((ns7__WorkingArea*)p->ptr); else SOAP_DELETE_ARRAY((ns7__WorkingArea*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByTypeListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByTypeListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByTypeListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByTypeListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByTypeListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByTypeListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByProductListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByProductListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByProductListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByProductListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByProductListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByProductListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getAllCountryListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getAllCountryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getAllCountryListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getAllCountryListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getAllCountryListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getAllCountryListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionListByCountryRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionListByCountryRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionListByCountryRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionListByCountryResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionListByCountryResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionListByCountryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictListByRegionRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictListByRegionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictListByRegionResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictListByRegionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByRegionRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByRegionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByRegionResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByRegionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByDistrictRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByDistrictRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByDistrictResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByDistrictResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByLocalityRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByLocalityRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByLocalityResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByLocalityResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getStreetListByLocalityRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getStreetListByLocalityRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getStreetListByLocalityResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getStreetListByLocalityResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findLocalityListByNameRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__findLocalityListByNameRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findLocalityListByNameRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findLocalityListByNameResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__findLocalityListByNameResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findLocalityListByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findStreetListByNameRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__findStreetListByNameRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findStreetListByNameRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findStreetListByNameResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__findStreetListByNameResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findStreetListByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessMemberByGLNRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessMemberByGLNRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessMemberByGLNResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessMemberByGLNResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActivityLocationListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getActivityLocationListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActivityLocationListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActivityLocationListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getActivityLocationListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActivityLocationListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getR13nConditionListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getR13nConditionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getR13nConditionListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getR13nConditionListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getR13nConditionListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getR13nConditionListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nRegionStatusListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nRegionStatusListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nRegionStatusListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nRegionStatusListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nShippingRuleListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nShippingRuleListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nShippingRuleListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nShippingRuleListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns3__GenericVersioningEntity:
		if(p->size < 0) SOAP_DELETE((ns3__GenericVersioningEntity*)p->ptr); else SOAP_DELETE_ARRAY((ns3__GenericVersioningEntity*)p->ptr);
		break;
	case SOAP_TYPE_ns3__Error:
		if(p->size < 0) SOAP_DELETE((ns3__Error*)p->ptr); else SOAP_DELETE_ARRAY((ns3__Error*)p->ptr);
		break;
	case SOAP_TYPE_ns5__MercuryApplicationRequest:
		if(p->size < 0) SOAP_DELETE((ns5__MercuryApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__MercuryApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse:
		if(p->size < 0) SOAP_DELETE((ns5__ProcessIncomingConsignmentResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ProcessIncomingConsignmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse:
		if(p->size < 0) SOAP_DELETE((ns5__PrepareOutgoingConsignmentResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__PrepareOutgoingConsignmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__RegisterProductionOperationResponse:
		if(p->size < 0) SOAP_DELETE((ns5__RegisterProductionOperationResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__RegisterProductionOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__MergeStockEntriesResponse:
		if(p->size < 0) SOAP_DELETE((ns5__MergeStockEntriesResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__MergeStockEntriesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__WithdrawVetDocumentResponse:
		if(p->size < 0) SOAP_DELETE((ns5__WithdrawVetDocumentResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__WithdrawVetDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyBusinessEntityResponse:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyBusinessEntityResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyBusinessEntityResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyEnterpriseResponse:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyEnterpriseResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyEnterpriseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyActivityLocationsResponse:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyActivityLocationsResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyActivityLocationsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ResolveDiscrepancyResponse:
		if(p->size < 0) SOAP_DELETE((ns5__ResolveDiscrepancyResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ResolveDiscrepancyResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyProducerStockListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyProducerStockListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyProducerStockListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetVetDocumentByUuidResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetVetDocumentByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetVetDocumentByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetVetDocumentListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetVetDocumentListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetVetDocumentListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetVetDocumentChangesListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetVetDocumentChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetVetDocumentChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryByGuidResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryByUuidResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryChangesListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryVersionListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryVersionListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryVersionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateTransportMovementDetailsResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateTransportMovementDetailsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateVeterinaryEventsResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateVeterinaryEventsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse:
		if(p->size < 0) SOAP_DELETE((ns5__CheckShipmentRegionalizationResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__CheckShipmentRegionalizationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__AddBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((ns5__AddBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__AddBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetBusinessEntityUserListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetBusinessEntityUserListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateUserAuthoritiesResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateUserAuthoritiesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateUserWorkingAreasResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateUserWorkingAreasResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((ns5__UnbindBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UnbindBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse:
		if(p->size < 0) SOAP_DELETE((ns5__GetAppliedUserAuthorityListResponse*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetAppliedUserAuthorityListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns6__PurposeList:
		if(p->size < 0) SOAP_DELETE((ns6__PurposeList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__PurposeList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__UnitList:
		if(p->size < 0) SOAP_DELETE((ns6__UnitList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__UnitList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__CountryList:
		if(p->size < 0) SOAP_DELETE((ns6__CountryList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__CountryList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionList:
		if(p->size < 0) SOAP_DELETE((ns6__RegionList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__DistrictList:
		if(p->size < 0) SOAP_DELETE((ns6__DistrictList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__DistrictList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__LocalityList:
		if(p->size < 0) SOAP_DELETE((ns6__LocalityList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__LocalityList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__StreetList:
		if(p->size < 0) SOAP_DELETE((ns6__StreetList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__StreetList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__EnterpriseActivityList:
		if(p->size < 0) SOAP_DELETE((ns6__EnterpriseActivityList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__EnterpriseActivityList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__EnterpriseActivity:
		if(p->size < 0) SOAP_DELETE((ns6__EnterpriseActivity*)p->ptr); else SOAP_DELETE_ARRAY((ns6__EnterpriseActivity*)p->ptr);
		break;
	case SOAP_TYPE_ns6__EnterpriseList:
		if(p->size < 0) SOAP_DELETE((ns6__EnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__EnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__IncorporationForm:
		if(p->size < 0) SOAP_DELETE((ns6__IncorporationForm*)p->ptr); else SOAP_DELETE_ARRAY((ns6__IncorporationForm*)p->ptr);
		break;
	case SOAP_TYPE_ns6__BusinessEntityList:
		if(p->size < 0) SOAP_DELETE((ns6__BusinessEntityList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__BusinessEntityList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ProductList:
		if(p->size < 0) SOAP_DELETE((ns6__ProductList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ProductList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__SubProductList:
		if(p->size < 0) SOAP_DELETE((ns6__SubProductList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__SubProductList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ProductItemList:
		if(p->size < 0) SOAP_DELETE((ns6__ProductItemList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ProductItemList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Area:
		if(p->size < 0) SOAP_DELETE((ns6__Area*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Area*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationConditionList:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationConditionList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationConditionList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationRegionStatusList:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationRegionStatusList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationRegionStatusList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationShippingRuleList:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationShippingRuleList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationShippingRuleList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__AnimalDiseaseList:
		if(p->size < 0) SOAP_DELETE((ns6__AnimalDiseaseList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__AnimalDiseaseList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ResearchMethodList:
		if(p->size < 0) SOAP_DELETE((ns6__ResearchMethodList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ResearchMethodList*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ActivityLocationList:
		if(p->size < 0) SOAP_DELETE((ns6__ActivityLocationList*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ActivityLocationList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__Consignment:
		if(p->size < 0) SOAP_DELETE((ns7__Consignment*)p->ptr); else SOAP_DELETE_ARRAY((ns7__Consignment*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ProductiveBatch:
		if(p->size < 0) SOAP_DELETE((ns7__ProductiveBatch*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ProductiveBatch*)p->ptr);
		break;
	case SOAP_TYPE_ns7__Delivery:
		if(p->size < 0) SOAP_DELETE((ns7__Delivery*)p->ptr); else SOAP_DELETE_ARRAY((ns7__Delivery*)p->ptr);
		break;
	case SOAP_TYPE_ns7__VetDocumentList:
		if(p->size < 0) SOAP_DELETE((ns7__VetDocumentList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__VetDocumentList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__DiscrepancyReason:
		if(p->size < 0) SOAP_DELETE((ns7__DiscrepancyReason*)p->ptr); else SOAP_DELETE_ARRAY((ns7__DiscrepancyReason*)p->ptr);
		break;
	case SOAP_TYPE_ns7__StockEntryList:
		if(p->size < 0) SOAP_DELETE((ns7__StockEntryList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__StockEntryList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__Document:
		if(p->size < 0) SOAP_DELETE((ns7__Document*)p->ptr); else SOAP_DELETE_ARRAY((ns7__Document*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ShipmentRoutePoint:
		if(p->size < 0) SOAP_DELETE((ns7__ShipmentRoutePoint*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ShipmentRoutePoint*)p->ptr);
		break;
	case SOAP_TYPE_ns7__LaboratoryResearchEvent:
		if(p->size < 0) SOAP_DELETE((ns7__LaboratoryResearchEvent*)p->ptr); else SOAP_DELETE_ARRAY((ns7__LaboratoryResearchEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns7__AnimalMedicationEvent:
		if(p->size < 0) SOAP_DELETE((ns7__AnimalMedicationEvent*)p->ptr); else SOAP_DELETE_ARRAY((ns7__AnimalMedicationEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns7__QuarantineEvent:
		if(p->size < 0) SOAP_DELETE((ns7__QuarantineEvent*)p->ptr); else SOAP_DELETE_ARRAY((ns7__QuarantineEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns7__User:
		if(p->size < 0) SOAP_DELETE((ns7__User*)p->ptr); else SOAP_DELETE_ARRAY((ns7__User*)p->ptr);
		break;
	case SOAP_TYPE_ns7__UserList:
		if(p->size < 0) SOAP_DELETE((ns7__UserList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__UserList*)p->ptr);
		break;
	case SOAP_TYPE_ns7__WorkingAreaList:
		if(p->size < 0) SOAP_DELETE((ns7__WorkingAreaList*)p->ptr); else SOAP_DELETE_ARRAY((ns7__WorkingAreaList*)p->ptr);
		break;
	case SOAP_TYPE_ns4__BusinessError:
		if(p->size < 0) SOAP_DELETE((ns4__BusinessError*)p->ptr); else SOAP_DELETE_ARRAY((ns4__BusinessError*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((ns5__ProcessIncomingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ProcessIncomingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((ns5__PrepareOutgoingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__PrepareOutgoingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__RegisterProductionOperationRequest:
		if(p->size < 0) SOAP_DELETE((ns5__RegisterProductionOperationRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__RegisterProductionOperationRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__MergeStockEntriesRequest:
		if(p->size < 0) SOAP_DELETE((ns5__MergeStockEntriesRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__MergeStockEntriesRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__WithdrawVetDocumentRequest:
		if(p->size < 0) SOAP_DELETE((ns5__WithdrawVetDocumentRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__WithdrawVetDocumentRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyBusinessEntityRequest:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyBusinessEntityRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyBusinessEntityRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyEnterpriseRequest:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyEnterpriseRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyEnterpriseRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyActivityLocationsRequest:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyActivityLocationsRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyActivityLocationsRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ResolveDiscrepancyRequest:
		if(p->size < 0) SOAP_DELETE((ns5__ResolveDiscrepancyRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ResolveDiscrepancyRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ModifyProducerStockListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__ModifyProducerStockListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__ModifyProducerStockListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetVetDocumentByUuidRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetVetDocumentByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetVetDocumentByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetVetDocumentListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetVetDocumentListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetVetDocumentListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetVetDocumentChangesListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetVetDocumentChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetVetDocumentChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetStockEntryVersionListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetStockEntryVersionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetStockEntryVersionListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateTransportMovementDetailsRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateTransportMovementDetailsRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateVeterinaryEventsRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateVeterinaryEventsRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest:
		if(p->size < 0) SOAP_DELETE((ns5__CheckShipmentRegionalizationRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__CheckShipmentRegionalizationRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__AddBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((ns5__AddBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__AddBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetBusinessEntityUserListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetBusinessEntityUserListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateUserAuthoritiesRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateUserAuthoritiesRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest:
		if(p->size < 0) SOAP_DELETE((ns5__UpdateUserWorkingAreasRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UpdateUserWorkingAreasRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((ns5__UnbindBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__UnbindBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest:
		if(p->size < 0) SOAP_DELETE((ns5__GetAppliedUserAuthorityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((ns5__GetAppliedUserAuthorityListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Purpose:
		if(p->size < 0) SOAP_DELETE((ns6__Purpose*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Purpose*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Unit:
		if(p->size < 0) SOAP_DELETE((ns6__Unit*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Unit*)p->ptr);
		break;
	case SOAP_TYPE_ns6__PackingType:
		if(p->size < 0) SOAP_DELETE((ns6__PackingType*)p->ptr); else SOAP_DELETE_ARRAY((ns6__PackingType*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Country:
		if(p->size < 0) SOAP_DELETE((ns6__Country*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Country*)p->ptr);
		break;
	case SOAP_TYPE_ns6__FederalDistrict:
		if(p->size < 0) SOAP_DELETE((ns6__FederalDistrict*)p->ptr); else SOAP_DELETE_ARRAY((ns6__FederalDistrict*)p->ptr);
		break;
	case SOAP_TYPE_ns6__AddressObjectView:
		if(p->size < 0) SOAP_DELETE((ns6__AddressObjectView*)p->ptr); else SOAP_DELETE_ARRAY((ns6__AddressObjectView*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Enterprise:
		if(p->size < 0) SOAP_DELETE((ns6__Enterprise*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Enterprise*)p->ptr);
		break;
	case SOAP_TYPE__ns6__BusinessEntity_activityLocation:
		if(p->size < 0) SOAP_DELETE((_ns6__BusinessEntity_activityLocation*)p->ptr); else SOAP_DELETE_ARRAY((_ns6__BusinessEntity_activityLocation*)p->ptr);
		break;
	case SOAP_TYPE_ns6__BusinessEntity:
		if(p->size < 0) SOAP_DELETE((ns6__BusinessEntity*)p->ptr); else SOAP_DELETE_ARRAY((ns6__BusinessEntity*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ProductItem:
		if(p->size < 0) SOAP_DELETE((ns6__ProductItem*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ProductItem*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Product:
		if(p->size < 0) SOAP_DELETE((ns6__Product*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Product*)p->ptr);
		break;
	case SOAP_TYPE_ns6__SubProduct:
		if(p->size < 0) SOAP_DELETE((ns6__SubProduct*)p->ptr); else SOAP_DELETE_ARRAY((ns6__SubProduct*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ProductMarks:
		if(p->size < 0) SOAP_DELETE((ns6__ProductMarks*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ProductMarks*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Indicator:
		if(p->size < 0) SOAP_DELETE((ns6__Indicator*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Indicator*)p->ptr);
		break;
	case SOAP_TYPE_ns6__AnimalDisease:
		if(p->size < 0) SOAP_DELETE((ns6__AnimalDisease*)p->ptr); else SOAP_DELETE_ARRAY((ns6__AnimalDisease*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ResearchMethod:
		if(p->size < 0) SOAP_DELETE((ns6__ResearchMethod*)p->ptr); else SOAP_DELETE_ARRAY((ns6__ResearchMethod*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationCondition:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationCondition*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationCondition*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationShippingRule:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationShippingRule*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationShippingRule*)p->ptr);
		break;
	case SOAP_TYPE_ns6__RegionalizationRegionStatus:
		if(p->size < 0) SOAP_DELETE((ns6__RegionalizationRegionStatus*)p->ptr); else SOAP_DELETE_ARRAY((ns6__RegionalizationRegionStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns7__VetDocument:
		if(p->size < 0) SOAP_DELETE((ns7__VetDocument*)p->ptr); else SOAP_DELETE_ARRAY((ns7__VetDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns7__DiscrepancyReport:
		if(p->size < 0) SOAP_DELETE((ns7__DiscrepancyReport*)p->ptr); else SOAP_DELETE_ARRAY((ns7__DiscrepancyReport*)p->ptr);
		break;
	case SOAP_TYPE_ns7__StockEntry:
		if(p->size < 0) SOAP_DELETE((ns7__StockEntry*)p->ptr); else SOAP_DELETE_ARRAY((ns7__StockEntry*)p->ptr);
		break;
	case SOAP_TYPE_ns7__Waybill:
		if(p->size < 0) SOAP_DELETE((ns7__Waybill*)p->ptr); else SOAP_DELETE_ARRAY((ns7__Waybill*)p->ptr);
		break;
	case SOAP_TYPE_ns7__ReferencedDocument:
		if(p->size < 0) SOAP_DELETE((ns7__ReferencedDocument*)p->ptr); else SOAP_DELETE_ARRAY((ns7__ReferencedDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Region:
		if(p->size < 0) SOAP_DELETE((ns6__Region*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Region*)p->ptr);
		break;
	case SOAP_TYPE_ns6__District:
		if(p->size < 0) SOAP_DELETE((ns6__District*)p->ptr); else SOAP_DELETE_ARRAY((ns6__District*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Locality:
		if(p->size < 0) SOAP_DELETE((ns6__Locality*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Locality*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Street:
		if(p->size < 0) SOAP_DELETE((ns6__Street*)p->ptr); else SOAP_DELETE_ARRAY((ns6__Street*)p->ptr);
		break;
	case SOAP_TYPE_ns7__StockEntrySearchPattern:
		if(p->size < 0) SOAP_DELETE((ns7__StockEntrySearchPattern*)p->ptr); else SOAP_DELETE_ARRAY((ns7__StockEntrySearchPattern*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns10__submitApplicationRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns10__submitApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns10__submitApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns10__receiveApplicationResult:
		if(p->size < 0) SOAP_DELETE((struct __ns10__receiveApplicationResult*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns10__receiveApplicationResult*)p->ptr);
		break;
	case SOAP_TYPE___ns11__processIncomingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__processIncomingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__processIncomingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__prepareOutgoingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__prepareOutgoingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__prepareOutgoingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__registerProductionOperationRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__registerProductionOperationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__registerProductionOperationRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__mergeStockEntriesRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__mergeStockEntriesRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__mergeStockEntriesRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__withdrawVetDocumentRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__withdrawVetDocumentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__withdrawVetDocumentRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__modifyBusinessEntityRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__modifyBusinessEntityRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__modifyBusinessEntityRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__modifyEnterpriseRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__modifyEnterpriseRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__modifyEnterpriseRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__modifyActivityLocationsRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__modifyActivityLocationsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__modifyActivityLocationsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__resolveDiscrepancyRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__resolveDiscrepancyRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__resolveDiscrepancyRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__modifyProducerStockListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__modifyProducerStockListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__modifyProducerStockListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getVetDocumentByUuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getVetDocumentByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getVetDocumentByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getVetDocumentListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getVetDocumentListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getVetDocumentListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getVetDocumentChangesListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getVetDocumentChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getVetDocumentChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getStockEntryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getStockEntryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getStockEntryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getStockEntryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getStockEntryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getStockEntryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getStockEntryListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getStockEntryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getStockEntryListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getStockEntryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getStockEntryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getStockEntryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getStockEntryVersionListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getStockEntryVersionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getStockEntryVersionListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__updateTransportMovementDetailsRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__updateTransportMovementDetailsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__updateTransportMovementDetailsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__updateVeterinaryEventsRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__updateVeterinaryEventsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__updateVeterinaryEventsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__checkShipmentRegionalizationRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__checkShipmentRegionalizationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__checkShipmentRegionalizationRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__addBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__addBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__addBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getBusinessEntityUserListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getBusinessEntityUserListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getBusinessEntityUserListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__updateUserAuthoritiesRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__updateUserAuthoritiesRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__updateUserAuthoritiesRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__updateUserWorkingAreasRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__updateUserWorkingAreasRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__updateUserWorkingAreasRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__unbindBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__unbindBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__unbindBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns11__getAppliedUserAuthorityListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns11__getAppliedUserAuthorityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns11__getAppliedUserAuthorityListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetBusinessEntityByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetBusinessEntityByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetBusinessEntityByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetBusinessEntityByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetBusinessEntityByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetBusinessEntityByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetBusinessEntityList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetBusinessEntityList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetBusinessEntityList*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetBusinessEntityChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetBusinessEntityChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetBusinessEntityChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetEnterpriseByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetEnterpriseByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetEnterpriseByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetEnterpriseByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetEnterpriseByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetEnterpriseByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetForeignEnterpriseList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetForeignEnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetForeignEnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetRussianEnterpriseList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetRussianEnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetRussianEnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetForeignEnterpriseChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetForeignEnterpriseChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetForeignEnterpriseChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetRussianEnterpriseChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetRussianEnterpriseChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetRussianEnterpriseChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetBusinessMemberByGLN:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetBusinessMemberByGLN*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetBusinessMemberByGLN*)p->ptr);
		break;
	case SOAP_TYPE___ns9__GetActivityLocationList:
		if(p->size < 0) SOAP_DELETE((struct __ns9__GetActivityLocationList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns9__GetActivityLocationList*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_ns4__BinaryContent:
		if(p->size < 0) SOAP_DELETE((xsd__base64Binary*)p->ptr); else SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{
	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, vetisams_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * FASTCALL soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{;
	char * p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	return soap_out_byte(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if((p = soap_in_byte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Minute(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns6__Minute);
}

SOAP_FMAC3 int * FASTCALL soap_in_ns6__Minute(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns6__Minute);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 59) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Minute(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Minute);
	return soap_out_ns6__Minute(soap, tag?tag:"ns6:Minute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns6__Minute(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Minute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Hour(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns6__Hour);
}

SOAP_FMAC3 int * FASTCALL soap_in_ns6__Hour(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns6__Hour);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 23) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Hour(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Hour);
	return soap_out_ns6__Hour(soap, tag?tag:"ns6:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns6__Hour(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Day(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns6__Day);
}

SOAP_FMAC3 int * FASTCALL soap_in_ns6__Day(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns6__Day);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 31) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Day(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Day);
	return soap_out_ns6__Day(soap, tag?tag:"ns6:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns6__Day(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Month(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns6__Month);
}

SOAP_FMAC3 int * FASTCALL soap_in_ns6__Month(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns6__Month);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 12) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Month(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Month);
	return soap_out_ns6__Month(soap, tag?tag:"ns6:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns6__Month(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Year(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns6__Year);
}

SOAP_FMAC3 int * FASTCALL soap_in_ns6__Year(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns6__Year);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Year(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Year);
	return soap_out_ns6__Year(soap, tag?tag:"ns6:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns6__Year(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * FASTCALL soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	return soap_out_int(soap, tag?tag:"int", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_int(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * FASTCALL soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{;
	LONG64 * p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	return soap_out_LONG64(soap, tag?tag:"long", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if((p = soap_in_LONG64(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * FASTCALL soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{;
	unsigned char * p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	return soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if((p = soap_in_unsignedByte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * FASTCALL soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{;
	unsigned int * p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	return soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if((p = soap_in_unsignedInt(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * FASTCALL soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{;
	time_t * p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	return soap_out_time(soap, tag?tag:"dateTime", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if((p = soap_in_time(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int FASTCALL soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if(map)
		*a = (bool)(map->code != 0);
	else {
		long n;
		if(soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * FASTCALL soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	return soap_out_bool(soap, tag?tag:"boolean", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if((p = soap_in_bool(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__AnimalSpentPeriod(struct soap *soap, enum ns7__AnimalSpentPeriod *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__AnimalSpentPeriod
	*a = SOAP_DEFAULT_ns7__AnimalSpentPeriod;
#else
	*a = (enum ns7__AnimalSpentPeriod)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__AnimalSpentPeriod[] =
{	{ (long)ns7__AnimalSpentPeriod__FROM_USCOREBIRTH, "FROM_BIRTH" },
	{ (long)ns7__AnimalSpentPeriod__NOT_USCORELESS_USCORESIX_USCOREMONTHS, "NOT_LESS_SIX_MONTHS" },
	{ (long)ns7__AnimalSpentPeriod__IN_USCOREMONTHS, "IN_MONTHS" },
	{ (long)ns7__AnimalSpentPeriod__ZERO, "ZERO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__AnimalSpentPeriod2s(struct soap *soap, enum ns7__AnimalSpentPeriod n)
{
	const char *s = soap_code_str(soap_codes_ns7__AnimalSpentPeriod, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__AnimalSpentPeriod(struct soap *soap, const char *tag, int id, const enum ns7__AnimalSpentPeriod *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__AnimalSpentPeriod), type) || soap_send(soap, soap_ns7__AnimalSpentPeriod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__AnimalSpentPeriod(struct soap *soap, const char *s, enum ns7__AnimalSpentPeriod *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__AnimalSpentPeriod, s);
	if(map)
		*a = (enum ns7__AnimalSpentPeriod)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__AnimalSpentPeriod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__AnimalSpentPeriod * FASTCALL soap_in_ns7__AnimalSpentPeriod(struct soap *soap, const char *tag, enum ns7__AnimalSpentPeriod *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__AnimalSpentPeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__AnimalSpentPeriod, sizeof(enum ns7__AnimalSpentPeriod), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__AnimalSpentPeriod(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__AnimalSpentPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__AnimalSpentPeriod, 0, sizeof(enum ns7__AnimalSpentPeriod), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__AnimalSpentPeriod(struct soap *soap, const enum ns7__AnimalSpentPeriod *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__AnimalSpentPeriod);
	return soap_out_ns7__AnimalSpentPeriod(soap, tag?tag:"ns7:AnimalSpentPeriod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__AnimalSpentPeriod * SOAP_FMAC4 soap_get_ns7__AnimalSpentPeriod(struct soap *soap, enum ns7__AnimalSpentPeriod *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__AnimalSpentPeriod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__VetDocumentStatus(struct soap *soap, enum ns7__VetDocumentStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__VetDocumentStatus
	*a = SOAP_DEFAULT_ns7__VetDocumentStatus;
#else
	*a = (enum ns7__VetDocumentStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__VetDocumentStatus[] =
{	{ (long)ns7__VetDocumentStatus__CREATED, "CREATED" },
	{ (long)ns7__VetDocumentStatus__CONFIRMED, "CONFIRMED" },
	{ (long)ns7__VetDocumentStatus__WITHDRAWN, "WITHDRAWN" },
	{ (long)ns7__VetDocumentStatus__UTILIZED, "UTILIZED" },
	{ (long)ns7__VetDocumentStatus__FINALIZED, "FINALIZED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__VetDocumentStatus2s(struct soap *soap, enum ns7__VetDocumentStatus n)
{
	const char *s = soap_code_str(soap_codes_ns7__VetDocumentStatus, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocumentStatus(struct soap *soap, const char *tag, int id, const enum ns7__VetDocumentStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VetDocumentStatus), type) || soap_send(soap, soap_ns7__VetDocumentStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__VetDocumentStatus(struct soap *soap, const char *s, enum ns7__VetDocumentStatus *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__VetDocumentStatus, s);
	if(map)
		*a = (enum ns7__VetDocumentStatus)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__VetDocumentStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__VetDocumentStatus * FASTCALL soap_in_ns7__VetDocumentStatus(struct soap *soap, const char *tag, enum ns7__VetDocumentStatus *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__VetDocumentStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VetDocumentStatus, sizeof(enum ns7__VetDocumentStatus), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__VetDocumentStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__VetDocumentStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VetDocumentStatus, 0, sizeof(enum ns7__VetDocumentStatus), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__VetDocumentStatus(struct soap *soap, const enum ns7__VetDocumentStatus *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__VetDocumentStatus);
	return soap_out_ns7__VetDocumentStatus(soap, tag?tag:"ns7:VetDocumentStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VetDocumentStatus * SOAP_FMAC4 soap_get_ns7__VetDocumentStatus(struct soap *soap, enum ns7__VetDocumentStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocumentStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__VetDocumentType(struct soap *soap, enum ns7__VetDocumentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__VetDocumentType
	*a = SOAP_DEFAULT_ns7__VetDocumentType;
#else
	*a = (enum ns7__VetDocumentType)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__VetDocumentType[] =
{	{ (long)ns7__VetDocumentType__TRANSPORT, "TRANSPORT" },
	{ (long)ns7__VetDocumentType__PRODUCTIVE, "PRODUCTIVE" },
	{ (long)ns7__VetDocumentType__RETURNABLE, "RETURNABLE" },
	{ (long)ns7__VetDocumentType__INCOMING, "INCOMING" },
	{ (long)ns7__VetDocumentType__OUTGOING, "OUTGOING" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__VetDocumentType2s(struct soap *soap, enum ns7__VetDocumentType n)
{
	const char *s = soap_code_str(soap_codes_ns7__VetDocumentType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocumentType(struct soap *soap, const char *tag, int id, const enum ns7__VetDocumentType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VetDocumentType), type) || soap_send(soap, soap_ns7__VetDocumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__VetDocumentType(struct soap *soap, const char *s, enum ns7__VetDocumentType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__VetDocumentType, s);
	if(map)
		*a = (enum ns7__VetDocumentType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__VetDocumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__VetDocumentType * FASTCALL soap_in_ns7__VetDocumentType(struct soap *soap, const char *tag, enum ns7__VetDocumentType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__VetDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VetDocumentType, sizeof(enum ns7__VetDocumentType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__VetDocumentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__VetDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VetDocumentType, 0, sizeof(enum ns7__VetDocumentType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__VetDocumentType(struct soap *soap, const enum ns7__VetDocumentType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__VetDocumentType);
	return soap_out_ns7__VetDocumentType(soap, tag?tag:"ns7:VetDocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VetDocumentType * SOAP_FMAC4 soap_get_ns7__VetDocumentType(struct soap *soap, enum ns7__VetDocumentType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__VetDocumentForm(struct soap *soap, enum ns7__VetDocumentForm *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__VetDocumentForm
	*a = SOAP_DEFAULT_ns7__VetDocumentForm;
#else
	*a = (enum ns7__VetDocumentForm)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__VetDocumentForm[] =
{	{ (long)ns7__VetDocumentForm__CERTCU1, "CERTCU1" },
	{ (long)ns7__VetDocumentForm__LIC1, "LIC1" },
	{ (long)ns7__VetDocumentForm__CERTCU2, "CERTCU2" },
	{ (long)ns7__VetDocumentForm__LIC2, "LIC2" },
	{ (long)ns7__VetDocumentForm__CERTCU3, "CERTCU3" },
	{ (long)ns7__VetDocumentForm__LIC3, "LIC3" },
	{ (long)ns7__VetDocumentForm__NOTE4, "NOTE4" },
	{ (long)ns7__VetDocumentForm__CERT5I, "CERT5I" },
	{ (long)ns7__VetDocumentForm__CERT61, "CERT61" },
	{ (long)ns7__VetDocumentForm__CERT62, "CERT62" },
	{ (long)ns7__VetDocumentForm__CERT63, "CERT63" },
	{ (long)ns7__VetDocumentForm__PRODUCTIVE, "PRODUCTIVE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__VetDocumentForm2s(struct soap *soap, enum ns7__VetDocumentForm n)
{
	const char *s = soap_code_str(soap_codes_ns7__VetDocumentForm, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocumentForm(struct soap *soap, const char *tag, int id, const enum ns7__VetDocumentForm *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VetDocumentForm), type) || soap_send(soap, soap_ns7__VetDocumentForm2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__VetDocumentForm(struct soap *soap, const char *s, enum ns7__VetDocumentForm *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__VetDocumentForm, s);
	if(map)
		*a = (enum ns7__VetDocumentForm)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__VetDocumentForm)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__VetDocumentForm * FASTCALL soap_in_ns7__VetDocumentForm(struct soap *soap, const char *tag, enum ns7__VetDocumentForm *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__VetDocumentForm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VetDocumentForm, sizeof(enum ns7__VetDocumentForm), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__VetDocumentForm(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__VetDocumentForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VetDocumentForm, 0, sizeof(enum ns7__VetDocumentForm), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__VetDocumentForm(struct soap *soap, const enum ns7__VetDocumentForm *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__VetDocumentForm);
	return soap_out_ns7__VetDocumentForm(soap, tag?tag:"ns7:VetDocumentForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VetDocumentForm * SOAP_FMAC4 soap_get_ns7__VetDocumentForm(struct soap *soap, enum ns7__VetDocumentForm *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocumentForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__DeliveryInspectionResult(struct soap *soap, enum ns7__DeliveryInspectionResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__DeliveryInspectionResult
	*a = SOAP_DEFAULT_ns7__DeliveryInspectionResult;
#else
	*a = (enum ns7__DeliveryInspectionResult)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__DeliveryInspectionResult[] =
{	{ (long)ns7__DeliveryInspectionResult__CORRESPONDS, "CORRESPONDS" },
	{ (long)ns7__DeliveryInspectionResult__MISMATCH, "MISMATCH" },
	{ (long)ns7__DeliveryInspectionResult__UNSUPERVISED, "UNSUPERVISED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__DeliveryInspectionResult2s(struct soap *soap, enum ns7__DeliveryInspectionResult n)
{
	const char *s = soap_code_str(soap_codes_ns7__DeliveryInspectionResult, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__DeliveryInspectionResult(struct soap *soap, const char *tag, int id, const enum ns7__DeliveryInspectionResult *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__DeliveryInspectionResult), type) || soap_send(soap, soap_ns7__DeliveryInspectionResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__DeliveryInspectionResult(struct soap *soap, const char *s, enum ns7__DeliveryInspectionResult *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__DeliveryInspectionResult, s);
	if(map)
		*a = (enum ns7__DeliveryInspectionResult)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__DeliveryInspectionResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__DeliveryInspectionResult * FASTCALL soap_in_ns7__DeliveryInspectionResult(struct soap *soap, const char *tag, enum ns7__DeliveryInspectionResult *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__DeliveryInspectionResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__DeliveryInspectionResult, sizeof(enum ns7__DeliveryInspectionResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__DeliveryInspectionResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__DeliveryInspectionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__DeliveryInspectionResult, 0, sizeof(enum ns7__DeliveryInspectionResult), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__DeliveryInspectionResult(struct soap *soap, const enum ns7__DeliveryInspectionResult *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__DeliveryInspectionResult);
	return soap_out_ns7__DeliveryInspectionResult(soap, tag?tag:"ns7:DeliveryInspectionResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__DeliveryInspectionResult * SOAP_FMAC4 soap_get_ns7__DeliveryInspectionResult(struct soap *soap, enum ns7__DeliveryInspectionResult *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__DeliveryInspectionResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__DeliveryDecision(struct soap *soap, enum ns7__DeliveryDecision *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__DeliveryDecision
	*a = SOAP_DEFAULT_ns7__DeliveryDecision;
#else
	*a = (enum ns7__DeliveryDecision)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__DeliveryDecision[] =
{	{ (long)ns7__DeliveryDecision__ACCEPT_USCOREALL, "ACCEPT_ALL" },
	{ (long)ns7__DeliveryDecision__PARTIALLY, "PARTIALLY" },
	{ (long)ns7__DeliveryDecision__RETURN_USCOREALL, "RETURN_ALL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__DeliveryDecision2s(struct soap *soap, enum ns7__DeliveryDecision n)
{
	const char *s = soap_code_str(soap_codes_ns7__DeliveryDecision, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__DeliveryDecision(struct soap *soap, const char *tag, int id, const enum ns7__DeliveryDecision *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__DeliveryDecision), type) || soap_send(soap, soap_ns7__DeliveryDecision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__DeliveryDecision(struct soap *soap, const char *s, enum ns7__DeliveryDecision *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__DeliveryDecision, s);
	if(map)
		*a = (enum ns7__DeliveryDecision)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__DeliveryDecision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__DeliveryDecision * FASTCALL soap_in_ns7__DeliveryDecision(struct soap *soap, const char *tag, enum ns7__DeliveryDecision *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__DeliveryDecision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__DeliveryDecision, sizeof(enum ns7__DeliveryDecision), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__DeliveryDecision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__DeliveryDecision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__DeliveryDecision, 0, sizeof(enum ns7__DeliveryDecision), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__DeliveryDecision(struct soap *soap, const enum ns7__DeliveryDecision *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__DeliveryDecision);
	return soap_out_ns7__DeliveryDecision(soap, tag?tag:"ns7:DeliveryDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__DeliveryDecision * SOAP_FMAC4 soap_get_ns7__DeliveryDecision(struct soap *soap, enum ns7__DeliveryDecision *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__DeliveryDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ProductMarkingClass(struct soap *soap, enum ns6__ProductMarkingClass *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ProductMarkingClass
	*a = SOAP_DEFAULT_ns6__ProductMarkingClass;
#else
	*a = (enum ns6__ProductMarkingClass)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ProductMarkingClass[] =
{	{ (long)ns6__ProductMarkingClass__UNDEFINED, "UNDEFINED" },
	{ (long)ns6__ProductMarkingClass__BN, "BN" },
	{ (long)ns6__ProductMarkingClass__SSCC, "SSCC" },
	{ (long)ns6__ProductMarkingClass__EAN8, "EAN8" },
	{ (long)ns6__ProductMarkingClass__EAN13, "EAN13" },
	{ (long)ns6__ProductMarkingClass__EAN128, "EAN128" },
	{ (long)ns6__ProductMarkingClass__BUNDLE, "BUNDLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ProductMarkingClass2s(struct soap *soap, enum ns6__ProductMarkingClass n)
{
	const char *s = soap_code_str(soap_codes_ns6__ProductMarkingClass, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductMarkingClass(struct soap *soap, const char *tag, int id, const enum ns6__ProductMarkingClass *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProductMarkingClass), type) || soap_send(soap, soap_ns6__ProductMarkingClass2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ProductMarkingClass(struct soap *soap, const char *s, enum ns6__ProductMarkingClass *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ProductMarkingClass, s);
	if(map)
		*a = (enum ns6__ProductMarkingClass)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ProductMarkingClass)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ProductMarkingClass * FASTCALL soap_in_ns6__ProductMarkingClass(struct soap *soap, const char *tag, enum ns6__ProductMarkingClass *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ProductMarkingClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductMarkingClass, sizeof(enum ns6__ProductMarkingClass), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__ProductMarkingClass(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__ProductMarkingClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProductMarkingClass, 0, sizeof(enum ns6__ProductMarkingClass), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ProductMarkingClass(struct soap *soap, const enum ns6__ProductMarkingClass *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ProductMarkingClass);
	return soap_out_ns6__ProductMarkingClass(soap, tag?tag:"ns6:ProductMarkingClass", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ProductMarkingClass * SOAP_FMAC4 soap_get_ns6__ProductMarkingClass(struct soap *soap, enum ns6__ProductMarkingClass *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductMarkingClass(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__TransportationStorageType(struct soap *soap, enum ns6__TransportationStorageType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__TransportationStorageType
	*a = SOAP_DEFAULT_ns6__TransportationStorageType;
#else
	*a = (enum ns6__TransportationStorageType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__TransportationStorageType[] =
{	{ (long)ns6__TransportationStorageType__FROZEN, "FROZEN" },
	{ (long)ns6__TransportationStorageType__CHILLED, "CHILLED" },
	{ (long)ns6__TransportationStorageType__COOLED, "COOLED" },
	{ (long)ns6__TransportationStorageType__VENTILATED, "VENTILATED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__TransportationStorageType2s(struct soap *soap, enum ns6__TransportationStorageType n)
{
	const char *s = soap_code_str(soap_codes_ns6__TransportationStorageType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__TransportationStorageType(struct soap *soap, const char *tag, int id, const enum ns6__TransportationStorageType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__TransportationStorageType), type) || soap_send(soap, soap_ns6__TransportationStorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__TransportationStorageType(struct soap *soap, const char *s, enum ns6__TransportationStorageType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__TransportationStorageType, s);
	if(map)
		*a = (enum ns6__TransportationStorageType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__TransportationStorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__TransportationStorageType * FASTCALL soap_in_ns6__TransportationStorageType(struct soap *soap, const char *tag, enum ns6__TransportationStorageType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__TransportationStorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__TransportationStorageType, sizeof(enum ns6__TransportationStorageType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__TransportationStorageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__TransportationStorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__TransportationStorageType, 0, sizeof(enum ns6__TransportationStorageType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__TransportationStorageType(struct soap *soap, const enum ns6__TransportationStorageType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__TransportationStorageType);
	return soap_out_ns6__TransportationStorageType(soap, tag?tag:"ns6:TransportationStorageType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__TransportationStorageType * SOAP_FMAC4 soap_get_ns6__TransportationStorageType(struct soap *soap, enum ns6__TransportationStorageType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__TransportationStorageType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__DocumentNature(struct soap *soap, enum ns6__DocumentNature *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__DocumentNature
	*a = SOAP_DEFAULT_ns6__DocumentNature;
#else
	*a = (enum ns6__DocumentNature)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__DocumentNature[] =
{	{ (long)ns6__DocumentNature__ELECTRONIC, "ELECTRONIC" },
	{ (long)ns6__DocumentNature__PAPER, "PAPER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__DocumentNature2s(struct soap *soap, enum ns6__DocumentNature n)
{
	const char *s = soap_code_str(soap_codes_ns6__DocumentNature, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__DocumentNature(struct soap *soap, const char *tag, int id, const enum ns6__DocumentNature *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentNature), type) || soap_send(soap, soap_ns6__DocumentNature2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__DocumentNature(struct soap *soap, const char *s, enum ns6__DocumentNature *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__DocumentNature, s);
	if(map)
		*a = (enum ns6__DocumentNature)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__DocumentNature)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__DocumentNature * FASTCALL soap_in_ns6__DocumentNature(struct soap *soap, const char *tag, enum ns6__DocumentNature *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__DocumentNature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentNature, sizeof(enum ns6__DocumentNature), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__DocumentNature(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__DocumentNature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentNature, 0, sizeof(enum ns6__DocumentNature), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__DocumentNature(struct soap *soap, const enum ns6__DocumentNature *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__DocumentNature);
	return soap_out_ns6__DocumentNature(soap, tag?tag:"ns6:DocumentNature", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__DocumentNature * SOAP_FMAC4 soap_get_ns6__DocumentNature(struct soap *soap, enum ns6__DocumentNature *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__DocumentNature(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__EnterpriseRole(struct soap *soap, enum ns6__EnterpriseRole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__EnterpriseRole
	*a = SOAP_DEFAULT_ns6__EnterpriseRole;
#else
	*a = (enum ns6__EnterpriseRole)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__EnterpriseRole[] =
{	{ (long)ns6__EnterpriseRole__UNKNOWN, "UNKNOWN" },
	{ (long)ns6__EnterpriseRole__PRODUCER, "PRODUCER" },
	{ (long)ns6__EnterpriseRole__SLAUGHTER_USCOREHOUSE, "SLAUGHTER_HOUSE" },
	{ (long)ns6__EnterpriseRole__CUTTING_USCOREPLANT, "CUTTING_PLANT" },
	{ (long)ns6__EnterpriseRole__COLD_USCORESTORE, "COLD_STORE" },
	{ (long)ns6__EnterpriseRole__PACKAGING_USCOREPLANT, "PACKAGING_PLANT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__EnterpriseRole2s(struct soap *soap, enum ns6__EnterpriseRole n)
{
	const char *s = soap_code_str(soap_codes_ns6__EnterpriseRole, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseRole(struct soap *soap, const char *tag, int id, const enum ns6__EnterpriseRole *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseRole), type) || soap_send(soap, soap_ns6__EnterpriseRole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__EnterpriseRole(struct soap *soap, const char *s, enum ns6__EnterpriseRole *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__EnterpriseRole, s);
	if(map)
		*a = (enum ns6__EnterpriseRole)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__EnterpriseRole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__EnterpriseRole * FASTCALL soap_in_ns6__EnterpriseRole(struct soap *soap, const char *tag, enum ns6__EnterpriseRole *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__EnterpriseRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseRole, sizeof(enum ns6__EnterpriseRole), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__EnterpriseRole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__EnterpriseRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseRole, 0, sizeof(enum ns6__EnterpriseRole), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EnterpriseRole(struct soap *soap, const enum ns6__EnterpriseRole *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseRole);
	return soap_out_ns6__EnterpriseRole(soap, tag?tag:"ns6:EnterpriseRole", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__EnterpriseRole * SOAP_FMAC4 soap_get_ns6__EnterpriseRole(struct soap *soap, enum ns6__EnterpriseRole *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseRole(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ProcessingProcedureType(struct soap *soap, enum ns7__ProcessingProcedureType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__ProcessingProcedureType
	*a = SOAP_DEFAULT_ns7__ProcessingProcedureType;
#else
	*a = (enum ns7__ProcessingProcedureType)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__ProcessingProcedureType[] =
{	{ (long)ns7__ProcessingProcedureType__7, "7" },
	{ (long)ns7__ProcessingProcedureType__12, "12" },
	{ (long)ns7__ProcessingProcedureType__13, "13" },
	{ (long)ns7__ProcessingProcedureType__34, "34" },
	{ (long)ns7__ProcessingProcedureType__35, "35" },
	{ (long)ns7__ProcessingProcedureType__37, "37" },
	{ (long)ns7__ProcessingProcedureType__39, "39" },
	{ (long)ns7__ProcessingProcedureType__40, "40" },
	{ (long)ns7__ProcessingProcedureType__43, "43" },
	{ (long)ns7__ProcessingProcedureType__51, "51" },
	{ (long)ns7__ProcessingProcedureType__73, "73" },
	{ (long)ns7__ProcessingProcedureType__95, "95" },
	{ (long)ns7__ProcessingProcedureType__101, "101" },
	{ (long)ns7__ProcessingProcedureType__102, "102" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__ProcessingProcedureType2s(struct soap *soap, enum ns7__ProcessingProcedureType n)
{
	const char *s = soap_code_str(soap_codes_ns7__ProcessingProcedureType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ProcessingProcedureType(struct soap *soap, const char *tag, int id, const enum ns7__ProcessingProcedureType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ProcessingProcedureType), type) || soap_send(soap, soap_ns7__ProcessingProcedureType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__ProcessingProcedureType(struct soap *soap, const char *s, enum ns7__ProcessingProcedureType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__ProcessingProcedureType, s);
	if(map)
		*a = (enum ns7__ProcessingProcedureType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 102)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__ProcessingProcedureType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__ProcessingProcedureType * FASTCALL soap_in_ns7__ProcessingProcedureType(struct soap *soap, const char *tag, enum ns7__ProcessingProcedureType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__ProcessingProcedureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ProcessingProcedureType, sizeof(enum ns7__ProcessingProcedureType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__ProcessingProcedureType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__ProcessingProcedureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ProcessingProcedureType, 0, sizeof(enum ns7__ProcessingProcedureType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ProcessingProcedureType(struct soap *soap, const enum ns7__ProcessingProcedureType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__ProcessingProcedureType);
	return soap_out_ns7__ProcessingProcedureType(soap, tag?tag:"ns7:ProcessingProcedureType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__ProcessingProcedureType * SOAP_FMAC4 soap_get_ns7__ProcessingProcedureType(struct soap *soap, enum ns7__ProcessingProcedureType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ProcessingProcedureType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__VeterinaryEventType(struct soap *soap, enum ns7__VeterinaryEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__VeterinaryEventType
	*a = SOAP_DEFAULT_ns7__VeterinaryEventType;
#else
	*a = (enum ns7__VeterinaryEventType)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__VeterinaryEventType[] =
{	{ (long)ns7__VeterinaryEventType__UND, "UND" },
	{ (long)ns7__VeterinaryEventType__LBR, "LBR" },
	{ (long)ns7__VeterinaryEventType__VSE, "VSE" },
	{ (long)ns7__VeterinaryEventType__IMM, "IMM" },
	{ (long)ns7__VeterinaryEventType__MED, "MED" },
	{ (long)ns7__VeterinaryEventType__QRT, "QRT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__VeterinaryEventType2s(struct soap *soap, enum ns7__VeterinaryEventType n)
{
	const char *s = soap_code_str(soap_codes_ns7__VeterinaryEventType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VeterinaryEventType(struct soap *soap, const char *tag, int id, const enum ns7__VeterinaryEventType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VeterinaryEventType), type) || soap_send(soap, soap_ns7__VeterinaryEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__VeterinaryEventType(struct soap *soap, const char *s, enum ns7__VeterinaryEventType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__VeterinaryEventType, s);
	if(map)
		*a = (enum ns7__VeterinaryEventType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__VeterinaryEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__VeterinaryEventType * FASTCALL soap_in_ns7__VeterinaryEventType(struct soap *soap, const char *tag, enum ns7__VeterinaryEventType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__VeterinaryEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VeterinaryEventType, sizeof(enum ns7__VeterinaryEventType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__VeterinaryEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__VeterinaryEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VeterinaryEventType, 0, sizeof(enum ns7__VeterinaryEventType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__VeterinaryEventType(struct soap *soap, const enum ns7__VeterinaryEventType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__VeterinaryEventType);
	return soap_out_ns7__VeterinaryEventType(soap, tag?tag:"ns7:VeterinaryEventType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VeterinaryEventType * SOAP_FMAC4 soap_get_ns7__VeterinaryEventType(struct soap *soap, enum ns7__VeterinaryEventType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VeterinaryEventType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__StockEntryBlankFilter(struct soap *soap, enum ns7__StockEntryBlankFilter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns7__StockEntryBlankFilter
	*a = SOAP_DEFAULT_ns7__StockEntryBlankFilter;
#else
	*a = (enum ns7__StockEntryBlankFilter)0;
#endif
}

static const struct soap_code_map soap_codes_ns7__StockEntryBlankFilter[] =
{	{ (long)ns7__StockEntryBlankFilter__ALL, "ALL" },
	{ (long)ns7__StockEntryBlankFilter__BLANK, "BLANK" },
	{ (long)ns7__StockEntryBlankFilter__NOT_USCOREBLANK, "NOT_BLANK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__StockEntryBlankFilter2s(struct soap *soap, enum ns7__StockEntryBlankFilter n)
{
	const char *s = soap_code_str(soap_codes_ns7__StockEntryBlankFilter, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockEntryBlankFilter(struct soap *soap, const char *tag, int id, const enum ns7__StockEntryBlankFilter *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__StockEntryBlankFilter), type) || soap_send(soap, soap_ns7__StockEntryBlankFilter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__StockEntryBlankFilter(struct soap *soap, const char *s, enum ns7__StockEntryBlankFilter *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__StockEntryBlankFilter, s);
	if(map)
		*a = (enum ns7__StockEntryBlankFilter)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__StockEntryBlankFilter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__StockEntryBlankFilter * FASTCALL soap_in_ns7__StockEntryBlankFilter(struct soap *soap, const char *tag, enum ns7__StockEntryBlankFilter *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__StockEntryBlankFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__StockEntryBlankFilter, sizeof(enum ns7__StockEntryBlankFilter), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns7__StockEntryBlankFilter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns7__StockEntryBlankFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__StockEntryBlankFilter, 0, sizeof(enum ns7__StockEntryBlankFilter), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__StockEntryBlankFilter(struct soap *soap, const enum ns7__StockEntryBlankFilter *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__StockEntryBlankFilter);
	return soap_out_ns7__StockEntryBlankFilter(soap, tag?tag:"ns7:StockEntryBlankFilter", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__StockEntryBlankFilter * SOAP_FMAC4 soap_get_ns7__StockEntryBlankFilter(struct soap *soap, enum ns7__StockEntryBlankFilter *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockEntryBlankFilter(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__VaccinationType(struct soap *soap, enum ns6__VaccinationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__VaccinationType
	*a = SOAP_DEFAULT_ns6__VaccinationType;
#else
	*a = (enum ns6__VaccinationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__VaccinationType[] =
{	{ (long)ns6__VaccinationType__UNDEFINED, "UNDEFINED" },
	{ (long)ns6__VaccinationType__APPLIED, "APPLIED" },
	{ (long)ns6__VaccinationType__UNVACCINATED, "UNVACCINATED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__VaccinationType2s(struct soap *soap, enum ns6__VaccinationType n)
{
	const char *s = soap_code_str(soap_codes_ns6__VaccinationType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__VaccinationType(struct soap *soap, const char *tag, int id, const enum ns6__VaccinationType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__VaccinationType), type) || soap_send(soap, soap_ns6__VaccinationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__VaccinationType(struct soap *soap, const char *s, enum ns6__VaccinationType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__VaccinationType, s);
	if(map)
		*a = (enum ns6__VaccinationType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__VaccinationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__VaccinationType * FASTCALL soap_in_ns6__VaccinationType(struct soap *soap, const char *tag, enum ns6__VaccinationType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__VaccinationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__VaccinationType, sizeof(enum ns6__VaccinationType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__VaccinationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__VaccinationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__VaccinationType, 0, sizeof(enum ns6__VaccinationType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__VaccinationType(struct soap *soap, const enum ns6__VaccinationType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__VaccinationType);
	return soap_out_ns6__VaccinationType(soap, tag?tag:"ns6:VaccinationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__VaccinationType * SOAP_FMAC4 soap_get_ns6__VaccinationType(struct soap *soap, enum ns6__VaccinationType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__VaccinationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ProsperityType(struct soap *soap, enum ns6__ProsperityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ProsperityType
	*a = SOAP_DEFAULT_ns6__ProsperityType;
#else
	*a = (enum ns6__ProsperityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ProsperityType[] =
{	{ (long)ns6__ProsperityType__UNDEFINED, "UNDEFINED" },
	{ (long)ns6__ProsperityType__UNKNOWN, "UNKNOWN" },
	{ (long)ns6__ProsperityType__SAFE, "SAFE" },
	{ (long)ns6__ProsperityType__UNSAFE, "UNSAFE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ProsperityType2s(struct soap *soap, enum ns6__ProsperityType n)
{
	const char *s = soap_code_str(soap_codes_ns6__ProsperityType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProsperityType(struct soap *soap, const char *tag, int id, const enum ns6__ProsperityType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProsperityType), type) || soap_send(soap, soap_ns6__ProsperityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ProsperityType(struct soap *soap, const char *s, enum ns6__ProsperityType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ProsperityType, s);
	if(map)
		*a = (enum ns6__ProsperityType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ProsperityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ProsperityType * FASTCALL soap_in_ns6__ProsperityType(struct soap *soap, const char *tag, enum ns6__ProsperityType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ProsperityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProsperityType, sizeof(enum ns6__ProsperityType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__ProsperityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__ProsperityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProsperityType, 0, sizeof(enum ns6__ProsperityType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ProsperityType(struct soap *soap, const enum ns6__ProsperityType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ProsperityType);
	return soap_out_ns6__ProsperityType(soap, tag?tag:"ns6:ProsperityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ProsperityType * SOAP_FMAC4 soap_get_ns6__ProsperityType(struct soap *soap, enum ns6__ProsperityType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProsperityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__RegionalizationDecision(struct soap *soap, enum ns6__RegionalizationDecision *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__RegionalizationDecision
	*a = SOAP_DEFAULT_ns6__RegionalizationDecision;
#else
	*a = (enum ns6__RegionalizationDecision)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__RegionalizationDecision[] =
{	{ (long)ns6__RegionalizationDecision__1, "1" },
	{ (long)ns6__RegionalizationDecision__2, "2" },
	{ (long)ns6__RegionalizationDecision__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__RegionalizationDecision2s(struct soap *soap, enum ns6__RegionalizationDecision n)
{
	const char *s = soap_code_str(soap_codes_ns6__RegionalizationDecision, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationDecision(struct soap *soap, const char *tag, int id, const enum ns6__RegionalizationDecision *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationDecision), type) || soap_send(soap, soap_ns6__RegionalizationDecision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__RegionalizationDecision(struct soap *soap, const char *s, enum ns6__RegionalizationDecision *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__RegionalizationDecision, s);
	if(map)
		*a = (enum ns6__RegionalizationDecision)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__RegionalizationDecision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__RegionalizationDecision * FASTCALL soap_in_ns6__RegionalizationDecision(struct soap *soap, const char *tag, enum ns6__RegionalizationDecision *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__RegionalizationDecision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationDecision, sizeof(enum ns6__RegionalizationDecision), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__RegionalizationDecision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__RegionalizationDecision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationDecision, 0, sizeof(enum ns6__RegionalizationDecision), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__RegionalizationDecision(struct soap *soap, const enum ns6__RegionalizationDecision *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationDecision);
	return soap_out_ns6__RegionalizationDecision(soap, tag?tag:"ns6:RegionalizationDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__RegionalizationDecision * SOAP_FMAC4 soap_get_ns6__RegionalizationDecision(struct soap *soap, enum ns6__RegionalizationDecision *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ResearchResult(struct soap *soap, enum ns6__ResearchResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ResearchResult
	*a = SOAP_DEFAULT_ns6__ResearchResult;
#else
	*a = (enum ns6__ResearchResult)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ResearchResult[] =
{	{ (long)ns6__ResearchResult__UNKNOWN, "UNKNOWN" },
	{ (long)ns6__ResearchResult__UNDEFINED, "UNDEFINED" },
	{ (long)ns6__ResearchResult__POSITIVE, "POSITIVE" },
	{ (long)ns6__ResearchResult__NEGATIVE, "NEGATIVE" },
	{ (long)ns6__ResearchResult__UNFULFILLED, "UNFULFILLED" },
	{ (long)ns6__ResearchResult__VSERAW, "VSERAW" },
	{ (long)ns6__ResearchResult__VSEFULL, "VSEFULL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ResearchResult2s(struct soap *soap, enum ns6__ResearchResult n)
{
	const char *s = soap_code_str(soap_codes_ns6__ResearchResult, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ResearchResult(struct soap *soap, const char *tag, int id, const enum ns6__ResearchResult *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ResearchResult), type) || soap_send(soap, soap_ns6__ResearchResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ResearchResult(struct soap *soap, const char *s, enum ns6__ResearchResult *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ResearchResult, s);
	if(map)
		*a = (enum ns6__ResearchResult)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ResearchResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ResearchResult * FASTCALL soap_in_ns6__ResearchResult(struct soap *soap, const char *tag, enum ns6__ResearchResult *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ResearchResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ResearchResult, sizeof(enum ns6__ResearchResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__ResearchResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__ResearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ResearchResult, 0, sizeof(enum ns6__ResearchResult), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ResearchResult(struct soap *soap, const enum ns6__ResearchResult *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ResearchResult);
	return soap_out_ns6__ResearchResult(soap, tag?tag:"ns6:ResearchResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ResearchResult * SOAP_FMAC4 soap_get_ns6__ResearchResult(struct soap *soap, enum ns6__ResearchResult *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ResearchResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__TransportType(struct soap *soap, enum ns6__TransportType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__TransportType
	*a = SOAP_DEFAULT_ns6__TransportType;
#else
	*a = (enum ns6__TransportType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__TransportType[] =
{	{ (long)ns6__TransportType__1, "1" },
	{ (long)ns6__TransportType__2, "2" },
	{ (long)ns6__TransportType__3, "3" },
	{ (long)ns6__TransportType__4, "4" },
	{ (long)ns6__TransportType__5, "5" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__TransportType2s(struct soap *soap, enum ns6__TransportType n)
{
	const char *s = soap_code_str(soap_codes_ns6__TransportType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__TransportType(struct soap *soap, const char *tag, int id, const enum ns6__TransportType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__TransportType), type) || soap_send(soap, soap_ns6__TransportType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__TransportType(struct soap *soap, const char *s, enum ns6__TransportType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__TransportType, s);
	if(map)
		*a = (enum ns6__TransportType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__TransportType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__TransportType * FASTCALL soap_in_ns6__TransportType(struct soap *soap, const char *tag, enum ns6__TransportType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__TransportType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__TransportType, sizeof(enum ns6__TransportType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__TransportType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__TransportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__TransportType, 0, sizeof(enum ns6__TransportType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__TransportType(struct soap *soap, const enum ns6__TransportType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__TransportType);
	return soap_out_ns6__TransportType(soap, tag?tag:"ns6:TransportType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__TransportType * SOAP_FMAC4 soap_get_ns6__TransportType(struct soap *soap, enum ns6__TransportType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__TransportType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ReferenceType(struct soap *soap, enum ns6__ReferenceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ReferenceType
	*a = SOAP_DEFAULT_ns6__ReferenceType;
#else
	*a = (enum ns6__ReferenceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ReferenceType[] =
{	{ (long)ns6__ReferenceType__1, "1" },
	{ (long)ns6__ReferenceType__2, "2" },
	{ (long)ns6__ReferenceType__3, "3" },
	{ (long)ns6__ReferenceType__4, "4" },
	{ (long)ns6__ReferenceType__5, "5" },
	{ (long)ns6__ReferenceType__6, "6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ReferenceType2s(struct soap *soap, enum ns6__ReferenceType n)
{
	const char *s = soap_code_str(soap_codes_ns6__ReferenceType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ReferenceType(struct soap *soap, const char *tag, int id, const enum ns6__ReferenceType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ReferenceType), type) || soap_send(soap, soap_ns6__ReferenceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ReferenceType(struct soap *soap, const char *s, enum ns6__ReferenceType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ReferenceType, s);
	if(map)
		*a = (enum ns6__ReferenceType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ReferenceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ReferenceType * FASTCALL soap_in_ns6__ReferenceType(struct soap *soap, const char *tag, enum ns6__ReferenceType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ReferenceType, sizeof(enum ns6__ReferenceType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__ReferenceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ReferenceType, 0, sizeof(enum ns6__ReferenceType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ReferenceType(struct soap *soap, const enum ns6__ReferenceType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ReferenceType);
	return soap_out_ns6__ReferenceType(soap, tag?tag:"ns6:ReferenceType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ReferenceType * SOAP_FMAC4 soap_get_ns6__ReferenceType(struct soap *soap, enum ns6__ReferenceType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ReferenceType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__DocumentType(struct soap *soap, enum ns6__DocumentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__DocumentType
	*a = SOAP_DEFAULT_ns6__DocumentType;
#else
	*a = (enum ns6__DocumentType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__DocumentType[] =
{	{ (long)ns6__DocumentType__1, "1" },
	{ (long)ns6__DocumentType__2, "2" },
	{ (long)ns6__DocumentType__3, "3" },
	{ (long)ns6__DocumentType__4, "4" },
	{ (long)ns6__DocumentType__5, "5" },
	{ (long)ns6__DocumentType__6, "6" },
	{ (long)ns6__DocumentType__7, "7" },
	{ (long)ns6__DocumentType__8, "8" },
	{ (long)ns6__DocumentType__9, "9" },
	{ (long)ns6__DocumentType__10, "10" },
	{ (long)ns6__DocumentType__11, "11" },
	{ (long)ns6__DocumentType__12, "12" },
	{ (long)ns6__DocumentType__13, "13" },
	{ (long)ns6__DocumentType__14, "14" },
	{ (long)ns6__DocumentType__15, "15" },
	{ (long)ns6__DocumentType__16, "16" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__DocumentType2s(struct soap *soap, enum ns6__DocumentType n)
{
	const char *s = soap_code_str(soap_codes_ns6__DocumentType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__DocumentType(struct soap *soap, const char *tag, int id, const enum ns6__DocumentType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentType), type) || soap_send(soap, soap_ns6__DocumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__DocumentType(struct soap *soap, const char *s, enum ns6__DocumentType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__DocumentType, s);
	if(map)
		*a = (enum ns6__DocumentType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__DocumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__DocumentType * FASTCALL soap_in_ns6__DocumentType(struct soap *soap, const char *tag, enum ns6__DocumentType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__DocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentType, sizeof(enum ns6__DocumentType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__DocumentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__DocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentType, 0, sizeof(enum ns6__DocumentType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__DocumentType(struct soap *soap, const enum ns6__DocumentType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__DocumentType);
	return soap_out_ns6__DocumentType(soap, tag?tag:"ns6:DocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__DocumentType * SOAP_FMAC4 soap_get_ns6__DocumentType(struct soap *soap, enum ns6__DocumentType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__DocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ProductType(struct soap *soap, enum ns6__ProductType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ProductType
	*a = SOAP_DEFAULT_ns6__ProductType;
#else
	*a = (enum ns6__ProductType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ProductType[] =
{	{ (long)ns6__ProductType__1, "1" },
	{ (long)ns6__ProductType__2, "2" },
	{ (long)ns6__ProductType__3, "3" },
	{ (long)ns6__ProductType__4, "4" },
	{ (long)ns6__ProductType__5, "5" },
	{ (long)ns6__ProductType__6, "6" },
	{ (long)ns6__ProductType__7, "7" },
	{ (long)ns6__ProductType__8, "8" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ProductType2s(struct soap *soap, enum ns6__ProductType n)
{
	const char *s = soap_code_str(soap_codes_ns6__ProductType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductType(struct soap *soap, const char *tag, int id, const enum ns6__ProductType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProductType), type) || soap_send(soap, soap_ns6__ProductType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ProductType(struct soap *soap, const char *s, enum ns6__ProductType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ProductType, s);
	if(map)
		*a = (enum ns6__ProductType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ProductType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ProductType * FASTCALL soap_in_ns6__ProductType(struct soap *soap, const char *tag, enum ns6__ProductType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ProductType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductType, sizeof(enum ns6__ProductType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__ProductType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__ProductType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProductType, 0, sizeof(enum ns6__ProductType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ProductType(struct soap *soap, const enum ns6__ProductType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ProductType);
	return soap_out_ns6__ProductType(soap, tag?tag:"ns6:ProductType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ProductType * SOAP_FMAC4 soap_get_ns6__ProductType(struct soap *soap, enum ns6__ProductType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__BusinessEntityType(struct soap *soap, enum ns6__BusinessEntityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__BusinessEntityType
	*a = SOAP_DEFAULT_ns6__BusinessEntityType;
#else
	*a = (enum ns6__BusinessEntityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__BusinessEntityType[] =
{	{ (long)ns6__BusinessEntityType__1, "1" },
	{ (long)ns6__BusinessEntityType__2, "2" },
	{ (long)ns6__BusinessEntityType__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__BusinessEntityType2s(struct soap *soap, enum ns6__BusinessEntityType n)
{
	const char *s = soap_code_str(soap_codes_ns6__BusinessEntityType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__BusinessEntityType(struct soap *soap, const char *tag, int id, const enum ns6__BusinessEntityType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BusinessEntityType), type) || soap_send(soap, soap_ns6__BusinessEntityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__BusinessEntityType(struct soap *soap, const char *s, enum ns6__BusinessEntityType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__BusinessEntityType, s);
	if(map)
		*a = (enum ns6__BusinessEntityType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__BusinessEntityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__BusinessEntityType * FASTCALL soap_in_ns6__BusinessEntityType(struct soap *soap, const char *tag, enum ns6__BusinessEntityType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__BusinessEntityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BusinessEntityType, sizeof(enum ns6__BusinessEntityType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__BusinessEntityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__BusinessEntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BusinessEntityType, 0, sizeof(enum ns6__BusinessEntityType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__BusinessEntityType(struct soap *soap, const enum ns6__BusinessEntityType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__BusinessEntityType);
	return soap_out_ns6__BusinessEntityType(soap, tag?tag:"ns6:BusinessEntityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__BusinessEntityType * SOAP_FMAC4 soap_get_ns6__BusinessEntityType(struct soap *soap, enum ns6__BusinessEntityType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__BusinessEntityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__EnterpriseGroup(struct soap *soap, enum ns6__EnterpriseGroup *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__EnterpriseGroup
	*a = SOAP_DEFAULT_ns6__EnterpriseGroup;
#else
	*a = (enum ns6__EnterpriseGroup)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__EnterpriseGroup[] =
{	{ (long)ns6__EnterpriseGroup__0, "0" },
	{ (long)ns6__EnterpriseGroup__1, "1" },
	{ (long)ns6__EnterpriseGroup__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__EnterpriseGroup2s(struct soap *soap, enum ns6__EnterpriseGroup n)
{
	const char *s = soap_code_str(soap_codes_ns6__EnterpriseGroup, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseGroup(struct soap *soap, const char *tag, int id, const enum ns6__EnterpriseGroup *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseGroup), type) || soap_send(soap, soap_ns6__EnterpriseGroup2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__EnterpriseGroup(struct soap *soap, const char *s, enum ns6__EnterpriseGroup *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__EnterpriseGroup, s);
	if(map)
		*a = (enum ns6__EnterpriseGroup)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__EnterpriseGroup)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__EnterpriseGroup * FASTCALL soap_in_ns6__EnterpriseGroup(struct soap *soap, const char *tag, enum ns6__EnterpriseGroup *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__EnterpriseGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseGroup, sizeof(enum ns6__EnterpriseGroup), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__EnterpriseGroup(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__EnterpriseGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseGroup, 0, sizeof(enum ns6__EnterpriseGroup), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EnterpriseGroup(struct soap *soap, const enum ns6__EnterpriseGroup *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseGroup);
	return soap_out_ns6__EnterpriseGroup(soap, tag?tag:"ns6:EnterpriseGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__EnterpriseGroup * SOAP_FMAC4 soap_get_ns6__EnterpriseGroup(struct soap *soap, enum ns6__EnterpriseGroup *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__PackingCodeType(struct soap *soap, enum ns6__PackingCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__PackingCodeType
	*a = SOAP_DEFAULT_ns6__PackingCodeType;
#else
	*a = (enum ns6__PackingCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__PackingCodeType[] =
{	{ (long)ns6__PackingCodeType__1A, "1A" },
	{ (long)ns6__PackingCodeType__1B, "1B" },
	{ (long)ns6__PackingCodeType__1D, "1D" },
	{ (long)ns6__PackingCodeType__1F, "1F" },
	{ (long)ns6__PackingCodeType__1G, "1G" },
	{ (long)ns6__PackingCodeType__1W, "1W" },
	{ (long)ns6__PackingCodeType__2C, "2C" },
	{ (long)ns6__PackingCodeType__3A, "3A" },
	{ (long)ns6__PackingCodeType__3H, "3H" },
	{ (long)ns6__PackingCodeType__43, "43" },
	{ (long)ns6__PackingCodeType__44, "44" },
	{ (long)ns6__PackingCodeType__4A, "4A" },
	{ (long)ns6__PackingCodeType__4B, "4B" },
	{ (long)ns6__PackingCodeType__4C, "4C" },
	{ (long)ns6__PackingCodeType__4D, "4D" },
	{ (long)ns6__PackingCodeType__4F, "4F" },
	{ (long)ns6__PackingCodeType__4G, "4G" },
	{ (long)ns6__PackingCodeType__4H, "4H" },
	{ (long)ns6__PackingCodeType__5H, "5H" },
	{ (long)ns6__PackingCodeType__5L, "5L" },
	{ (long)ns6__PackingCodeType__5M, "5M" },
	{ (long)ns6__PackingCodeType__6H, "6H" },
	{ (long)ns6__PackingCodeType__6P, "6P" },
	{ (long)ns6__PackingCodeType__7A, "7A" },
	{ (long)ns6__PackingCodeType__7B, "7B" },
	{ (long)ns6__PackingCodeType__8A, "8A" },
	{ (long)ns6__PackingCodeType__8B, "8B" },
	{ (long)ns6__PackingCodeType__8C, "8C" },
	{ (long)ns6__PackingCodeType__AA, "AA" },
	{ (long)ns6__PackingCodeType__AB, "AB" },
	{ (long)ns6__PackingCodeType__AC, "AC" },
	{ (long)ns6__PackingCodeType__AD, "AD" },
	{ (long)ns6__PackingCodeType__AE, "AE" },
	{ (long)ns6__PackingCodeType__AF, "AF" },
	{ (long)ns6__PackingCodeType__AG, "AG" },
	{ (long)ns6__PackingCodeType__AH, "AH" },
	{ (long)ns6__PackingCodeType__AI, "AI" },
	{ (long)ns6__PackingCodeType__AJ, "AJ" },
	{ (long)ns6__PackingCodeType__AL, "AL" },
	{ (long)ns6__PackingCodeType__AM, "AM" },
	{ (long)ns6__PackingCodeType__AP, "AP" },
	{ (long)ns6__PackingCodeType__AT, "AT" },
	{ (long)ns6__PackingCodeType__AV, "AV" },
	{ (long)ns6__PackingCodeType__B4, "B4" },
	{ (long)ns6__PackingCodeType__BA, "BA" },
	{ (long)ns6__PackingCodeType__BB, "BB" },
	{ (long)ns6__PackingCodeType__BC, "BC" },
	{ (long)ns6__PackingCodeType__BD, "BD" },
	{ (long)ns6__PackingCodeType__BE, "BE" },
	{ (long)ns6__PackingCodeType__BF, "BF" },
	{ (long)ns6__PackingCodeType__BG, "BG" },
	{ (long)ns6__PackingCodeType__BH, "BH" },
	{ (long)ns6__PackingCodeType__BI, "BI" },
	{ (long)ns6__PackingCodeType__BJ, "BJ" },
	{ (long)ns6__PackingCodeType__BK, "BK" },
	{ (long)ns6__PackingCodeType__BL, "BL" },
	{ (long)ns6__PackingCodeType__BM, "BM" },
	{ (long)ns6__PackingCodeType__BN, "BN" },
	{ (long)ns6__PackingCodeType__BO, "BO" },
	{ (long)ns6__PackingCodeType__BP, "BP" },
	{ (long)ns6__PackingCodeType__BQ, "BQ" },
	{ (long)ns6__PackingCodeType__BR, "BR" },
	{ (long)ns6__PackingCodeType__BS, "BS" },
	{ (long)ns6__PackingCodeType__BT, "BT" },
	{ (long)ns6__PackingCodeType__BU, "BU" },
	{ (long)ns6__PackingCodeType__BV, "BV" },
	{ (long)ns6__PackingCodeType__BW, "BW" },
	{ (long)ns6__PackingCodeType__BX, "BX" },
	{ (long)ns6__PackingCodeType__BY, "BY" },
	{ (long)ns6__PackingCodeType__BZ, "BZ" },
	{ (long)ns6__PackingCodeType__CA, "CA" },
	{ (long)ns6__PackingCodeType__CB, "CB" },
	{ (long)ns6__PackingCodeType__CC, "CC" },
	{ (long)ns6__PackingCodeType__CD, "CD" },
	{ (long)ns6__PackingCodeType__CE, "CE" },
	{ (long)ns6__PackingCodeType__CF, "CF" },
	{ (long)ns6__PackingCodeType__CG, "CG" },
	{ (long)ns6__PackingCodeType__CH, "CH" },
	{ (long)ns6__PackingCodeType__CI, "CI" },
	{ (long)ns6__PackingCodeType__CJ, "CJ" },
	{ (long)ns6__PackingCodeType__CK, "CK" },
	{ (long)ns6__PackingCodeType__CL, "CL" },
	{ (long)ns6__PackingCodeType__CM, "CM" },
	{ (long)ns6__PackingCodeType__CN, "CN" },
	{ (long)ns6__PackingCodeType__CO, "CO" },
	{ (long)ns6__PackingCodeType__CP, "CP" },
	{ (long)ns6__PackingCodeType__CQ, "CQ" },
	{ (long)ns6__PackingCodeType__CR, "CR" },
	{ (long)ns6__PackingCodeType__CS, "CS" },
	{ (long)ns6__PackingCodeType__CT, "CT" },
	{ (long)ns6__PackingCodeType__CU, "CU" },
	{ (long)ns6__PackingCodeType__CV, "CV" },
	{ (long)ns6__PackingCodeType__CW, "CW" },
	{ (long)ns6__PackingCodeType__CX, "CX" },
	{ (long)ns6__PackingCodeType__CY, "CY" },
	{ (long)ns6__PackingCodeType__CZ, "CZ" },
	{ (long)ns6__PackingCodeType__DA, "DA" },
	{ (long)ns6__PackingCodeType__DB, "DB" },
	{ (long)ns6__PackingCodeType__DC, "DC" },
	{ (long)ns6__PackingCodeType__DG, "DG" },
	{ (long)ns6__PackingCodeType__DH, "DH" },
	{ (long)ns6__PackingCodeType__DI, "DI" },
	{ (long)ns6__PackingCodeType__DJ, "DJ" },
	{ (long)ns6__PackingCodeType__DK, "DK" },
	{ (long)ns6__PackingCodeType__DL, "DL" },
	{ (long)ns6__PackingCodeType__DM, "DM" },
	{ (long)ns6__PackingCodeType__DN, "DN" },
	{ (long)ns6__PackingCodeType__DP, "DP" },
	{ (long)ns6__PackingCodeType__DR, "DR" },
	{ (long)ns6__PackingCodeType__DS, "DS" },
	{ (long)ns6__PackingCodeType__DT, "DT" },
	{ (long)ns6__PackingCodeType__DU, "DU" },
	{ (long)ns6__PackingCodeType__DV, "DV" },
	{ (long)ns6__PackingCodeType__DW, "DW" },
	{ (long)ns6__PackingCodeType__DX, "DX" },
	{ (long)ns6__PackingCodeType__DY, "DY" },
	{ (long)ns6__PackingCodeType__EC, "EC" },
	{ (long)ns6__PackingCodeType__ED, "ED" },
	{ (long)ns6__PackingCodeType__EE, "EE" },
	{ (long)ns6__PackingCodeType__EF, "EF" },
	{ (long)ns6__PackingCodeType__EG, "EG" },
	{ (long)ns6__PackingCodeType__EH, "EH" },
	{ (long)ns6__PackingCodeType__EI, "EI" },
	{ (long)ns6__PackingCodeType__EN, "EN" },
	{ (long)ns6__PackingCodeType__FC, "FC" },
	{ (long)ns6__PackingCodeType__FD, "FD" },
	{ (long)ns6__PackingCodeType__FE, "FE" },
	{ (long)ns6__PackingCodeType__FI, "FI" },
	{ (long)ns6__PackingCodeType__FL, "FL" },
	{ (long)ns6__PackingCodeType__FO, "FO" },
	{ (long)ns6__PackingCodeType__FP, "FP" },
	{ (long)ns6__PackingCodeType__FR, "FR" },
	{ (long)ns6__PackingCodeType__FT, "FT" },
	{ (long)ns6__PackingCodeType__FX, "FX" },
	{ (long)ns6__PackingCodeType__GB, "GB" },
	{ (long)ns6__PackingCodeType__GI, "GI" },
	{ (long)ns6__PackingCodeType__GL, "GL" },
	{ (long)ns6__PackingCodeType__GR, "GR" },
	{ (long)ns6__PackingCodeType__GY, "GY" },
	{ (long)ns6__PackingCodeType__GZ, "GZ" },
	{ (long)ns6__PackingCodeType__HA, "HA" },
	{ (long)ns6__PackingCodeType__HB, "HB" },
	{ (long)ns6__PackingCodeType__HC, "HC" },
	{ (long)ns6__PackingCodeType__HG, "HG" },
	{ (long)ns6__PackingCodeType__HN, "HN" },
	{ (long)ns6__PackingCodeType__HR, "HR" },
	{ (long)ns6__PackingCodeType__IA, "IA" },
	{ (long)ns6__PackingCodeType__IB, "IB" },
	{ (long)ns6__PackingCodeType__IC, "IC" },
	{ (long)ns6__PackingCodeType__ID, "ID" },
	{ (long)ns6__PackingCodeType__IE, "IE" },
	{ (long)ns6__PackingCodeType__IF, "IF" },
	{ (long)ns6__PackingCodeType__IG, "IG" },
	{ (long)ns6__PackingCodeType__IH, "IH" },
	{ (long)ns6__PackingCodeType__IK, "IK" },
	{ (long)ns6__PackingCodeType__IN, "IN" },
	{ (long)ns6__PackingCodeType__IZ, "IZ" },
	{ (long)ns6__PackingCodeType__JB, "JB" },
	{ (long)ns6__PackingCodeType__JC, "JC" },
	{ (long)ns6__PackingCodeType__JG, "JG" },
	{ (long)ns6__PackingCodeType__JR, "JR" },
	{ (long)ns6__PackingCodeType__JT, "JT" },
	{ (long)ns6__PackingCodeType__JY, "JY" },
	{ (long)ns6__PackingCodeType__KG, "KG" },
	{ (long)ns6__PackingCodeType__KI, "KI" },
	{ (long)ns6__PackingCodeType__LE, "LE" },
	{ (long)ns6__PackingCodeType__LG, "LG" },
	{ (long)ns6__PackingCodeType__LT, "LT" },
	{ (long)ns6__PackingCodeType__LU, "LU" },
	{ (long)ns6__PackingCodeType__LV, "LV" },
	{ (long)ns6__PackingCodeType__LZ, "LZ" },
	{ (long)ns6__PackingCodeType__MA, "MA" },
	{ (long)ns6__PackingCodeType__MB, "MB" },
	{ (long)ns6__PackingCodeType__MC, "MC" },
	{ (long)ns6__PackingCodeType__ME, "ME" },
	{ (long)ns6__PackingCodeType__MR, "MR" },
	{ (long)ns6__PackingCodeType__MS, "MS" },
	{ (long)ns6__PackingCodeType__MT, "MT" },
	{ (long)ns6__PackingCodeType__MW, "MW" },
	{ (long)ns6__PackingCodeType__MX, "MX" },
	{ (long)ns6__PackingCodeType__NA, "NA" },
	{ (long)ns6__PackingCodeType__NE, "NE" },
	{ (long)ns6__PackingCodeType__NF, "NF" },
	{ (long)ns6__PackingCodeType__NG, "NG" },
	{ (long)ns6__PackingCodeType__NS, "NS" },
	{ (long)ns6__PackingCodeType__NT, "NT" },
	{ (long)ns6__PackingCodeType__NU, "NU" },
	{ (long)ns6__PackingCodeType__NV, "NV" },
	{ (long)ns6__PackingCodeType__OT, "OT" },
	{ (long)ns6__PackingCodeType__OU, "OU" },
	{ (long)ns6__PackingCodeType__P2, "P2" },
	{ (long)ns6__PackingCodeType__PA, "PA" },
	{ (long)ns6__PackingCodeType__PB, "PB" },
	{ (long)ns6__PackingCodeType__PC, "PC" },
	{ (long)ns6__PackingCodeType__PD, "PD" },
	{ (long)ns6__PackingCodeType__PE, "PE" },
	{ (long)ns6__PackingCodeType__PF, "PF" },
	{ (long)ns6__PackingCodeType__PG, "PG" },
	{ (long)ns6__PackingCodeType__PH, "PH" },
	{ (long)ns6__PackingCodeType__PI, "PI" },
	{ (long)ns6__PackingCodeType__PJ, "PJ" },
	{ (long)ns6__PackingCodeType__PK, "PK" },
	{ (long)ns6__PackingCodeType__PL, "PL" },
	{ (long)ns6__PackingCodeType__PN, "PN" },
	{ (long)ns6__PackingCodeType__PO, "PO" },
	{ (long)ns6__PackingCodeType__PP, "PP" },
	{ (long)ns6__PackingCodeType__PR, "PR" },
	{ (long)ns6__PackingCodeType__PT, "PT" },
	{ (long)ns6__PackingCodeType__PU, "PU" },
	{ (long)ns6__PackingCodeType__PV, "PV" },
	{ (long)ns6__PackingCodeType__PX, "PX" },
	{ (long)ns6__PackingCodeType__PY, "PY" },
	{ (long)ns6__PackingCodeType__PZ, "PZ" },
	{ (long)ns6__PackingCodeType__QA, "QA" },
	{ (long)ns6__PackingCodeType__QB, "QB" },
	{ (long)ns6__PackingCodeType__QC, "QC" },
	{ (long)ns6__PackingCodeType__QD, "QD" },
	{ (long)ns6__PackingCodeType__QF, "QF" },
	{ (long)ns6__PackingCodeType__QG, "QG" },
	{ (long)ns6__PackingCodeType__QH, "QH" },
	{ (long)ns6__PackingCodeType__QJ, "QJ" },
	{ (long)ns6__PackingCodeType__QK, "QK" },
	{ (long)ns6__PackingCodeType__QL, "QL" },
	{ (long)ns6__PackingCodeType__QM, "QM" },
	{ (long)ns6__PackingCodeType__QN, "QN" },
	{ (long)ns6__PackingCodeType__QP, "QP" },
	{ (long)ns6__PackingCodeType__QQ, "QQ" },
	{ (long)ns6__PackingCodeType__QR, "QR" },
	{ (long)ns6__PackingCodeType__QS, "QS" },
	{ (long)ns6__PackingCodeType__RD, "RD" },
	{ (long)ns6__PackingCodeType__RG, "RG" },
	{ (long)ns6__PackingCodeType__RJ, "RJ" },
	{ (long)ns6__PackingCodeType__RK, "RK" },
	{ (long)ns6__PackingCodeType__RL, "RL" },
	{ (long)ns6__PackingCodeType__RO, "RO" },
	{ (long)ns6__PackingCodeType__RT, "RT" },
	{ (long)ns6__PackingCodeType__RZ, "RZ" },
	{ (long)ns6__PackingCodeType__SA, "SA" },
	{ (long)ns6__PackingCodeType__SB, "SB" },
	{ (long)ns6__PackingCodeType__SC, "SC" },
	{ (long)ns6__PackingCodeType__SD, "SD" },
	{ (long)ns6__PackingCodeType__SE, "SE" },
	{ (long)ns6__PackingCodeType__SH, "SH" },
	{ (long)ns6__PackingCodeType__SI, "SI" },
	{ (long)ns6__PackingCodeType__SK, "SK" },
	{ (long)ns6__PackingCodeType__SL, "SL" },
	{ (long)ns6__PackingCodeType__SM, "SM" },
	{ (long)ns6__PackingCodeType__SO, "SO" },
	{ (long)ns6__PackingCodeType__SP, "SP" },
	{ (long)ns6__PackingCodeType__SS, "SS" },
	{ (long)ns6__PackingCodeType__ST, "ST" },
	{ (long)ns6__PackingCodeType__SU, "SU" },
	{ (long)ns6__PackingCodeType__SV, "SV" },
	{ (long)ns6__PackingCodeType__SW, "SW" },
	{ (long)ns6__PackingCodeType__SX, "SX" },
	{ (long)ns6__PackingCodeType__SY, "SY" },
	{ (long)ns6__PackingCodeType__SZ, "SZ" },
	{ (long)ns6__PackingCodeType__T1, "T1" },
	{ (long)ns6__PackingCodeType__TB, "TB" },
	{ (long)ns6__PackingCodeType__TC, "TC" },
	{ (long)ns6__PackingCodeType__TD, "TD" },
	{ (long)ns6__PackingCodeType__TE, "TE" },
	{ (long)ns6__PackingCodeType__TG, "TG" },
	{ (long)ns6__PackingCodeType__TI, "TI" },
	{ (long)ns6__PackingCodeType__TK, "TK" },
	{ (long)ns6__PackingCodeType__TL, "TL" },
	{ (long)ns6__PackingCodeType__TN, "TN" },
	{ (long)ns6__PackingCodeType__TO, "TO" },
	{ (long)ns6__PackingCodeType__TR, "TR" },
	{ (long)ns6__PackingCodeType__TS, "TS" },
	{ (long)ns6__PackingCodeType__TT, "TT" },
	{ (long)ns6__PackingCodeType__TU, "TU" },
	{ (long)ns6__PackingCodeType__TV, "TV" },
	{ (long)ns6__PackingCodeType__TW, "TW" },
	{ (long)ns6__PackingCodeType__TY, "TY" },
	{ (long)ns6__PackingCodeType__TZ, "TZ" },
	{ (long)ns6__PackingCodeType__UC, "UC" },
	{ (long)ns6__PackingCodeType__UN, "UN" },
	{ (long)ns6__PackingCodeType__VA, "VA" },
	{ (long)ns6__PackingCodeType__VG, "VG" },
	{ (long)ns6__PackingCodeType__VI, "VI" },
	{ (long)ns6__PackingCodeType__VK, "VK" },
	{ (long)ns6__PackingCodeType__VL, "VL" },
	{ (long)ns6__PackingCodeType__VO, "VO" },
	{ (long)ns6__PackingCodeType__VP, "VP" },
	{ (long)ns6__PackingCodeType__VQ, "VQ" },
	{ (long)ns6__PackingCodeType__VR, "VR" },
	{ (long)ns6__PackingCodeType__VS, "VS" },
	{ (long)ns6__PackingCodeType__VY, "VY" },
	{ (long)ns6__PackingCodeType__WA, "WA" },
	{ (long)ns6__PackingCodeType__WB, "WB" },
	{ (long)ns6__PackingCodeType__WC, "WC" },
	{ (long)ns6__PackingCodeType__WD, "WD" },
	{ (long)ns6__PackingCodeType__WF, "WF" },
	{ (long)ns6__PackingCodeType__WG, "WG" },
	{ (long)ns6__PackingCodeType__WH, "WH" },
	{ (long)ns6__PackingCodeType__WJ, "WJ" },
	{ (long)ns6__PackingCodeType__WK, "WK" },
	{ (long)ns6__PackingCodeType__WL, "WL" },
	{ (long)ns6__PackingCodeType__WM, "WM" },
	{ (long)ns6__PackingCodeType__WN, "WN" },
	{ (long)ns6__PackingCodeType__WP, "WP" },
	{ (long)ns6__PackingCodeType__WQ, "WQ" },
	{ (long)ns6__PackingCodeType__WR, "WR" },
	{ (long)ns6__PackingCodeType__WS, "WS" },
	{ (long)ns6__PackingCodeType__WT, "WT" },
	{ (long)ns6__PackingCodeType__WU, "WU" },
	{ (long)ns6__PackingCodeType__WV, "WV" },
	{ (long)ns6__PackingCodeType__WW, "WW" },
	{ (long)ns6__PackingCodeType__WX, "WX" },
	{ (long)ns6__PackingCodeType__WY, "WY" },
	{ (long)ns6__PackingCodeType__WZ, "WZ" },
	{ (long)ns6__PackingCodeType__XA, "XA" },
	{ (long)ns6__PackingCodeType__XB, "XB" },
	{ (long)ns6__PackingCodeType__XC, "XC" },
	{ (long)ns6__PackingCodeType__XD, "XD" },
	{ (long)ns6__PackingCodeType__XF, "XF" },
	{ (long)ns6__PackingCodeType__XG, "XG" },
	{ (long)ns6__PackingCodeType__XH, "XH" },
	{ (long)ns6__PackingCodeType__XJ, "XJ" },
	{ (long)ns6__PackingCodeType__XK, "XK" },
	{ (long)ns6__PackingCodeType__YA, "YA" },
	{ (long)ns6__PackingCodeType__YB, "YB" },
	{ (long)ns6__PackingCodeType__YC, "YC" },
	{ (long)ns6__PackingCodeType__YD, "YD" },
	{ (long)ns6__PackingCodeType__YF, "YF" },
	{ (long)ns6__PackingCodeType__YH, "YH" },
	{ (long)ns6__PackingCodeType__YJ, "YJ" },
	{ (long)ns6__PackingCodeType__YK, "YK" },
	{ (long)ns6__PackingCodeType__YL, "YL" },
	{ (long)ns6__PackingCodeType__YM, "YM" },
	{ (long)ns6__PackingCodeType__YN, "YN" },
	{ (long)ns6__PackingCodeType__YP, "YP" },
	{ (long)ns6__PackingCodeType__YQ, "YQ" },
	{ (long)ns6__PackingCodeType__YR, "YR" },
	{ (long)ns6__PackingCodeType__YS, "YS" },
	{ (long)ns6__PackingCodeType__YT, "YT" },
	{ (long)ns6__PackingCodeType__YV, "YV" },
	{ (long)ns6__PackingCodeType__YW, "YW" },
	{ (long)ns6__PackingCodeType__YX, "YX" },
	{ (long)ns6__PackingCodeType__YY, "YY" },
	{ (long)ns6__PackingCodeType__YZ, "YZ" },
	{ (long)ns6__PackingCodeType__ZA, "ZA" },
	{ (long)ns6__PackingCodeType__ZB, "ZB" },
	{ (long)ns6__PackingCodeType__ZC, "ZC" },
	{ (long)ns6__PackingCodeType__ZD, "ZD" },
	{ (long)ns6__PackingCodeType__ZF, "ZF" },
	{ (long)ns6__PackingCodeType__ZG, "ZG" },
	{ (long)ns6__PackingCodeType__ZH, "ZH" },
	{ (long)ns6__PackingCodeType__ZJ, "ZJ" },
	{ (long)ns6__PackingCodeType__ZK, "ZK" },
	{ (long)ns6__PackingCodeType__ZL, "ZL" },
	{ (long)ns6__PackingCodeType__ZM, "ZM" },
	{ (long)ns6__PackingCodeType__ZN, "ZN" },
	{ (long)ns6__PackingCodeType__ZP, "ZP" },
	{ (long)ns6__PackingCodeType__ZQ, "ZQ" },
	{ (long)ns6__PackingCodeType__ZR, "ZR" },
	{ (long)ns6__PackingCodeType__ZS, "ZS" },
	{ (long)ns6__PackingCodeType__ZT, "ZT" },
	{ (long)ns6__PackingCodeType__ZU, "ZU" },
	{ (long)ns6__PackingCodeType__ZV, "ZV" },
	{ (long)ns6__PackingCodeType__ZW, "ZW" },
	{ (long)ns6__PackingCodeType__ZX, "ZX" },
	{ (long)ns6__PackingCodeType__ZY, "ZY" },
	{ (long)ns6__PackingCodeType__ZZ, "ZZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__PackingCodeType2s(struct soap *soap, enum ns6__PackingCodeType n)
{
	const char *s = soap_code_str(soap_codes_ns6__PackingCodeType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__PackingCodeType(struct soap *soap, const char *tag, int id, const enum ns6__PackingCodeType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PackingCodeType), type) || soap_send(soap, soap_ns6__PackingCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__PackingCodeType(struct soap *soap, const char *s, enum ns6__PackingCodeType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__PackingCodeType, s);
	if(map)
		*a = (enum ns6__PackingCodeType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 364)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__PackingCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__PackingCodeType * FASTCALL soap_in_ns6__PackingCodeType(struct soap *soap, const char *tag, enum ns6__PackingCodeType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__PackingCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PackingCodeType, sizeof(enum ns6__PackingCodeType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__PackingCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__PackingCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PackingCodeType, 0, sizeof(enum ns6__PackingCodeType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__PackingCodeType(struct soap *soap, const enum ns6__PackingCodeType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__PackingCodeType);
	return soap_out_ns6__PackingCodeType(soap, tag?tag:"ns6:PackingCodeType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__PackingCodeType * SOAP_FMAC4 soap_get_ns6__PackingCodeType(struct soap *soap, enum ns6__PackingCodeType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__PackingCodeType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__PackageLevelType(struct soap *soap, enum ns6__PackageLevelType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__PackageLevelType
	*a = SOAP_DEFAULT_ns6__PackageLevelType;
#else
	*a = (enum ns6__PackageLevelType)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__PackageLevelType[] =
{	{ (long)ns6__PackageLevelType__1, "1" },
	{ (long)ns6__PackageLevelType__2, "2" },
	{ (long)ns6__PackageLevelType__3, "3" },
	{ (long)ns6__PackageLevelType__4, "4" },
	{ (long)ns6__PackageLevelType__5, "5" },
	{ (long)ns6__PackageLevelType__6, "6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__PackageLevelType2s(struct soap *soap, enum ns6__PackageLevelType n)
{
	const char *s = soap_code_str(soap_codes_ns6__PackageLevelType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__PackageLevelType(struct soap *soap, const char *tag, int id, const enum ns6__PackageLevelType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PackageLevelType), type) || soap_send(soap, soap_ns6__PackageLevelType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__PackageLevelType(struct soap *soap, const char *s, enum ns6__PackageLevelType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__PackageLevelType, s);
	if(map)
		*a = (enum ns6__PackageLevelType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__PackageLevelType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__PackageLevelType * FASTCALL soap_in_ns6__PackageLevelType(struct soap *soap, const char *tag, enum ns6__PackageLevelType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__PackageLevelType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PackageLevelType, sizeof(enum ns6__PackageLevelType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns6__PackageLevelType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns6__PackageLevelType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PackageLevelType, 0, sizeof(enum ns6__PackageLevelType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__PackageLevelType(struct soap *soap, const enum ns6__PackageLevelType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__PackageLevelType);
	return soap_out_ns6__PackageLevelType(soap, tag?tag:"ns6:PackageLevelType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__PackageLevelType * SOAP_FMAC4 soap_get_ns6__PackageLevelType(struct soap *soap, enum ns6__PackageLevelType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__PackageLevelType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ContentEncoding(struct soap *soap, enum ns4__ContentEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__ContentEncoding
	*a = SOAP_DEFAULT_ns4__ContentEncoding;
#else
	*a = (enum ns4__ContentEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__ContentEncoding[] =
{	{ (long)ns4__ContentEncoding__plain, "plain" },
	{ (long)ns4__ContentEncoding__gzip, "gzip" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__ContentEncoding2s(struct soap *soap, enum ns4__ContentEncoding n)
{
	const char *s = soap_code_str(soap_codes_ns4__ContentEncoding, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__ContentEncoding(struct soap *soap, const char *tag, int id, const enum ns4__ContentEncoding *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ContentEncoding), type) || soap_send(soap, soap_ns4__ContentEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__ContentEncoding(struct soap *soap, const char *s, enum ns4__ContentEncoding *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__ContentEncoding, s);
	if(map)
		*a = (enum ns4__ContentEncoding)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__ContentEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__ContentEncoding * FASTCALL soap_in_ns4__ContentEncoding(struct soap *soap, const char *tag, enum ns4__ContentEncoding *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__ContentEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ContentEncoding, sizeof(enum ns4__ContentEncoding), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns4__ContentEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns4__ContentEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ContentEncoding, 0, sizeof(enum ns4__ContentEncoding), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ContentEncoding(struct soap *soap, const enum ns4__ContentEncoding *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ContentEncoding);
	return soap_out_ns4__ContentEncoding(soap, tag?tag:"ns4:ContentEncoding", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ContentEncoding * SOAP_FMAC4 soap_get_ns4__ContentEncoding(struct soap *soap, enum ns4__ContentEncoding *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__ContentEncoding(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ApplicationStatus(struct soap *soap, enum ns4__ApplicationStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__ApplicationStatus
	*a = SOAP_DEFAULT_ns4__ApplicationStatus;
#else
	*a = (enum ns4__ApplicationStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__ApplicationStatus[] =
{	{ (long)ns4__ApplicationStatus__ACCEPTED, "ACCEPTED" },
	{ (long)ns4__ApplicationStatus__IN_USCOREPROCESS, "IN_PROCESS" },
	{ (long)ns4__ApplicationStatus__COMPLETED, "COMPLETED" },
	{ (long)ns4__ApplicationStatus__REJECTED, "REJECTED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__ApplicationStatus2s(struct soap *soap, enum ns4__ApplicationStatus n)
{
	const char *s = soap_code_str(soap_codes_ns4__ApplicationStatus, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__ApplicationStatus(struct soap *soap, const char *tag, int id, const enum ns4__ApplicationStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ApplicationStatus), type) || soap_send(soap, soap_ns4__ApplicationStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__ApplicationStatus(struct soap *soap, const char *s, enum ns4__ApplicationStatus *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__ApplicationStatus, s);
	if(map)
		*a = (enum ns4__ApplicationStatus)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__ApplicationStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__ApplicationStatus * FASTCALL soap_in_ns4__ApplicationStatus(struct soap *soap, const char *tag, enum ns4__ApplicationStatus *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__ApplicationStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ApplicationStatus, sizeof(enum ns4__ApplicationStatus), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns4__ApplicationStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns4__ApplicationStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ApplicationStatus, 0, sizeof(enum ns4__ApplicationStatus), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ApplicationStatus(struct soap *soap, const enum ns4__ApplicationStatus *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ApplicationStatus);
	return soap_out_ns4__ApplicationStatus(soap, tag?tag:"ns4:ApplicationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ApplicationStatus * SOAP_FMAC4 soap_get_ns4__ApplicationStatus(struct soap *soap, enum ns4__ApplicationStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__ApplicationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__RegisterModificationType(struct soap *soap, enum ns3__RegisterModificationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__RegisterModificationType
	*a = SOAP_DEFAULT_ns3__RegisterModificationType;
#else
	*a = (enum ns3__RegisterModificationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__RegisterModificationType[] =
{	{ (long)ns3__RegisterModificationType__CREATE, "CREATE" },
	{ (long)ns3__RegisterModificationType__FIND_USCOREOR_USCORECREATE, "FIND_OR_CREATE" },
	{ (long)ns3__RegisterModificationType__UPDATE, "UPDATE" },
	{ (long)ns3__RegisterModificationType__DELETE, "DELETE" },
	{ (long)ns3__RegisterModificationType__MERGE, "MERGE" },
	{ (long)ns3__RegisterModificationType__ATTACH, "ATTACH" },
	{ (long)ns3__RegisterModificationType__SPLIT, "SPLIT" },
	{ (long)ns3__RegisterModificationType__FORK, "FORK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__RegisterModificationType2s(struct soap *soap, enum ns3__RegisterModificationType n)
{
	const char *s = soap_code_str(soap_codes_ns3__RegisterModificationType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__RegisterModificationType(struct soap *soap, const char *tag, int id, const enum ns3__RegisterModificationType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__RegisterModificationType), type) || soap_send(soap, soap_ns3__RegisterModificationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__RegisterModificationType(struct soap *soap, const char *s, enum ns3__RegisterModificationType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__RegisterModificationType, s);
	if(map)
		*a = (enum ns3__RegisterModificationType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__RegisterModificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__RegisterModificationType * FASTCALL soap_in_ns3__RegisterModificationType(struct soap *soap, const char *tag, enum ns3__RegisterModificationType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__RegisterModificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__RegisterModificationType, sizeof(enum ns3__RegisterModificationType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ns3__RegisterModificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ns3__RegisterModificationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__RegisterModificationType, 0, sizeof(enum ns3__RegisterModificationType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__RegisterModificationType(struct soap *soap, const enum ns3__RegisterModificationType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__RegisterModificationType);
	return soap_out_ns3__RegisterModificationType(soap, tag?tag:"ns3:RegisterModificationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__RegisterModificationType * SOAP_FMAC4 soap_get_ns3__RegisterModificationType(struct soap *soap, enum ns3__RegisterModificationType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__RegisterModificationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns6__BusinessEntity_activityLocation::soap_default(struct soap *soap)
{
	this->_ns6__BusinessEntity_activityLocation::__sizeglobalID = 0;
	this->_ns6__BusinessEntity_activityLocation::globalID = NULL;
	this->_ns6__BusinessEntity_activityLocation::enterprise = NULL;
}

void _ns6__BusinessEntity_activityLocation::soap_serialize(struct soap *soap) const
{
	if(this->_ns6__BusinessEntity_activityLocation::globalID) {
		for(int i = 0; i < this->_ns6__BusinessEntity_activityLocation::__sizeglobalID; i++) {
			soap_serialize_ns6__GLNType(soap, this->_ns6__BusinessEntity_activityLocation::globalID + i);
		}
	}
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns6__BusinessEntity_activityLocation::enterprise);
}

int _ns6__BusinessEntity_activityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__BusinessEntity_activityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns6__BusinessEntity_activityLocation(struct soap *soap, const char *tag, int id, const _ns6__BusinessEntity_activityLocation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__BusinessEntity_activityLocation), type))
		return soap->error;
	if(a->_ns6__BusinessEntity_activityLocation::globalID) {
		int i;
		for(i = 0; i < a->_ns6__BusinessEntity_activityLocation::__sizeglobalID; i++)
			if(soap_out_ns6__GLNType(soap, "ns6:globalID", -1, a->_ns6__BusinessEntity_activityLocation::globalID + i, ""))
				return soap->error;
	}
	if(a->_ns6__BusinessEntity_activityLocation::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &a->_ns6__BusinessEntity_activityLocation::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterprise"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns6__BusinessEntity_activityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns6__BusinessEntity_activityLocation(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__BusinessEntity_activityLocation * FASTCALL soap_in__ns6__BusinessEntity_activityLocation(struct soap *soap, const char *tag, _ns6__BusinessEntity_activityLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__BusinessEntity_activityLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__BusinessEntity_activityLocation, sizeof(_ns6__BusinessEntity_activityLocation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns6__BusinessEntity_activityLocation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__BusinessEntity_activityLocation *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_globalID1 = NULL;
	size_t soap_flag_enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:globalID", 1, NULL)) {
				if(a->_ns6__BusinessEntity_activityLocation::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->_ns6__BusinessEntity_activityLocation::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->_ns6__BusinessEntity_activityLocation::globalID == NULL)
						return NULL;
					*a->_ns6__BusinessEntity_activityLocation::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns6__GLNType(soap, "ns6:globalID", a->_ns6__BusinessEntity_activityLocation::globalID, "ns6:GLNType"))
				{	a->_ns6__BusinessEntity_activityLocation::__sizeglobalID++;
					a->_ns6__BusinessEntity_activityLocation::globalID = NULL;
					continue;
				}
			}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns6__BusinessEntity_activityLocation::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->_ns6__BusinessEntity_activityLocation::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->_ns6__BusinessEntity_activityLocation::__sizeglobalID)
			a->_ns6__BusinessEntity_activityLocation::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->_ns6__BusinessEntity_activityLocation::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns6__BusinessEntity_activityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__BusinessEntity_activityLocation, 0, sizeof(_ns6__BusinessEntity_activityLocation), 0, soap_copy__ns6__BusinessEntity_activityLocation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns6__BusinessEntity_activityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__BusinessEntity_activityLocation);
	return this->soap_out(soap, tag?tag:"ns6:BusinessEntity-activityLocation", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns6__BusinessEntity_activityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__BusinessEntity_activityLocation(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__BusinessEntity_activityLocation * SOAP_FMAC4 soap_get__ns6__BusinessEntity_activityLocation(struct soap *soap, _ns6__BusinessEntity_activityLocation *p, const char *tag, const char *type)
{
	if((p = soap_in__ns6__BusinessEntity_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns6__BusinessEntity_activityLocation * FASTCALL soap_instantiate__ns6__BusinessEntity_activityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__BusinessEntity_activityLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__BusinessEntity_activityLocation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns6__BusinessEntity_activityLocation);
		ASSIGN_PTR(size, sizeof(_ns6__BusinessEntity_activityLocation));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns6__BusinessEntity_activityLocation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns6__BusinessEntity_activityLocation));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__BusinessEntity_activityLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__BusinessEntity_activityLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__BusinessEntity_activityLocation %p -> %p\n", q, p));
	*(_ns6__BusinessEntity_activityLocation*)p = *(_ns6__BusinessEntity_activityLocation*)q;
}

void _ns7__BEActivityLocationsModificationOperation_activityLocation::soap_default(struct soap *soap)
{
	this->_ns7__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID = 0;
	this->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
	this->_ns7__BEActivityLocationsModificationOperation_activityLocation::enterprise = NULL;
}

void _ns7__BEActivityLocationsModificationOperation_activityLocation::soap_serialize(struct soap *soap) const
{
	if(this->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID) {
		for(int i = 0; i < this->_ns7__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID; i++) {
			soap_serialize_ns6__GLNType(soap, this->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID + i);
		}
	}
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns7__BEActivityLocationsModificationOperation_activityLocation::enterprise);
}

int _ns7__BEActivityLocationsModificationOperation_activityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, int id, const _ns7__BEActivityLocationsModificationOperation_activityLocation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation), type))
		return soap->error;
	if(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID) {
		int i;
		for(i = 0; i < a->_ns7__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID; i++)
			if(soap_out_ns6__GLNType(soap, "ns7:globalID", -1, a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID + i, ""))
				return soap->error;
	}
	if(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns7:enterprise", -1, &a->_ns7__BEActivityLocationsModificationOperation_activityLocation::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:enterprise"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__BEActivityLocationsModificationOperation_activityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__BEActivityLocationsModificationOperation_activityLocation * FASTCALL soap_in__ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, _ns7__BEActivityLocationsModificationOperation_activityLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__BEActivityLocationsModificationOperation_activityLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation, sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__BEActivityLocationsModificationOperation_activityLocation *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_globalID1 = NULL;
	size_t soap_flag_enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:globalID", 1, NULL)) {
				if(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID == NULL)
						return NULL;
					*a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns6__GLNType(soap, "ns7:globalID", a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID, "ns6:GLNType"))
				{	a->_ns7__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID++;
					a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
					continue;
				}
			}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns7:enterprise", &(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->_ns7__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID)
			a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->_ns7__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns7__BEActivityLocationsModificationOperation_activityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation, 0, sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation), 0, soap_copy__ns7__BEActivityLocationsModificationOperation_activityLocation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns7__BEActivityLocationsModificationOperation_activityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation);
	return this->soap_out(soap, tag?tag:"ns7:BEActivityLocationsModificationOperation-activityLocation", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns7__BEActivityLocationsModificationOperation_activityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__BEActivityLocationsModificationOperation_activityLocation * SOAP_FMAC4 soap_get__ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _ns7__BEActivityLocationsModificationOperation_activityLocation *p, const char *tag, const char *type)
{
	if((p = soap_in__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__BEActivityLocationsModificationOperation_activityLocation * FASTCALL soap_instantiate__ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__BEActivityLocationsModificationOperation_activityLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns7__BEActivityLocationsModificationOperation_activityLocation);
		ASSIGN_PTR(size, sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns7__BEActivityLocationsModificationOperation_activityLocation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__BEActivityLocationsModificationOperation_activityLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__BEActivityLocationsModificationOperation_activityLocation %p -> %p\n", q, p));
	*(_ns7__BEActivityLocationsModificationOperation_activityLocation*)p = *(_ns7__BEActivityLocationsModificationOperation_activityLocation*)q;
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__BinaryContent(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_ns4__BinaryContent);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns4__BinaryContent);
#endif
	if(id < 0)
		return soap->error;
	if(soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if(soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 xsd__base64Binary * FASTCALL soap_in_ns4__BinaryContent(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__BinaryContent, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced)
		a->soap_default(soap);
	if(soap->body && !*soap->href) {	
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if(soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		
#ifndef WITH_LEANER
		if(*soap->href != '#')
		{	if(soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__BinaryContent, 0, sizeof(xsd__base64Binary), 0, soap_copy_ns4__BinaryContent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__BinaryContent(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns4__BinaryContent);
	return soap_out_ns4__BinaryContent(soap, tag?tag:"ns4:BinaryContent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_ns4__BinaryContent(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__BinaryContent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns8__getResearchMethodChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodChangesListResponse::ns6__researchMethodList = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ResearchMethodList(soap, &this->_ns8__getResearchMethodChangesListResponse::ns6__researchMethodList);
	/* transient soap skipped */
}

int _ns8__getResearchMethodChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodChangesListResponse::ns6__researchMethodList) {
		if(soap_out_PointerTons6__ResearchMethodList(soap, "ns6:researchMethodList", -1, &a->_ns8__getResearchMethodChangesListResponse::ns6__researchMethodList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:researchMethodList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListResponse * FASTCALL soap_in__ns8__getResearchMethodChangesListResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodChangesListResponse, sizeof(_ns8__getResearchMethodChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__researchMethodList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__researchMethodList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchMethodList(soap, "ns6:researchMethodList", &(a->_ns8__getResearchMethodChangesListResponse::ns6__researchMethodList), "ns6:ResearchMethodList"))
				{	soap_flag_ns6__researchMethodList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodChangesListResponse, 0, sizeof(_ns8__getResearchMethodChangesListResponse), 0, soap_copy__ns8__getResearchMethodChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__researchMethodList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodChangesListResponse(struct soap *soap, _ns8__getResearchMethodChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodChangesListResponse * FASTCALL soap_instantiate__ns8__getResearchMethodChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodChangesListResponse));
		((_ns8__getResearchMethodChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodChangesListResponse*)p = *(_ns8__getResearchMethodChangesListResponse*)q;
}

void _ns8__getResearchMethodChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getResearchMethodChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getResearchMethodChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getResearchMethodChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getResearchMethodChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getResearchMethodChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getResearchMethodChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getResearchMethodChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListRequest * FASTCALL soap_in__ns8__getResearchMethodChangesListRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodChangesListRequest, sizeof(_ns8__getResearchMethodChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getResearchMethodChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getResearchMethodChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodChangesListRequest, 0, sizeof(_ns8__getResearchMethodChangesListRequest), 0, soap_copy__ns8__getResearchMethodChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodChangesListRequest(struct soap *soap, _ns8__getResearchMethodChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodChangesListRequest * FASTCALL soap_instantiate__ns8__getResearchMethodChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodChangesListRequest));
		((_ns8__getResearchMethodChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodChangesListRequest*)p = *(_ns8__getResearchMethodChangesListRequest*)q;
}

void _ns8__getResearchMethodListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodListResponse::ns6__researchMethodList = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ResearchMethodList(soap, &this->_ns8__getResearchMethodListResponse::ns6__researchMethodList);
	/* transient soap skipped */
}

int _ns8__getResearchMethodListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodListResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodListResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodListResponse::ns6__researchMethodList) {
		if(soap_out_PointerTons6__ResearchMethodList(soap, "ns6:researchMethodList", -1, &a->_ns8__getResearchMethodListResponse::ns6__researchMethodList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:researchMethodList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListResponse * FASTCALL soap_in__ns8__getResearchMethodListResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodListResponse, sizeof(_ns8__getResearchMethodListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__researchMethodList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__researchMethodList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchMethodList(soap, "ns6:researchMethodList", &(a->_ns8__getResearchMethodListResponse::ns6__researchMethodList), "ns6:ResearchMethodList"))
				{	soap_flag_ns6__researchMethodList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodListResponse, 0, sizeof(_ns8__getResearchMethodListResponse), 0, soap_copy__ns8__getResearchMethodListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__researchMethodList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodListResponse(struct soap *soap, _ns8__getResearchMethodListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodListResponse * FASTCALL soap_instantiate__ns8__getResearchMethodListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodListResponse));
		((_ns8__getResearchMethodListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodListResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodListResponse*)p = *(_ns8__getResearchMethodListResponse*)q;
}

void _ns8__getResearchMethodListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodListRequest::ns3__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getResearchMethodListRequest::ns3__listOptions);
	/* transient soap skipped */
}

int _ns8__getResearchMethodListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodListRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getResearchMethodListRequest::ns3__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListRequest * FASTCALL soap_in__ns8__getResearchMethodListRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodListRequest, sizeof(_ns8__getResearchMethodListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getResearchMethodListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodListRequest, 0, sizeof(_ns8__getResearchMethodListRequest), 0, soap_copy__ns8__getResearchMethodListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getResearchMethodListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodListRequest(struct soap *soap, _ns8__getResearchMethodListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodListRequest * FASTCALL soap_instantiate__ns8__getResearchMethodListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodListRequest));
		((_ns8__getResearchMethodListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodListRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodListRequest*)p = *(_ns8__getResearchMethodListRequest*)q;
}

void _ns8__getResearchMethodByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodByUuidResponse::ns6__researchMethod = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ResearchMethod(soap, &this->_ns8__getResearchMethodByUuidResponse::ns6__researchMethod);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByUuidResponse::ns6__researchMethod) {
		if(soap_out_PointerTons6__ResearchMethod(soap, "ns6:researchMethod", -1, &a->_ns8__getResearchMethodByUuidResponse::ns6__researchMethod, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:researchMethod"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidResponse * FASTCALL soap_in__ns8__getResearchMethodByUuidResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByUuidResponse, sizeof(_ns8__getResearchMethodByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__researchMethod1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__researchMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchMethod(soap, "ns6:researchMethod", &(a->_ns8__getResearchMethodByUuidResponse::ns6__researchMethod), "ns6:ResearchMethod"))
				{	soap_flag_ns6__researchMethod1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByUuidResponse, 0, sizeof(_ns8__getResearchMethodByUuidResponse), 0, soap_copy__ns8__getResearchMethodByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__researchMethod1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodByUuidResponse(struct soap *soap, _ns8__getResearchMethodByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByUuidResponse * FASTCALL soap_instantiate__ns8__getResearchMethodByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByUuidResponse));
		((_ns8__getResearchMethodByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByUuidResponse*)p = *(_ns8__getResearchMethodByUuidResponse*)q;
}

void _ns8__getResearchMethodByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getResearchMethodByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getResearchMethodByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getResearchMethodByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getResearchMethodByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidRequest * FASTCALL soap_in__ns8__getResearchMethodByUuidRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByUuidRequest, sizeof(_ns8__getResearchMethodByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getResearchMethodByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByUuidRequest, 0, sizeof(_ns8__getResearchMethodByUuidRequest), 0, soap_copy__ns8__getResearchMethodByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodByUuidRequest(struct soap *soap, _ns8__getResearchMethodByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByUuidRequest * FASTCALL soap_instantiate__ns8__getResearchMethodByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByUuidRequest));
		((_ns8__getResearchMethodByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByUuidRequest*)p = *(_ns8__getResearchMethodByUuidRequest*)q;
}

void _ns8__getResearchMethodByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodByGuidResponse::ns6__researchMethod = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ResearchMethod(soap, &this->_ns8__getResearchMethodByGuidResponse::ns6__researchMethod);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByGuidResponse::ns6__researchMethod) {
		if(soap_out_PointerTons6__ResearchMethod(soap, "ns6:researchMethod", -1, &a->_ns8__getResearchMethodByGuidResponse::ns6__researchMethod, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:researchMethod"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidResponse * FASTCALL soap_in__ns8__getResearchMethodByGuidResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByGuidResponse, sizeof(_ns8__getResearchMethodByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__researchMethod1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__researchMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchMethod(soap, "ns6:researchMethod", &(a->_ns8__getResearchMethodByGuidResponse::ns6__researchMethod), "ns6:ResearchMethod"))
				{	soap_flag_ns6__researchMethod1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByGuidResponse, 0, sizeof(_ns8__getResearchMethodByGuidResponse), 0, soap_copy__ns8__getResearchMethodByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__researchMethod1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodByGuidResponse(struct soap *soap, _ns8__getResearchMethodByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByGuidResponse * FASTCALL soap_instantiate__ns8__getResearchMethodByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByGuidResponse));
		((_ns8__getResearchMethodByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByGuidResponse*)p = *(_ns8__getResearchMethodByGuidResponse*)q;
}

void _ns8__getResearchMethodByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getResearchMethodByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getResearchMethodByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getResearchMethodByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getResearchMethodByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidRequest * FASTCALL soap_in__ns8__getResearchMethodByGuidRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByGuidRequest, sizeof(_ns8__getResearchMethodByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getResearchMethodByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByGuidRequest, 0, sizeof(_ns8__getResearchMethodByGuidRequest), 0, soap_copy__ns8__getResearchMethodByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodByGuidRequest(struct soap *soap, _ns8__getResearchMethodByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByGuidRequest * FASTCALL soap_instantiate__ns8__getResearchMethodByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByGuidRequest));
		((_ns8__getResearchMethodByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByGuidRequest*)p = *(_ns8__getResearchMethodByGuidRequest*)q;
}

void _ns8__getDiseaseChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseChangesListResponse::ns6__diseaseList = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDiseaseList(soap, &this->_ns8__getDiseaseChangesListResponse::ns6__diseaseList);
	/* transient soap skipped */
}

int _ns8__getDiseaseChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseChangesListResponse::ns6__diseaseList) {
		if(soap_out_PointerTons6__AnimalDiseaseList(soap, "ns6:diseaseList", -1, &a->_ns8__getDiseaseChangesListResponse::ns6__diseaseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:diseaseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListResponse * FASTCALL soap_in__ns8__getDiseaseChangesListResponse(struct soap *soap, const char *tag, _ns8__getDiseaseChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseChangesListResponse, sizeof(_ns8__getDiseaseChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__diseaseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__diseaseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDiseaseList(soap, "ns6:diseaseList", &(a->_ns8__getDiseaseChangesListResponse::ns6__diseaseList), "ns6:AnimalDiseaseList"))
				{	soap_flag_ns6__diseaseList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseChangesListResponse, 0, sizeof(_ns8__getDiseaseChangesListResponse), 0, soap_copy__ns8__getDiseaseChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__diseaseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseChangesListResponse(struct soap *soap, _ns8__getDiseaseChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseChangesListResponse * FASTCALL soap_instantiate__ns8__getDiseaseChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseChangesListResponse));
		((_ns8__getDiseaseChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseChangesListResponse*)p = *(_ns8__getDiseaseChangesListResponse*)q;
}

void _ns8__getDiseaseChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getDiseaseChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getDiseaseChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getDiseaseChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getDiseaseChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getDiseaseChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getDiseaseChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getDiseaseChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListRequest * FASTCALL soap_in__ns8__getDiseaseChangesListRequest(struct soap *soap, const char *tag, _ns8__getDiseaseChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseChangesListRequest, sizeof(_ns8__getDiseaseChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getDiseaseChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getDiseaseChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseChangesListRequest, 0, sizeof(_ns8__getDiseaseChangesListRequest), 0, soap_copy__ns8__getDiseaseChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseChangesListRequest(struct soap *soap, _ns8__getDiseaseChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseChangesListRequest * FASTCALL soap_instantiate__ns8__getDiseaseChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseChangesListRequest));
		((_ns8__getDiseaseChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseChangesListRequest*)p = *(_ns8__getDiseaseChangesListRequest*)q;
}

void _ns8__getDiseaseListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseListResponse::ns6__diseaseList = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDiseaseList(soap, &this->_ns8__getDiseaseListResponse::ns6__diseaseList);
	/* transient soap skipped */
}

int _ns8__getDiseaseListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseListResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseListResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseListResponse::ns6__diseaseList) {
		if(soap_out_PointerTons6__AnimalDiseaseList(soap, "ns6:diseaseList", -1, &a->_ns8__getDiseaseListResponse::ns6__diseaseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:diseaseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseListResponse * FASTCALL soap_in__ns8__getDiseaseListResponse(struct soap *soap, const char *tag, _ns8__getDiseaseListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseListResponse, sizeof(_ns8__getDiseaseListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__diseaseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__diseaseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDiseaseList(soap, "ns6:diseaseList", &(a->_ns8__getDiseaseListResponse::ns6__diseaseList), "ns6:AnimalDiseaseList"))
				{	soap_flag_ns6__diseaseList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseListResponse, 0, sizeof(_ns8__getDiseaseListResponse), 0, soap_copy__ns8__getDiseaseListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__diseaseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseListResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseListResponse(struct soap *soap, _ns8__getDiseaseListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseListResponse * FASTCALL soap_instantiate__ns8__getDiseaseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseListResponse));
		((_ns8__getDiseaseListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseListResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseListResponse*)p = *(_ns8__getDiseaseListResponse*)q;
}

void _ns8__getDiseaseListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseListRequest::ns3__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getDiseaseListRequest::ns3__listOptions);
	/* transient soap skipped */
}

int _ns8__getDiseaseListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseListRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getDiseaseListRequest::ns3__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseListRequest * FASTCALL soap_in__ns8__getDiseaseListRequest(struct soap *soap, const char *tag, _ns8__getDiseaseListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseListRequest, sizeof(_ns8__getDiseaseListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getDiseaseListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseListRequest, 0, sizeof(_ns8__getDiseaseListRequest), 0, soap_copy__ns8__getDiseaseListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getDiseaseListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseListRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseListRequest(struct soap *soap, _ns8__getDiseaseListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseListRequest * FASTCALL soap_instantiate__ns8__getDiseaseListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseListRequest));
		((_ns8__getDiseaseListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseListRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseListRequest*)p = *(_ns8__getDiseaseListRequest*)q;
}

void _ns8__getDiseaseByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseByUuidResponse::ns6__disease = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->_ns8__getDiseaseByUuidResponse::ns6__disease);
	/* transient soap skipped */
}

int _ns8__getDiseaseByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseByUuidResponse::ns6__disease) {
		if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:disease", -1, &a->_ns8__getDiseaseByUuidResponse::ns6__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:disease"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidResponse * FASTCALL soap_in__ns8__getDiseaseByUuidResponse(struct soap *soap, const char *tag, _ns8__getDiseaseByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByUuidResponse, sizeof(_ns8__getDiseaseByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__disease1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:disease", &(a->_ns8__getDiseaseByUuidResponse::ns6__disease), "ns6:AnimalDisease"))
				{	soap_flag_ns6__disease1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByUuidResponse, 0, sizeof(_ns8__getDiseaseByUuidResponse), 0, soap_copy__ns8__getDiseaseByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseByUuidResponse(struct soap *soap, _ns8__getDiseaseByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByUuidResponse * FASTCALL soap_instantiate__ns8__getDiseaseByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByUuidResponse));
		((_ns8__getDiseaseByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseByUuidResponse*)p = *(_ns8__getDiseaseByUuidResponse*)q;
}

void _ns8__getDiseaseByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getDiseaseByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getDiseaseByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getDiseaseByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getDiseaseByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getDiseaseByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getDiseaseByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidRequest * FASTCALL soap_in__ns8__getDiseaseByUuidRequest(struct soap *soap, const char *tag, _ns8__getDiseaseByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByUuidRequest, sizeof(_ns8__getDiseaseByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getDiseaseByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByUuidRequest, 0, sizeof(_ns8__getDiseaseByUuidRequest), 0, soap_copy__ns8__getDiseaseByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseByUuidRequest(struct soap *soap, _ns8__getDiseaseByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByUuidRequest * FASTCALL soap_instantiate__ns8__getDiseaseByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByUuidRequest));
		((_ns8__getDiseaseByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseByUuidRequest*)p = *(_ns8__getDiseaseByUuidRequest*)q;
}

void _ns8__getDiseaseByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseByGuidResponse::ns6__disease = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->_ns8__getDiseaseByGuidResponse::ns6__disease);
	/* transient soap skipped */
}

int _ns8__getDiseaseByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseByGuidResponse::ns6__disease) {
		if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:disease", -1, &a->_ns8__getDiseaseByGuidResponse::ns6__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:disease"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidResponse * FASTCALL soap_in__ns8__getDiseaseByGuidResponse(struct soap *soap, const char *tag, _ns8__getDiseaseByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByGuidResponse, sizeof(_ns8__getDiseaseByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__disease1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:disease", &(a->_ns8__getDiseaseByGuidResponse::ns6__disease), "ns6:AnimalDisease"))
				{	soap_flag_ns6__disease1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByGuidResponse, 0, sizeof(_ns8__getDiseaseByGuidResponse), 0, soap_copy__ns8__getDiseaseByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseByGuidResponse(struct soap *soap, _ns8__getDiseaseByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByGuidResponse * FASTCALL soap_instantiate__ns8__getDiseaseByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByGuidResponse));
		((_ns8__getDiseaseByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseByGuidResponse*)p = *(_ns8__getDiseaseByGuidResponse*)q;
}

void _ns8__getDiseaseByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getDiseaseByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getDiseaseByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getDiseaseByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getDiseaseByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getDiseaseByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getDiseaseByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidRequest * FASTCALL soap_in__ns8__getDiseaseByGuidRequest(struct soap *soap, const char *tag, _ns8__getDiseaseByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByGuidRequest, sizeof(_ns8__getDiseaseByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getDiseaseByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByGuidRequest, 0, sizeof(_ns8__getDiseaseByGuidRequest), 0, soap_copy__ns8__getDiseaseByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseByGuidRequest(struct soap *soap, _ns8__getDiseaseByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByGuidRequest * FASTCALL soap_instantiate__ns8__getDiseaseByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByGuidRequest));
		((_ns8__getDiseaseByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseByGuidRequest*)p = *(_ns8__getDiseaseByGuidRequest*)q;
}

void _ns8__getActualR13nShippingRuleListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nShippingRuleListResponse::ns6__r13nShippingRuleList = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nShippingRuleListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__RegionalizationShippingRuleList(soap, &this->_ns8__getActualR13nShippingRuleListResponse::ns6__r13nShippingRuleList);
	/* transient soap skipped */
}

int _ns8__getActualR13nShippingRuleListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nShippingRuleListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nShippingRuleListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse), type))
		return soap->error;
	if(a->_ns8__getActualR13nShippingRuleListResponse::ns6__r13nShippingRuleList) {
		if(soap_out_PointerTons6__RegionalizationShippingRuleList(soap, "ns6:r13nShippingRuleList", -1, &a->_ns8__getActualR13nShippingRuleListResponse::ns6__r13nShippingRuleList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:r13nShippingRuleList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nShippingRuleListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nShippingRuleListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListResponse * FASTCALL soap_in__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, const char *tag, _ns8__getActualR13nShippingRuleListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nShippingRuleListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse, sizeof(_ns8__getActualR13nShippingRuleListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nShippingRuleListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__r13nShippingRuleList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__r13nShippingRuleList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationShippingRuleList(soap, "ns6:r13nShippingRuleList", &(a->_ns8__getActualR13nShippingRuleListResponse::ns6__r13nShippingRuleList), "ns6:RegionalizationShippingRuleList"))
				{	soap_flag_ns6__r13nShippingRuleList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nShippingRuleListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse, 0, sizeof(_ns8__getActualR13nShippingRuleListResponse), 0, soap_copy__ns8__getActualR13nShippingRuleListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__r13nShippingRuleList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nShippingRuleListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nShippingRuleListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nShippingRuleListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nShippingRuleListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListResponse * SOAP_FMAC4 soap_get__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, _ns8__getActualR13nShippingRuleListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nShippingRuleListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nShippingRuleListResponse * FASTCALL soap_instantiate__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nShippingRuleListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nShippingRuleListResponse));
		((_ns8__getActualR13nShippingRuleListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nShippingRuleListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nShippingRuleListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nShippingRuleListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nShippingRuleListResponse %p -> %p\n", q, p));
	*(_ns8__getActualR13nShippingRuleListResponse*)p = *(_ns8__getActualR13nShippingRuleListResponse*)q;
}

void _ns8__getActualR13nShippingRuleListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nShippingRuleListRequest::ns3__listOptions = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ns6__disease = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ns6__productType = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ns6__product = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ns6__subProduct = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nShippingRuleListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ns6__disease);
	soap_serialize_PointerTons6__ProductType(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ns6__productType);
	soap_serialize_PointerTons6__Product(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ns6__product);
	soap_serialize_PointerTons6__SubProduct(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ns6__subProduct);
	/* transient soap skipped */
}

int _ns8__getActualR13nShippingRuleListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nShippingRuleListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nShippingRuleListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getActualR13nShippingRuleListRequest::ns6__disease) {
		if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:disease", -1, &a->_ns8__getActualR13nShippingRuleListRequest::ns6__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:disease"))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns6:productType", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__productType), ""))
		return soap->error;
	if(soap_out_PointerTons6__Product(soap, "ns6:product", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__product), ""))
		return soap->error;
	if(soap_out_PointerTons6__SubProduct(soap, "ns6:subProduct", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__subProduct), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nShippingRuleListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nShippingRuleListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListRequest * FASTCALL soap_in__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, const char *tag, _ns8__getActualR13nShippingRuleListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nShippingRuleListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest, sizeof(_ns8__getActualR13nShippingRuleListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nShippingRuleListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__disease1 = 1;
	size_t soap_flag_ns6__productType1 = 1;
	size_t soap_flag_ns6__product1 = 1;
	size_t soap_flag_ns6__subProduct1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getActualR13nShippingRuleListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:disease", &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__disease), "ns6:AnimalDisease"))
				{	soap_flag_ns6__disease1--;
					continue;
				}
			if(soap_flag_ns6__productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns6:productType", &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__productType), "ns6:ProductType"))
				{	soap_flag_ns6__productType1--;
					continue;
				}
			if(soap_flag_ns6__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns6:product", &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__product), "ns6:Product"))
				{	soap_flag_ns6__product1--;
					continue;
				}
			if(soap_flag_ns6__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:subProduct", &(a->_ns8__getActualR13nShippingRuleListRequest::ns6__subProduct), "ns6:SubProduct"))
				{	soap_flag_ns6__subProduct1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nShippingRuleListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest, 0, sizeof(_ns8__getActualR13nShippingRuleListRequest), 0, soap_copy__ns8__getActualR13nShippingRuleListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nShippingRuleListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nShippingRuleListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nShippingRuleListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nShippingRuleListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListRequest * SOAP_FMAC4 soap_get__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, _ns8__getActualR13nShippingRuleListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nShippingRuleListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nShippingRuleListRequest * FASTCALL soap_instantiate__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nShippingRuleListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nShippingRuleListRequest));
		((_ns8__getActualR13nShippingRuleListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nShippingRuleListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nShippingRuleListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nShippingRuleListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nShippingRuleListRequest %p -> %p\n", q, p));
	*(_ns8__getActualR13nShippingRuleListRequest*)p = *(_ns8__getActualR13nShippingRuleListRequest*)q;
}

void _ns8__getActualR13nRegionStatusListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nRegionStatusListResponse::ns6__r13nRegionStatusList = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nRegionStatusListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__RegionalizationRegionStatusList(soap, &this->_ns8__getActualR13nRegionStatusListResponse::ns6__r13nRegionStatusList);
	/* transient soap skipped */
}

int _ns8__getActualR13nRegionStatusListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nRegionStatusListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nRegionStatusListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse), type))
		return soap->error;
	if(a->_ns8__getActualR13nRegionStatusListResponse::ns6__r13nRegionStatusList) {
		if(soap_out_PointerTons6__RegionalizationRegionStatusList(soap, "ns6:r13nRegionStatusList", -1, &a->_ns8__getActualR13nRegionStatusListResponse::ns6__r13nRegionStatusList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:r13nRegionStatusList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nRegionStatusListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nRegionStatusListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListResponse * FASTCALL soap_in__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, const char *tag, _ns8__getActualR13nRegionStatusListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nRegionStatusListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse, sizeof(_ns8__getActualR13nRegionStatusListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nRegionStatusListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__r13nRegionStatusList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__r13nRegionStatusList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationRegionStatusList(soap, "ns6:r13nRegionStatusList", &(a->_ns8__getActualR13nRegionStatusListResponse::ns6__r13nRegionStatusList), "ns6:RegionalizationRegionStatusList"))
				{	soap_flag_ns6__r13nRegionStatusList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nRegionStatusListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse, 0, sizeof(_ns8__getActualR13nRegionStatusListResponse), 0, soap_copy__ns8__getActualR13nRegionStatusListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__r13nRegionStatusList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nRegionStatusListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nRegionStatusListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nRegionStatusListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nRegionStatusListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListResponse * SOAP_FMAC4 soap_get__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, _ns8__getActualR13nRegionStatusListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nRegionStatusListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nRegionStatusListResponse * FASTCALL soap_instantiate__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nRegionStatusListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nRegionStatusListResponse));
		((_ns8__getActualR13nRegionStatusListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nRegionStatusListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nRegionStatusListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nRegionStatusListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nRegionStatusListResponse %p -> %p\n", q, p));
	*(_ns8__getActualR13nRegionStatusListResponse*)p = *(_ns8__getActualR13nRegionStatusListResponse*)q;
}

void _ns8__getActualR13nRegionStatusListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nRegionStatusListRequest::ns3__listOptions = NULL;
	this->_ns8__getActualR13nRegionStatusListRequest::ns6__disease = NULL;
	this->_ns8__getActualR13nRegionStatusListRequest::ns6__r13nZone = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nRegionStatusListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getActualR13nRegionStatusListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->_ns8__getActualR13nRegionStatusListRequest::ns6__disease);
	soap_serialize_PointerTons6__Area(soap, &this->_ns8__getActualR13nRegionStatusListRequest::ns6__r13nZone);
	/* transient soap skipped */
}

int _ns8__getActualR13nRegionStatusListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nRegionStatusListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nRegionStatusListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getActualR13nRegionStatusListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getActualR13nRegionStatusListRequest::ns6__disease) {
		if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:disease", -1, &a->_ns8__getActualR13nRegionStatusListRequest::ns6__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:disease"))
		return soap->error;
	if(soap_out_PointerTons6__Area(soap, "ns6:r13nZone", -1, &(a->_ns8__getActualR13nRegionStatusListRequest::ns6__r13nZone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nRegionStatusListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nRegionStatusListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListRequest * FASTCALL soap_in__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, const char *tag, _ns8__getActualR13nRegionStatusListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nRegionStatusListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest, sizeof(_ns8__getActualR13nRegionStatusListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nRegionStatusListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__disease1 = 1;
	size_t soap_flag_ns6__r13nZone1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getActualR13nRegionStatusListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:disease", &(a->_ns8__getActualR13nRegionStatusListRequest::ns6__disease), "ns6:AnimalDisease"))
				{	soap_flag_ns6__disease1--;
					continue;
				}
			if(soap_flag_ns6__r13nZone1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Area(soap, "ns6:r13nZone", &(a->_ns8__getActualR13nRegionStatusListRequest::ns6__r13nZone), "ns6:Area"))
				{	soap_flag_ns6__r13nZone1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nRegionStatusListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest, 0, sizeof(_ns8__getActualR13nRegionStatusListRequest), 0, soap_copy__ns8__getActualR13nRegionStatusListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nRegionStatusListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nRegionStatusListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nRegionStatusListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nRegionStatusListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListRequest * SOAP_FMAC4 soap_get__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, _ns8__getActualR13nRegionStatusListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nRegionStatusListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nRegionStatusListRequest * FASTCALL soap_instantiate__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nRegionStatusListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nRegionStatusListRequest));
		((_ns8__getActualR13nRegionStatusListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nRegionStatusListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nRegionStatusListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nRegionStatusListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nRegionStatusListRequest %p -> %p\n", q, p));
	*(_ns8__getActualR13nRegionStatusListRequest*)p = *(_ns8__getActualR13nRegionStatusListRequest*)q;
}

void _ns8__getR13nConditionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getR13nConditionListResponse::ns6__r13nConditionList = NULL;
	/* transient soap skipped */
}

void _ns8__getR13nConditionListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__RegionalizationConditionList(soap, &this->_ns8__getR13nConditionListResponse::ns6__r13nConditionList);
	/* transient soap skipped */
}

int _ns8__getR13nConditionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getR13nConditionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getR13nConditionListResponse(struct soap *soap, const char *tag, int id, const _ns8__getR13nConditionListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getR13nConditionListResponse), type))
		return soap->error;
	if(a->_ns8__getR13nConditionListResponse::ns6__r13nConditionList) {
		if(soap_out_PointerTons6__RegionalizationConditionList(soap, "ns6:r13nConditionList", -1, &a->_ns8__getR13nConditionListResponse::ns6__r13nConditionList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:r13nConditionList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getR13nConditionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getR13nConditionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListResponse * FASTCALL soap_in__ns8__getR13nConditionListResponse(struct soap *soap, const char *tag, _ns8__getR13nConditionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getR13nConditionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getR13nConditionListResponse, sizeof(_ns8__getR13nConditionListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getR13nConditionListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getR13nConditionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__r13nConditionList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__r13nConditionList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationConditionList(soap, "ns6:r13nConditionList", &(a->_ns8__getR13nConditionListResponse::ns6__r13nConditionList), "ns6:RegionalizationConditionList"))
				{	soap_flag_ns6__r13nConditionList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getR13nConditionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getR13nConditionListResponse, 0, sizeof(_ns8__getR13nConditionListResponse), 0, soap_copy__ns8__getR13nConditionListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__r13nConditionList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getR13nConditionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getR13nConditionListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getR13nConditionListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getR13nConditionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getR13nConditionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListResponse * SOAP_FMAC4 soap_get__ns8__getR13nConditionListResponse(struct soap *soap, _ns8__getR13nConditionListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getR13nConditionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getR13nConditionListResponse * FASTCALL soap_instantiate__ns8__getR13nConditionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getR13nConditionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getR13nConditionListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getR13nConditionListResponse));
		((_ns8__getR13nConditionListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getR13nConditionListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getR13nConditionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getR13nConditionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getR13nConditionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getR13nConditionListResponse %p -> %p\n", q, p));
	*(_ns8__getR13nConditionListResponse*)p = *(_ns8__getR13nConditionListResponse*)q;
}

void _ns8__getR13nConditionListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getR13nConditionListRequest::ns3__listOptions = NULL;
	this->_ns8__getR13nConditionListRequest::ns6__disease = NULL;
	/* transient soap skipped */
}

void _ns8__getR13nConditionListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getR13nConditionListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->_ns8__getR13nConditionListRequest::ns6__disease);
	/* transient soap skipped */
}

int _ns8__getR13nConditionListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getR13nConditionListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getR13nConditionListRequest(struct soap *soap, const char *tag, int id, const _ns8__getR13nConditionListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getR13nConditionListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getR13nConditionListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:disease", -1, &(a->_ns8__getR13nConditionListRequest::ns6__disease), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getR13nConditionListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getR13nConditionListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListRequest * FASTCALL soap_in__ns8__getR13nConditionListRequest(struct soap *soap, const char *tag, _ns8__getR13nConditionListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getR13nConditionListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getR13nConditionListRequest, sizeof(_ns8__getR13nConditionListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getR13nConditionListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getR13nConditionListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__disease1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getR13nConditionListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:disease", &(a->_ns8__getR13nConditionListRequest::ns6__disease), "ns6:AnimalDisease"))
				{	soap_flag_ns6__disease1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getR13nConditionListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getR13nConditionListRequest, 0, sizeof(_ns8__getR13nConditionListRequest), 0, soap_copy__ns8__getR13nConditionListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getR13nConditionListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getR13nConditionListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getR13nConditionListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getR13nConditionListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getR13nConditionListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListRequest * SOAP_FMAC4 soap_get__ns8__getR13nConditionListRequest(struct soap *soap, _ns8__getR13nConditionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getR13nConditionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getR13nConditionListRequest * FASTCALL soap_instantiate__ns8__getR13nConditionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getR13nConditionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getR13nConditionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getR13nConditionListRequest));
		((_ns8__getR13nConditionListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getR13nConditionListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getR13nConditionListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getR13nConditionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getR13nConditionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getR13nConditionListRequest %p -> %p\n", q, p));
	*(_ns8__getR13nConditionListRequest*)p = *(_ns8__getR13nConditionListRequest*)q;
}

void _ns8__getActivityLocationListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActivityLocationListResponse::ns6__activityLocationList = NULL;
	/* transient soap skipped */
}

void _ns8__getActivityLocationListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ActivityLocationList(soap, &this->_ns8__getActivityLocationListResponse::ns6__activityLocationList);
	/* transient soap skipped */
}

int _ns8__getActivityLocationListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActivityLocationListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, int id, const _ns8__getActivityLocationListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActivityLocationListResponse), type))
		return soap->error;
	if(a->ns6__activityLocationList)
		soap_element_result(soap, "ns6:activityLocationList");
	if(a->_ns8__getActivityLocationListResponse::ns6__activityLocationList) {
		if(soap_out_PointerTons6__ActivityLocationList(soap, "ns6:activityLocationList", -1, &a->_ns8__getActivityLocationListResponse::ns6__activityLocationList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:activityLocationList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActivityLocationListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActivityLocationListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse * FASTCALL soap_in__ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, _ns8__getActivityLocationListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActivityLocationListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActivityLocationListResponse, sizeof(_ns8__getActivityLocationListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActivityLocationListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActivityLocationListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__activityLocationList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__activityLocationList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ActivityLocationList(soap, "ns6:activityLocationList", &(a->_ns8__getActivityLocationListResponse::ns6__activityLocationList), "ns6:ActivityLocationList"))
				{	soap_flag_ns6__activityLocationList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:activityLocationList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActivityLocationListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActivityLocationListResponse, 0, sizeof(_ns8__getActivityLocationListResponse), 0, soap_copy__ns8__getActivityLocationListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__activityLocationList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActivityLocationListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActivityLocationListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getActivityLocationListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActivityLocationListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActivityLocationListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse * SOAP_FMAC4 soap_get__ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActivityLocationListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActivityLocationListResponse * FASTCALL soap_instantiate__ns8__getActivityLocationListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActivityLocationListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActivityLocationListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getActivityLocationListResponse));
		((_ns8__getActivityLocationListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActivityLocationListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getActivityLocationListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActivityLocationListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActivityLocationListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActivityLocationListResponse %p -> %p\n", q, p));
	*(_ns8__getActivityLocationListResponse*)p = *(_ns8__getActivityLocationListResponse*)q;
}

void _ns8__getActivityLocationListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActivityLocationListRequest::ns3__listOptions = NULL;
	this->_ns8__getActivityLocationListRequest::ns6__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getActivityLocationListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getActivityLocationListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->_ns8__getActivityLocationListRequest::ns6__businessEntity);
	/* transient soap skipped */
}

int _ns8__getActivityLocationListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActivityLocationListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, int id, const _ns8__getActivityLocationListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActivityLocationListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getActivityLocationListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getActivityLocationListRequest::ns6__businessEntity) {
		if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &a->_ns8__getActivityLocationListRequest::ns6__businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessEntity"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActivityLocationListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActivityLocationListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest * FASTCALL soap_in__ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, _ns8__getActivityLocationListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActivityLocationListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActivityLocationListRequest, sizeof(_ns8__getActivityLocationListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActivityLocationListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActivityLocationListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getActivityLocationListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->_ns8__getActivityLocationListRequest::ns6__businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_ns6__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActivityLocationListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActivityLocationListRequest, 0, sizeof(_ns8__getActivityLocationListRequest), 0, soap_copy__ns8__getActivityLocationListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__businessEntity1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActivityLocationListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActivityLocationListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getActivityLocationListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActivityLocationListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActivityLocationListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest * SOAP_FMAC4 soap_get__ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActivityLocationListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActivityLocationListRequest * FASTCALL soap_instantiate__ns8__getActivityLocationListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActivityLocationListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActivityLocationListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getActivityLocationListRequest));
		((_ns8__getActivityLocationListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActivityLocationListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getActivityLocationListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActivityLocationListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActivityLocationListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActivityLocationListRequest %p -> %p\n", q, p));
	*(_ns8__getActivityLocationListRequest*)p = *(_ns8__getActivityLocationListRequest*)q;
}

void _ns8__getBusinessMemberByGLNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessMemberByGLNResponse::ns6__businessMember = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessMemberByGLNResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessMember(soap, &this->_ns8__getBusinessMemberByGLNResponse::ns6__businessMember);
	/* transient soap skipped */
}

int _ns8__getBusinessMemberByGLNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessMemberByGLNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessMemberByGLNResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse), type))
		return soap->error;
	if(a->ns6__businessMember)
		soap_element_result(soap, "ns6:businessMember");
	if(a->_ns8__getBusinessMemberByGLNResponse::ns6__businessMember) {
		if(soap_out_PointerTons6__BusinessMember(soap, "ns6:businessMember", -1, &a->_ns8__getBusinessMemberByGLNResponse::ns6__businessMember, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessMember"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessMemberByGLNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessMemberByGLNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse * FASTCALL soap_in__ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessMemberByGLNResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, sizeof(_ns8__getBusinessMemberByGLNResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessMemberByGLNResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessMemberByGLNResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__businessMember1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__businessMember1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns6:businessMember", &(a->_ns8__getBusinessMemberByGLNResponse::ns6__businessMember), "ns6:BusinessMember"))
				{	soap_flag_ns6__businessMember1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:businessMember");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessMemberByGLNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, 0, sizeof(_ns8__getBusinessMemberByGLNResponse), 0, soap_copy__ns8__getBusinessMemberByGLNResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__businessMember1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessMemberByGLNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessMemberByGLNResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessMemberByGLNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessMemberByGLNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse * SOAP_FMAC4 soap_get__ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessMemberByGLNResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessMemberByGLNResponse * FASTCALL soap_instantiate__ns8__getBusinessMemberByGLNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessMemberByGLNResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessMemberByGLNResponse));
		((_ns8__getBusinessMemberByGLNResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessMemberByGLNResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessMemberByGLNResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessMemberByGLNResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessMemberByGLNResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessMemberByGLNResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessMemberByGLNResponse*)p = *(_ns8__getBusinessMemberByGLNResponse*)q;
}

void _ns8__getBusinessMemberByGLNRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__GLNType(soap, &this->_ns8__getBusinessMemberByGLNRequest::ns6__globalID);
	/* transient soap skipped */
}

void _ns8__getBusinessMemberByGLNRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns6__GLNType(soap, &this->_ns8__getBusinessMemberByGLNRequest::ns6__globalID);
	/* transient soap skipped */
}

int _ns8__getBusinessMemberByGLNRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessMemberByGLNRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessMemberByGLNRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest), type))
		return soap->error;
	if(a->_ns8__getBusinessMemberByGLNRequest::ns6__globalID) {
		if(soap_out_ns6__GLNType(soap, "ns6:globalID", -1, &a->_ns8__getBusinessMemberByGLNRequest::ns6__globalID, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:globalID"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessMemberByGLNRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessMemberByGLNRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest * FASTCALL soap_in__ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessMemberByGLNRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, sizeof(_ns8__getBusinessMemberByGLNRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessMemberByGLNRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessMemberByGLNRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__globalID1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__GLNType(soap, "ns6:globalID", &(a->_ns8__getBusinessMemberByGLNRequest::ns6__globalID), "ns6:GLNType"))
				{	soap_flag_ns6__globalID1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessMemberByGLNRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, 0, sizeof(_ns8__getBusinessMemberByGLNRequest), 0, soap_copy__ns8__getBusinessMemberByGLNRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__globalID1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessMemberByGLNRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessMemberByGLNRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessMemberByGLNRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessMemberByGLNRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest * SOAP_FMAC4 soap_get__ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessMemberByGLNRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessMemberByGLNRequest * FASTCALL soap_instantiate__ns8__getBusinessMemberByGLNRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessMemberByGLNRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessMemberByGLNRequest));
		((_ns8__getBusinessMemberByGLNRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessMemberByGLNRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessMemberByGLNRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessMemberByGLNRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessMemberByGLNRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessMemberByGLNRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessMemberByGLNRequest*)p = *(_ns8__getBusinessMemberByGLNRequest*)q;
}

void _ns8__getBusinessEntityChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityChangesListResponse::ns6__businessEntityList = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntityList(soap, &this->_ns8__getBusinessEntityChangesListResponse::ns6__businessEntityList);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse), type))
		return soap->error;
	if(a->ns6__businessEntityList)
		soap_element_result(soap, "ns6:businessEntityList");
	if(a->_ns8__getBusinessEntityChangesListResponse::ns6__businessEntityList) {
		if(soap_out_PointerTons6__BusinessEntityList(soap, "ns6:businessEntityList", -1, &a->_ns8__getBusinessEntityChangesListResponse::ns6__businessEntityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessEntityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse * FASTCALL soap_in__ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, sizeof(_ns8__getBusinessEntityChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__businessEntityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__businessEntityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntityList(soap, "ns6:businessEntityList", &(a->_ns8__getBusinessEntityChangesListResponse::ns6__businessEntityList), "ns6:BusinessEntityList"))
				{	soap_flag_ns6__businessEntityList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:businessEntityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, 0, sizeof(_ns8__getBusinessEntityChangesListResponse), 0, soap_copy__ns8__getBusinessEntityChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__businessEntityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityChangesListResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityChangesListResponse));
		((_ns8__getBusinessEntityChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityChangesListResponse*)p = *(_ns8__getBusinessEntityChangesListResponse*)q;
}

void _ns8__getBusinessEntityChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getBusinessEntityChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getBusinessEntityChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getBusinessEntityChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getBusinessEntityChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getBusinessEntityChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getBusinessEntityChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest * FASTCALL soap_in__ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, sizeof(_ns8__getBusinessEntityChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getBusinessEntityChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getBusinessEntityChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, 0, sizeof(_ns8__getBusinessEntityChangesListRequest), 0, soap_copy__ns8__getBusinessEntityChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityChangesListRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityChangesListRequest));
		((_ns8__getBusinessEntityChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityChangesListRequest*)p = *(_ns8__getBusinessEntityChangesListRequest*)q;
}

void _ns8__getBusinessEntityListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityListResponse::ns6__businessEntityList = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntityList(soap, &this->_ns8__getBusinessEntityListResponse::ns6__businessEntityList);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityListResponse), type))
		return soap->error;
	if(a->ns6__businessEntityList)
		soap_element_result(soap, "ns6:businessEntityList");
	if(a->_ns8__getBusinessEntityListResponse::ns6__businessEntityList) {
		if(soap_out_PointerTons6__BusinessEntityList(soap, "ns6:businessEntityList", -1, &a->_ns8__getBusinessEntityListResponse::ns6__businessEntityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessEntityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse * FASTCALL soap_in__ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityListResponse, sizeof(_ns8__getBusinessEntityListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__businessEntityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__businessEntityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntityList(soap, "ns6:businessEntityList", &(a->_ns8__getBusinessEntityListResponse::ns6__businessEntityList), "ns6:BusinessEntityList"))
				{	soap_flag_ns6__businessEntityList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:businessEntityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityListResponse, 0, sizeof(_ns8__getBusinessEntityListResponse), 0, soap_copy__ns8__getBusinessEntityListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__businessEntityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityListResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityListResponse));
		((_ns8__getBusinessEntityListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityListResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityListResponse*)p = *(_ns8__getBusinessEntityListResponse*)q;
}

void _ns8__getBusinessEntityListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityListRequest::ns3__listOptions = NULL;
	this->_ns8__getBusinessEntityListRequest::ns6__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getBusinessEntityListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->_ns8__getBusinessEntityListRequest::ns6__businessEntity);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getBusinessEntityListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &(a->_ns8__getBusinessEntityListRequest::ns6__businessEntity), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest * FASTCALL soap_in__ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityListRequest, sizeof(_ns8__getBusinessEntityListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getBusinessEntityListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->_ns8__getBusinessEntityListRequest::ns6__businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_ns6__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityListRequest, 0, sizeof(_ns8__getBusinessEntityListRequest), 0, soap_copy__ns8__getBusinessEntityListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityListRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityListRequest));
		((_ns8__getBusinessEntityListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityListRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityListRequest*)p = *(_ns8__getBusinessEntityListRequest*)q;
}

void _ns8__getBusinessEntityByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityByUuidResponse::ns6__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->_ns8__getBusinessEntityByUuidResponse::ns6__businessEntity);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse), type))
		return soap->error;
	if(a->ns6__businessEntity)
		soap_element_result(soap, "ns6:businessEntity");
	if(a->_ns8__getBusinessEntityByUuidResponse::ns6__businessEntity) {
		if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &a->_ns8__getBusinessEntityByUuidResponse::ns6__businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessEntity"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse * FASTCALL soap_in__ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, sizeof(_ns8__getBusinessEntityByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->_ns8__getBusinessEntityByUuidResponse::ns6__businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_ns6__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, 0, sizeof(_ns8__getBusinessEntityByUuidResponse), 0, soap_copy__ns8__getBusinessEntityByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__businessEntity1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByUuidResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByUuidResponse));
		((_ns8__getBusinessEntityByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByUuidResponse*)p = *(_ns8__getBusinessEntityByUuidResponse*)q;
}

void _ns8__getBusinessEntityByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getBusinessEntityByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getBusinessEntityByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getBusinessEntityByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getBusinessEntityByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest * FASTCALL soap_in__ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, sizeof(_ns8__getBusinessEntityByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getBusinessEntityByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, 0, sizeof(_ns8__getBusinessEntityByUuidRequest), 0, soap_copy__ns8__getBusinessEntityByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByUuidRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByUuidRequest));
		((_ns8__getBusinessEntityByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByUuidRequest*)p = *(_ns8__getBusinessEntityByUuidRequest*)q;
}

void _ns8__getBusinessEntityByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityByGuidResponse::ns6__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->_ns8__getBusinessEntityByGuidResponse::ns6__businessEntity);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse), type))
		return soap->error;
	if(a->ns6__businessEntity)
		soap_element_result(soap, "ns6:businessEntity");
	if(a->_ns8__getBusinessEntityByGuidResponse::ns6__businessEntity) {
		if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &a->_ns8__getBusinessEntityByGuidResponse::ns6__businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessEntity"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse * FASTCALL soap_in__ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, sizeof(_ns8__getBusinessEntityByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->_ns8__getBusinessEntityByGuidResponse::ns6__businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_ns6__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, 0, sizeof(_ns8__getBusinessEntityByGuidResponse), 0, soap_copy__ns8__getBusinessEntityByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__businessEntity1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByGuidResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByGuidResponse));
		((_ns8__getBusinessEntityByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByGuidResponse*)p = *(_ns8__getBusinessEntityByGuidResponse*)q;
}

void _ns8__getBusinessEntityByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getBusinessEntityByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getBusinessEntityByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getBusinessEntityByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getBusinessEntityByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest * FASTCALL soap_in__ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, sizeof(_ns8__getBusinessEntityByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getBusinessEntityByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, 0, sizeof(_ns8__getBusinessEntityByGuidRequest), 0, soap_copy__ns8__getBusinessEntityByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByGuidRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByGuidRequest));
		((_ns8__getBusinessEntityByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByGuidRequest*)p = *(_ns8__getBusinessEntityByGuidRequest*)q;
}

void _ns8__getRussianEnterpriseChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseChangesListResponse::ns6__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__EnterpriseList(soap, &this->_ns8__getRussianEnterpriseChangesListResponse::ns6__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse), type))
		return soap->error;
	if(a->ns6__enterpriseList)
		soap_element_result(soap, "ns6:enterpriseList");
	if(a->_ns8__getRussianEnterpriseChangesListResponse::ns6__enterpriseList) {
		if(soap_out_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", -1, &a->_ns8__getRussianEnterpriseChangesListResponse::ns6__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse * FASTCALL soap_in__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, sizeof(_ns8__getRussianEnterpriseChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", &(a->_ns8__getRussianEnterpriseChangesListResponse::ns6__enterpriseList), "ns6:EnterpriseList"))
				{	soap_flag_ns6__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, 0, sizeof(_ns8__getRussianEnterpriseChangesListResponse), 0, soap_copy__ns8__getRussianEnterpriseChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseChangesListResponse * FASTCALL soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseChangesListResponse));
		((_ns8__getRussianEnterpriseChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseChangesListResponse*)p = *(_ns8__getRussianEnterpriseChangesListResponse*)q;
}

void _ns8__getRussianEnterpriseChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getRussianEnterpriseChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getRussianEnterpriseChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getRussianEnterpriseChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getRussianEnterpriseChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getRussianEnterpriseChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getRussianEnterpriseChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest * FASTCALL soap_in__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, sizeof(_ns8__getRussianEnterpriseChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getRussianEnterpriseChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getRussianEnterpriseChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, 0, sizeof(_ns8__getRussianEnterpriseChangesListRequest), 0, soap_copy__ns8__getRussianEnterpriseChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseChangesListRequest * FASTCALL soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseChangesListRequest));
		((_ns8__getRussianEnterpriseChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseChangesListRequest*)p = *(_ns8__getRussianEnterpriseChangesListRequest*)q;
}

void _ns8__getForeignEnterpriseChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseChangesListResponse::ns6__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__EnterpriseList(soap, &this->_ns8__getForeignEnterpriseChangesListResponse::ns6__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse), type))
		return soap->error;
	if(a->ns6__enterpriseList)
		soap_element_result(soap, "ns6:enterpriseList");
	if(a->_ns8__getForeignEnterpriseChangesListResponse::ns6__enterpriseList) {
		if(soap_out_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", -1, &a->_ns8__getForeignEnterpriseChangesListResponse::ns6__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse * FASTCALL soap_in__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, sizeof(_ns8__getForeignEnterpriseChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", &(a->_ns8__getForeignEnterpriseChangesListResponse::ns6__enterpriseList), "ns6:EnterpriseList"))
				{	soap_flag_ns6__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, 0, sizeof(_ns8__getForeignEnterpriseChangesListResponse), 0, soap_copy__ns8__getForeignEnterpriseChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseChangesListResponse * FASTCALL soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseChangesListResponse));
		((_ns8__getForeignEnterpriseChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseChangesListResponse*)p = *(_ns8__getForeignEnterpriseChangesListResponse*)q;
}

void _ns8__getForeignEnterpriseChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getForeignEnterpriseChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getForeignEnterpriseChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getForeignEnterpriseChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getForeignEnterpriseChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getForeignEnterpriseChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getForeignEnterpriseChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest * FASTCALL soap_in__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, sizeof(_ns8__getForeignEnterpriseChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getForeignEnterpriseChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getForeignEnterpriseChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, 0, sizeof(_ns8__getForeignEnterpriseChangesListRequest), 0, soap_copy__ns8__getForeignEnterpriseChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseChangesListRequest * FASTCALL soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseChangesListRequest));
		((_ns8__getForeignEnterpriseChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseChangesListRequest*)p = *(_ns8__getForeignEnterpriseChangesListRequest*)q;
}

void _ns8__getRussianEnterpriseListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseListResponse::ns6__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__EnterpriseList(soap, &this->_ns8__getRussianEnterpriseListResponse::ns6__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse), type))
		return soap->error;
	if(a->ns6__enterpriseList)
		soap_element_result(soap, "ns6:enterpriseList");
	if(a->_ns8__getRussianEnterpriseListResponse::ns6__enterpriseList) {
		if(soap_out_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", -1, &a->_ns8__getRussianEnterpriseListResponse::ns6__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse * FASTCALL soap_in__ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, sizeof(_ns8__getRussianEnterpriseListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", &(a->_ns8__getRussianEnterpriseListResponse::ns6__enterpriseList), "ns6:EnterpriseList"))
				{	soap_flag_ns6__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, 0, sizeof(_ns8__getRussianEnterpriseListResponse), 0, soap_copy__ns8__getRussianEnterpriseListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseListResponse * FASTCALL soap_instantiate__ns8__getRussianEnterpriseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseListResponse));
		((_ns8__getRussianEnterpriseListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseListResponse %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseListResponse*)p = *(_ns8__getRussianEnterpriseListResponse*)q;
}

void _ns8__getRussianEnterpriseListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseListRequest::ns3__listOptions = NULL;
	this->_ns8__getRussianEnterpriseListRequest::ns6__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getRussianEnterpriseListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns8__getRussianEnterpriseListRequest::ns6__enterprise);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getRussianEnterpriseListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &(a->_ns8__getRussianEnterpriseListRequest::ns6__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest * FASTCALL soap_in__ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, sizeof(_ns8__getRussianEnterpriseListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getRussianEnterpriseListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns8__getRussianEnterpriseListRequest::ns6__enterprise), "ns6:Enterprise"))
				{	soap_flag_ns6__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, 0, sizeof(_ns8__getRussianEnterpriseListRequest), 0, soap_copy__ns8__getRussianEnterpriseListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseListRequest * FASTCALL soap_instantiate__ns8__getRussianEnterpriseListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseListRequest));
		((_ns8__getRussianEnterpriseListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseListRequest %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseListRequest*)p = *(_ns8__getRussianEnterpriseListRequest*)q;
}

void _ns8__getForeignEnterpriseListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseListResponse::ns6__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__EnterpriseList(soap, &this->_ns8__getForeignEnterpriseListResponse::ns6__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse), type))
		return soap->error;
	if(a->ns6__enterpriseList)
		soap_element_result(soap, "ns6:enterpriseList");
	if(a->_ns8__getForeignEnterpriseListResponse::ns6__enterpriseList) {
		if(soap_out_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", -1, &a->_ns8__getForeignEnterpriseListResponse::ns6__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse * FASTCALL soap_in__ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, sizeof(_ns8__getForeignEnterpriseListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseList(soap, "ns6:enterpriseList", &(a->_ns8__getForeignEnterpriseListResponse::ns6__enterpriseList), "ns6:EnterpriseList"))
				{	soap_flag_ns6__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, 0, sizeof(_ns8__getForeignEnterpriseListResponse), 0, soap_copy__ns8__getForeignEnterpriseListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseListResponse * FASTCALL soap_instantiate__ns8__getForeignEnterpriseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseListResponse));
		((_ns8__getForeignEnterpriseListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseListResponse %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseListResponse*)p = *(_ns8__getForeignEnterpriseListResponse*)q;
}

void _ns8__getForeignEnterpriseListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseListRequest::ns3__listOptions = NULL;
	this->_ns8__getForeignEnterpriseListRequest::ns6__enterpriseGroup = NULL;
	this->_ns8__getForeignEnterpriseListRequest::ns6__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getForeignEnterpriseListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__EnterpriseGroup(soap, &this->_ns8__getForeignEnterpriseListRequest::ns6__enterpriseGroup);
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns8__getForeignEnterpriseListRequest::ns6__enterprise);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getForeignEnterpriseListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseGroup(soap, "ns6:enterpriseGroup", -1, &(a->_ns8__getForeignEnterpriseListRequest::ns6__enterpriseGroup), ""))
		return soap->error;
	if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &(a->_ns8__getForeignEnterpriseListRequest::ns6__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest * FASTCALL soap_in__ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, sizeof(_ns8__getForeignEnterpriseListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__enterpriseGroup1 = 1;
	size_t soap_flag_ns6__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getForeignEnterpriseListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseGroup(soap, "ns6:enterpriseGroup", &(a->_ns8__getForeignEnterpriseListRequest::ns6__enterpriseGroup), "ns6:EnterpriseGroup"))
				{	soap_flag_ns6__enterpriseGroup1--;
					continue;
				}
			if(soap_flag_ns6__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns8__getForeignEnterpriseListRequest::ns6__enterprise), "ns6:Enterprise"))
				{	soap_flag_ns6__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, 0, sizeof(_ns8__getForeignEnterpriseListRequest), 0, soap_copy__ns8__getForeignEnterpriseListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseListRequest * FASTCALL soap_instantiate__ns8__getForeignEnterpriseListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseListRequest));
		((_ns8__getForeignEnterpriseListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseListRequest %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseListRequest*)p = *(_ns8__getForeignEnterpriseListRequest*)q;
}

void _ns8__getEnterpriseByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getEnterpriseByUuidResponse::ns6__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getEnterpriseByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns8__getEnterpriseByUuidResponse::ns6__enterprise);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse), type))
		return soap->error;
	if(a->ns6__enterprise)
		soap_element_result(soap, "ns6:enterprise");
	if(a->_ns8__getEnterpriseByUuidResponse::ns6__enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &a->_ns8__getEnterpriseByUuidResponse::ns6__enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterprise"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse * FASTCALL soap_in__ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, sizeof(_ns8__getEnterpriseByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns8__getEnterpriseByUuidResponse::ns6__enterprise), "ns6:Enterprise"))
				{	soap_flag_ns6__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:enterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, 0, sizeof(_ns8__getEnterpriseByUuidResponse), 0, soap_copy__ns8__getEnterpriseByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse * SOAP_FMAC4 soap_get__ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByUuidResponse * FASTCALL soap_instantiate__ns8__getEnterpriseByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByUuidResponse));
		((_ns8__getEnterpriseByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByUuidResponse*)p = *(_ns8__getEnterpriseByUuidResponse*)q;
}

void _ns8__getEnterpriseByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getEnterpriseByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getEnterpriseByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getEnterpriseByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getEnterpriseByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getEnterpriseByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest * FASTCALL soap_in__ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, sizeof(_ns8__getEnterpriseByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getEnterpriseByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, 0, sizeof(_ns8__getEnterpriseByUuidRequest), 0, soap_copy__ns8__getEnterpriseByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest * SOAP_FMAC4 soap_get__ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByUuidRequest * FASTCALL soap_instantiate__ns8__getEnterpriseByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByUuidRequest));
		((_ns8__getEnterpriseByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByUuidRequest*)p = *(_ns8__getEnterpriseByUuidRequest*)q;
}

void _ns8__getEnterpriseByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getEnterpriseByGuidResponse::ns6__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getEnterpriseByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns8__getEnterpriseByGuidResponse::ns6__enterprise);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse), type))
		return soap->error;
	if(a->ns6__enterprise)
		soap_element_result(soap, "ns6:enterprise");
	if(a->_ns8__getEnterpriseByGuidResponse::ns6__enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &a->_ns8__getEnterpriseByGuidResponse::ns6__enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterprise"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse * FASTCALL soap_in__ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, sizeof(_ns8__getEnterpriseByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns8__getEnterpriseByGuidResponse::ns6__enterprise), "ns6:Enterprise"))
				{	soap_flag_ns6__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns6:enterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, 0, sizeof(_ns8__getEnterpriseByGuidResponse), 0, soap_copy__ns8__getEnterpriseByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse * SOAP_FMAC4 soap_get__ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByGuidResponse * FASTCALL soap_instantiate__ns8__getEnterpriseByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByGuidResponse));
		((_ns8__getEnterpriseByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByGuidResponse*)p = *(_ns8__getEnterpriseByGuidResponse*)q;
}

void _ns8__getEnterpriseByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getEnterpriseByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getEnterpriseByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getEnterpriseByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getEnterpriseByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getEnterpriseByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest * FASTCALL soap_in__ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, sizeof(_ns8__getEnterpriseByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getEnterpriseByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, 0, sizeof(_ns8__getEnterpriseByGuidRequest), 0, soap_copy__ns8__getEnterpriseByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest * SOAP_FMAC4 soap_get__ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByGuidRequest * FASTCALL soap_instantiate__ns8__getEnterpriseByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByGuidRequest));
		((_ns8__getEnterpriseByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByGuidRequest*)p = *(_ns8__getEnterpriseByGuidRequest*)q;
}

void _ns8__findStreetListByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findStreetListByNameResponse::ns6__streetList = NULL;
	/* transient soap skipped */
}

void _ns8__findStreetListByNameResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__StreetList(soap, &this->_ns8__findStreetListByNameResponse::ns6__streetList);
	/* transient soap skipped */
}

int _ns8__findStreetListByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findStreetListByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findStreetListByNameResponse(struct soap *soap, const char *tag, int id, const _ns8__findStreetListByNameResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findStreetListByNameResponse), type))
		return soap->error;
	if(a->_ns8__findStreetListByNameResponse::ns6__streetList) {
		if(soap_out_PointerTons6__StreetList(soap, "ns6:streetList", -1, &a->_ns8__findStreetListByNameResponse::ns6__streetList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:streetList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findStreetListByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findStreetListByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameResponse * FASTCALL soap_in__ns8__findStreetListByNameResponse(struct soap *soap, const char *tag, _ns8__findStreetListByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findStreetListByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findStreetListByNameResponse, sizeof(_ns8__findStreetListByNameResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findStreetListByNameResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findStreetListByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__streetList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__streetList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__StreetList(soap, "ns6:streetList", &(a->_ns8__findStreetListByNameResponse::ns6__streetList), "ns6:StreetList"))
				{	soap_flag_ns6__streetList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findStreetListByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findStreetListByNameResponse, 0, sizeof(_ns8__findStreetListByNameResponse), 0, soap_copy__ns8__findStreetListByNameResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__streetList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findStreetListByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findStreetListByNameResponse);
	return this->soap_out(soap, tag?tag:"ns8:findStreetListByNameResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findStreetListByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findStreetListByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameResponse * SOAP_FMAC4 soap_get__ns8__findStreetListByNameResponse(struct soap *soap, _ns8__findStreetListByNameResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findStreetListByNameResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findStreetListByNameResponse * FASTCALL soap_instantiate__ns8__findStreetListByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findStreetListByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findStreetListByNameResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameResponse);
		ASSIGN_PTR(size, sizeof(_ns8__findStreetListByNameResponse));
		((_ns8__findStreetListByNameResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findStreetListByNameResponse));
		for(int i = 0; i < n; i++)
			((_ns8__findStreetListByNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findStreetListByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findStreetListByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findStreetListByNameResponse %p -> %p\n", q, p));
	*(_ns8__findStreetListByNameResponse*)p = *(_ns8__findStreetListByNameResponse*)q;
}

void _ns8__findStreetListByNameRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findStreetListByNameRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__findStreetListByNameRequest::ns6__localityGuid);
	soap_default_string(soap, &this->_ns8__findStreetListByNameRequest::pattern);
	/* transient soap skipped */
}

void _ns8__findStreetListByNameRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__findStreetListByNameRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__findStreetListByNameRequest::ns6__localityGuid);
	soap_serialize_string(soap, &this->_ns8__findStreetListByNameRequest::pattern);
	/* transient soap skipped */
}

int _ns8__findStreetListByNameRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findStreetListByNameRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findStreetListByNameRequest(struct soap *soap, const char *tag, int id, const _ns8__findStreetListByNameRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findStreetListByNameRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__findStreetListByNameRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__findStreetListByNameRequest::ns6__localityGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:localityGuid", -1, &a->_ns8__findStreetListByNameRequest::ns6__localityGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityGuid"))
		return soap->error;
	if(a->_ns8__findStreetListByNameRequest::pattern) {
		if(soap_out_string(soap, "ns8:pattern", -1, &a->_ns8__findStreetListByNameRequest::pattern, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns8:pattern"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findStreetListByNameRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findStreetListByNameRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameRequest * FASTCALL soap_in__ns8__findStreetListByNameRequest(struct soap *soap, const char *tag, _ns8__findStreetListByNameRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findStreetListByNameRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findStreetListByNameRequest, sizeof(_ns8__findStreetListByNameRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findStreetListByNameRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findStreetListByNameRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__localityGuid1 = 1;
	size_t soap_flag_pattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__findStreetListByNameRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:localityGuid", &(a->_ns8__findStreetListByNameRequest::ns6__localityGuid), "ns3:UUID"))
				{	soap_flag_ns6__localityGuid1--;
					continue;
				}
			if(soap_flag_pattern1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns8:pattern", &(a->_ns8__findStreetListByNameRequest::pattern), "xsd:string"))
				{	soap_flag_pattern1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findStreetListByNameRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findStreetListByNameRequest, 0, sizeof(_ns8__findStreetListByNameRequest), 0, soap_copy__ns8__findStreetListByNameRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityGuid1 > 0 || soap_flag_pattern1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findStreetListByNameRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findStreetListByNameRequest);
	return this->soap_out(soap, tag?tag:"ns8:findStreetListByNameRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findStreetListByNameRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findStreetListByNameRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameRequest * SOAP_FMAC4 soap_get__ns8__findStreetListByNameRequest(struct soap *soap, _ns8__findStreetListByNameRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findStreetListByNameRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findStreetListByNameRequest * FASTCALL soap_instantiate__ns8__findStreetListByNameRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findStreetListByNameRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findStreetListByNameRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameRequest);
		ASSIGN_PTR(size, sizeof(_ns8__findStreetListByNameRequest));
		((_ns8__findStreetListByNameRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findStreetListByNameRequest));
		for(int i = 0; i < n; i++)
			((_ns8__findStreetListByNameRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findStreetListByNameRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findStreetListByNameRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findStreetListByNameRequest %p -> %p\n", q, p));
	*(_ns8__findStreetListByNameRequest*)p = *(_ns8__findStreetListByNameRequest*)q;
}

void _ns8__findLocalityListByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findLocalityListByNameResponse::ns6__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__findLocalityListByNameResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__LocalityList(soap, &this->_ns8__findLocalityListByNameResponse::ns6__localityList);
	/* transient soap skipped */
}

int _ns8__findLocalityListByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findLocalityListByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findLocalityListByNameResponse(struct soap *soap, const char *tag, int id, const _ns8__findLocalityListByNameResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findLocalityListByNameResponse), type))
		return soap->error;
	if(a->_ns8__findLocalityListByNameResponse::ns6__localityList) {
		if(soap_out_PointerTons6__LocalityList(soap, "ns6:localityList", -1, &a->_ns8__findLocalityListByNameResponse::ns6__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findLocalityListByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findLocalityListByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameResponse * FASTCALL soap_in__ns8__findLocalityListByNameResponse(struct soap *soap, const char *tag, _ns8__findLocalityListByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findLocalityListByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findLocalityListByNameResponse, sizeof(_ns8__findLocalityListByNameResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findLocalityListByNameResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findLocalityListByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__LocalityList(soap, "ns6:localityList", &(a->_ns8__findLocalityListByNameResponse::ns6__localityList), "ns6:LocalityList"))
				{	soap_flag_ns6__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findLocalityListByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findLocalityListByNameResponse, 0, sizeof(_ns8__findLocalityListByNameResponse), 0, soap_copy__ns8__findLocalityListByNameResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findLocalityListByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findLocalityListByNameResponse);
	return this->soap_out(soap, tag?tag:"ns8:findLocalityListByNameResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findLocalityListByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findLocalityListByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameResponse * SOAP_FMAC4 soap_get__ns8__findLocalityListByNameResponse(struct soap *soap, _ns8__findLocalityListByNameResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findLocalityListByNameResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findLocalityListByNameResponse * FASTCALL soap_instantiate__ns8__findLocalityListByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findLocalityListByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findLocalityListByNameResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameResponse);
		ASSIGN_PTR(size, sizeof(_ns8__findLocalityListByNameResponse));
		((_ns8__findLocalityListByNameResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findLocalityListByNameResponse));
		for(int i = 0; i < n; i++)
			((_ns8__findLocalityListByNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findLocalityListByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findLocalityListByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findLocalityListByNameResponse %p -> %p\n", q, p));
	*(_ns8__findLocalityListByNameResponse*)p = *(_ns8__findLocalityListByNameResponse*)q;
}

void _ns8__findLocalityListByNameRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findLocalityListByNameRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__findLocalityListByNameRequest::ns6__regionGuid);
	soap_default_string(soap, &this->_ns8__findLocalityListByNameRequest::pattern);
	/* transient soap skipped */
}

void _ns8__findLocalityListByNameRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__findLocalityListByNameRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__findLocalityListByNameRequest::ns6__regionGuid);
	soap_serialize_string(soap, &this->_ns8__findLocalityListByNameRequest::pattern);
	/* transient soap skipped */
}

int _ns8__findLocalityListByNameRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findLocalityListByNameRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findLocalityListByNameRequest(struct soap *soap, const char *tag, int id, const _ns8__findLocalityListByNameRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findLocalityListByNameRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__findLocalityListByNameRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__findLocalityListByNameRequest::ns6__regionGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:regionGuid", -1, &a->_ns8__findLocalityListByNameRequest::ns6__regionGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:regionGuid"))
		return soap->error;
	if(a->_ns8__findLocalityListByNameRequest::pattern) {
		if(soap_out_string(soap, "ns8:pattern", -1, &a->_ns8__findLocalityListByNameRequest::pattern, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns8:pattern"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findLocalityListByNameRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findLocalityListByNameRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameRequest * FASTCALL soap_in__ns8__findLocalityListByNameRequest(struct soap *soap, const char *tag, _ns8__findLocalityListByNameRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findLocalityListByNameRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findLocalityListByNameRequest, sizeof(_ns8__findLocalityListByNameRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findLocalityListByNameRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findLocalityListByNameRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__regionGuid1 = 1;
	size_t soap_flag_pattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__findLocalityListByNameRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:regionGuid", &(a->_ns8__findLocalityListByNameRequest::ns6__regionGuid), "ns3:UUID"))
				{	soap_flag_ns6__regionGuid1--;
					continue;
				}
			if(soap_flag_pattern1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns8:pattern", &(a->_ns8__findLocalityListByNameRequest::pattern), "xsd:string"))
				{	soap_flag_pattern1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findLocalityListByNameRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findLocalityListByNameRequest, 0, sizeof(_ns8__findLocalityListByNameRequest), 0, soap_copy__ns8__findLocalityListByNameRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__regionGuid1 > 0 || soap_flag_pattern1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findLocalityListByNameRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findLocalityListByNameRequest);
	return this->soap_out(soap, tag?tag:"ns8:findLocalityListByNameRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findLocalityListByNameRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findLocalityListByNameRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameRequest * SOAP_FMAC4 soap_get__ns8__findLocalityListByNameRequest(struct soap *soap, _ns8__findLocalityListByNameRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findLocalityListByNameRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findLocalityListByNameRequest * FASTCALL soap_instantiate__ns8__findLocalityListByNameRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findLocalityListByNameRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findLocalityListByNameRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameRequest);
		ASSIGN_PTR(size, sizeof(_ns8__findLocalityListByNameRequest));
		((_ns8__findLocalityListByNameRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findLocalityListByNameRequest));
		for(int i = 0; i < n; i++)
			((_ns8__findLocalityListByNameRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findLocalityListByNameRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findLocalityListByNameRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findLocalityListByNameRequest %p -> %p\n", q, p));
	*(_ns8__findLocalityListByNameRequest*)p = *(_ns8__findLocalityListByNameRequest*)q;
}

void _ns8__getStreetListByLocalityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getStreetListByLocalityResponse::ns6__streetList = NULL;
	/* transient soap skipped */
}

void _ns8__getStreetListByLocalityResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__StreetList(soap, &this->_ns8__getStreetListByLocalityResponse::ns6__streetList);
	/* transient soap skipped */
}

int _ns8__getStreetListByLocalityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getStreetListByLocalityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getStreetListByLocalityResponse(struct soap *soap, const char *tag, int id, const _ns8__getStreetListByLocalityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getStreetListByLocalityResponse), type))
		return soap->error;
	if(a->_ns8__getStreetListByLocalityResponse::ns6__streetList) {
		if(soap_out_PointerTons6__StreetList(soap, "ns6:streetList", -1, &a->_ns8__getStreetListByLocalityResponse::ns6__streetList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:streetList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getStreetListByLocalityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getStreetListByLocalityResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityResponse * FASTCALL soap_in__ns8__getStreetListByLocalityResponse(struct soap *soap, const char *tag, _ns8__getStreetListByLocalityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getStreetListByLocalityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getStreetListByLocalityResponse, sizeof(_ns8__getStreetListByLocalityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getStreetListByLocalityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getStreetListByLocalityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__streetList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__streetList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__StreetList(soap, "ns6:streetList", &(a->_ns8__getStreetListByLocalityResponse::ns6__streetList), "ns6:StreetList"))
				{	soap_flag_ns6__streetList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getStreetListByLocalityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getStreetListByLocalityResponse, 0, sizeof(_ns8__getStreetListByLocalityResponse), 0, soap_copy__ns8__getStreetListByLocalityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__streetList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getStreetListByLocalityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getStreetListByLocalityResponse);
	return this->soap_out(soap, tag?tag:"ns8:getStreetListByLocalityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getStreetListByLocalityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getStreetListByLocalityResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityResponse * SOAP_FMAC4 soap_get__ns8__getStreetListByLocalityResponse(struct soap *soap, _ns8__getStreetListByLocalityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getStreetListByLocalityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getStreetListByLocalityResponse * FASTCALL soap_instantiate__ns8__getStreetListByLocalityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getStreetListByLocalityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getStreetListByLocalityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getStreetListByLocalityResponse));
		((_ns8__getStreetListByLocalityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getStreetListByLocalityResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getStreetListByLocalityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getStreetListByLocalityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getStreetListByLocalityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getStreetListByLocalityResponse %p -> %p\n", q, p));
	*(_ns8__getStreetListByLocalityResponse*)p = *(_ns8__getStreetListByLocalityResponse*)q;
}

void _ns8__getStreetListByLocalityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getStreetListByLocalityRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getStreetListByLocalityRequest::ns6__localityGuid);
	/* transient soap skipped */
}

void _ns8__getStreetListByLocalityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getStreetListByLocalityRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getStreetListByLocalityRequest::ns6__localityGuid);
	/* transient soap skipped */
}

int _ns8__getStreetListByLocalityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getStreetListByLocalityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getStreetListByLocalityRequest(struct soap *soap, const char *tag, int id, const _ns8__getStreetListByLocalityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getStreetListByLocalityRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getStreetListByLocalityRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getStreetListByLocalityRequest::ns6__localityGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:localityGuid", -1, &a->_ns8__getStreetListByLocalityRequest::ns6__localityGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getStreetListByLocalityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getStreetListByLocalityRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityRequest * FASTCALL soap_in__ns8__getStreetListByLocalityRequest(struct soap *soap, const char *tag, _ns8__getStreetListByLocalityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getStreetListByLocalityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getStreetListByLocalityRequest, sizeof(_ns8__getStreetListByLocalityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getStreetListByLocalityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getStreetListByLocalityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getStreetListByLocalityRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:localityGuid", &(a->_ns8__getStreetListByLocalityRequest::ns6__localityGuid), "ns3:UUID"))
				{	soap_flag_ns6__localityGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getStreetListByLocalityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getStreetListByLocalityRequest, 0, sizeof(_ns8__getStreetListByLocalityRequest), 0, soap_copy__ns8__getStreetListByLocalityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getStreetListByLocalityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getStreetListByLocalityRequest);
	return this->soap_out(soap, tag?tag:"ns8:getStreetListByLocalityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getStreetListByLocalityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getStreetListByLocalityRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityRequest * SOAP_FMAC4 soap_get__ns8__getStreetListByLocalityRequest(struct soap *soap, _ns8__getStreetListByLocalityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getStreetListByLocalityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getStreetListByLocalityRequest * FASTCALL soap_instantiate__ns8__getStreetListByLocalityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getStreetListByLocalityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getStreetListByLocalityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getStreetListByLocalityRequest));
		((_ns8__getStreetListByLocalityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getStreetListByLocalityRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getStreetListByLocalityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getStreetListByLocalityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getStreetListByLocalityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getStreetListByLocalityRequest %p -> %p\n", q, p));
	*(_ns8__getStreetListByLocalityRequest*)p = *(_ns8__getStreetListByLocalityRequest*)q;
}

void _ns8__getLocalityListByLocalityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByLocalityResponse::ns6__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__getLocalityListByLocalityResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__LocalityList(soap, &this->_ns8__getLocalityListByLocalityResponse::ns6__localityList);
	/* transient soap skipped */
}

int _ns8__getLocalityListByLocalityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByLocalityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByLocalityResponse(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByLocalityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByLocalityResponse), type))
		return soap->error;
	if(a->_ns8__getLocalityListByLocalityResponse::ns6__localityList) {
		if(soap_out_PointerTons6__LocalityList(soap, "ns6:localityList", -1, &a->_ns8__getLocalityListByLocalityResponse::ns6__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByLocalityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByLocalityResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityResponse * FASTCALL soap_in__ns8__getLocalityListByLocalityResponse(struct soap *soap, const char *tag, _ns8__getLocalityListByLocalityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByLocalityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByLocalityResponse, sizeof(_ns8__getLocalityListByLocalityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByLocalityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByLocalityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__LocalityList(soap, "ns6:localityList", &(a->_ns8__getLocalityListByLocalityResponse::ns6__localityList), "ns6:LocalityList"))
				{	soap_flag_ns6__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByLocalityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByLocalityResponse, 0, sizeof(_ns8__getLocalityListByLocalityResponse), 0, soap_copy__ns8__getLocalityListByLocalityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByLocalityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByLocalityResponse);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByLocalityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByLocalityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByLocalityResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityResponse * SOAP_FMAC4 soap_get__ns8__getLocalityListByLocalityResponse(struct soap *soap, _ns8__getLocalityListByLocalityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByLocalityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByLocalityResponse * FASTCALL soap_instantiate__ns8__getLocalityListByLocalityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByLocalityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByLocalityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByLocalityResponse));
		((_ns8__getLocalityListByLocalityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByLocalityResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByLocalityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByLocalityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByLocalityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByLocalityResponse %p -> %p\n", q, p));
	*(_ns8__getLocalityListByLocalityResponse*)p = *(_ns8__getLocalityListByLocalityResponse*)q;
}

void _ns8__getLocalityListByLocalityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByLocalityRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getLocalityListByLocalityRequest::ns6__localityGuid);
	/* transient soap skipped */
}

void _ns8__getLocalityListByLocalityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getLocalityListByLocalityRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getLocalityListByLocalityRequest::ns6__localityGuid);
	/* transient soap skipped */
}

int _ns8__getLocalityListByLocalityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByLocalityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByLocalityRequest(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByLocalityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByLocalityRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getLocalityListByLocalityRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getLocalityListByLocalityRequest::ns6__localityGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:localityGuid", -1, &a->_ns8__getLocalityListByLocalityRequest::ns6__localityGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByLocalityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByLocalityRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityRequest * FASTCALL soap_in__ns8__getLocalityListByLocalityRequest(struct soap *soap, const char *tag, _ns8__getLocalityListByLocalityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByLocalityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByLocalityRequest, sizeof(_ns8__getLocalityListByLocalityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByLocalityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByLocalityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getLocalityListByLocalityRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:localityGuid", &(a->_ns8__getLocalityListByLocalityRequest::ns6__localityGuid), "ns3:UUID"))
				{	soap_flag_ns6__localityGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByLocalityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByLocalityRequest, 0, sizeof(_ns8__getLocalityListByLocalityRequest), 0, soap_copy__ns8__getLocalityListByLocalityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByLocalityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByLocalityRequest);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByLocalityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByLocalityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByLocalityRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityRequest * SOAP_FMAC4 soap_get__ns8__getLocalityListByLocalityRequest(struct soap *soap, _ns8__getLocalityListByLocalityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByLocalityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByLocalityRequest * FASTCALL soap_instantiate__ns8__getLocalityListByLocalityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByLocalityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByLocalityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByLocalityRequest));
		((_ns8__getLocalityListByLocalityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByLocalityRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByLocalityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByLocalityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByLocalityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByLocalityRequest %p -> %p\n", q, p));
	*(_ns8__getLocalityListByLocalityRequest*)p = *(_ns8__getLocalityListByLocalityRequest*)q;
}

void _ns8__getLocalityListByDistrictResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByDistrictResponse::ns6__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__getLocalityListByDistrictResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__LocalityList(soap, &this->_ns8__getLocalityListByDistrictResponse::ns6__localityList);
	/* transient soap skipped */
}

int _ns8__getLocalityListByDistrictResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByDistrictResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByDistrictResponse(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByDistrictResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByDistrictResponse), type))
		return soap->error;
	if(a->_ns8__getLocalityListByDistrictResponse::ns6__localityList) {
		if(soap_out_PointerTons6__LocalityList(soap, "ns6:localityList", -1, &a->_ns8__getLocalityListByDistrictResponse::ns6__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByDistrictResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByDistrictResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictResponse * FASTCALL soap_in__ns8__getLocalityListByDistrictResponse(struct soap *soap, const char *tag, _ns8__getLocalityListByDistrictResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByDistrictResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByDistrictResponse, sizeof(_ns8__getLocalityListByDistrictResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByDistrictResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByDistrictResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__LocalityList(soap, "ns6:localityList", &(a->_ns8__getLocalityListByDistrictResponse::ns6__localityList), "ns6:LocalityList"))
				{	soap_flag_ns6__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByDistrictResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByDistrictResponse, 0, sizeof(_ns8__getLocalityListByDistrictResponse), 0, soap_copy__ns8__getLocalityListByDistrictResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByDistrictResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByDistrictResponse);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByDistrictResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByDistrictResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByDistrictResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictResponse * SOAP_FMAC4 soap_get__ns8__getLocalityListByDistrictResponse(struct soap *soap, _ns8__getLocalityListByDistrictResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByDistrictResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByDistrictResponse * FASTCALL soap_instantiate__ns8__getLocalityListByDistrictResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByDistrictResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByDistrictResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByDistrictResponse));
		((_ns8__getLocalityListByDistrictResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByDistrictResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByDistrictResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByDistrictResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByDistrictResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByDistrictResponse %p -> %p\n", q, p));
	*(_ns8__getLocalityListByDistrictResponse*)p = *(_ns8__getLocalityListByDistrictResponse*)q;
}

void _ns8__getLocalityListByDistrictRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByDistrictRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getLocalityListByDistrictRequest::ns6__districtGuid);
	/* transient soap skipped */
}

void _ns8__getLocalityListByDistrictRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getLocalityListByDistrictRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getLocalityListByDistrictRequest::ns6__districtGuid);
	/* transient soap skipped */
}

int _ns8__getLocalityListByDistrictRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByDistrictRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByDistrictRequest(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByDistrictRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByDistrictRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getLocalityListByDistrictRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getLocalityListByDistrictRequest::ns6__districtGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:districtGuid", -1, &a->_ns8__getLocalityListByDistrictRequest::ns6__districtGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:districtGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByDistrictRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByDistrictRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictRequest * FASTCALL soap_in__ns8__getLocalityListByDistrictRequest(struct soap *soap, const char *tag, _ns8__getLocalityListByDistrictRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByDistrictRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByDistrictRequest, sizeof(_ns8__getLocalityListByDistrictRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByDistrictRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByDistrictRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__districtGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getLocalityListByDistrictRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__districtGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:districtGuid", &(a->_ns8__getLocalityListByDistrictRequest::ns6__districtGuid), "ns3:UUID"))
				{	soap_flag_ns6__districtGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByDistrictRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByDistrictRequest, 0, sizeof(_ns8__getLocalityListByDistrictRequest), 0, soap_copy__ns8__getLocalityListByDistrictRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__districtGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByDistrictRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByDistrictRequest);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByDistrictRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByDistrictRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByDistrictRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictRequest * SOAP_FMAC4 soap_get__ns8__getLocalityListByDistrictRequest(struct soap *soap, _ns8__getLocalityListByDistrictRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByDistrictRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByDistrictRequest * FASTCALL soap_instantiate__ns8__getLocalityListByDistrictRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByDistrictRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByDistrictRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByDistrictRequest));
		((_ns8__getLocalityListByDistrictRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByDistrictRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByDistrictRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByDistrictRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByDistrictRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByDistrictRequest %p -> %p\n", q, p));
	*(_ns8__getLocalityListByDistrictRequest*)p = *(_ns8__getLocalityListByDistrictRequest*)q;
}

void _ns8__getLocalityListByRegionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByRegionResponse::ns6__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__getLocalityListByRegionResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__LocalityList(soap, &this->_ns8__getLocalityListByRegionResponse::ns6__localityList);
	/* transient soap skipped */
}

int _ns8__getLocalityListByRegionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByRegionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByRegionResponse(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByRegionResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByRegionResponse), type))
		return soap->error;
	if(a->_ns8__getLocalityListByRegionResponse::ns6__localityList) {
		if(soap_out_PointerTons6__LocalityList(soap, "ns6:localityList", -1, &a->_ns8__getLocalityListByRegionResponse::ns6__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByRegionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByRegionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionResponse * FASTCALL soap_in__ns8__getLocalityListByRegionResponse(struct soap *soap, const char *tag, _ns8__getLocalityListByRegionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByRegionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByRegionResponse, sizeof(_ns8__getLocalityListByRegionResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByRegionResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByRegionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__LocalityList(soap, "ns6:localityList", &(a->_ns8__getLocalityListByRegionResponse::ns6__localityList), "ns6:LocalityList"))
				{	soap_flag_ns6__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByRegionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByRegionResponse, 0, sizeof(_ns8__getLocalityListByRegionResponse), 0, soap_copy__ns8__getLocalityListByRegionResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByRegionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByRegionResponse);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByRegionResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByRegionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByRegionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionResponse * SOAP_FMAC4 soap_get__ns8__getLocalityListByRegionResponse(struct soap *soap, _ns8__getLocalityListByRegionResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByRegionResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByRegionResponse * FASTCALL soap_instantiate__ns8__getLocalityListByRegionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByRegionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByRegionResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByRegionResponse));
		((_ns8__getLocalityListByRegionResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByRegionResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByRegionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByRegionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByRegionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByRegionResponse %p -> %p\n", q, p));
	*(_ns8__getLocalityListByRegionResponse*)p = *(_ns8__getLocalityListByRegionResponse*)q;
}

void _ns8__getLocalityListByRegionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByRegionRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getLocalityListByRegionRequest::ns6__regionGuid);
	/* transient soap skipped */
}

void _ns8__getLocalityListByRegionRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getLocalityListByRegionRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getLocalityListByRegionRequest::ns6__regionGuid);
	/* transient soap skipped */
}

int _ns8__getLocalityListByRegionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByRegionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByRegionRequest(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByRegionRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByRegionRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getLocalityListByRegionRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getLocalityListByRegionRequest::ns6__regionGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:regionGuid", -1, &a->_ns8__getLocalityListByRegionRequest::ns6__regionGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:regionGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByRegionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByRegionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionRequest * FASTCALL soap_in__ns8__getLocalityListByRegionRequest(struct soap *soap, const char *tag, _ns8__getLocalityListByRegionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByRegionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByRegionRequest, sizeof(_ns8__getLocalityListByRegionRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByRegionRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByRegionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getLocalityListByRegionRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:regionGuid", &(a->_ns8__getLocalityListByRegionRequest::ns6__regionGuid), "ns3:UUID"))
				{	soap_flag_ns6__regionGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByRegionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByRegionRequest, 0, sizeof(_ns8__getLocalityListByRegionRequest), 0, soap_copy__ns8__getLocalityListByRegionRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__regionGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByRegionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByRegionRequest);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByRegionRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByRegionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByRegionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionRequest * SOAP_FMAC4 soap_get__ns8__getLocalityListByRegionRequest(struct soap *soap, _ns8__getLocalityListByRegionRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByRegionRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByRegionRequest * FASTCALL soap_instantiate__ns8__getLocalityListByRegionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByRegionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByRegionRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByRegionRequest));
		((_ns8__getLocalityListByRegionRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByRegionRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByRegionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByRegionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByRegionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByRegionRequest %p -> %p\n", q, p));
	*(_ns8__getLocalityListByRegionRequest*)p = *(_ns8__getLocalityListByRegionRequest*)q;
}

void _ns8__getDistrictChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictChangesListResponse::ns6__districtList = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__DistrictList(soap, &this->_ns8__getDistrictChangesListResponse::ns6__districtList);
	/* transient soap skipped */
}

int _ns8__getDistrictChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictChangesListResponse::ns6__districtList) {
		if(soap_out_PointerTons6__DistrictList(soap, "ns6:districtList", -1, &a->_ns8__getDistrictChangesListResponse::ns6__districtList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:districtList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListResponse * FASTCALL soap_in__ns8__getDistrictChangesListResponse(struct soap *soap, const char *tag, _ns8__getDistrictChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictChangesListResponse, sizeof(_ns8__getDistrictChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__districtList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__districtList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DistrictList(soap, "ns6:districtList", &(a->_ns8__getDistrictChangesListResponse::ns6__districtList), "ns6:DistrictList"))
				{	soap_flag_ns6__districtList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictChangesListResponse, 0, sizeof(_ns8__getDistrictChangesListResponse), 0, soap_copy__ns8__getDistrictChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__districtList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListResponse * SOAP_FMAC4 soap_get__ns8__getDistrictChangesListResponse(struct soap *soap, _ns8__getDistrictChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictChangesListResponse * FASTCALL soap_instantiate__ns8__getDistrictChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictChangesListResponse));
		((_ns8__getDistrictChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictChangesListResponse*)p = *(_ns8__getDistrictChangesListResponse*)q;
}

void _ns8__getDistrictChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getDistrictChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getDistrictChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getDistrictChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getDistrictChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getDistrictChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getDistrictChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getDistrictChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListRequest * FASTCALL soap_in__ns8__getDistrictChangesListRequest(struct soap *soap, const char *tag, _ns8__getDistrictChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictChangesListRequest, sizeof(_ns8__getDistrictChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getDistrictChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getDistrictChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictChangesListRequest, 0, sizeof(_ns8__getDistrictChangesListRequest), 0, soap_copy__ns8__getDistrictChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListRequest * SOAP_FMAC4 soap_get__ns8__getDistrictChangesListRequest(struct soap *soap, _ns8__getDistrictChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictChangesListRequest * FASTCALL soap_instantiate__ns8__getDistrictChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictChangesListRequest));
		((_ns8__getDistrictChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictChangesListRequest*)p = *(_ns8__getDistrictChangesListRequest*)q;
}

void _ns8__getDistrictByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictByUuidResponse::ns6__district = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__District(soap, &this->_ns8__getDistrictByUuidResponse::ns6__district);
	/* transient soap skipped */
}

int _ns8__getDistrictByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictByUuidResponse::ns6__district) {
		if(soap_out_PointerTons6__District(soap, "ns6:district", -1, &a->_ns8__getDistrictByUuidResponse::ns6__district, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:district"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidResponse * FASTCALL soap_in__ns8__getDistrictByUuidResponse(struct soap *soap, const char *tag, _ns8__getDistrictByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByUuidResponse, sizeof(_ns8__getDistrictByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__district1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__District(soap, "ns6:district", &(a->_ns8__getDistrictByUuidResponse::ns6__district), "ns6:District"))
				{	soap_flag_ns6__district1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByUuidResponse, 0, sizeof(_ns8__getDistrictByUuidResponse), 0, soap_copy__ns8__getDistrictByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__district1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidResponse * SOAP_FMAC4 soap_get__ns8__getDistrictByUuidResponse(struct soap *soap, _ns8__getDistrictByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByUuidResponse * FASTCALL soap_instantiate__ns8__getDistrictByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByUuidResponse));
		((_ns8__getDistrictByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictByUuidResponse*)p = *(_ns8__getDistrictByUuidResponse*)q;
}

void _ns8__getDistrictByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getDistrictByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getDistrictByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getDistrictByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getDistrictByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getDistrictByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getDistrictByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidRequest * FASTCALL soap_in__ns8__getDistrictByUuidRequest(struct soap *soap, const char *tag, _ns8__getDistrictByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByUuidRequest, sizeof(_ns8__getDistrictByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getDistrictByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByUuidRequest, 0, sizeof(_ns8__getDistrictByUuidRequest), 0, soap_copy__ns8__getDistrictByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidRequest * SOAP_FMAC4 soap_get__ns8__getDistrictByUuidRequest(struct soap *soap, _ns8__getDistrictByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByUuidRequest * FASTCALL soap_instantiate__ns8__getDistrictByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByUuidRequest));
		((_ns8__getDistrictByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictByUuidRequest*)p = *(_ns8__getDistrictByUuidRequest*)q;
}

void _ns8__getDistrictByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictByGuidResponse::ns6__district = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__District(soap, &this->_ns8__getDistrictByGuidResponse::ns6__district);
	/* transient soap skipped */
}

int _ns8__getDistrictByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictByGuidResponse::ns6__district) {
		if(soap_out_PointerTons6__District(soap, "ns6:district", -1, &a->_ns8__getDistrictByGuidResponse::ns6__district, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:district"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidResponse * FASTCALL soap_in__ns8__getDistrictByGuidResponse(struct soap *soap, const char *tag, _ns8__getDistrictByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByGuidResponse, sizeof(_ns8__getDistrictByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__district1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__District(soap, "ns6:district", &(a->_ns8__getDistrictByGuidResponse::ns6__district), "ns6:District"))
				{	soap_flag_ns6__district1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByGuidResponse, 0, sizeof(_ns8__getDistrictByGuidResponse), 0, soap_copy__ns8__getDistrictByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__district1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidResponse * SOAP_FMAC4 soap_get__ns8__getDistrictByGuidResponse(struct soap *soap, _ns8__getDistrictByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByGuidResponse * FASTCALL soap_instantiate__ns8__getDistrictByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByGuidResponse));
		((_ns8__getDistrictByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictByGuidResponse*)p = *(_ns8__getDistrictByGuidResponse*)q;
}

void _ns8__getDistrictByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getDistrictByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getDistrictByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getDistrictByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getDistrictByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getDistrictByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getDistrictByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidRequest * FASTCALL soap_in__ns8__getDistrictByGuidRequest(struct soap *soap, const char *tag, _ns8__getDistrictByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByGuidRequest, sizeof(_ns8__getDistrictByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getDistrictByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByGuidRequest, 0, sizeof(_ns8__getDistrictByGuidRequest), 0, soap_copy__ns8__getDistrictByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidRequest * SOAP_FMAC4 soap_get__ns8__getDistrictByGuidRequest(struct soap *soap, _ns8__getDistrictByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByGuidRequest * FASTCALL soap_instantiate__ns8__getDistrictByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByGuidRequest));
		((_ns8__getDistrictByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictByGuidRequest*)p = *(_ns8__getDistrictByGuidRequest*)q;
}

void _ns8__getDistrictListByRegionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictListByRegionResponse::ns6__districtList = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictListByRegionResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__DistrictList(soap, &this->_ns8__getDistrictListByRegionResponse::ns6__districtList);
	/* transient soap skipped */
}

int _ns8__getDistrictListByRegionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictListByRegionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictListByRegionResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictListByRegionResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictListByRegionResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictListByRegionResponse::ns6__districtList) {
		if(soap_out_PointerTons6__DistrictList(soap, "ns6:districtList", -1, &a->_ns8__getDistrictListByRegionResponse::ns6__districtList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:districtList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictListByRegionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictListByRegionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionResponse * FASTCALL soap_in__ns8__getDistrictListByRegionResponse(struct soap *soap, const char *tag, _ns8__getDistrictListByRegionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictListByRegionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictListByRegionResponse, sizeof(_ns8__getDistrictListByRegionResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictListByRegionResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictListByRegionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__districtList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__districtList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DistrictList(soap, "ns6:districtList", &(a->_ns8__getDistrictListByRegionResponse::ns6__districtList), "ns6:DistrictList"))
				{	soap_flag_ns6__districtList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictListByRegionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictListByRegionResponse, 0, sizeof(_ns8__getDistrictListByRegionResponse), 0, soap_copy__ns8__getDistrictListByRegionResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__districtList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictListByRegionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictListByRegionResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictListByRegionResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictListByRegionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictListByRegionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionResponse * SOAP_FMAC4 soap_get__ns8__getDistrictListByRegionResponse(struct soap *soap, _ns8__getDistrictListByRegionResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictListByRegionResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictListByRegionResponse * FASTCALL soap_instantiate__ns8__getDistrictListByRegionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictListByRegionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictListByRegionResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictListByRegionResponse));
		((_ns8__getDistrictListByRegionResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictListByRegionResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictListByRegionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictListByRegionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictListByRegionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictListByRegionResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictListByRegionResponse*)p = *(_ns8__getDistrictListByRegionResponse*)q;
}

void _ns8__getDistrictListByRegionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictListByRegionRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getDistrictListByRegionRequest::ns6__regionGuid);
	/* transient soap skipped */
}

void _ns8__getDistrictListByRegionRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getDistrictListByRegionRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getDistrictListByRegionRequest::ns6__regionGuid);
	/* transient soap skipped */
}

int _ns8__getDistrictListByRegionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictListByRegionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictListByRegionRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictListByRegionRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictListByRegionRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getDistrictListByRegionRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getDistrictListByRegionRequest::ns6__regionGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:regionGuid", -1, &a->_ns8__getDistrictListByRegionRequest::ns6__regionGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:regionGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictListByRegionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictListByRegionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionRequest * FASTCALL soap_in__ns8__getDistrictListByRegionRequest(struct soap *soap, const char *tag, _ns8__getDistrictListByRegionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictListByRegionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictListByRegionRequest, sizeof(_ns8__getDistrictListByRegionRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictListByRegionRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictListByRegionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getDistrictListByRegionRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:regionGuid", &(a->_ns8__getDistrictListByRegionRequest::ns6__regionGuid), "ns3:UUID"))
				{	soap_flag_ns6__regionGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictListByRegionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictListByRegionRequest, 0, sizeof(_ns8__getDistrictListByRegionRequest), 0, soap_copy__ns8__getDistrictListByRegionRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__regionGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictListByRegionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictListByRegionRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictListByRegionRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictListByRegionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictListByRegionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionRequest * SOAP_FMAC4 soap_get__ns8__getDistrictListByRegionRequest(struct soap *soap, _ns8__getDistrictListByRegionRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictListByRegionRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictListByRegionRequest * FASTCALL soap_instantiate__ns8__getDistrictListByRegionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictListByRegionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictListByRegionRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictListByRegionRequest));
		((_ns8__getDistrictListByRegionRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictListByRegionRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictListByRegionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictListByRegionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictListByRegionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictListByRegionRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictListByRegionRequest*)p = *(_ns8__getDistrictListByRegionRequest*)q;
}

void _ns8__getRegionChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionChangesListResponse::ns6__regionList = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__RegionList(soap, &this->_ns8__getRegionChangesListResponse::ns6__regionList);
	/* transient soap skipped */
}

int _ns8__getRegionChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getRegionChangesListResponse::ns6__regionList) {
		if(soap_out_PointerTons6__RegionList(soap, "ns6:regionList", -1, &a->_ns8__getRegionChangesListResponse::ns6__regionList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:regionList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListResponse * FASTCALL soap_in__ns8__getRegionChangesListResponse(struct soap *soap, const char *tag, _ns8__getRegionChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionChangesListResponse, sizeof(_ns8__getRegionChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__regionList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__regionList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionList(soap, "ns6:regionList", &(a->_ns8__getRegionChangesListResponse::ns6__regionList), "ns6:RegionList"))
				{	soap_flag_ns6__regionList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionChangesListResponse, 0, sizeof(_ns8__getRegionChangesListResponse), 0, soap_copy__ns8__getRegionChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__regionList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListResponse * SOAP_FMAC4 soap_get__ns8__getRegionChangesListResponse(struct soap *soap, _ns8__getRegionChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionChangesListResponse * FASTCALL soap_instantiate__ns8__getRegionChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionChangesListResponse));
		((_ns8__getRegionChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getRegionChangesListResponse*)p = *(_ns8__getRegionChangesListResponse*)q;
}

void _ns8__getRegionChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getRegionChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getRegionChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getRegionChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getRegionChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getRegionChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getRegionChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getRegionChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListRequest * FASTCALL soap_in__ns8__getRegionChangesListRequest(struct soap *soap, const char *tag, _ns8__getRegionChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionChangesListRequest, sizeof(_ns8__getRegionChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getRegionChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getRegionChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionChangesListRequest, 0, sizeof(_ns8__getRegionChangesListRequest), 0, soap_copy__ns8__getRegionChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListRequest * SOAP_FMAC4 soap_get__ns8__getRegionChangesListRequest(struct soap *soap, _ns8__getRegionChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionChangesListRequest * FASTCALL soap_instantiate__ns8__getRegionChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionChangesListRequest));
		((_ns8__getRegionChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getRegionChangesListRequest*)p = *(_ns8__getRegionChangesListRequest*)q;
}

void _ns8__getRegionByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionByUuidResponse::ns6__region = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Region(soap, &this->_ns8__getRegionByUuidResponse::ns6__region);
	/* transient soap skipped */
}

int _ns8__getRegionByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getRegionByUuidResponse::ns6__region) {
		if(soap_out_PointerTons6__Region(soap, "ns6:region", -1, &a->_ns8__getRegionByUuidResponse::ns6__region, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:region"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidResponse * FASTCALL soap_in__ns8__getRegionByUuidResponse(struct soap *soap, const char *tag, _ns8__getRegionByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByUuidResponse, sizeof(_ns8__getRegionByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__region1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Region(soap, "ns6:region", &(a->_ns8__getRegionByUuidResponse::ns6__region), "ns6:Region"))
				{	soap_flag_ns6__region1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByUuidResponse, 0, sizeof(_ns8__getRegionByUuidResponse), 0, soap_copy__ns8__getRegionByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__region1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidResponse * SOAP_FMAC4 soap_get__ns8__getRegionByUuidResponse(struct soap *soap, _ns8__getRegionByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByUuidResponse * FASTCALL soap_instantiate__ns8__getRegionByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByUuidResponse));
		((_ns8__getRegionByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getRegionByUuidResponse*)p = *(_ns8__getRegionByUuidResponse*)q;
}

void _ns8__getRegionByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getRegionByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getRegionByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getRegionByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getRegionByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getRegionByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getRegionByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidRequest * FASTCALL soap_in__ns8__getRegionByUuidRequest(struct soap *soap, const char *tag, _ns8__getRegionByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByUuidRequest, sizeof(_ns8__getRegionByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getRegionByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByUuidRequest, 0, sizeof(_ns8__getRegionByUuidRequest), 0, soap_copy__ns8__getRegionByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidRequest * SOAP_FMAC4 soap_get__ns8__getRegionByUuidRequest(struct soap *soap, _ns8__getRegionByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByUuidRequest * FASTCALL soap_instantiate__ns8__getRegionByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByUuidRequest));
		((_ns8__getRegionByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getRegionByUuidRequest*)p = *(_ns8__getRegionByUuidRequest*)q;
}

void _ns8__getRegionByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionByGuidResponse::ns6__region = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Region(soap, &this->_ns8__getRegionByGuidResponse::ns6__region);
	/* transient soap skipped */
}

int _ns8__getRegionByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getRegionByGuidResponse::ns6__region) {
		if(soap_out_PointerTons6__Region(soap, "ns6:region", -1, &a->_ns8__getRegionByGuidResponse::ns6__region, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:region"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidResponse * FASTCALL soap_in__ns8__getRegionByGuidResponse(struct soap *soap, const char *tag, _ns8__getRegionByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByGuidResponse, sizeof(_ns8__getRegionByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__region1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Region(soap, "ns6:region", &(a->_ns8__getRegionByGuidResponse::ns6__region), "ns6:Region"))
				{	soap_flag_ns6__region1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByGuidResponse, 0, sizeof(_ns8__getRegionByGuidResponse), 0, soap_copy__ns8__getRegionByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__region1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidResponse * SOAP_FMAC4 soap_get__ns8__getRegionByGuidResponse(struct soap *soap, _ns8__getRegionByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByGuidResponse * FASTCALL soap_instantiate__ns8__getRegionByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByGuidResponse));
		((_ns8__getRegionByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getRegionByGuidResponse*)p = *(_ns8__getRegionByGuidResponse*)q;
}

void _ns8__getRegionByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getRegionByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getRegionByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getRegionByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getRegionByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getRegionByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getRegionByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidRequest * FASTCALL soap_in__ns8__getRegionByGuidRequest(struct soap *soap, const char *tag, _ns8__getRegionByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByGuidRequest, sizeof(_ns8__getRegionByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getRegionByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByGuidRequest, 0, sizeof(_ns8__getRegionByGuidRequest), 0, soap_copy__ns8__getRegionByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidRequest * SOAP_FMAC4 soap_get__ns8__getRegionByGuidRequest(struct soap *soap, _ns8__getRegionByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByGuidRequest * FASTCALL soap_instantiate__ns8__getRegionByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByGuidRequest));
		((_ns8__getRegionByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getRegionByGuidRequest*)p = *(_ns8__getRegionByGuidRequest*)q;
}

void _ns8__getRegionListByCountryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionListByCountryResponse::ns6__regionList = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionListByCountryResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__RegionList(soap, &this->_ns8__getRegionListByCountryResponse::ns6__regionList);
	/* transient soap skipped */
}

int _ns8__getRegionListByCountryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionListByCountryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionListByCountryResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionListByCountryResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionListByCountryResponse), type))
		return soap->error;
	if(a->_ns8__getRegionListByCountryResponse::ns6__regionList) {
		if(soap_out_PointerTons6__RegionList(soap, "ns6:regionList", -1, &a->_ns8__getRegionListByCountryResponse::ns6__regionList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:regionList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionListByCountryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionListByCountryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryResponse * FASTCALL soap_in__ns8__getRegionListByCountryResponse(struct soap *soap, const char *tag, _ns8__getRegionListByCountryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionListByCountryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionListByCountryResponse, sizeof(_ns8__getRegionListByCountryResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionListByCountryResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionListByCountryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__regionList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__regionList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionList(soap, "ns6:regionList", &(a->_ns8__getRegionListByCountryResponse::ns6__regionList), "ns6:RegionList"))
				{	soap_flag_ns6__regionList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionListByCountryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionListByCountryResponse, 0, sizeof(_ns8__getRegionListByCountryResponse), 0, soap_copy__ns8__getRegionListByCountryResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__regionList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionListByCountryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionListByCountryResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionListByCountryResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionListByCountryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionListByCountryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryResponse * SOAP_FMAC4 soap_get__ns8__getRegionListByCountryResponse(struct soap *soap, _ns8__getRegionListByCountryResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionListByCountryResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionListByCountryResponse * FASTCALL soap_instantiate__ns8__getRegionListByCountryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionListByCountryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionListByCountryResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionListByCountryResponse));
		((_ns8__getRegionListByCountryResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionListByCountryResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionListByCountryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionListByCountryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionListByCountryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionListByCountryResponse %p -> %p\n", q, p));
	*(_ns8__getRegionListByCountryResponse*)p = *(_ns8__getRegionListByCountryResponse*)q;
}

void _ns8__getRegionListByCountryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionListByCountryRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getRegionListByCountryRequest::ns6__countryGuid);
	/* transient soap skipped */
}

void _ns8__getRegionListByCountryRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getRegionListByCountryRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getRegionListByCountryRequest::ns6__countryGuid);
	/* transient soap skipped */
}

int _ns8__getRegionListByCountryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionListByCountryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionListByCountryRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionListByCountryRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionListByCountryRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getRegionListByCountryRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getRegionListByCountryRequest::ns6__countryGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:countryGuid", -1, &a->_ns8__getRegionListByCountryRequest::ns6__countryGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:countryGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionListByCountryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionListByCountryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryRequest * FASTCALL soap_in__ns8__getRegionListByCountryRequest(struct soap *soap, const char *tag, _ns8__getRegionListByCountryRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionListByCountryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionListByCountryRequest, sizeof(_ns8__getRegionListByCountryRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionListByCountryRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionListByCountryRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__countryGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getRegionListByCountryRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__countryGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:countryGuid", &(a->_ns8__getRegionListByCountryRequest::ns6__countryGuid), "ns3:UUID"))
				{	soap_flag_ns6__countryGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionListByCountryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionListByCountryRequest, 0, sizeof(_ns8__getRegionListByCountryRequest), 0, soap_copy__ns8__getRegionListByCountryRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__countryGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionListByCountryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionListByCountryRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionListByCountryRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionListByCountryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionListByCountryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryRequest * SOAP_FMAC4 soap_get__ns8__getRegionListByCountryRequest(struct soap *soap, _ns8__getRegionListByCountryRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionListByCountryRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionListByCountryRequest * FASTCALL soap_instantiate__ns8__getRegionListByCountryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionListByCountryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionListByCountryRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionListByCountryRequest));
		((_ns8__getRegionListByCountryRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionListByCountryRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionListByCountryRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionListByCountryRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionListByCountryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionListByCountryRequest %p -> %p\n", q, p));
	*(_ns8__getRegionListByCountryRequest*)p = *(_ns8__getRegionListByCountryRequest*)q;
}

void _ns8__getCountryChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryChangesListResponse::ns6__countryList = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__CountryList(soap, &this->_ns8__getCountryChangesListResponse::ns6__countryList);
	/* transient soap skipped */
}

int _ns8__getCountryChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getCountryChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getCountryChangesListResponse::ns6__countryList) {
		if(soap_out_PointerTons6__CountryList(soap, "ns6:countryList", -1, &a->_ns8__getCountryChangesListResponse::ns6__countryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:countryList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListResponse * FASTCALL soap_in__ns8__getCountryChangesListResponse(struct soap *soap, const char *tag, _ns8__getCountryChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryChangesListResponse, sizeof(_ns8__getCountryChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__countryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__countryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__CountryList(soap, "ns6:countryList", &(a->_ns8__getCountryChangesListResponse::ns6__countryList), "ns6:CountryList"))
				{	soap_flag_ns6__countryList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryChangesListResponse, 0, sizeof(_ns8__getCountryChangesListResponse), 0, soap_copy__ns8__getCountryChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__countryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getCountryChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListResponse * SOAP_FMAC4 soap_get__ns8__getCountryChangesListResponse(struct soap *soap, _ns8__getCountryChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryChangesListResponse * FASTCALL soap_instantiate__ns8__getCountryChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryChangesListResponse));
		((_ns8__getCountryChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getCountryChangesListResponse*)p = *(_ns8__getCountryChangesListResponse*)q;
}

void _ns8__getCountryChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getCountryChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getCountryChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getCountryChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getCountryChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getCountryChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getCountryChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getCountryChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getCountryChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListRequest * FASTCALL soap_in__ns8__getCountryChangesListRequest(struct soap *soap, const char *tag, _ns8__getCountryChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryChangesListRequest, sizeof(_ns8__getCountryChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getCountryChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getCountryChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryChangesListRequest, 0, sizeof(_ns8__getCountryChangesListRequest), 0, soap_copy__ns8__getCountryChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getCountryChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListRequest * SOAP_FMAC4 soap_get__ns8__getCountryChangesListRequest(struct soap *soap, _ns8__getCountryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryChangesListRequest * FASTCALL soap_instantiate__ns8__getCountryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryChangesListRequest));
		((_ns8__getCountryChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getCountryChangesListRequest*)p = *(_ns8__getCountryChangesListRequest*)q;
}

void _ns8__getCountryByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryByUuidResponse::ns6__country = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Country(soap, &this->_ns8__getCountryByUuidResponse::ns6__country);
	/* transient soap skipped */
}

int _ns8__getCountryByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getCountryByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getCountryByUuidResponse::ns6__country) {
		if(soap_out_PointerTons6__Country(soap, "ns6:country", -1, &a->_ns8__getCountryByUuidResponse::ns6__country, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:country"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidResponse * FASTCALL soap_in__ns8__getCountryByUuidResponse(struct soap *soap, const char *tag, _ns8__getCountryByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByUuidResponse, sizeof(_ns8__getCountryByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__country1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Country(soap, "ns6:country", &(a->_ns8__getCountryByUuidResponse::ns6__country), "ns6:Country"))
				{	soap_flag_ns6__country1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByUuidResponse, 0, sizeof(_ns8__getCountryByUuidResponse), 0, soap_copy__ns8__getCountryByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__country1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidResponse * SOAP_FMAC4 soap_get__ns8__getCountryByUuidResponse(struct soap *soap, _ns8__getCountryByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByUuidResponse * FASTCALL soap_instantiate__ns8__getCountryByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByUuidResponse));
		((_ns8__getCountryByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getCountryByUuidResponse*)p = *(_ns8__getCountryByUuidResponse*)q;
}

void _ns8__getCountryByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getCountryByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getCountryByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getCountryByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getCountryByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getCountryByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getCountryByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getCountryByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidRequest * FASTCALL soap_in__ns8__getCountryByUuidRequest(struct soap *soap, const char *tag, _ns8__getCountryByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByUuidRequest, sizeof(_ns8__getCountryByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getCountryByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByUuidRequest, 0, sizeof(_ns8__getCountryByUuidRequest), 0, soap_copy__ns8__getCountryByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidRequest * SOAP_FMAC4 soap_get__ns8__getCountryByUuidRequest(struct soap *soap, _ns8__getCountryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByUuidRequest * FASTCALL soap_instantiate__ns8__getCountryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByUuidRequest));
		((_ns8__getCountryByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getCountryByUuidRequest*)p = *(_ns8__getCountryByUuidRequest*)q;
}

void _ns8__getCountryByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryByGuidResponse::ns6__country = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Country(soap, &this->_ns8__getCountryByGuidResponse::ns6__country);
	/* transient soap skipped */
}

int _ns8__getCountryByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getCountryByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getCountryByGuidResponse::ns6__country) {
		if(soap_out_PointerTons6__Country(soap, "ns6:country", -1, &a->_ns8__getCountryByGuidResponse::ns6__country, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:country"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidResponse * FASTCALL soap_in__ns8__getCountryByGuidResponse(struct soap *soap, const char *tag, _ns8__getCountryByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByGuidResponse, sizeof(_ns8__getCountryByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__country1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Country(soap, "ns6:country", &(a->_ns8__getCountryByGuidResponse::ns6__country), "ns6:Country"))
				{	soap_flag_ns6__country1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByGuidResponse, 0, sizeof(_ns8__getCountryByGuidResponse), 0, soap_copy__ns8__getCountryByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__country1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidResponse * SOAP_FMAC4 soap_get__ns8__getCountryByGuidResponse(struct soap *soap, _ns8__getCountryByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByGuidResponse * FASTCALL soap_instantiate__ns8__getCountryByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByGuidResponse));
		((_ns8__getCountryByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getCountryByGuidResponse*)p = *(_ns8__getCountryByGuidResponse*)q;
}

void _ns8__getCountryByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getCountryByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getCountryByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getCountryByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getCountryByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getCountryByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getCountryByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getCountryByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidRequest * FASTCALL soap_in__ns8__getCountryByGuidRequest(struct soap *soap, const char *tag, _ns8__getCountryByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByGuidRequest, sizeof(_ns8__getCountryByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getCountryByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByGuidRequest, 0, sizeof(_ns8__getCountryByGuidRequest), 0, soap_copy__ns8__getCountryByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidRequest * SOAP_FMAC4 soap_get__ns8__getCountryByGuidRequest(struct soap *soap, _ns8__getCountryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByGuidRequest * FASTCALL soap_instantiate__ns8__getCountryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByGuidRequest));
		((_ns8__getCountryByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getCountryByGuidRequest*)p = *(_ns8__getCountryByGuidRequest*)q;
}

void _ns8__getAllCountryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getAllCountryListResponse::ns6__countryList = NULL;
	/* transient soap skipped */
}

void _ns8__getAllCountryListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__CountryList(soap, &this->_ns8__getAllCountryListResponse::ns6__countryList);
	/* transient soap skipped */
}

int _ns8__getAllCountryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getAllCountryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getAllCountryListResponse(struct soap *soap, const char *tag, int id, const _ns8__getAllCountryListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getAllCountryListResponse), type))
		return soap->error;
	if(a->_ns8__getAllCountryListResponse::ns6__countryList) {
		if(soap_out_PointerTons6__CountryList(soap, "ns6:countryList", -1, &a->_ns8__getAllCountryListResponse::ns6__countryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:countryList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getAllCountryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getAllCountryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getAllCountryListResponse * FASTCALL soap_in__ns8__getAllCountryListResponse(struct soap *soap, const char *tag, _ns8__getAllCountryListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getAllCountryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getAllCountryListResponse, sizeof(_ns8__getAllCountryListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getAllCountryListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getAllCountryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__countryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__countryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__CountryList(soap, "ns6:countryList", &(a->_ns8__getAllCountryListResponse::ns6__countryList), "ns6:CountryList"))
				{	soap_flag_ns6__countryList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getAllCountryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getAllCountryListResponse, 0, sizeof(_ns8__getAllCountryListResponse), 0, soap_copy__ns8__getAllCountryListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__countryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getAllCountryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getAllCountryListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getAllCountryListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getAllCountryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getAllCountryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getAllCountryListResponse * SOAP_FMAC4 soap_get__ns8__getAllCountryListResponse(struct soap *soap, _ns8__getAllCountryListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getAllCountryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getAllCountryListResponse * FASTCALL soap_instantiate__ns8__getAllCountryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getAllCountryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getAllCountryListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getAllCountryListResponse));
		((_ns8__getAllCountryListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getAllCountryListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getAllCountryListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getAllCountryListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getAllCountryListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getAllCountryListResponse %p -> %p\n", q, p));
	*(_ns8__getAllCountryListResponse*)p = *(_ns8__getAllCountryListResponse*)q;
}

void _ns8__getAllCountryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getAllCountryListRequest::ns3__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getAllCountryListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getAllCountryListRequest::ns3__listOptions);
	/* transient soap skipped */
}

int _ns8__getAllCountryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getAllCountryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getAllCountryListRequest(struct soap *soap, const char *tag, int id, const _ns8__getAllCountryListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getAllCountryListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getAllCountryListRequest::ns3__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getAllCountryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getAllCountryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getAllCountryListRequest * FASTCALL soap_in__ns8__getAllCountryListRequest(struct soap *soap, const char *tag, _ns8__getAllCountryListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getAllCountryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getAllCountryListRequest, sizeof(_ns8__getAllCountryListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getAllCountryListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getAllCountryListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getAllCountryListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getAllCountryListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getAllCountryListRequest, 0, sizeof(_ns8__getAllCountryListRequest), 0, soap_copy__ns8__getAllCountryListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getAllCountryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getAllCountryListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getAllCountryListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getAllCountryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getAllCountryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getAllCountryListRequest * SOAP_FMAC4 soap_get__ns8__getAllCountryListRequest(struct soap *soap, _ns8__getAllCountryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getAllCountryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getAllCountryListRequest * FASTCALL soap_instantiate__ns8__getAllCountryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getAllCountryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getAllCountryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getAllCountryListRequest));
		((_ns8__getAllCountryListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getAllCountryListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getAllCountryListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getAllCountryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getAllCountryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getAllCountryListRequest %p -> %p\n", q, p));
	*(_ns8__getAllCountryListRequest*)p = *(_ns8__getAllCountryListRequest*)q;
}

void _ns8__getProductItemChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemChangesListResponse::ns6__productItemList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductItemList(soap, &this->_ns8__getProductItemChangesListResponse::ns6__productItemList);
	/* transient soap skipped */
}

int _ns8__getProductItemChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemChangesListResponse), type))
		return soap->error;
	if(soap_out_PointerTons6__ProductItemList(soap, "ns6:productItemList", -1, &(a->_ns8__getProductItemChangesListResponse::ns6__productItemList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListResponse * FASTCALL soap_in__ns8__getProductItemChangesListResponse(struct soap *soap, const char *tag, _ns8__getProductItemChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemChangesListResponse, sizeof(_ns8__getProductItemChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItemList(soap, "ns6:productItemList", &(a->_ns8__getProductItemChangesListResponse::ns6__productItemList), "ns6:ProductItemList"))
				{	soap_flag_ns6__productItemList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemChangesListResponse, 0, sizeof(_ns8__getProductItemChangesListResponse), 0, soap_copy__ns8__getProductItemChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListResponse * SOAP_FMAC4 soap_get__ns8__getProductItemChangesListResponse(struct soap *soap, _ns8__getProductItemChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemChangesListResponse * FASTCALL soap_instantiate__ns8__getProductItemChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemChangesListResponse));
		((_ns8__getProductItemChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemChangesListResponse*)p = *(_ns8__getProductItemChangesListResponse*)q;
}

void _ns8__getProductItemChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getProductItemChangesListRequest::ns3__updateDateInterval = NULL;
	this->_ns8__getProductItemChangesListRequest::ns6__businessEntity = NULL;
	this->_ns8__getProductItemChangesListRequest::ns6__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getProductItemChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getProductItemChangesListRequest::ns3__updateDateInterval);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->_ns8__getProductItemChangesListRequest::ns6__businessEntity);
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns8__getProductItemChangesListRequest::ns6__enterprise);
	/* transient soap skipped */
}

int _ns8__getProductItemChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getProductItemChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getProductItemChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getProductItemChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &(a->_ns8__getProductItemChangesListRequest::ns6__businessEntity), ""))
		return soap->error;
	if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &(a->_ns8__getProductItemChangesListRequest::ns6__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListRequest * FASTCALL soap_in__ns8__getProductItemChangesListRequest(struct soap *soap, const char *tag, _ns8__getProductItemChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemChangesListRequest, sizeof(_ns8__getProductItemChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	size_t soap_flag_ns6__businessEntity1 = 1;
	size_t soap_flag_ns6__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getProductItemChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getProductItemChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			if(soap_flag_ns6__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->_ns8__getProductItemChangesListRequest::ns6__businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_ns6__businessEntity1--;
					continue;
				}
			if(soap_flag_ns6__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns8__getProductItemChangesListRequest::ns6__enterprise), "ns6:Enterprise"))
				{	soap_flag_ns6__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemChangesListRequest, 0, sizeof(_ns8__getProductItemChangesListRequest), 0, soap_copy__ns8__getProductItemChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductItemChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListRequest * SOAP_FMAC4 soap_get__ns8__getProductItemChangesListRequest(struct soap *soap, _ns8__getProductItemChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemChangesListRequest * FASTCALL soap_instantiate__ns8__getProductItemChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemChangesListRequest));
		((_ns8__getProductItemChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemChangesListRequest*)p = *(_ns8__getProductItemChangesListRequest*)q;
}

void _ns8__getProductItemListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemListResponse::ns6__productItemList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductItemList(soap, &this->_ns8__getProductItemListResponse::ns6__productItemList);
	/* transient soap skipped */
}

int _ns8__getProductItemListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemListResponse), type))
		return soap->error;
	if(soap_out_PointerTons6__ProductItemList(soap, "ns6:productItemList", -1, &(a->_ns8__getProductItemListResponse::ns6__productItemList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemListResponse * FASTCALL soap_in__ns8__getProductItemListResponse(struct soap *soap, const char *tag, _ns8__getProductItemListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemListResponse, sizeof(_ns8__getProductItemListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItemList(soap, "ns6:productItemList", &(a->_ns8__getProductItemListResponse::ns6__productItemList), "ns6:ProductItemList"))
				{	soap_flag_ns6__productItemList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemListResponse, 0, sizeof(_ns8__getProductItemListResponse), 0, soap_copy__ns8__getProductItemListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemListResponse * SOAP_FMAC4 soap_get__ns8__getProductItemListResponse(struct soap *soap, _ns8__getProductItemListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemListResponse * FASTCALL soap_instantiate__ns8__getProductItemListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemListResponse));
		((_ns8__getProductItemListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemListResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemListResponse*)p = *(_ns8__getProductItemListResponse*)q;
}

void _ns8__getProductItemListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemListRequest::ns3__listOptions = NULL;
	this->_ns8__getProductItemListRequest::ns6__productType = NULL;
	this->_ns8__getProductItemListRequest::ns6__product = NULL;
	this->_ns8__getProductItemListRequest::ns6__subProduct = NULL;
	this->_ns8__getProductItemListRequest::ns6__businessEntity = NULL;
	this->_ns8__getProductItemListRequest::ns6__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getProductItemListRequest::ns3__listOptions);
	soap_serialize_PointerTons6__ProductType(soap, &this->_ns8__getProductItemListRequest::ns6__productType);
	soap_serialize_PointerTons6__Product(soap, &this->_ns8__getProductItemListRequest::ns6__product);
	soap_serialize_PointerTons6__SubProduct(soap, &this->_ns8__getProductItemListRequest::ns6__subProduct);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->_ns8__getProductItemListRequest::ns6__businessEntity);
	soap_serialize_PointerTons6__Enterprise(soap, &this->_ns8__getProductItemListRequest::ns6__enterprise);
	/* transient soap skipped */
}

int _ns8__getProductItemListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getProductItemListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns6:productType", -1, &(a->_ns8__getProductItemListRequest::ns6__productType), ""))
		return soap->error;
	if(soap_out_PointerTons6__Product(soap, "ns6:product", -1, &(a->_ns8__getProductItemListRequest::ns6__product), ""))
		return soap->error;
	if(soap_out_PointerTons6__SubProduct(soap, "ns6:subProduct", -1, &(a->_ns8__getProductItemListRequest::ns6__subProduct), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &(a->_ns8__getProductItemListRequest::ns6__businessEntity), ""))
		return soap->error;
	if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &(a->_ns8__getProductItemListRequest::ns6__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemListRequest * FASTCALL soap_in__ns8__getProductItemListRequest(struct soap *soap, const char *tag, _ns8__getProductItemListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemListRequest, sizeof(_ns8__getProductItemListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__productType1 = 1;
	size_t soap_flag_ns6__product1 = 1;
	size_t soap_flag_ns6__subProduct1 = 1;
	size_t soap_flag_ns6__businessEntity1 = 1;
	size_t soap_flag_ns6__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getProductItemListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns6:productType", &(a->_ns8__getProductItemListRequest::ns6__productType), "ns6:ProductType"))
				{	soap_flag_ns6__productType1--;
					continue;
				}
			if(soap_flag_ns6__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns6:product", &(a->_ns8__getProductItemListRequest::ns6__product), "ns6:Product"))
				{	soap_flag_ns6__product1--;
					continue;
				}
			if(soap_flag_ns6__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:subProduct", &(a->_ns8__getProductItemListRequest::ns6__subProduct), "ns6:SubProduct"))
				{	soap_flag_ns6__subProduct1--;
					continue;
				}
			if(soap_flag_ns6__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->_ns8__getProductItemListRequest::ns6__businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_ns6__businessEntity1--;
					continue;
				}
			if(soap_flag_ns6__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->_ns8__getProductItemListRequest::ns6__enterprise), "ns6:Enterprise"))
				{	soap_flag_ns6__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemListRequest, 0, sizeof(_ns8__getProductItemListRequest), 0, soap_copy__ns8__getProductItemListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemListRequest * SOAP_FMAC4 soap_get__ns8__getProductItemListRequest(struct soap *soap, _ns8__getProductItemListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemListRequest * FASTCALL soap_instantiate__ns8__getProductItemListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemListRequest));
		((_ns8__getProductItemListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemListRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemListRequest*)p = *(_ns8__getProductItemListRequest*)q;
}

void _ns8__getProductItemByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemByUuidResponse::ns6__productItem = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductItem(soap, &this->_ns8__getProductItemByUuidResponse::ns6__productItem);
	/* transient soap skipped */
}

int _ns8__getProductItemByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByUuidResponse), type))
		return soap->error;
	if(soap_out_PointerTons6__ProductItem(soap, "ns6:productItem", -1, &(a->_ns8__getProductItemByUuidResponse::ns6__productItem), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidResponse * FASTCALL soap_in__ns8__getProductItemByUuidResponse(struct soap *soap, const char *tag, _ns8__getProductItemByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByUuidResponse, sizeof(_ns8__getProductItemByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__productItem1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItem(soap, "ns6:productItem", &(a->_ns8__getProductItemByUuidResponse::ns6__productItem), "ns6:ProductItem"))
				{	soap_flag_ns6__productItem1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByUuidResponse, 0, sizeof(_ns8__getProductItemByUuidResponse), 0, soap_copy__ns8__getProductItemByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidResponse * SOAP_FMAC4 soap_get__ns8__getProductItemByUuidResponse(struct soap *soap, _ns8__getProductItemByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByUuidResponse * FASTCALL soap_instantiate__ns8__getProductItemByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByUuidResponse));
		((_ns8__getProductItemByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemByUuidResponse*)p = *(_ns8__getProductItemByUuidResponse*)q;
}

void _ns8__getProductItemByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getProductItemByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getProductItemByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getProductItemByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getProductItemByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductItemByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getProductItemByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidRequest * FASTCALL soap_in__ns8__getProductItemByUuidRequest(struct soap *soap, const char *tag, _ns8__getProductItemByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByUuidRequest, sizeof(_ns8__getProductItemByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getProductItemByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByUuidRequest, 0, sizeof(_ns8__getProductItemByUuidRequest), 0, soap_copy__ns8__getProductItemByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductItemByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidRequest * SOAP_FMAC4 soap_get__ns8__getProductItemByUuidRequest(struct soap *soap, _ns8__getProductItemByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByUuidRequest * FASTCALL soap_instantiate__ns8__getProductItemByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByUuidRequest));
		((_ns8__getProductItemByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemByUuidRequest*)p = *(_ns8__getProductItemByUuidRequest*)q;
}

void _ns8__getProductItemByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemByGuidResponse::ns6__productItem = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductItem(soap, &this->_ns8__getProductItemByGuidResponse::ns6__productItem);
	/* transient soap skipped */
}

int _ns8__getProductItemByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByGuidResponse), type))
		return soap->error;
	if(soap_out_PointerTons6__ProductItem(soap, "ns6:productItem", -1, &(a->_ns8__getProductItemByGuidResponse::ns6__productItem), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidResponse * FASTCALL soap_in__ns8__getProductItemByGuidResponse(struct soap *soap, const char *tag, _ns8__getProductItemByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByGuidResponse, sizeof(_ns8__getProductItemByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__productItem1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItem(soap, "ns6:productItem", &(a->_ns8__getProductItemByGuidResponse::ns6__productItem), "ns6:ProductItem"))
				{	soap_flag_ns6__productItem1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByGuidResponse, 0, sizeof(_ns8__getProductItemByGuidResponse), 0, soap_copy__ns8__getProductItemByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidResponse * SOAP_FMAC4 soap_get__ns8__getProductItemByGuidResponse(struct soap *soap, _ns8__getProductItemByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByGuidResponse * FASTCALL soap_instantiate__ns8__getProductItemByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByGuidResponse));
		((_ns8__getProductItemByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemByGuidResponse*)p = *(_ns8__getProductItemByGuidResponse*)q;
}

void _ns8__getProductItemByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getProductItemByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getProductItemByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getProductItemByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getProductItemByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductItemByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getProductItemByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidRequest * FASTCALL soap_in__ns8__getProductItemByGuidRequest(struct soap *soap, const char *tag, _ns8__getProductItemByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByGuidRequest, sizeof(_ns8__getProductItemByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getProductItemByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByGuidRequest, 0, sizeof(_ns8__getProductItemByGuidRequest), 0, soap_copy__ns8__getProductItemByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductItemByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidRequest * SOAP_FMAC4 soap_get__ns8__getProductItemByGuidRequest(struct soap *soap, _ns8__getProductItemByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByGuidRequest * FASTCALL soap_instantiate__ns8__getProductItemByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByGuidRequest));
		((_ns8__getProductItemByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemByGuidRequest*)p = *(_ns8__getProductItemByGuidRequest*)q;
}

void _ns8__getSubProductChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductChangesListResponse::ns6__subProductList = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__SubProductList(soap, &this->_ns8__getSubProductChangesListResponse::ns6__subProductList);
	/* transient soap skipped */
}

int _ns8__getSubProductChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getSubProductChangesListResponse::ns6__subProductList) {
		if(soap_out_PointerTons6__SubProductList(soap, "ns6:subProductList", -1, &a->_ns8__getSubProductChangesListResponse::ns6__subProductList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:subProductList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListResponse * FASTCALL soap_in__ns8__getSubProductChangesListResponse(struct soap *soap, const char *tag, _ns8__getSubProductChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductChangesListResponse, sizeof(_ns8__getSubProductChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__subProductList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__subProductList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProductList(soap, "ns6:subProductList", &(a->_ns8__getSubProductChangesListResponse::ns6__subProductList), "ns6:SubProductList"))
				{	soap_flag_ns6__subProductList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductChangesListResponse, 0, sizeof(_ns8__getSubProductChangesListResponse), 0, soap_copy__ns8__getSubProductChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__subProductList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListResponse * SOAP_FMAC4 soap_get__ns8__getSubProductChangesListResponse(struct soap *soap, _ns8__getSubProductChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductChangesListResponse * FASTCALL soap_instantiate__ns8__getSubProductChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductChangesListResponse));
		((_ns8__getSubProductChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductChangesListResponse*)p = *(_ns8__getSubProductChangesListResponse*)q;
}

void _ns8__getSubProductChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getSubProductChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getSubProductChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getSubProductChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getSubProductChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getSubProductChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getSubProductChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getSubProductChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListRequest * FASTCALL soap_in__ns8__getSubProductChangesListRequest(struct soap *soap, const char *tag, _ns8__getSubProductChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductChangesListRequest, sizeof(_ns8__getSubProductChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getSubProductChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getSubProductChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductChangesListRequest, 0, sizeof(_ns8__getSubProductChangesListRequest), 0, soap_copy__ns8__getSubProductChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListRequest * SOAP_FMAC4 soap_get__ns8__getSubProductChangesListRequest(struct soap *soap, _ns8__getSubProductChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductChangesListRequest * FASTCALL soap_instantiate__ns8__getSubProductChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductChangesListRequest));
		((_ns8__getSubProductChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductChangesListRequest*)p = *(_ns8__getSubProductChangesListRequest*)q;
}

void _ns8__getSubProductByProductListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByProductListResponse::ns6__subProductList = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductByProductListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__SubProductList(soap, &this->_ns8__getSubProductByProductListResponse::ns6__subProductList);
	/* transient soap skipped */
}

int _ns8__getSubProductByProductListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByProductListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByProductListResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByProductListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByProductListResponse), type))
		return soap->error;
	if(a->_ns8__getSubProductByProductListResponse::ns6__subProductList) {
		if(soap_out_PointerTons6__SubProductList(soap, "ns6:subProductList", -1, &a->_ns8__getSubProductByProductListResponse::ns6__subProductList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:subProductList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByProductListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByProductListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListResponse * FASTCALL soap_in__ns8__getSubProductByProductListResponse(struct soap *soap, const char *tag, _ns8__getSubProductByProductListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByProductListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByProductListResponse, sizeof(_ns8__getSubProductByProductListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByProductListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByProductListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__subProductList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__subProductList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProductList(soap, "ns6:subProductList", &(a->_ns8__getSubProductByProductListResponse::ns6__subProductList), "ns6:SubProductList"))
				{	soap_flag_ns6__subProductList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByProductListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByProductListResponse, 0, sizeof(_ns8__getSubProductByProductListResponse), 0, soap_copy__ns8__getSubProductByProductListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__subProductList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByProductListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByProductListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByProductListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByProductListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByProductListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListResponse * SOAP_FMAC4 soap_get__ns8__getSubProductByProductListResponse(struct soap *soap, _ns8__getSubProductByProductListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByProductListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByProductListResponse * FASTCALL soap_instantiate__ns8__getSubProductByProductListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByProductListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByProductListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByProductListResponse));
		((_ns8__getSubProductByProductListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByProductListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByProductListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByProductListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByProductListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByProductListResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductByProductListResponse*)p = *(_ns8__getSubProductByProductListResponse*)q;
}

void _ns8__getSubProductByProductListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByProductListRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->_ns8__getSubProductByProductListRequest::ns6__productGuid);
	/* transient soap skipped */
}

void _ns8__getSubProductByProductListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getSubProductByProductListRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->_ns8__getSubProductByProductListRequest::ns6__productGuid);
	/* transient soap skipped */
}

int _ns8__getSubProductByProductListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByProductListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByProductListRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByProductListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByProductListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getSubProductByProductListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getSubProductByProductListRequest::ns6__productGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:productGuid", -1, &a->_ns8__getSubProductByProductListRequest::ns6__productGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:productGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByProductListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByProductListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListRequest * FASTCALL soap_in__ns8__getSubProductByProductListRequest(struct soap *soap, const char *tag, _ns8__getSubProductByProductListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByProductListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByProductListRequest, sizeof(_ns8__getSubProductByProductListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByProductListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByProductListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__productGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getSubProductByProductListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__productGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:productGuid", &(a->_ns8__getSubProductByProductListRequest::ns6__productGuid), "ns3:UUID"))
				{	soap_flag_ns6__productGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByProductListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByProductListRequest, 0, sizeof(_ns8__getSubProductByProductListRequest), 0, soap_copy__ns8__getSubProductByProductListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__productGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByProductListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByProductListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByProductListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByProductListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByProductListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListRequest * SOAP_FMAC4 soap_get__ns8__getSubProductByProductListRequest(struct soap *soap, _ns8__getSubProductByProductListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByProductListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByProductListRequest * FASTCALL soap_instantiate__ns8__getSubProductByProductListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByProductListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByProductListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByProductListRequest));
		((_ns8__getSubProductByProductListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByProductListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByProductListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByProductListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByProductListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByProductListRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductByProductListRequest*)p = *(_ns8__getSubProductByProductListRequest*)q;
}

void _ns8__getSubProductByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByUuidResponse::ns6__subProduct = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__SubProduct(soap, &this->_ns8__getSubProductByUuidResponse::ns6__subProduct);
	/* transient soap skipped */
}

int _ns8__getSubProductByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getSubProductByUuidResponse::ns6__subProduct) {
		if(soap_out_PointerTons6__SubProduct(soap, "ns6:subProduct", -1, &a->_ns8__getSubProductByUuidResponse::ns6__subProduct, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:subProduct"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidResponse * FASTCALL soap_in__ns8__getSubProductByUuidResponse(struct soap *soap, const char *tag, _ns8__getSubProductByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByUuidResponse, sizeof(_ns8__getSubProductByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__subProduct1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:subProduct", &(a->_ns8__getSubProductByUuidResponse::ns6__subProduct), "ns6:SubProduct"))
				{	soap_flag_ns6__subProduct1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByUuidResponse, 0, sizeof(_ns8__getSubProductByUuidResponse), 0, soap_copy__ns8__getSubProductByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__subProduct1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidResponse * SOAP_FMAC4 soap_get__ns8__getSubProductByUuidResponse(struct soap *soap, _ns8__getSubProductByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByUuidResponse * FASTCALL soap_instantiate__ns8__getSubProductByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByUuidResponse));
		((_ns8__getSubProductByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductByUuidResponse*)p = *(_ns8__getSubProductByUuidResponse*)q;
}

void _ns8__getSubProductByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getSubProductByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getSubProductByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getSubProductByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getSubProductByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getSubProductByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getSubProductByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidRequest * FASTCALL soap_in__ns8__getSubProductByUuidRequest(struct soap *soap, const char *tag, _ns8__getSubProductByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByUuidRequest, sizeof(_ns8__getSubProductByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getSubProductByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByUuidRequest, 0, sizeof(_ns8__getSubProductByUuidRequest), 0, soap_copy__ns8__getSubProductByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidRequest * SOAP_FMAC4 soap_get__ns8__getSubProductByUuidRequest(struct soap *soap, _ns8__getSubProductByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByUuidRequest * FASTCALL soap_instantiate__ns8__getSubProductByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByUuidRequest));
		((_ns8__getSubProductByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductByUuidRequest*)p = *(_ns8__getSubProductByUuidRequest*)q;
}

void _ns8__getSubProductByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByGuidResponse::ns6__subProduct = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__SubProduct(soap, &this->_ns8__getSubProductByGuidResponse::ns6__subProduct);
	/* transient soap skipped */
}

int _ns8__getSubProductByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getSubProductByGuidResponse::ns6__subProduct) {
		if(soap_out_PointerTons6__SubProduct(soap, "ns6:subProduct", -1, &a->_ns8__getSubProductByGuidResponse::ns6__subProduct, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:subProduct"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidResponse * FASTCALL soap_in__ns8__getSubProductByGuidResponse(struct soap *soap, const char *tag, _ns8__getSubProductByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByGuidResponse, sizeof(_ns8__getSubProductByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__subProduct1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:subProduct", &(a->_ns8__getSubProductByGuidResponse::ns6__subProduct), "ns6:SubProduct"))
				{	soap_flag_ns6__subProduct1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByGuidResponse, 0, sizeof(_ns8__getSubProductByGuidResponse), 0, soap_copy__ns8__getSubProductByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__subProduct1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidResponse * SOAP_FMAC4 soap_get__ns8__getSubProductByGuidResponse(struct soap *soap, _ns8__getSubProductByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByGuidResponse * FASTCALL soap_instantiate__ns8__getSubProductByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByGuidResponse));
		((_ns8__getSubProductByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductByGuidResponse*)p = *(_ns8__getSubProductByGuidResponse*)q;
}

void _ns8__getSubProductByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getSubProductByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getSubProductByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getSubProductByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getSubProductByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getSubProductByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getSubProductByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidRequest * FASTCALL soap_in__ns8__getSubProductByGuidRequest(struct soap *soap, const char *tag, _ns8__getSubProductByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByGuidRequest, sizeof(_ns8__getSubProductByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getSubProductByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByGuidRequest, 0, sizeof(_ns8__getSubProductByGuidRequest), 0, soap_copy__ns8__getSubProductByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidRequest * SOAP_FMAC4 soap_get__ns8__getSubProductByGuidRequest(struct soap *soap, _ns8__getSubProductByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByGuidRequest * FASTCALL soap_instantiate__ns8__getSubProductByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByGuidRequest));
		((_ns8__getSubProductByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductByGuidRequest*)p = *(_ns8__getSubProductByGuidRequest*)q;
}

void _ns8__getProductChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductChangesListResponse::ns6__productList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductList(soap, &this->_ns8__getProductChangesListResponse::ns6__productList);
	/* transient soap skipped */
}

int _ns8__getProductChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getProductChangesListResponse::ns6__productList) {
		if(soap_out_PointerTons6__ProductList(soap, "ns6:productList", -1, &a->_ns8__getProductChangesListResponse::ns6__productList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:productList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductChangesListResponse * FASTCALL soap_in__ns8__getProductChangesListResponse(struct soap *soap, const char *tag, _ns8__getProductChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductChangesListResponse, sizeof(_ns8__getProductChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__productList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__productList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductList(soap, "ns6:productList", &(a->_ns8__getProductChangesListResponse::ns6__productList), "ns6:ProductList"))
				{	soap_flag_ns6__productList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductChangesListResponse, 0, sizeof(_ns8__getProductChangesListResponse), 0, soap_copy__ns8__getProductChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__productList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductChangesListResponse * SOAP_FMAC4 soap_get__ns8__getProductChangesListResponse(struct soap *soap, _ns8__getProductChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductChangesListResponse * FASTCALL soap_instantiate__ns8__getProductChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductChangesListResponse));
		((_ns8__getProductChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getProductChangesListResponse*)p = *(_ns8__getProductChangesListResponse*)q;
}

void _ns8__getProductChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getProductChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getProductChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getProductChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getProductChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getProductChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getProductChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getProductChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getProductChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductChangesListRequest * FASTCALL soap_in__ns8__getProductChangesListRequest(struct soap *soap, const char *tag, _ns8__getProductChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductChangesListRequest, sizeof(_ns8__getProductChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getProductChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getProductChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductChangesListRequest, 0, sizeof(_ns8__getProductChangesListRequest), 0, soap_copy__ns8__getProductChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductChangesListRequest * SOAP_FMAC4 soap_get__ns8__getProductChangesListRequest(struct soap *soap, _ns8__getProductChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductChangesListRequest * FASTCALL soap_instantiate__ns8__getProductChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductChangesListRequest));
		((_ns8__getProductChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getProductChangesListRequest*)p = *(_ns8__getProductChangesListRequest*)q;
}

void _ns8__getProductByTypeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByTypeListResponse::ns6__productList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductByTypeListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductList(soap, &this->_ns8__getProductByTypeListResponse::ns6__productList);
	/* transient soap skipped */
}

int _ns8__getProductByTypeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByTypeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByTypeListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductByTypeListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByTypeListResponse), type))
		return soap->error;
	if(a->_ns8__getProductByTypeListResponse::ns6__productList) {
		if(soap_out_PointerTons6__ProductList(soap, "ns6:productList", -1, &a->_ns8__getProductByTypeListResponse::ns6__productList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:productList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByTypeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByTypeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListResponse * FASTCALL soap_in__ns8__getProductByTypeListResponse(struct soap *soap, const char *tag, _ns8__getProductByTypeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByTypeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByTypeListResponse, sizeof(_ns8__getProductByTypeListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByTypeListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByTypeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__productList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__productList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductList(soap, "ns6:productList", &(a->_ns8__getProductByTypeListResponse::ns6__productList), "ns6:ProductList"))
				{	soap_flag_ns6__productList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByTypeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByTypeListResponse, 0, sizeof(_ns8__getProductByTypeListResponse), 0, soap_copy__ns8__getProductByTypeListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__productList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByTypeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByTypeListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductByTypeListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByTypeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByTypeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListResponse * SOAP_FMAC4 soap_get__ns8__getProductByTypeListResponse(struct soap *soap, _ns8__getProductByTypeListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByTypeListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByTypeListResponse * FASTCALL soap_instantiate__ns8__getProductByTypeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByTypeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByTypeListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByTypeListResponse));
		((_ns8__getProductByTypeListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByTypeListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByTypeListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByTypeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByTypeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByTypeListResponse %p -> %p\n", q, p));
	*(_ns8__getProductByTypeListResponse*)p = *(_ns8__getProductByTypeListResponse*)q;
}

void _ns8__getProductByTypeListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByTypeListRequest::ns3__listOptions = NULL;
	soap_default_ns6__ProductType(soap, &this->_ns8__getProductByTypeListRequest::ns6__productType);
	/* transient soap skipped */
}

void _ns8__getProductByTypeListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getProductByTypeListRequest::ns3__listOptions);
	soap_embedded(soap, &this->_ns8__getProductByTypeListRequest::ns6__productType, SOAP_TYPE_ns6__ProductType);
	/* transient soap skipped */
}

int _ns8__getProductByTypeListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByTypeListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByTypeListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductByTypeListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByTypeListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getProductByTypeListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_ns6__ProductType(soap, "ns6:productType", -1, &(a->_ns8__getProductByTypeListRequest::ns6__productType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByTypeListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByTypeListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListRequest * FASTCALL soap_in__ns8__getProductByTypeListRequest(struct soap *soap, const char *tag, _ns8__getProductByTypeListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByTypeListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByTypeListRequest, sizeof(_ns8__getProductByTypeListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByTypeListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByTypeListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__productType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getProductByTypeListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__ProductType(soap, "ns6:productType", &(a->_ns8__getProductByTypeListRequest::ns6__productType), "ns6:ProductType"))
				{	soap_flag_ns6__productType1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByTypeListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByTypeListRequest, 0, sizeof(_ns8__getProductByTypeListRequest), 0, soap_copy__ns8__getProductByTypeListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__productType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByTypeListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByTypeListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductByTypeListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByTypeListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByTypeListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListRequest * SOAP_FMAC4 soap_get__ns8__getProductByTypeListRequest(struct soap *soap, _ns8__getProductByTypeListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByTypeListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByTypeListRequest * FASTCALL soap_instantiate__ns8__getProductByTypeListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByTypeListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByTypeListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByTypeListRequest));
		((_ns8__getProductByTypeListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByTypeListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByTypeListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByTypeListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByTypeListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByTypeListRequest %p -> %p\n", q, p));
	*(_ns8__getProductByTypeListRequest*)p = *(_ns8__getProductByTypeListRequest*)q;
}

void _ns8__getProductByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByUuidResponse::ns6__product = NULL;
	/* transient soap skipped */
}

void _ns8__getProductByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Product(soap, &this->_ns8__getProductByUuidResponse::ns6__product);
	/* transient soap skipped */
}

int _ns8__getProductByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getProductByUuidResponse::ns6__product) {
		if(soap_out_PointerTons6__Product(soap, "ns6:product", -1, &a->_ns8__getProductByUuidResponse::ns6__product, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:product"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByUuidResponse * FASTCALL soap_in__ns8__getProductByUuidResponse(struct soap *soap, const char *tag, _ns8__getProductByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByUuidResponse, sizeof(_ns8__getProductByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__product1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns6:product", &(a->_ns8__getProductByUuidResponse::ns6__product), "ns6:Product"))
				{	soap_flag_ns6__product1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByUuidResponse, 0, sizeof(_ns8__getProductByUuidResponse), 0, soap_copy__ns8__getProductByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__product1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByUuidResponse * SOAP_FMAC4 soap_get__ns8__getProductByUuidResponse(struct soap *soap, _ns8__getProductByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByUuidResponse * FASTCALL soap_instantiate__ns8__getProductByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByUuidResponse));
		((_ns8__getProductByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductByUuidResponse*)p = *(_ns8__getProductByUuidResponse*)q;
}

void _ns8__getProductByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getProductByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getProductByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getProductByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getProductByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getProductByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByUuidRequest * FASTCALL soap_in__ns8__getProductByUuidRequest(struct soap *soap, const char *tag, _ns8__getProductByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByUuidRequest, sizeof(_ns8__getProductByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getProductByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByUuidRequest, 0, sizeof(_ns8__getProductByUuidRequest), 0, soap_copy__ns8__getProductByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByUuidRequest * SOAP_FMAC4 soap_get__ns8__getProductByUuidRequest(struct soap *soap, _ns8__getProductByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByUuidRequest * FASTCALL soap_instantiate__ns8__getProductByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByUuidRequest));
		((_ns8__getProductByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductByUuidRequest*)p = *(_ns8__getProductByUuidRequest*)q;
}

void _ns8__getProductByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByGuidResponse::ns6__product = NULL;
	/* transient soap skipped */
}

void _ns8__getProductByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Product(soap, &this->_ns8__getProductByGuidResponse::ns6__product);
	/* transient soap skipped */
}

int _ns8__getProductByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getProductByGuidResponse::ns6__product) {
		if(soap_out_PointerTons6__Product(soap, "ns6:product", -1, &a->_ns8__getProductByGuidResponse::ns6__product, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:product"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByGuidResponse * FASTCALL soap_in__ns8__getProductByGuidResponse(struct soap *soap, const char *tag, _ns8__getProductByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByGuidResponse, sizeof(_ns8__getProductByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__product1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns6:product", &(a->_ns8__getProductByGuidResponse::ns6__product), "ns6:Product"))
				{	soap_flag_ns6__product1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByGuidResponse, 0, sizeof(_ns8__getProductByGuidResponse), 0, soap_copy__ns8__getProductByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__product1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByGuidResponse * SOAP_FMAC4 soap_get__ns8__getProductByGuidResponse(struct soap *soap, _ns8__getProductByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByGuidResponse * FASTCALL soap_instantiate__ns8__getProductByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByGuidResponse));
		((_ns8__getProductByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductByGuidResponse*)p = *(_ns8__getProductByGuidResponse*)q;
}

void _ns8__getProductByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getProductByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getProductByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getProductByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getProductByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getProductByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByGuidRequest * FASTCALL soap_in__ns8__getProductByGuidRequest(struct soap *soap, const char *tag, _ns8__getProductByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByGuidRequest, sizeof(_ns8__getProductByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getProductByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByGuidRequest, 0, sizeof(_ns8__getProductByGuidRequest), 0, soap_copy__ns8__getProductByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByGuidRequest * SOAP_FMAC4 soap_get__ns8__getProductByGuidRequest(struct soap *soap, _ns8__getProductByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByGuidRequest * FASTCALL soap_instantiate__ns8__getProductByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByGuidRequest));
		((_ns8__getProductByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductByGuidRequest*)p = *(_ns8__getProductByGuidRequest*)q;
}

void _ns8__getUnitChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitChangesListResponse::ns6__unitList = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__UnitList(soap, &this->_ns8__getUnitChangesListResponse::ns6__unitList);
	/* transient soap skipped */
}

int _ns8__getUnitChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getUnitChangesListResponse::ns6__unitList) {
		if(soap_out_PointerTons6__UnitList(soap, "ns6:unitList", -1, &a->_ns8__getUnitChangesListResponse::ns6__unitList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:unitList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListResponse * FASTCALL soap_in__ns8__getUnitChangesListResponse(struct soap *soap, const char *tag, _ns8__getUnitChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitChangesListResponse, sizeof(_ns8__getUnitChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__unitList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__unitList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__UnitList(soap, "ns6:unitList", &(a->_ns8__getUnitChangesListResponse::ns6__unitList), "ns6:UnitList"))
				{	soap_flag_ns6__unitList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitChangesListResponse, 0, sizeof(_ns8__getUnitChangesListResponse), 0, soap_copy__ns8__getUnitChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__unitList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListResponse * SOAP_FMAC4 soap_get__ns8__getUnitChangesListResponse(struct soap *soap, _ns8__getUnitChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitChangesListResponse * FASTCALL soap_instantiate__ns8__getUnitChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitChangesListResponse));
		((_ns8__getUnitChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getUnitChangesListResponse*)p = *(_ns8__getUnitChangesListResponse*)q;
}

void _ns8__getUnitChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getUnitChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getUnitChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getUnitChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getUnitChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getUnitChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getUnitChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getUnitChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListRequest * FASTCALL soap_in__ns8__getUnitChangesListRequest(struct soap *soap, const char *tag, _ns8__getUnitChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitChangesListRequest, sizeof(_ns8__getUnitChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getUnitChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getUnitChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitChangesListRequest, 0, sizeof(_ns8__getUnitChangesListRequest), 0, soap_copy__ns8__getUnitChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListRequest * SOAP_FMAC4 soap_get__ns8__getUnitChangesListRequest(struct soap *soap, _ns8__getUnitChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitChangesListRequest * FASTCALL soap_instantiate__ns8__getUnitChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitChangesListRequest));
		((_ns8__getUnitChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getUnitChangesListRequest*)p = *(_ns8__getUnitChangesListRequest*)q;
}

void _ns8__getUnitListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitListResponse::ns6__unitList = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__UnitList(soap, &this->_ns8__getUnitListResponse::ns6__unitList);
	/* transient soap skipped */
}

int _ns8__getUnitListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitListResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitListResponse), type))
		return soap->error;
	if(a->_ns8__getUnitListResponse::ns6__unitList) {
		if(soap_out_PointerTons6__UnitList(soap, "ns6:unitList", -1, &a->_ns8__getUnitListResponse::ns6__unitList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:unitList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitListResponse * FASTCALL soap_in__ns8__getUnitListResponse(struct soap *soap, const char *tag, _ns8__getUnitListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitListResponse, sizeof(_ns8__getUnitListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__unitList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__unitList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__UnitList(soap, "ns6:unitList", &(a->_ns8__getUnitListResponse::ns6__unitList), "ns6:UnitList"))
				{	soap_flag_ns6__unitList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitListResponse, 0, sizeof(_ns8__getUnitListResponse), 0, soap_copy__ns8__getUnitListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__unitList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitListResponse * SOAP_FMAC4 soap_get__ns8__getUnitListResponse(struct soap *soap, _ns8__getUnitListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitListResponse * FASTCALL soap_instantiate__ns8__getUnitListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitListResponse));
		((_ns8__getUnitListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitListResponse %p -> %p\n", q, p));
	*(_ns8__getUnitListResponse*)p = *(_ns8__getUnitListResponse*)q;
}

void _ns8__getUnitListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitListRequest::ns3__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getUnitListRequest::ns3__listOptions);
	/* transient soap skipped */
}

int _ns8__getUnitListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitListRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getUnitListRequest::ns3__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitListRequest * FASTCALL soap_in__ns8__getUnitListRequest(struct soap *soap, const char *tag, _ns8__getUnitListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitListRequest, sizeof(_ns8__getUnitListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getUnitListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitListRequest, 0, sizeof(_ns8__getUnitListRequest), 0, soap_copy__ns8__getUnitListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getUnitListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitListRequest * SOAP_FMAC4 soap_get__ns8__getUnitListRequest(struct soap *soap, _ns8__getUnitListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitListRequest * FASTCALL soap_instantiate__ns8__getUnitListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitListRequest));
		((_ns8__getUnitListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitListRequest %p -> %p\n", q, p));
	*(_ns8__getUnitListRequest*)p = *(_ns8__getUnitListRequest*)q;
}

void _ns8__getUnitByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitByUuidResponse::ns6__unit = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Unit(soap, &this->_ns8__getUnitByUuidResponse::ns6__unit);
	/* transient soap skipped */
}

int _ns8__getUnitByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getUnitByUuidResponse::ns6__unit) {
		if(soap_out_PointerTons6__Unit(soap, "ns6:unit", -1, &a->_ns8__getUnitByUuidResponse::ns6__unit, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:unit"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidResponse * FASTCALL soap_in__ns8__getUnitByUuidResponse(struct soap *soap, const char *tag, _ns8__getUnitByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByUuidResponse, sizeof(_ns8__getUnitByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns6:unit", &(a->_ns8__getUnitByUuidResponse::ns6__unit), "ns6:Unit"))
				{	soap_flag_ns6__unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByUuidResponse, 0, sizeof(_ns8__getUnitByUuidResponse), 0, soap_copy__ns8__getUnitByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__unit1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidResponse * SOAP_FMAC4 soap_get__ns8__getUnitByUuidResponse(struct soap *soap, _ns8__getUnitByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByUuidResponse * FASTCALL soap_instantiate__ns8__getUnitByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByUuidResponse));
		((_ns8__getUnitByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getUnitByUuidResponse*)p = *(_ns8__getUnitByUuidResponse*)q;
}

void _ns8__getUnitByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getUnitByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getUnitByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getUnitByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getUnitByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getUnitByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getUnitByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidRequest * FASTCALL soap_in__ns8__getUnitByUuidRequest(struct soap *soap, const char *tag, _ns8__getUnitByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByUuidRequest, sizeof(_ns8__getUnitByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getUnitByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByUuidRequest, 0, sizeof(_ns8__getUnitByUuidRequest), 0, soap_copy__ns8__getUnitByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidRequest * SOAP_FMAC4 soap_get__ns8__getUnitByUuidRequest(struct soap *soap, _ns8__getUnitByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByUuidRequest * FASTCALL soap_instantiate__ns8__getUnitByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByUuidRequest));
		((_ns8__getUnitByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getUnitByUuidRequest*)p = *(_ns8__getUnitByUuidRequest*)q;
}

void _ns8__getUnitByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitByGuidResponse::ns6__unit = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Unit(soap, &this->_ns8__getUnitByGuidResponse::ns6__unit);
	/* transient soap skipped */
}

int _ns8__getUnitByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getUnitByGuidResponse::ns6__unit) {
		if(soap_out_PointerTons6__Unit(soap, "ns6:unit", -1, &a->_ns8__getUnitByGuidResponse::ns6__unit, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:unit"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidResponse * FASTCALL soap_in__ns8__getUnitByGuidResponse(struct soap *soap, const char *tag, _ns8__getUnitByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByGuidResponse, sizeof(_ns8__getUnitByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns6:unit", &(a->_ns8__getUnitByGuidResponse::ns6__unit), "ns6:Unit"))
				{	soap_flag_ns6__unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByGuidResponse, 0, sizeof(_ns8__getUnitByGuidResponse), 0, soap_copy__ns8__getUnitByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__unit1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidResponse * SOAP_FMAC4 soap_get__ns8__getUnitByGuidResponse(struct soap *soap, _ns8__getUnitByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByGuidResponse * FASTCALL soap_instantiate__ns8__getUnitByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByGuidResponse));
		((_ns8__getUnitByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getUnitByGuidResponse*)p = *(_ns8__getUnitByGuidResponse*)q;
}

void _ns8__getUnitByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getUnitByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getUnitByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getUnitByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getUnitByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getUnitByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getUnitByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidRequest * FASTCALL soap_in__ns8__getUnitByGuidRequest(struct soap *soap, const char *tag, _ns8__getUnitByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByGuidRequest, sizeof(_ns8__getUnitByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getUnitByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByGuidRequest, 0, sizeof(_ns8__getUnitByGuidRequest), 0, soap_copy__ns8__getUnitByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidRequest * SOAP_FMAC4 soap_get__ns8__getUnitByGuidRequest(struct soap *soap, _ns8__getUnitByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByGuidRequest * FASTCALL soap_instantiate__ns8__getUnitByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByGuidRequest));
		((_ns8__getUnitByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getUnitByGuidRequest*)p = *(_ns8__getUnitByGuidRequest*)q;
}

void _ns8__getPurposeChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeChangesListResponse::ns6__purposeList = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__PurposeList(soap, &this->_ns8__getPurposeChangesListResponse::ns6__purposeList);
	/* transient soap skipped */
}

int _ns8__getPurposeChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeChangesListResponse::ns6__purposeList) {
		if(soap_out_PointerTons6__PurposeList(soap, "ns6:purposeList", -1, &a->_ns8__getPurposeChangesListResponse::ns6__purposeList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:purposeList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListResponse * FASTCALL soap_in__ns8__getPurposeChangesListResponse(struct soap *soap, const char *tag, _ns8__getPurposeChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeChangesListResponse, sizeof(_ns8__getPurposeChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__purposeList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__purposeList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PurposeList(soap, "ns6:purposeList", &(a->_ns8__getPurposeChangesListResponse::ns6__purposeList), "ns6:PurposeList"))
				{	soap_flag_ns6__purposeList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeChangesListResponse, 0, sizeof(_ns8__getPurposeChangesListResponse), 0, soap_copy__ns8__getPurposeChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__purposeList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListResponse * SOAP_FMAC4 soap_get__ns8__getPurposeChangesListResponse(struct soap *soap, _ns8__getPurposeChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeChangesListResponse * FASTCALL soap_instantiate__ns8__getPurposeChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeChangesListResponse));
		((_ns8__getPurposeChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeChangesListResponse*)p = *(_ns8__getPurposeChangesListResponse*)q;
}

void _ns8__getPurposeChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeChangesListRequest::ns3__listOptions = NULL;
	this->_ns8__getPurposeChangesListRequest::ns3__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getPurposeChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->_ns8__getPurposeChangesListRequest::ns3__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getPurposeChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getPurposeChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->_ns8__getPurposeChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->_ns8__getPurposeChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListRequest * FASTCALL soap_in__ns8__getPurposeChangesListRequest(struct soap *soap, const char *tag, _ns8__getPurposeChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeChangesListRequest, sizeof(_ns8__getPurposeChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getPurposeChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->_ns8__getPurposeChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeChangesListRequest, 0, sizeof(_ns8__getPurposeChangesListRequest), 0, soap_copy__ns8__getPurposeChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListRequest * SOAP_FMAC4 soap_get__ns8__getPurposeChangesListRequest(struct soap *soap, _ns8__getPurposeChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeChangesListRequest * FASTCALL soap_instantiate__ns8__getPurposeChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeChangesListRequest));
		((_ns8__getPurposeChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeChangesListRequest*)p = *(_ns8__getPurposeChangesListRequest*)q;
}

void _ns8__getPurposeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeListResponse::ns6__purposeList = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__PurposeList(soap, &this->_ns8__getPurposeListResponse::ns6__purposeList);
	/* transient soap skipped */
}

int _ns8__getPurposeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeListResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeListResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeListResponse::ns6__purposeList) {
		if(soap_out_PointerTons6__PurposeList(soap, "ns6:purposeList", -1, &a->_ns8__getPurposeListResponse::ns6__purposeList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:purposeList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeListResponse * FASTCALL soap_in__ns8__getPurposeListResponse(struct soap *soap, const char *tag, _ns8__getPurposeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeListResponse, sizeof(_ns8__getPurposeListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__purposeList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__purposeList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PurposeList(soap, "ns6:purposeList", &(a->_ns8__getPurposeListResponse::ns6__purposeList), "ns6:PurposeList"))
				{	soap_flag_ns6__purposeList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeListResponse, 0, sizeof(_ns8__getPurposeListResponse), 0, soap_copy__ns8__getPurposeListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__purposeList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeListResponse * SOAP_FMAC4 soap_get__ns8__getPurposeListResponse(struct soap *soap, _ns8__getPurposeListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeListResponse * FASTCALL soap_instantiate__ns8__getPurposeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeListResponse));
		((_ns8__getPurposeListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeListResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeListResponse*)p = *(_ns8__getPurposeListResponse*)q;
}

void _ns8__getPurposeListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeListRequest::ns3__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->_ns8__getPurposeListRequest::ns3__listOptions);
	/* transient soap skipped */
}

int _ns8__getPurposeListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeListRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeListRequest), type))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->_ns8__getPurposeListRequest::ns3__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeListRequest * FASTCALL soap_in__ns8__getPurposeListRequest(struct soap *soap, const char *tag, _ns8__getPurposeListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeListRequest, sizeof(_ns8__getPurposeListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->_ns8__getPurposeListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeListRequest, 0, sizeof(_ns8__getPurposeListRequest), 0, soap_copy__ns8__getPurposeListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getPurposeListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeListRequest * SOAP_FMAC4 soap_get__ns8__getPurposeListRequest(struct soap *soap, _ns8__getPurposeListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeListRequest * FASTCALL soap_instantiate__ns8__getPurposeListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeListRequest));
		((_ns8__getPurposeListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeListRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeListRequest*)p = *(_ns8__getPurposeListRequest*)q;
}

void _ns8__getPurposeByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeByUuidResponse::ns6__purpose = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Purpose(soap, &this->_ns8__getPurposeByUuidResponse::ns6__purpose);
	/* transient soap skipped */
}

int _ns8__getPurposeByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeByUuidResponse::ns6__purpose) {
		if(soap_out_PointerTons6__Purpose(soap, "ns6:purpose", -1, &a->_ns8__getPurposeByUuidResponse::ns6__purpose, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:purpose"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidResponse * FASTCALL soap_in__ns8__getPurposeByUuidResponse(struct soap *soap, const char *tag, _ns8__getPurposeByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByUuidResponse, sizeof(_ns8__getPurposeByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__purpose1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Purpose(soap, "ns6:purpose", &(a->_ns8__getPurposeByUuidResponse::ns6__purpose), "ns6:Purpose"))
				{	soap_flag_ns6__purpose1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByUuidResponse, 0, sizeof(_ns8__getPurposeByUuidResponse), 0, soap_copy__ns8__getPurposeByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__purpose1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidResponse * SOAP_FMAC4 soap_get__ns8__getPurposeByUuidResponse(struct soap *soap, _ns8__getPurposeByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByUuidResponse * FASTCALL soap_instantiate__ns8__getPurposeByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByUuidResponse));
		((_ns8__getPurposeByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeByUuidResponse*)p = *(_ns8__getPurposeByUuidResponse*)q;
}

void _ns8__getPurposeByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getPurposeByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

void _ns8__getPurposeByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getPurposeByUuidRequest::ns3__uuid);
	/* transient soap skipped */
}

int _ns8__getPurposeByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getPurposeByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->_ns8__getPurposeByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidRequest * FASTCALL soap_in__ns8__getPurposeByUuidRequest(struct soap *soap, const char *tag, _ns8__getPurposeByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByUuidRequest, sizeof(_ns8__getPurposeByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->_ns8__getPurposeByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByUuidRequest, 0, sizeof(_ns8__getPurposeByUuidRequest), 0, soap_copy__ns8__getPurposeByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidRequest * SOAP_FMAC4 soap_get__ns8__getPurposeByUuidRequest(struct soap *soap, _ns8__getPurposeByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByUuidRequest * FASTCALL soap_instantiate__ns8__getPurposeByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByUuidRequest));
		((_ns8__getPurposeByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeByUuidRequest*)p = *(_ns8__getPurposeByUuidRequest*)q;
}

void _ns8__getPurposeByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeByGuidResponse::ns6__purpose = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Purpose(soap, &this->_ns8__getPurposeByGuidResponse::ns6__purpose);
	/* transient soap skipped */
}

int _ns8__getPurposeByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeByGuidResponse::ns6__purpose) {
		if(soap_out_PointerTons6__Purpose(soap, "ns6:purpose", -1, &a->_ns8__getPurposeByGuidResponse::ns6__purpose, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:purpose"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidResponse * FASTCALL soap_in__ns8__getPurposeByGuidResponse(struct soap *soap, const char *tag, _ns8__getPurposeByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByGuidResponse, sizeof(_ns8__getPurposeByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns6__purpose1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns6__purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Purpose(soap, "ns6:purpose", &(a->_ns8__getPurposeByGuidResponse::ns6__purpose), "ns6:Purpose"))
				{	soap_flag_ns6__purpose1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByGuidResponse, 0, sizeof(_ns8__getPurposeByGuidResponse), 0, soap_copy__ns8__getPurposeByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns6__purpose1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidResponse * SOAP_FMAC4 soap_get__ns8__getPurposeByGuidResponse(struct soap *soap, _ns8__getPurposeByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByGuidResponse * FASTCALL soap_instantiate__ns8__getPurposeByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByGuidResponse));
		((_ns8__getPurposeByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeByGuidResponse*)p = *(_ns8__getPurposeByGuidResponse*)q;
}

void _ns8__getPurposeByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->_ns8__getPurposeByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

void _ns8__getPurposeByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->_ns8__getPurposeByGuidRequest::ns3__guid);
	/* transient soap skipped */
}

int _ns8__getPurposeByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getPurposeByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->_ns8__getPurposeByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidRequest * FASTCALL soap_in__ns8__getPurposeByGuidRequest(struct soap *soap, const char *tag, _ns8__getPurposeByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByGuidRequest, sizeof(_ns8__getPurposeByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns3__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->_ns8__getPurposeByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByGuidRequest, 0, sizeof(_ns8__getPurposeByGuidRequest), 0, soap_copy__ns8__getPurposeByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidRequest * SOAP_FMAC4 soap_get__ns8__getPurposeByGuidRequest(struct soap *soap, _ns8__getPurposeByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByGuidRequest * FASTCALL soap_instantiate__ns8__getPurposeByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByGuidRequest));
		((_ns8__getPurposeByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeByGuidRequest*)p = *(_ns8__getPurposeByGuidRequest*)q;
}

void ns7__WorkingArea::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__WorkingArea::__union_WorkingArea = 0;
	/* transient soap skipped */
}

void ns7__WorkingArea::soap_serialize(struct soap *soap) const
{
	soap_serialize__ns7__union_WorkingArea(soap, this->ns7__WorkingArea::__union_WorkingArea, &this->ns7__WorkingArea::union_WorkingArea);
	/* transient soap skipped */
}

int ns7__WorkingArea::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__WorkingArea(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__WorkingArea(struct soap *soap, const char *tag, int id, const ns7__WorkingArea *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__WorkingArea), type))
		return soap->error;
	if(soap_out__ns7__union_WorkingArea(soap, a->ns7__WorkingArea::__union_WorkingArea, &a->ns7__WorkingArea::union_WorkingArea))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__WorkingArea::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__WorkingArea(soap, tag, this, type);
}

SOAP_FMAC3 ns7__WorkingArea * FASTCALL soap_in_ns7__WorkingArea(struct soap *soap, const char *tag, ns7__WorkingArea *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__WorkingArea *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__WorkingArea, sizeof(ns7__WorkingArea), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	a->soap_default(soap);
	if(!tag || *tag == '-' || (soap->body && !*soap->href)) {
	
		if(!soap_in__ns7__union_WorkingArea(soap, &a->__union_WorkingArea, &a->union_WorkingArea))
			return NULL;
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__WorkingArea *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__WorkingArea, 0, sizeof(ns7__WorkingArea), 0, soap_copy_ns7__WorkingArea);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__WorkingArea::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__WorkingArea);
	return this->soap_out(soap, tag?tag:"ns7:WorkingArea", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__WorkingArea::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__WorkingArea(soap, this, tag, type);
}

SOAP_FMAC3 ns7__WorkingArea * SOAP_FMAC4 soap_get_ns7__WorkingArea(struct soap *soap, ns7__WorkingArea *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__WorkingArea * FASTCALL soap_instantiate_ns7__WorkingArea(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__WorkingArea(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__WorkingArea, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__WorkingArea);
		ASSIGN_PTR(size, sizeof(ns7__WorkingArea));
		((ns7__WorkingArea*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__WorkingArea[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__WorkingArea));
		for(int i = 0; i < n; i++)
			((ns7__WorkingArea*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__WorkingArea*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__WorkingArea(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__WorkingArea %p -> %p\n", q, p));
	*(ns7__WorkingArea*)p = *(ns7__WorkingArea*)q;
}

void ns7__UserAuthority::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->ns7__UserAuthority::ID);
	soap_default_ns3__String255(soap, &this->ns7__UserAuthority::name);
	this->ns7__UserAuthority::granted = NULL;
	/* transient soap skipped */
}

void ns7__UserAuthority::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__NCName(soap, &this->ns7__UserAuthority::ID);
	soap_serialize_ns3__String255(soap, &this->ns7__UserAuthority::name);
	soap_serialize_PointerTobool(soap, &this->ns7__UserAuthority::granted);
	/* transient soap skipped */
}

int ns7__UserAuthority::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__UserAuthority(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__UserAuthority(struct soap *soap, const char *tag, int id, const ns7__UserAuthority *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__UserAuthority), type))
		return soap->error;
	if(a->ns7__UserAuthority::ID) {
		if(soap_out_xsd__NCName(soap, "ns7:ID", -1, &a->ns7__UserAuthority::ID, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:ID"))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__UserAuthority::name), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:granted", -1, &(a->ns7__UserAuthority::granted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__UserAuthority::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__UserAuthority(soap, tag, this, type);
}

SOAP_FMAC3 ns7__UserAuthority * FASTCALL soap_in_ns7__UserAuthority(struct soap *soap, const char *tag, ns7__UserAuthority *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__UserAuthority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__UserAuthority, sizeof(ns7__UserAuthority), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__UserAuthority) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__UserAuthority *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_granted1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__NCName(soap, "ns7:ID", &(a->ns7__UserAuthority::ID), "xsd:NCName"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__UserAuthority::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_granted1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:granted", &(a->ns7__UserAuthority::granted), "xsd:boolean"))
				{	soap_flag_granted1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__UserAuthority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__UserAuthority, 0, sizeof(ns7__UserAuthority), 0, soap_copy_ns7__UserAuthority);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__UserAuthority::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__UserAuthority);
	return this->soap_out(soap, tag?tag:"ns7:UserAuthority", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__UserAuthority::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__UserAuthority(soap, this, tag, type);
}

SOAP_FMAC3 ns7__UserAuthority * SOAP_FMAC4 soap_get_ns7__UserAuthority(struct soap *soap, ns7__UserAuthority *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__UserAuthority * FASTCALL soap_instantiate_ns7__UserAuthority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__UserAuthority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__UserAuthority, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__UserAuthority);
		ASSIGN_PTR(size, sizeof(ns7__UserAuthority));
		((ns7__UserAuthority*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__UserAuthority[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__UserAuthority));
		for(int i = 0; i < n; i++)
			((ns7__UserAuthority*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__UserAuthority*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__UserAuthority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__UserAuthority %p -> %p\n", q, p));
	*(ns7__UserAuthority*)p = *(ns7__UserAuthority*)q;
}

void ns7__WorkingAreaList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__WorkingAreaList::__sizeworkingArea = 0;
	this->ns7__WorkingAreaList::workingArea = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns7__WorkingAreaList::soap_serialize(struct soap *soap) const
{
	if(this->ns7__WorkingAreaList::workingArea) {
		for(int i = 0; i < this->ns7__WorkingAreaList::__sizeworkingArea; i++) {
			soap_serialize_PointerTons7__WorkingArea(soap, this->ns7__WorkingAreaList::workingArea + i);
		}
	}
	/* transient soap skipped */
}

int ns7__WorkingAreaList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__WorkingAreaList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__WorkingAreaList(struct soap *soap, const char *tag, int id, const ns7__WorkingAreaList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__WorkingAreaList), "ns7:WorkingAreaList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__WorkingAreaList::workingArea) {
		int i;
		for(i = 0; i < a->ns7__WorkingAreaList::__sizeworkingArea; i++)
			if(soap_out_PointerTons7__WorkingArea(soap, "ns7:workingArea", -1, a->ns7__WorkingAreaList::workingArea + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__WorkingAreaList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__WorkingAreaList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__WorkingAreaList * FASTCALL soap_in_ns7__WorkingAreaList(struct soap *soap, const char *tag, ns7__WorkingAreaList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__WorkingAreaList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__WorkingAreaList, sizeof(ns7__WorkingAreaList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__WorkingAreaList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__WorkingAreaList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_workingArea1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:workingArea", 1, NULL)) {
				if(a->ns7__WorkingAreaList::workingArea == NULL) {
					if(soap_blist_workingArea1 == NULL)
						soap_blist_workingArea1 = soap_new_block(soap);
					a->ns7__WorkingAreaList::workingArea = (ns7__WorkingArea **)soap_push_block(soap, soap_blist_workingArea1, sizeof(ns7__WorkingArea *));
					if(a->ns7__WorkingAreaList::workingArea == NULL)
						return NULL;
					*a->ns7__WorkingAreaList::workingArea = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__WorkingArea(soap, "ns7:workingArea", a->ns7__WorkingAreaList::workingArea, "ns7:WorkingArea"))
				{	a->ns7__WorkingAreaList::__sizeworkingArea++;
					a->ns7__WorkingAreaList::workingArea = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__WorkingAreaList::workingArea)
			soap_pop_block(soap, soap_blist_workingArea1);
		if(a->ns7__WorkingAreaList::__sizeworkingArea)
			a->ns7__WorkingAreaList::workingArea = (ns7__WorkingArea **)soap_save_block(soap, soap_blist_workingArea1, NULL, 1);
		else
		{	a->ns7__WorkingAreaList::workingArea = NULL;
			if(soap_blist_workingArea1)
				soap_end_block(soap, soap_blist_workingArea1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__WorkingAreaList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__WorkingAreaList, 0, sizeof(ns7__WorkingAreaList), 0, soap_copy_ns7__WorkingAreaList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__WorkingAreaList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__WorkingAreaList);
	return this->soap_out(soap, tag?tag:"ns7:WorkingAreaList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__WorkingAreaList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__WorkingAreaList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__WorkingAreaList * SOAP_FMAC4 soap_get_ns7__WorkingAreaList(struct soap *soap, ns7__WorkingAreaList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__WorkingAreaList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__WorkingAreaList * FASTCALL soap_instantiate_ns7__WorkingAreaList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__WorkingAreaList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__WorkingAreaList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__WorkingAreaList);
		ASSIGN_PTR(size, sizeof(ns7__WorkingAreaList));
		((ns7__WorkingAreaList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__WorkingAreaList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__WorkingAreaList));
		for(int i = 0; i < n; i++)
			((ns7__WorkingAreaList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__WorkingAreaList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__WorkingAreaList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__WorkingAreaList %p -> %p\n", q, p));
	*(ns7__WorkingAreaList*)p = *(ns7__WorkingAreaList*)q;
}

void ns7__AuthorityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__AuthorityList::__sizeauthority = 0;
	this->ns7__AuthorityList::authority = NULL;
	/* transient soap skipped */
}

void ns7__AuthorityList::soap_serialize(struct soap *soap) const
{
	if(this->ns7__AuthorityList::authority) {
		for(int i = 0; i < this->ns7__AuthorityList::__sizeauthority; i++) {
			soap_serialize_PointerTons7__UserAuthority(soap, this->ns7__AuthorityList::authority + i);
		}
	}
	/* transient soap skipped */
}

int ns7__AuthorityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__AuthorityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__AuthorityList(struct soap *soap, const char *tag, int id, const ns7__AuthorityList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__AuthorityList), type))
		return soap->error;
	if(a->ns7__AuthorityList::authority) {
		int i;
		for(i = 0; i < a->ns7__AuthorityList::__sizeauthority; i++)
			if(soap_out_PointerTons7__UserAuthority(soap, "ns7:authority", -1, a->ns7__AuthorityList::authority + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__AuthorityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__AuthorityList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__AuthorityList * FASTCALL soap_in_ns7__AuthorityList(struct soap *soap, const char *tag, ns7__AuthorityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__AuthorityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__AuthorityList, sizeof(ns7__AuthorityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__AuthorityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__AuthorityList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_authority1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:authority", 1, NULL)) {
				if(a->ns7__AuthorityList::authority == NULL) {
					if(soap_blist_authority1 == NULL)
						soap_blist_authority1 = soap_new_block(soap);
					a->ns7__AuthorityList::authority = (ns7__UserAuthority **)soap_push_block(soap, soap_blist_authority1, sizeof(ns7__UserAuthority *));
					if(a->ns7__AuthorityList::authority == NULL)
						return NULL;
					*a->ns7__AuthorityList::authority = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__UserAuthority(soap, "ns7:authority", a->ns7__AuthorityList::authority, "ns7:UserAuthority"))
				{	a->ns7__AuthorityList::__sizeauthority++;
					a->ns7__AuthorityList::authority = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__AuthorityList::authority)
			soap_pop_block(soap, soap_blist_authority1);
		if(a->ns7__AuthorityList::__sizeauthority)
			a->ns7__AuthorityList::authority = (ns7__UserAuthority **)soap_save_block(soap, soap_blist_authority1, NULL, 1);
		else
		{	a->ns7__AuthorityList::authority = NULL;
			if(soap_blist_authority1)
				soap_end_block(soap, soap_blist_authority1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__AuthorityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__AuthorityList, 0, sizeof(ns7__AuthorityList), 0, soap_copy_ns7__AuthorityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__AuthorityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__AuthorityList);
	return this->soap_out(soap, tag?tag:"ns7:AuthorityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__AuthorityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__AuthorityList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__AuthorityList * SOAP_FMAC4 soap_get_ns7__AuthorityList(struct soap *soap, ns7__AuthorityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__AuthorityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__AuthorityList * FASTCALL soap_instantiate_ns7__AuthorityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__AuthorityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__AuthorityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__AuthorityList);
		ASSIGN_PTR(size, sizeof(ns7__AuthorityList));
		((ns7__AuthorityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__AuthorityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__AuthorityList));
		for(int i = 0; i < n; i++)
			((ns7__AuthorityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__AuthorityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__AuthorityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__AuthorityList %p -> %p\n", q, p));
	*(ns7__AuthorityList*)p = *(ns7__AuthorityList*)q;
}

void ns7__UserList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__UserList::__sizeuser = 0;
	this->ns7__UserList::user = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns7__UserList::soap_serialize(struct soap *soap) const
{
	if(this->ns7__UserList::user) {
		for(int i = 0; i < this->ns7__UserList::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns7__UserList::user + i);
		}
	}
	/* transient soap skipped */
}

int ns7__UserList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__UserList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__UserList(struct soap *soap, const char *tag, int id, const ns7__UserList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__UserList), "ns7:UserList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__UserList::user) {
		int i;
		for(i = 0; i < a->ns7__UserList::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns7__UserList::user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__UserList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__UserList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__UserList * FASTCALL soap_in_ns7__UserList(struct soap *soap, const char *tag, ns7__UserList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__UserList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__UserList, sizeof(ns7__UserList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__UserList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__UserList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns7__UserList::user == NULL) {
					if(soap_blist_user1 == NULL)
						soap_blist_user1 = soap_new_block(soap);
					a->ns7__UserList::user = (ns7__User **)soap_push_block(soap, soap_blist_user1, sizeof(ns7__User *));
					if(a->ns7__UserList::user == NULL)
						return NULL;
					*a->ns7__UserList::user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns7__UserList::user, "ns7:User"))
				{	a->ns7__UserList::__sizeuser++;
					a->ns7__UserList::user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__UserList::user)
			soap_pop_block(soap, soap_blist_user1);
		if(a->ns7__UserList::__sizeuser)
			a->ns7__UserList::user = (ns7__User **)soap_save_block(soap, soap_blist_user1, NULL, 1);
		else
		{	a->ns7__UserList::user = NULL;
			if(soap_blist_user1)
				soap_end_block(soap, soap_blist_user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__UserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__UserList, 0, sizeof(ns7__UserList), 0, soap_copy_ns7__UserList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__UserList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__UserList);
	return this->soap_out(soap, tag?tag:"ns7:UserList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__UserList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__UserList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__UserList * SOAP_FMAC4 soap_get_ns7__UserList(struct soap *soap, ns7__UserList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__UserList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__UserList * FASTCALL soap_instantiate_ns7__UserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__UserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__UserList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__UserList);
		ASSIGN_PTR(size, sizeof(ns7__UserList));
		((ns7__UserList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__UserList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__UserList));
		for(int i = 0; i < n; i++)
			((ns7__UserList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__UserList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__UserList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__UserList %p -> %p\n", q, p));
	*(ns7__UserList*)p = *(ns7__UserList*)q;
}

void ns7__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->ns7__User::login);
	soap_default_ns3__String255(soap, &this->ns7__User::fio);
	soap_default_xsd__date(soap, &this->ns7__User::birthDate);
	this->ns7__User::identity = NULL;
	this->ns7__User::snils = NULL;
	soap_default_ns3__String255(soap, &this->ns7__User::phone);
	soap_default_ns3__String255(soap, &this->ns7__User::workPhone);
	soap_default_ns3__String255(soap, &this->ns7__User::email);
	soap_default_ns3__String255(soap, &this->ns7__User::workEmail);
	this->ns7__User::__union_User = 0;
	soap_default_ns3__String255(soap, &this->ns7__User::post);
	this->ns7__User::enabled = NULL;
	this->ns7__User::nonExpired = NULL;
	this->ns7__User::nonLocked = NULL;
	this->ns7__User::authorityList = NULL;
	this->ns7__User::workingAreaList = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__User::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__NCName(soap, &this->ns7__User::login);
	soap_serialize_ns3__String255(soap, &this->ns7__User::fio);
	soap_serialize_xsd__date(soap, &this->ns7__User::birthDate);
	soap_serialize_PointerTons7__Document(soap, &this->ns7__User::identity);
	soap_serialize_PointerTons7__SNILSType(soap, &this->ns7__User::snils);
	soap_serialize_ns3__String255(soap, &this->ns7__User::phone);
	soap_serialize_ns3__String255(soap, &this->ns7__User::workPhone);
	soap_serialize_ns3__String255(soap, &this->ns7__User::email);
	soap_serialize_ns3__String255(soap, &this->ns7__User::workEmail);
	soap_serialize__ns7__union_User(soap, this->ns7__User::__union_User, &this->ns7__User::union_User);
	soap_serialize_ns3__String255(soap, &this->ns7__User::post);
	soap_serialize_PointerTobool(soap, &this->ns7__User::enabled);
	soap_serialize_PointerTobool(soap, &this->ns7__User::nonExpired);
	soap_serialize_PointerTobool(soap, &this->ns7__User::nonLocked);
	soap_serialize_PointerTons7__AuthorityList(soap, &this->ns7__User::authorityList);
	soap_serialize_PointerTons7__WorkingAreaList(soap, &this->ns7__User::workingAreaList);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__User(struct soap *soap, const char *tag, int id, const ns7__User *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__User), "ns7:User"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_xsd__NCName(soap, "ns7:login", -1, &(a->ns7__User::login), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:fio", -1, &(a->ns7__User::fio), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "ns7:birthDate", -1, &(a->ns7__User::birthDate), ""))
		return soap->error;
	if(soap_out_PointerTons7__Document(soap, "ns7:identity", -1, &(a->ns7__User::identity), ""))
		return soap->error;
	if(soap_out_PointerTons7__SNILSType(soap, "ns7:snils", -1, &(a->ns7__User::snils), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:phone", -1, &(a->ns7__User::phone), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:workPhone", -1, &(a->ns7__User::workPhone), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:email", -1, &(a->ns7__User::email), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:workEmail", -1, &(a->ns7__User::workEmail), ""))
		return soap->error;
	if(soap_out__ns7__union_User(soap, a->ns7__User::__union_User, &a->ns7__User::union_User))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:post", -1, &(a->ns7__User::post), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:enabled", -1, &(a->ns7__User::enabled), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:nonExpired", -1, &(a->ns7__User::nonExpired), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:nonLocked", -1, &(a->ns7__User::nonLocked), ""))
		return soap->error;
	if(soap_out_PointerTons7__AuthorityList(soap, "ns7:authorityList", -1, &(a->ns7__User::authorityList), ""))
		return soap->error;
	if(soap_out_PointerTons7__WorkingAreaList(soap, "ns7:workingAreaList", -1, &(a->ns7__User::workingAreaList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__User::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__User(soap, tag, this, type);
}

SOAP_FMAC3 ns7__User * FASTCALL soap_in_ns7__User(struct soap *soap, const char *tag, ns7__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__User, sizeof(ns7__User), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__User) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__User *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_fio1 = 1;
	size_t soap_flag_birthDate1 = 1;
	size_t soap_flag_identity1 = 1;
	size_t soap_flag_snils1 = 1;
	size_t soap_flag_phone1 = 1;
	size_t soap_flag_workPhone1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_workEmail1 = 1;
	size_t soap_flag_union_User1 = 1;
	size_t soap_flag_post1 = 1;
	size_t soap_flag_enabled1 = 1;
	size_t soap_flag_nonExpired1 = 1;
	size_t soap_flag_nonLocked1 = 1;
	size_t soap_flag_authorityList1 = 1;
	size_t soap_flag_workingAreaList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__NCName(soap, "ns7:login", &(a->ns7__User::login), "xsd:NCName"))
				{	soap_flag_login1--;
					continue;
				}
			if(soap_flag_fio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:fio", &(a->ns7__User::fio), "ns3:String255"))
				{	soap_flag_fio1--;
					continue;
				}
			if(soap_flag_birthDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "ns7:birthDate", &(a->ns7__User::birthDate), "xsd:date"))
				{	soap_flag_birthDate1--;
					continue;
				}
			if(soap_flag_identity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Document(soap, "ns7:identity", &(a->ns7__User::identity), "ns7:Document"))
				{	soap_flag_identity1--;
					continue;
				}
			if(soap_flag_snils1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__SNILSType(soap, "ns7:snils", &(a->ns7__User::snils), "ns7:SNILSType"))
				{	soap_flag_snils1--;
					continue;
				}
			if(soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:phone", &(a->ns7__User::phone), "ns3:String255"))
				{	soap_flag_phone1--;
					continue;
				}
			if(soap_flag_workPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:workPhone", &(a->ns7__User::workPhone), "ns3:String255"))
				{	soap_flag_workPhone1--;
					continue;
				}
			if(soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:email", &(a->ns7__User::email), "ns3:String255"))
				{	soap_flag_email1--;
					continue;
				}
			if(soap_flag_workEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:workEmail", &(a->ns7__User::workEmail), "ns3:String255"))
				{	soap_flag_workEmail1--;
					continue;
				}
			if(soap_flag_union_User1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_User(soap, &a->ns7__User::__union_User, &a->ns7__User::union_User))
				{	soap_flag_union_User1 = 0;
					continue;
				}
			if(soap_flag_post1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:post", &(a->ns7__User::post), "ns3:String255"))
				{	soap_flag_post1--;
					continue;
				}
			if(soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:enabled", &(a->ns7__User::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if(soap_flag_nonExpired1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:nonExpired", &(a->ns7__User::nonExpired), "xsd:boolean"))
				{	soap_flag_nonExpired1--;
					continue;
				}
			if(soap_flag_nonLocked1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:nonLocked", &(a->ns7__User::nonLocked), "xsd:boolean"))
				{	soap_flag_nonLocked1--;
					continue;
				}
			if(soap_flag_authorityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__AuthorityList(soap, "ns7:authorityList", &(a->ns7__User::authorityList), "ns7:AuthorityList"))
				{	soap_flag_authorityList1--;
					continue;
				}
			if(soap_flag_workingAreaList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__WorkingAreaList(soap, "ns7:workingAreaList", &(a->ns7__User::workingAreaList), "ns7:WorkingAreaList"))
				{	soap_flag_workingAreaList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__User, 0, sizeof(ns7__User), 0, soap_copy_ns7__User);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_User1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__User);
	return this->soap_out(soap, tag?tag:"ns7:User", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__User(soap, this, tag, type);
}

SOAP_FMAC3 ns7__User * SOAP_FMAC4 soap_get_ns7__User(struct soap *soap, ns7__User *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__User * FASTCALL soap_instantiate_ns7__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__User, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__User);
		ASSIGN_PTR(size, sizeof(ns7__User));
		((ns7__User*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__User[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__User));
		for(int i = 0; i < n; i++)
			((ns7__User*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__User %p -> %p\n", q, p));
	*(ns7__User*)p = *(ns7__User*)q;
}

void ns7__ProcessingProcedure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns7__ProcessingProcedureType(soap, &this->ns7__ProcessingProcedure::type);
	this->ns7__ProcessingProcedure::startDateTime = NULL;
	this->ns7__ProcessingProcedure::endDateTime = NULL;
	/* transient soap skipped */
}

void ns7__ProcessingProcedure::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->ns7__ProcessingProcedure::startDateTime);
	soap_serialize_PointerTotime(soap, &this->ns7__ProcessingProcedure::endDateTime);
	/* transient soap skipped */
}

int ns7__ProcessingProcedure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ProcessingProcedure(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ProcessingProcedure(struct soap *soap, const char *tag, int id, const ns7__ProcessingProcedure *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ProcessingProcedure), type))
		return soap->error;
	if(soap_out_ns7__ProcessingProcedureType(soap, "ns7:type", -1, &(a->ns7__ProcessingProcedure::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:startDateTime", -1, &(a->ns7__ProcessingProcedure::startDateTime), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:endDateTime", -1, &(a->ns7__ProcessingProcedure::endDateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__ProcessingProcedure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ProcessingProcedure(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ProcessingProcedure * FASTCALL soap_in_ns7__ProcessingProcedure(struct soap *soap, const char *tag, ns7__ProcessingProcedure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ProcessingProcedure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ProcessingProcedure, sizeof(ns7__ProcessingProcedure), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ProcessingProcedure) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ProcessingProcedure *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_startDateTime1 = 1;
	size_t soap_flag_endDateTime1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns7__ProcessingProcedureType(soap, "ns7:type", &(a->ns7__ProcessingProcedure::type), "ns7:ProcessingProcedureType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_startDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:startDateTime", &(a->ns7__ProcessingProcedure::startDateTime), "xsd:dateTime"))
				{	soap_flag_startDateTime1--;
					continue;
				}
			if(soap_flag_endDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:endDateTime", &(a->ns7__ProcessingProcedure::endDateTime), "xsd:dateTime"))
				{	soap_flag_endDateTime1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ProcessingProcedure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ProcessingProcedure, 0, sizeof(ns7__ProcessingProcedure), 0, soap_copy_ns7__ProcessingProcedure);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__ProcessingProcedure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ProcessingProcedure);
	return this->soap_out(soap, tag?tag:"ns7:ProcessingProcedure", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ProcessingProcedure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ProcessingProcedure(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ProcessingProcedure * SOAP_FMAC4 soap_get_ns7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ProcessingProcedure * FASTCALL soap_instantiate_ns7__ProcessingProcedure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ProcessingProcedure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ProcessingProcedure, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ProcessingProcedure);
		ASSIGN_PTR(size, sizeof(ns7__ProcessingProcedure));
		((ns7__ProcessingProcedure*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ProcessingProcedure[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ProcessingProcedure));
		for(int i = 0; i < n; i++)
			((ns7__ProcessingProcedure*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ProcessingProcedure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ProcessingProcedure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ProcessingProcedure %p -> %p\n", q, p));
	*(ns7__ProcessingProcedure*)p = *(ns7__ProcessingProcedure*)q;
}

void ns7__RouteSectionR13nRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__RouteSectionR13nRules::sqnId = NULL;
	this->ns7__RouteSectionR13nRules::__sizeappliedR13nRule = 0;
	this->ns7__RouteSectionR13nRules::appliedR13nRule = NULL;
	/* transient soap skipped */
}

void ns7__RouteSectionR13nRules::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__SequenceNumber(soap, &this->ns7__RouteSectionR13nRules::sqnId);
	if(this->ns7__RouteSectionR13nRules::appliedR13nRule) {
		for(int i = 0; i < this->ns7__RouteSectionR13nRules::__sizeappliedR13nRule; i++) {
			soap_serialize_PointerTons6__RegionalizationShippingRule(soap, this->ns7__RouteSectionR13nRules::appliedR13nRule + i);
		}
	}
	/* transient soap skipped */
}

int ns7__RouteSectionR13nRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__RouteSectionR13nRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, const ns7__RouteSectionR13nRules *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__RouteSectionR13nRules), type))
		return soap->error;
	if(soap_out_PointerTons3__SequenceNumber(soap, "ns7:sqnId", -1, &(a->ns7__RouteSectionR13nRules::sqnId), ""))
		return soap->error;
	if(a->ns7__RouteSectionR13nRules::appliedR13nRule) {
		int i;
		for(i = 0; i < a->ns7__RouteSectionR13nRules::__sizeappliedR13nRule; i++)
			if(soap_out_PointerTons6__RegionalizationShippingRule(soap, "ns7:appliedR13nRule", -1, a->ns7__RouteSectionR13nRules::appliedR13nRule + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__RouteSectionR13nRules::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__RouteSectionR13nRules(soap, tag, this, type);
}

SOAP_FMAC3 ns7__RouteSectionR13nRules * FASTCALL soap_in_ns7__RouteSectionR13nRules(struct soap *soap, const char *tag, ns7__RouteSectionR13nRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__RouteSectionR13nRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__RouteSectionR13nRules, sizeof(ns7__RouteSectionR13nRules), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__RouteSectionR13nRules) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__RouteSectionR13nRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sqnId1 = 1;
	struct soap_blist *soap_blist_appliedR13nRule1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_sqnId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__SequenceNumber(soap, "ns7:sqnId", &(a->ns7__RouteSectionR13nRules::sqnId), "ns3:SequenceNumber"))
				{	soap_flag_sqnId1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:appliedR13nRule", 1, NULL)) {
				if(a->ns7__RouteSectionR13nRules::appliedR13nRule == NULL) {
					if(soap_blist_appliedR13nRule1 == NULL)
						soap_blist_appliedR13nRule1 = soap_new_block(soap);
					a->ns7__RouteSectionR13nRules::appliedR13nRule = (ns6__RegionalizationShippingRule **)soap_push_block(soap, soap_blist_appliedR13nRule1, sizeof(ns6__RegionalizationShippingRule *));
					if(a->ns7__RouteSectionR13nRules::appliedR13nRule == NULL)
						return NULL;
					*a->ns7__RouteSectionR13nRules::appliedR13nRule = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationShippingRule(soap, "ns7:appliedR13nRule", a->ns7__RouteSectionR13nRules::appliedR13nRule, "ns6:RegionalizationShippingRule"))
				{	a->ns7__RouteSectionR13nRules::__sizeappliedR13nRule++;
					a->ns7__RouteSectionR13nRules::appliedR13nRule = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__RouteSectionR13nRules::appliedR13nRule)
			soap_pop_block(soap, soap_blist_appliedR13nRule1);
		if(a->ns7__RouteSectionR13nRules::__sizeappliedR13nRule)
			a->ns7__RouteSectionR13nRules::appliedR13nRule = (ns6__RegionalizationShippingRule **)soap_save_block(soap, soap_blist_appliedR13nRule1, NULL, 1);
		else
		{	a->ns7__RouteSectionR13nRules::appliedR13nRule = NULL;
			if(soap_blist_appliedR13nRule1)
				soap_end_block(soap, soap_blist_appliedR13nRule1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__RouteSectionR13nRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__RouteSectionR13nRules, 0, sizeof(ns7__RouteSectionR13nRules), 0, soap_copy_ns7__RouteSectionR13nRules);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__RouteSectionR13nRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__RouteSectionR13nRules);
	return this->soap_out(soap, tag?tag:"ns7:RouteSectionR13nRules", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__RouteSectionR13nRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__RouteSectionR13nRules(soap, this, tag, type);
}

SOAP_FMAC3 ns7__RouteSectionR13nRules * SOAP_FMAC4 soap_get_ns7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__RouteSectionR13nRules * FASTCALL soap_instantiate_ns7__RouteSectionR13nRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__RouteSectionR13nRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__RouteSectionR13nRules, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__RouteSectionR13nRules);
		ASSIGN_PTR(size, sizeof(ns7__RouteSectionR13nRules));
		((ns7__RouteSectionR13nRules*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__RouteSectionR13nRules[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__RouteSectionR13nRules));
		for(int i = 0; i < n; i++)
			((ns7__RouteSectionR13nRules*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__RouteSectionR13nRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__RouteSectionR13nRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__RouteSectionR13nRules %p -> %p\n", q, p));
	*(ns7__RouteSectionR13nRules*)p = *(ns7__RouteSectionR13nRules*)q;
}

void ns7__RegionalizationClause::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__RegionalizationClause::condition = NULL;
	soap_default_ns3__Text(soap, &this->ns7__RegionalizationClause::text);
	/* transient soap skipped */
}

void ns7__RegionalizationClause::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__RegionalizationCondition(soap, &this->ns7__RegionalizationClause::condition);
	soap_serialize_ns3__Text(soap, &this->ns7__RegionalizationClause::text);
	/* transient soap skipped */
}

int ns7__RegionalizationClause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__RegionalizationClause(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__RegionalizationClause(struct soap *soap, const char *tag, int id, const ns7__RegionalizationClause *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__RegionalizationClause), type))
		return soap->error;
	if(a->ns7__RegionalizationClause::condition) {
		if(soap_out_PointerTons6__RegionalizationCondition(soap, "ns7:condition", -1, &a->ns7__RegionalizationClause::condition, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:condition"))
		return soap->error;
	if(soap_out_ns3__Text(soap, "ns7:text", -1, &(a->ns7__RegionalizationClause::text), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__RegionalizationClause::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__RegionalizationClause(soap, tag, this, type);
}

SOAP_FMAC3 ns7__RegionalizationClause * FASTCALL soap_in_ns7__RegionalizationClause(struct soap *soap, const char *tag, ns7__RegionalizationClause *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__RegionalizationClause *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__RegionalizationClause, sizeof(ns7__RegionalizationClause), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__RegionalizationClause) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__RegionalizationClause *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_text1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_condition1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationCondition(soap, "ns7:condition", &(a->ns7__RegionalizationClause::condition), "ns6:RegionalizationCondition"))
				{	soap_flag_condition1--;
					continue;
				}
			if(soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:text", &(a->ns7__RegionalizationClause::text), "ns3:Text"))
				{	soap_flag_text1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__RegionalizationClause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__RegionalizationClause, 0, sizeof(ns7__RegionalizationClause), 0, soap_copy_ns7__RegionalizationClause);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_condition1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__RegionalizationClause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__RegionalizationClause);
	return this->soap_out(soap, tag?tag:"ns7:RegionalizationClause", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__RegionalizationClause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__RegionalizationClause(soap, this, tag, type);
}

SOAP_FMAC3 ns7__RegionalizationClause * SOAP_FMAC4 soap_get_ns7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__RegionalizationClause * FASTCALL soap_instantiate_ns7__RegionalizationClause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__RegionalizationClause(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__RegionalizationClause, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__RegionalizationClause);
		ASSIGN_PTR(size, sizeof(ns7__RegionalizationClause));
		((ns7__RegionalizationClause*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__RegionalizationClause[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__RegionalizationClause));
		for(int i = 0; i < n; i++)
			((ns7__RegionalizationClause*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__RegionalizationClause*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__RegionalizationClause(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__RegionalizationClause %p -> %p\n", q, p));
	*(ns7__RegionalizationClause*)p = *(ns7__RegionalizationClause*)q;
}

void ns7__VetDocumentStatusChange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns7__VetDocumentStatus(soap, &this->ns7__VetDocumentStatusChange::status);
	this->ns7__VetDocumentStatusChange::specifiedPerson = NULL;
	soap_default_time(soap, &this->ns7__VetDocumentStatusChange::actualDateTime);
	soap_default_ns7__VetDocumentStatusChangeReason(soap, &this->ns7__VetDocumentStatusChange::reason);
	/* transient soap skipped */
}

void ns7__VetDocumentStatusChange::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->ns7__VetDocumentStatusChange::status, SOAP_TYPE_ns7__VetDocumentStatus);
	soap_serialize_PointerTons7__User(soap, &this->ns7__VetDocumentStatusChange::specifiedPerson);
	soap_embedded(soap, &this->ns7__VetDocumentStatusChange::actualDateTime, SOAP_TYPE_time);
	soap_serialize_ns7__VetDocumentStatusChangeReason(soap, &this->ns7__VetDocumentStatusChange::reason);
	/* transient soap skipped */
}

int ns7__VetDocumentStatusChange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__VetDocumentStatusChange(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, const ns7__VetDocumentStatusChange *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VetDocumentStatusChange), type))
		return soap->error;
	if(soap_out_ns7__VetDocumentStatus(soap, "ns7:status", -1, &(a->ns7__VetDocumentStatusChange::status), ""))
		return soap->error;
	if(a->ns7__VetDocumentStatusChange::specifiedPerson) {
		if(soap_out_PointerTons7__User(soap, "ns7:specifiedPerson", -1, &a->ns7__VetDocumentStatusChange::specifiedPerson, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:specifiedPerson"))
		return soap->error;
	if(soap_out_time(soap, "ns7:actualDateTime", -1, &(a->ns7__VetDocumentStatusChange::actualDateTime), ""))
		return soap->error;
	if(soap_out_ns7__VetDocumentStatusChangeReason(soap, "ns7:reason", -1, &(a->ns7__VetDocumentStatusChange::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__VetDocumentStatusChange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__VetDocumentStatusChange(soap, tag, this, type);
}

SOAP_FMAC3 ns7__VetDocumentStatusChange * FASTCALL soap_in_ns7__VetDocumentStatusChange(struct soap *soap, const char *tag, ns7__VetDocumentStatusChange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__VetDocumentStatusChange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VetDocumentStatusChange, sizeof(ns7__VetDocumentStatusChange), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__VetDocumentStatusChange) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__VetDocumentStatusChange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_specifiedPerson1 = 1;
	size_t soap_flag_actualDateTime1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns7__VetDocumentStatus(soap, "ns7:status", &(a->ns7__VetDocumentStatusChange::status), "ns7:VetDocumentStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_specifiedPerson1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns7:specifiedPerson", &(a->ns7__VetDocumentStatusChange::specifiedPerson), "ns7:User"))
				{	soap_flag_specifiedPerson1--;
					continue;
				}
			if(soap_flag_actualDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "ns7:actualDateTime", &(a->ns7__VetDocumentStatusChange::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns7__VetDocumentStatusChangeReason(soap, "ns7:reason", &(a->ns7__VetDocumentStatusChange::reason), "ns7:VetDocumentStatusChangeReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__VetDocumentStatusChange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VetDocumentStatusChange, 0, sizeof(ns7__VetDocumentStatusChange), 0, soap_copy_ns7__VetDocumentStatusChange);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0 || soap_flag_specifiedPerson1 > 0 || soap_flag_actualDateTime1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__VetDocumentStatusChange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__VetDocumentStatusChange);
	return this->soap_out(soap, tag?tag:"ns7:VetDocumentStatusChange", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__VetDocumentStatusChange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__VetDocumentStatusChange(soap, this, tag, type);
}

SOAP_FMAC3 ns7__VetDocumentStatusChange * SOAP_FMAC4 soap_get_ns7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__VetDocumentStatusChange * FASTCALL soap_instantiate_ns7__VetDocumentStatusChange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__VetDocumentStatusChange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__VetDocumentStatusChange, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__VetDocumentStatusChange);
		ASSIGN_PTR(size, sizeof(ns7__VetDocumentStatusChange));
		((ns7__VetDocumentStatusChange*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__VetDocumentStatusChange[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__VetDocumentStatusChange));
		for(int i = 0; i < n; i++)
			((ns7__VetDocumentStatusChange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__VetDocumentStatusChange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__VetDocumentStatusChange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__VetDocumentStatusChange %p -> %p\n", q, p));
	*(ns7__VetDocumentStatusChange*)p = *(ns7__VetDocumentStatusChange*)q;
}

void ns7__StockEntryEventList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__StockEntryEventList::__sizelaboratoryResearch = 0;
	this->ns7__StockEntryEventList::laboratoryResearch = NULL;
	this->ns7__StockEntryEventList::__sizequarantine = 0;
	this->ns7__StockEntryEventList::quarantine = NULL;
	this->ns7__StockEntryEventList::__sizeimmunization = 0;
	this->ns7__StockEntryEventList::immunization = NULL;
	this->ns7__StockEntryEventList::__sizeveterinaryEvent = 0;
	this->ns7__StockEntryEventList::veterinaryEvent = NULL;
	/* transient soap skipped */
}

void ns7__StockEntryEventList::soap_serialize(struct soap *soap) const
{
	if(this->ns7__StockEntryEventList::laboratoryResearch) {
		for(int i = 0; i < this->ns7__StockEntryEventList::__sizelaboratoryResearch; i++) {
			soap_serialize_PointerTons7__LaboratoryResearchEvent(soap, this->ns7__StockEntryEventList::laboratoryResearch + i);
		}
	}
	if(this->ns7__StockEntryEventList::quarantine) {
		for(int i = 0; i < this->ns7__StockEntryEventList::__sizequarantine; i++) {
			soap_serialize_PointerTons7__QuarantineEvent(soap, this->ns7__StockEntryEventList::quarantine + i);
		}
	}
	if(this->ns7__StockEntryEventList::immunization) {
		for(int i = 0; i < this->ns7__StockEntryEventList::__sizeimmunization; i++) {
			soap_serialize_PointerTons7__AnimalMedicationEvent(soap, this->ns7__StockEntryEventList::immunization + i);
		}
	}
	if(this->ns7__StockEntryEventList::veterinaryEvent) {
		for(int i = 0; i < this->ns7__StockEntryEventList::__sizeveterinaryEvent; i++) {
			soap_serialize_PointerTons7__VeterinaryEvent(soap, this->ns7__StockEntryEventList::veterinaryEvent + i);
		}
	}
	/* transient soap skipped */
}

int ns7__StockEntryEventList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__StockEntryEventList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockEntryEventList(struct soap *soap, const char *tag, int id, const ns7__StockEntryEventList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__StockEntryEventList), type))
		return soap->error;
	if(a->ns7__StockEntryEventList::laboratoryResearch) {
		int i;
		for(i = 0; i < a->ns7__StockEntryEventList::__sizelaboratoryResearch; i++)
			if(soap_out_PointerTons7__LaboratoryResearchEvent(soap, "ns7:laboratoryResearch", -1, a->ns7__StockEntryEventList::laboratoryResearch + i, ""))
				return soap->error;
	}
	if(a->ns7__StockEntryEventList::quarantine) {
		int i;
		for(i = 0; i < a->ns7__StockEntryEventList::__sizequarantine; i++)
			if(soap_out_PointerTons7__QuarantineEvent(soap, "ns7:quarantine", -1, a->ns7__StockEntryEventList::quarantine + i, ""))
				return soap->error;
	}
	if(a->ns7__StockEntryEventList::immunization) {
		int i;
		for(i = 0; i < a->ns7__StockEntryEventList::__sizeimmunization; i++)
			if(soap_out_PointerTons7__AnimalMedicationEvent(soap, "ns7:immunization", -1, a->ns7__StockEntryEventList::immunization + i, ""))
				return soap->error;
	}
	if(a->ns7__StockEntryEventList::veterinaryEvent) {
		int i;
		for(i = 0; i < a->ns7__StockEntryEventList::__sizeveterinaryEvent; i++)
			if(soap_out_PointerTons7__VeterinaryEvent(soap, "ns7:veterinaryEvent", -1, a->ns7__StockEntryEventList::veterinaryEvent + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__StockEntryEventList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__StockEntryEventList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__StockEntryEventList * FASTCALL soap_in_ns7__StockEntryEventList(struct soap *soap, const char *tag, ns7__StockEntryEventList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__StockEntryEventList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__StockEntryEventList, sizeof(ns7__StockEntryEventList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__StockEntryEventList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__StockEntryEventList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_laboratoryResearch1 = NULL;
	struct soap_blist *soap_blist_quarantine1 = NULL;
	struct soap_blist *soap_blist_immunization1 = NULL;
	struct soap_blist *soap_blist_veterinaryEvent1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:laboratoryResearch", 1, NULL)) {
				if(a->ns7__StockEntryEventList::laboratoryResearch == NULL) {
					if(soap_blist_laboratoryResearch1 == NULL)
						soap_blist_laboratoryResearch1 = soap_new_block(soap);
					a->ns7__StockEntryEventList::laboratoryResearch = (ns7__LaboratoryResearchEvent **)soap_push_block(soap, soap_blist_laboratoryResearch1, sizeof(ns7__LaboratoryResearchEvent *));
					if(a->ns7__StockEntryEventList::laboratoryResearch == NULL)
						return NULL;
					*a->ns7__StockEntryEventList::laboratoryResearch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__LaboratoryResearchEvent(soap, "ns7:laboratoryResearch", a->ns7__StockEntryEventList::laboratoryResearch, "ns7:LaboratoryResearchEvent"))
				{	a->ns7__StockEntryEventList::__sizelaboratoryResearch++;
					a->ns7__StockEntryEventList::laboratoryResearch = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:quarantine", 1, NULL)) {
				if(a->ns7__StockEntryEventList::quarantine == NULL) {
					if(soap_blist_quarantine1 == NULL)
						soap_blist_quarantine1 = soap_new_block(soap);
					a->ns7__StockEntryEventList::quarantine = (ns7__QuarantineEvent **)soap_push_block(soap, soap_blist_quarantine1, sizeof(ns7__QuarantineEvent *));
					if(a->ns7__StockEntryEventList::quarantine == NULL)
						return NULL;
					*a->ns7__StockEntryEventList::quarantine = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__QuarantineEvent(soap, "ns7:quarantine", a->ns7__StockEntryEventList::quarantine, "ns7:QuarantineEvent"))
				{	a->ns7__StockEntryEventList::__sizequarantine++;
					a->ns7__StockEntryEventList::quarantine = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:immunization", 1, NULL)) {
				if(a->ns7__StockEntryEventList::immunization == NULL) {
					if(soap_blist_immunization1 == NULL)
						soap_blist_immunization1 = soap_new_block(soap);
					a->ns7__StockEntryEventList::immunization = (ns7__AnimalMedicationEvent **)soap_push_block(soap, soap_blist_immunization1, sizeof(ns7__AnimalMedicationEvent *));
					if(a->ns7__StockEntryEventList::immunization == NULL)
						return NULL;
					*a->ns7__StockEntryEventList::immunization = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__AnimalMedicationEvent(soap, "ns7:immunization", a->ns7__StockEntryEventList::immunization, "ns7:AnimalMedicationEvent"))
				{	a->ns7__StockEntryEventList::__sizeimmunization++;
					a->ns7__StockEntryEventList::immunization = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:veterinaryEvent", 1, NULL)) {
				if(a->ns7__StockEntryEventList::veterinaryEvent == NULL) {
					if(soap_blist_veterinaryEvent1 == NULL)
						soap_blist_veterinaryEvent1 = soap_new_block(soap);
					a->ns7__StockEntryEventList::veterinaryEvent = (ns7__VeterinaryEvent **)soap_push_block(soap, soap_blist_veterinaryEvent1, sizeof(ns7__VeterinaryEvent *));
					if(a->ns7__StockEntryEventList::veterinaryEvent == NULL)
						return NULL;
					*a->ns7__StockEntryEventList::veterinaryEvent = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VeterinaryEvent(soap, "ns7:veterinaryEvent", a->ns7__StockEntryEventList::veterinaryEvent, "ns7:VeterinaryEvent"))
				{	a->ns7__StockEntryEventList::__sizeveterinaryEvent++;
					a->ns7__StockEntryEventList::veterinaryEvent = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__StockEntryEventList::laboratoryResearch)
			soap_pop_block(soap, soap_blist_laboratoryResearch1);
		if(a->ns7__StockEntryEventList::__sizelaboratoryResearch)
			a->ns7__StockEntryEventList::laboratoryResearch = (ns7__LaboratoryResearchEvent **)soap_save_block(soap, soap_blist_laboratoryResearch1, NULL, 1);
		else
		{	a->ns7__StockEntryEventList::laboratoryResearch = NULL;
			if(soap_blist_laboratoryResearch1)
				soap_end_block(soap, soap_blist_laboratoryResearch1);
		}
		if(a->ns7__StockEntryEventList::quarantine)
			soap_pop_block(soap, soap_blist_quarantine1);
		if(a->ns7__StockEntryEventList::__sizequarantine)
			a->ns7__StockEntryEventList::quarantine = (ns7__QuarantineEvent **)soap_save_block(soap, soap_blist_quarantine1, NULL, 1);
		else
		{	a->ns7__StockEntryEventList::quarantine = NULL;
			if(soap_blist_quarantine1)
				soap_end_block(soap, soap_blist_quarantine1);
		}
		if(a->ns7__StockEntryEventList::immunization)
			soap_pop_block(soap, soap_blist_immunization1);
		if(a->ns7__StockEntryEventList::__sizeimmunization)
			a->ns7__StockEntryEventList::immunization = (ns7__AnimalMedicationEvent **)soap_save_block(soap, soap_blist_immunization1, NULL, 1);
		else
		{	a->ns7__StockEntryEventList::immunization = NULL;
			if(soap_blist_immunization1)
				soap_end_block(soap, soap_blist_immunization1);
		}
		if(a->ns7__StockEntryEventList::veterinaryEvent)
			soap_pop_block(soap, soap_blist_veterinaryEvent1);
		if(a->ns7__StockEntryEventList::__sizeveterinaryEvent)
			a->ns7__StockEntryEventList::veterinaryEvent = (ns7__VeterinaryEvent **)soap_save_block(soap, soap_blist_veterinaryEvent1, NULL, 1);
		else
		{	a->ns7__StockEntryEventList::veterinaryEvent = NULL;
			if(soap_blist_veterinaryEvent1)
				soap_end_block(soap, soap_blist_veterinaryEvent1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__StockEntryEventList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__StockEntryEventList, 0, sizeof(ns7__StockEntryEventList), 0, soap_copy_ns7__StockEntryEventList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__StockEntryEventList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__StockEntryEventList);
	return this->soap_out(soap, tag?tag:"ns7:StockEntryEventList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__StockEntryEventList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__StockEntryEventList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__StockEntryEventList * SOAP_FMAC4 soap_get_ns7__StockEntryEventList(struct soap *soap, ns7__StockEntryEventList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockEntryEventList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__StockEntryEventList * FASTCALL soap_instantiate_ns7__StockEntryEventList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__StockEntryEventList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__StockEntryEventList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntryEventList);
		ASSIGN_PTR(size, sizeof(ns7__StockEntryEventList));
		((ns7__StockEntryEventList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntryEventList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__StockEntryEventList));
		for(int i = 0; i < n; i++)
			((ns7__StockEntryEventList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__StockEntryEventList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__StockEntryEventList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__StockEntryEventList %p -> %p\n", q, p));
	*(ns7__StockEntryEventList*)p = *(ns7__StockEntryEventList*)q;
}

void ns7__BatchOrigin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__BatchOrigin::productItem = NULL;
	this->ns7__BatchOrigin::country = NULL;
	this->ns7__BatchOrigin::__sizeproducer = 0;
	this->ns7__BatchOrigin::producer = NULL;
	/* transient soap skipped */
}

void ns7__BatchOrigin::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductItem(soap, &this->ns7__BatchOrigin::productItem);
	soap_serialize_PointerTons6__Country(soap, &this->ns7__BatchOrigin::country);
	if(this->ns7__BatchOrigin::producer) {
		for(int i = 0; i < this->ns7__BatchOrigin::__sizeproducer; i++) {
			soap_serialize_PointerTons6__Producer(soap, this->ns7__BatchOrigin::producer + i);
		}
	}
	/* transient soap skipped */
}

int ns7__BatchOrigin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__BatchOrigin(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__BatchOrigin(struct soap *soap, const char *tag, int id, const ns7__BatchOrigin *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__BatchOrigin), type))
		return soap->error;
	if(soap_out_PointerTons6__ProductItem(soap, "ns7:productItem", -1, &(a->ns7__BatchOrigin::productItem), ""))
		return soap->error;
	if(soap_out_PointerTons6__Country(soap, "ns7:country", -1, &(a->ns7__BatchOrigin::country), ""))
		return soap->error;
	if(a->ns7__BatchOrigin::producer) {
		int i;
		for(i = 0; i < a->ns7__BatchOrigin::__sizeproducer; i++)
			if(soap_out_PointerTons6__Producer(soap, "ns7:producer", -1, a->ns7__BatchOrigin::producer + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__BatchOrigin::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__BatchOrigin(soap, tag, this, type);
}

SOAP_FMAC3 ns7__BatchOrigin * FASTCALL soap_in_ns7__BatchOrigin(struct soap *soap, const char *tag, ns7__BatchOrigin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__BatchOrigin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__BatchOrigin, sizeof(ns7__BatchOrigin), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__BatchOrigin) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__BatchOrigin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productItem1 = 1;
	size_t soap_flag_country1 = 1;
	struct soap_blist *soap_blist_producer1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItem(soap, "ns7:productItem", &(a->ns7__BatchOrigin::productItem), "ns6:ProductItem"))
				{	soap_flag_productItem1--;
					continue;
				}
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Country(soap, "ns7:country", &(a->ns7__BatchOrigin::country), "ns6:Country"))
				{	soap_flag_country1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:producer", 1, NULL)) {
				if(a->ns7__BatchOrigin::producer == NULL) {
					if(soap_blist_producer1 == NULL)
						soap_blist_producer1 = soap_new_block(soap);
					a->ns7__BatchOrigin::producer = (ns6__Producer **)soap_push_block(soap, soap_blist_producer1, sizeof(ns6__Producer *));
					if(a->ns7__BatchOrigin::producer == NULL)
						return NULL;
					*a->ns7__BatchOrigin::producer = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Producer(soap, "ns7:producer", a->ns7__BatchOrigin::producer, "ns6:Producer"))
				{	a->ns7__BatchOrigin::__sizeproducer++;
					a->ns7__BatchOrigin::producer = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__BatchOrigin::producer)
			soap_pop_block(soap, soap_blist_producer1);
		if(a->ns7__BatchOrigin::__sizeproducer)
			a->ns7__BatchOrigin::producer = (ns6__Producer **)soap_save_block(soap, soap_blist_producer1, NULL, 1);
		else
		{	a->ns7__BatchOrigin::producer = NULL;
			if(soap_blist_producer1)
				soap_end_block(soap, soap_blist_producer1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__BatchOrigin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__BatchOrigin, 0, sizeof(ns7__BatchOrigin), 0, soap_copy_ns7__BatchOrigin);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__BatchOrigin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__BatchOrigin);
	return this->soap_out(soap, tag?tag:"ns7:BatchOrigin", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__BatchOrigin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__BatchOrigin(soap, this, tag, type);
}

SOAP_FMAC3 ns7__BatchOrigin * SOAP_FMAC4 soap_get_ns7__BatchOrigin(struct soap *soap, ns7__BatchOrigin *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__BatchOrigin(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__BatchOrigin * FASTCALL soap_instantiate_ns7__BatchOrigin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__BatchOrigin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__BatchOrigin, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__BatchOrigin);
		ASSIGN_PTR(size, sizeof(ns7__BatchOrigin));
		((ns7__BatchOrigin*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__BatchOrigin[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__BatchOrigin));
		for(int i = 0; i < n; i++)
			((ns7__BatchOrigin*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__BatchOrigin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__BatchOrigin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__BatchOrigin %p -> %p\n", q, p));
	*(ns7__BatchOrigin*)p = *(ns7__BatchOrigin*)q;
}

void ns7__VeterinaryAuthentication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__VeterinaryAuthentication::purpose = NULL;
	this->ns7__VeterinaryAuthentication::cargoInspected = NULL;
	this->ns7__VeterinaryAuthentication::cargoExpertized = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VeterinaryAuthentication::locationProsperity);
	this->ns7__VeterinaryAuthentication::animalSpentPeriod = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VeterinaryAuthentication::monthsSpent);
	this->ns7__VeterinaryAuthentication::__sizelaboratoryResearch = 0;
	this->ns7__VeterinaryAuthentication::laboratoryResearch = NULL;
	this->ns7__VeterinaryAuthentication::quarantine = NULL;
	this->ns7__VeterinaryAuthentication::__sizeimmunization = 0;
	this->ns7__VeterinaryAuthentication::immunization = NULL;
	this->ns7__VeterinaryAuthentication::__sizeveterinaryEvent = 0;
	this->ns7__VeterinaryAuthentication::veterinaryEvent = NULL;
	this->ns7__VeterinaryAuthentication::__sizer13nClause = 0;
	this->ns7__VeterinaryAuthentication::r13nClause = NULL;
	soap_default_ns3__Text(soap, &this->ns7__VeterinaryAuthentication::specialMarks);
	/* transient soap skipped */
}

void ns7__VeterinaryAuthentication::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Purpose(soap, &this->ns7__VeterinaryAuthentication::purpose);
	soap_serialize_PointerTobool(soap, &this->ns7__VeterinaryAuthentication::cargoInspected);
	soap_serialize_PointerTons6__ResearchResult(soap, &this->ns7__VeterinaryAuthentication::cargoExpertized);
	soap_serialize_ns3__String255(soap, &this->ns7__VeterinaryAuthentication::locationProsperity);
	soap_serialize_PointerTons7__AnimalSpentPeriod(soap, &this->ns7__VeterinaryAuthentication::animalSpentPeriod);
	soap_serialize_ns3__String255(soap, &this->ns7__VeterinaryAuthentication::monthsSpent);
	if(this->ns7__VeterinaryAuthentication::laboratoryResearch) {
		for(int i = 0; i < this->ns7__VeterinaryAuthentication::__sizelaboratoryResearch; i++) {
			soap_serialize_PointerTons7__LaboratoryResearchEvent(soap, this->ns7__VeterinaryAuthentication::laboratoryResearch + i);
		}
	}
	soap_serialize_PointerTons7__QuarantineEvent(soap, &this->ns7__VeterinaryAuthentication::quarantine);
	if(this->ns7__VeterinaryAuthentication::immunization) {
		for(int i = 0; i < this->ns7__VeterinaryAuthentication::__sizeimmunization; i++) {
			soap_serialize_PointerTons7__AnimalMedicationEvent(soap, this->ns7__VeterinaryAuthentication::immunization + i);
		}
	}
	if(this->ns7__VeterinaryAuthentication::veterinaryEvent) {
		for(int i = 0; i < this->ns7__VeterinaryAuthentication::__sizeveterinaryEvent; i++) {
			soap_serialize_PointerTons7__VeterinaryEvent(soap, this->ns7__VeterinaryAuthentication::veterinaryEvent + i);
		}
	}
	if(this->ns7__VeterinaryAuthentication::r13nClause) {
		for(int i = 0; i < this->ns7__VeterinaryAuthentication::__sizer13nClause; i++) {
			soap_serialize_PointerTons7__RegionalizationClause(soap, this->ns7__VeterinaryAuthentication::r13nClause + i);
		}
	}
	soap_serialize_ns3__Text(soap, &this->ns7__VeterinaryAuthentication::specialMarks);
	/* transient soap skipped */
}

int ns7__VeterinaryAuthentication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__VeterinaryAuthentication(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VeterinaryAuthentication(struct soap *soap, const char *tag, int id, const ns7__VeterinaryAuthentication *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VeterinaryAuthentication), type))
		return soap->error;
	if(soap_out_PointerTons6__Purpose(soap, "ns7:purpose", -1, &(a->ns7__VeterinaryAuthentication::purpose), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:cargoInspected", -1, &(a->ns7__VeterinaryAuthentication::cargoInspected), ""))
		return soap->error;
	if(soap_out_PointerTons6__ResearchResult(soap, "ns7:cargoExpertized", -1, &(a->ns7__VeterinaryAuthentication::cargoExpertized), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:locationProsperity", -1, &(a->ns7__VeterinaryAuthentication::locationProsperity), ""))
		return soap->error;
	if(soap_out_PointerTons7__AnimalSpentPeriod(soap, "ns7:animalSpentPeriod", -1, &(a->ns7__VeterinaryAuthentication::animalSpentPeriod), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:monthsSpent", -1, &(a->ns7__VeterinaryAuthentication::monthsSpent), ""))
		return soap->error;
	if(a->ns7__VeterinaryAuthentication::laboratoryResearch) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryAuthentication::__sizelaboratoryResearch; i++)
			if(soap_out_PointerTons7__LaboratoryResearchEvent(soap, "ns7:laboratoryResearch", -1, a->ns7__VeterinaryAuthentication::laboratoryResearch + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons7__QuarantineEvent(soap, "ns7:quarantine", -1, &(a->ns7__VeterinaryAuthentication::quarantine), ""))
		return soap->error;
	if(a->ns7__VeterinaryAuthentication::immunization) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryAuthentication::__sizeimmunization; i++)
			if(soap_out_PointerTons7__AnimalMedicationEvent(soap, "ns7:immunization", -1, a->ns7__VeterinaryAuthentication::immunization + i, ""))
				return soap->error;
	}
	if(a->ns7__VeterinaryAuthentication::veterinaryEvent) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryAuthentication::__sizeveterinaryEvent; i++)
			if(soap_out_PointerTons7__VeterinaryEvent(soap, "ns7:veterinaryEvent", -1, a->ns7__VeterinaryAuthentication::veterinaryEvent + i, ""))
				return soap->error;
	}
	if(a->ns7__VeterinaryAuthentication::r13nClause) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryAuthentication::__sizer13nClause; i++)
			if(soap_out_PointerTons7__RegionalizationClause(soap, "ns7:r13nClause", -1, a->ns7__VeterinaryAuthentication::r13nClause + i, ""))
				return soap->error;
	}
	if(soap_out_ns3__Text(soap, "ns7:specialMarks", -1, &(a->ns7__VeterinaryAuthentication::specialMarks), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__VeterinaryAuthentication::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__VeterinaryAuthentication(soap, tag, this, type);
}

SOAP_FMAC3 ns7__VeterinaryAuthentication * FASTCALL soap_in_ns7__VeterinaryAuthentication(struct soap *soap, const char *tag, ns7__VeterinaryAuthentication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__VeterinaryAuthentication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VeterinaryAuthentication, sizeof(ns7__VeterinaryAuthentication), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__VeterinaryAuthentication) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__VeterinaryAuthentication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_purpose1 = 1;
	size_t soap_flag_cargoInspected1 = 1;
	size_t soap_flag_cargoExpertized1 = 1;
	size_t soap_flag_locationProsperity1 = 1;
	size_t soap_flag_animalSpentPeriod1 = 1;
	size_t soap_flag_monthsSpent1 = 1;
	struct soap_blist *soap_blist_laboratoryResearch1 = NULL;
	size_t soap_flag_quarantine1 = 1;
	struct soap_blist *soap_blist_immunization1 = NULL;
	struct soap_blist *soap_blist_veterinaryEvent1 = NULL;
	struct soap_blist *soap_blist_r13nClause1 = NULL;
	size_t soap_flag_specialMarks1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Purpose(soap, "ns7:purpose", &(a->ns7__VeterinaryAuthentication::purpose), "ns6:Purpose"))
				{	soap_flag_purpose1--;
					continue;
				}
			if(soap_flag_cargoInspected1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:cargoInspected", &(a->ns7__VeterinaryAuthentication::cargoInspected), "xsd:boolean"))
				{	soap_flag_cargoInspected1--;
					continue;
				}
			if(soap_flag_cargoExpertized1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchResult(soap, "ns7:cargoExpertized", &(a->ns7__VeterinaryAuthentication::cargoExpertized), "ns6:ResearchResult"))
				{	soap_flag_cargoExpertized1--;
					continue;
				}
			if(soap_flag_locationProsperity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:locationProsperity", &(a->ns7__VeterinaryAuthentication::locationProsperity), "ns3:String255"))
				{	soap_flag_locationProsperity1--;
					continue;
				}
			if(soap_flag_animalSpentPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__AnimalSpentPeriod(soap, "ns7:animalSpentPeriod", &(a->ns7__VeterinaryAuthentication::animalSpentPeriod), "ns7:AnimalSpentPeriod"))
				{	soap_flag_animalSpentPeriod1--;
					continue;
				}
			if(soap_flag_monthsSpent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:monthsSpent", &(a->ns7__VeterinaryAuthentication::monthsSpent), "ns3:String255"))
				{	soap_flag_monthsSpent1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:laboratoryResearch", 1, NULL)) {
				if(a->ns7__VeterinaryAuthentication::laboratoryResearch == NULL) {
					if(soap_blist_laboratoryResearch1 == NULL)
						soap_blist_laboratoryResearch1 = soap_new_block(soap);
					a->ns7__VeterinaryAuthentication::laboratoryResearch = (ns7__LaboratoryResearchEvent **)soap_push_block(soap, soap_blist_laboratoryResearch1, sizeof(ns7__LaboratoryResearchEvent *));
					if(a->ns7__VeterinaryAuthentication::laboratoryResearch == NULL)
						return NULL;
					*a->ns7__VeterinaryAuthentication::laboratoryResearch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__LaboratoryResearchEvent(soap, "ns7:laboratoryResearch", a->ns7__VeterinaryAuthentication::laboratoryResearch, "ns7:LaboratoryResearchEvent"))
				{	a->ns7__VeterinaryAuthentication::__sizelaboratoryResearch++;
					a->ns7__VeterinaryAuthentication::laboratoryResearch = NULL;
					continue;
				}
			}
			if(soap_flag_quarantine1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__QuarantineEvent(soap, "ns7:quarantine", &(a->ns7__VeterinaryAuthentication::quarantine), "ns7:QuarantineEvent"))
				{	soap_flag_quarantine1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:immunization", 1, NULL)) {
				if(a->ns7__VeterinaryAuthentication::immunization == NULL) {
					if(soap_blist_immunization1 == NULL)
						soap_blist_immunization1 = soap_new_block(soap);
					a->ns7__VeterinaryAuthentication::immunization = (ns7__AnimalMedicationEvent **)soap_push_block(soap, soap_blist_immunization1, sizeof(ns7__AnimalMedicationEvent *));
					if(a->ns7__VeterinaryAuthentication::immunization == NULL)
						return NULL;
					*a->ns7__VeterinaryAuthentication::immunization = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__AnimalMedicationEvent(soap, "ns7:immunization", a->ns7__VeterinaryAuthentication::immunization, "ns7:AnimalMedicationEvent"))
				{	a->ns7__VeterinaryAuthentication::__sizeimmunization++;
					a->ns7__VeterinaryAuthentication::immunization = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:veterinaryEvent", 1, NULL)) {
				if(a->ns7__VeterinaryAuthentication::veterinaryEvent == NULL) {
					if(soap_blist_veterinaryEvent1 == NULL)
						soap_blist_veterinaryEvent1 = soap_new_block(soap);
					a->ns7__VeterinaryAuthentication::veterinaryEvent = (ns7__VeterinaryEvent **)soap_push_block(soap, soap_blist_veterinaryEvent1, sizeof(ns7__VeterinaryEvent *));
					if(a->ns7__VeterinaryAuthentication::veterinaryEvent == NULL)
						return NULL;
					*a->ns7__VeterinaryAuthentication::veterinaryEvent = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VeterinaryEvent(soap, "ns7:veterinaryEvent", a->ns7__VeterinaryAuthentication::veterinaryEvent, "ns7:VeterinaryEvent"))
				{	a->ns7__VeterinaryAuthentication::__sizeveterinaryEvent++;
					a->ns7__VeterinaryAuthentication::veterinaryEvent = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:r13nClause", 1, NULL)) {
				if(a->ns7__VeterinaryAuthentication::r13nClause == NULL) {
					if(soap_blist_r13nClause1 == NULL)
						soap_blist_r13nClause1 = soap_new_block(soap);
					a->ns7__VeterinaryAuthentication::r13nClause = (ns7__RegionalizationClause **)soap_push_block(soap, soap_blist_r13nClause1, sizeof(ns7__RegionalizationClause *));
					if(a->ns7__VeterinaryAuthentication::r13nClause == NULL)
						return NULL;
					*a->ns7__VeterinaryAuthentication::r13nClause = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__RegionalizationClause(soap, "ns7:r13nClause", a->ns7__VeterinaryAuthentication::r13nClause, "ns7:RegionalizationClause"))
				{	a->ns7__VeterinaryAuthentication::__sizer13nClause++;
					a->ns7__VeterinaryAuthentication::r13nClause = NULL;
					continue;
				}
			}
			if(soap_flag_specialMarks1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:specialMarks", &(a->ns7__VeterinaryAuthentication::specialMarks), "ns3:Text"))
				{	soap_flag_specialMarks1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VeterinaryAuthentication::laboratoryResearch)
			soap_pop_block(soap, soap_blist_laboratoryResearch1);
		if(a->ns7__VeterinaryAuthentication::__sizelaboratoryResearch)
			a->ns7__VeterinaryAuthentication::laboratoryResearch = (ns7__LaboratoryResearchEvent **)soap_save_block(soap, soap_blist_laboratoryResearch1, NULL, 1);
		else
		{	a->ns7__VeterinaryAuthentication::laboratoryResearch = NULL;
			if(soap_blist_laboratoryResearch1)
				soap_end_block(soap, soap_blist_laboratoryResearch1);
		}
		if(a->ns7__VeterinaryAuthentication::immunization)
			soap_pop_block(soap, soap_blist_immunization1);
		if(a->ns7__VeterinaryAuthentication::__sizeimmunization)
			a->ns7__VeterinaryAuthentication::immunization = (ns7__AnimalMedicationEvent **)soap_save_block(soap, soap_blist_immunization1, NULL, 1);
		else
		{	a->ns7__VeterinaryAuthentication::immunization = NULL;
			if(soap_blist_immunization1)
				soap_end_block(soap, soap_blist_immunization1);
		}
		if(a->ns7__VeterinaryAuthentication::veterinaryEvent)
			soap_pop_block(soap, soap_blist_veterinaryEvent1);
		if(a->ns7__VeterinaryAuthentication::__sizeveterinaryEvent)
			a->ns7__VeterinaryAuthentication::veterinaryEvent = (ns7__VeterinaryEvent **)soap_save_block(soap, soap_blist_veterinaryEvent1, NULL, 1);
		else
		{	a->ns7__VeterinaryAuthentication::veterinaryEvent = NULL;
			if(soap_blist_veterinaryEvent1)
				soap_end_block(soap, soap_blist_veterinaryEvent1);
		}
		if(a->ns7__VeterinaryAuthentication::r13nClause)
			soap_pop_block(soap, soap_blist_r13nClause1);
		if(a->ns7__VeterinaryAuthentication::__sizer13nClause)
			a->ns7__VeterinaryAuthentication::r13nClause = (ns7__RegionalizationClause **)soap_save_block(soap, soap_blist_r13nClause1, NULL, 1);
		else
		{	a->ns7__VeterinaryAuthentication::r13nClause = NULL;
			if(soap_blist_r13nClause1)
				soap_end_block(soap, soap_blist_r13nClause1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__VeterinaryAuthentication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VeterinaryAuthentication, 0, sizeof(ns7__VeterinaryAuthentication), 0, soap_copy_ns7__VeterinaryAuthentication);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__VeterinaryAuthentication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__VeterinaryAuthentication);
	return this->soap_out(soap, tag?tag:"ns7:VeterinaryAuthentication", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__VeterinaryAuthentication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__VeterinaryAuthentication(soap, this, tag, type);
}

SOAP_FMAC3 ns7__VeterinaryAuthentication * SOAP_FMAC4 soap_get_ns7__VeterinaryAuthentication(struct soap *soap, ns7__VeterinaryAuthentication *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VeterinaryAuthentication(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__VeterinaryAuthentication * FASTCALL soap_instantiate_ns7__VeterinaryAuthentication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__VeterinaryAuthentication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__VeterinaryAuthentication, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__VeterinaryAuthentication);
		ASSIGN_PTR(size, sizeof(ns7__VeterinaryAuthentication));
		((ns7__VeterinaryAuthentication*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__VeterinaryAuthentication[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__VeterinaryAuthentication));
		for(int i = 0; i < n; i++)
			((ns7__VeterinaryAuthentication*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__VeterinaryAuthentication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__VeterinaryAuthentication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__VeterinaryAuthentication %p -> %p\n", q, p));
	*(ns7__VeterinaryAuthentication*)p = *(ns7__VeterinaryAuthentication*)q;
}

void ns7__QuarantineEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->ns7__QuarantineEvent::duration);
	this->ns7__VeterinaryEvent::ID = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	this->ns7__VeterinaryEvent::type = NULL;
	this->ns7__VeterinaryEvent::actualDateTime = NULL;
	this->ns7__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->ns7__VeterinaryEvent::operator_ = NULL;
	this->ns7__VeterinaryEvent::__sizereferencedDocument = 0;
	this->ns7__VeterinaryEvent::referencedDocument = NULL;
	soap_default_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void ns7__QuarantineEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__positiveInteger(soap, &this->ns7__QuarantineEvent::duration);
	soap_serialize_PointerTons3__Identifier(soap, &this->ns7__VeterinaryEvent::ID);
	soap_serialize_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	soap_serialize_PointerTons7__VeterinaryEventType(soap, &this->ns7__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->ns7__VeterinaryEvent::actualDateTime);
	soap_serialize__ns7__union_VeterinaryEvent(soap, this->ns7__VeterinaryEvent::__union_VeterinaryEvent, &this->ns7__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__VeterinaryEvent::operator_);
	if(this->ns7__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->ns7__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTons7__Document(soap, this->ns7__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int ns7__QuarantineEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__QuarantineEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__QuarantineEvent(struct soap *soap, const char *tag, int id, const ns7__QuarantineEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__QuarantineEvent), "ns7:QuarantineEvent"))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns7:ID", -1, &(a->ns7__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTons7__VeterinaryEventType(soap, "ns7:type", -1, &(a->ns7__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:actualDateTime", -1, &(a->ns7__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__ns7__union_VeterinaryEvent(soap, a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:operator", -1, &(a->ns7__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->ns7__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTons7__Document(soap, "ns7:referencedDocument", -1, a->ns7__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_ns3__Text(soap, "ns7:notes", -1, &(a->ns7__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_xsd__positiveInteger(soap, "ns7:duration", -1, &(a->ns7__QuarantineEvent::duration), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__QuarantineEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__QuarantineEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns7__QuarantineEvent * FASTCALL soap_in_ns7__QuarantineEvent(struct soap *soap, const char *tag, ns7__QuarantineEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__QuarantineEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__QuarantineEvent, sizeof(ns7__QuarantineEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__QuarantineEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__QuarantineEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	size_t soap_flag_duration1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns7:ID", &(a->ns7__VeterinaryEvent::ID), "ns3:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__VeterinaryEvent::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VeterinaryEventType(soap, "ns7:type", &(a->ns7__VeterinaryEvent::type), "ns7:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:actualDateTime", &(a->ns7__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_VeterinaryEvent(soap, &a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:operator", &(a->ns7__VeterinaryEvent::operator_), "ns6:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:referencedDocument", 1, NULL)) {
				if(a->ns7__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(ns7__Document *));
					if(a->ns7__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->ns7__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__Document(soap, "ns7:referencedDocument", a->ns7__VeterinaryEvent::referencedDocument, "ns7:Document"))
				{	a->ns7__VeterinaryEvent::__sizereferencedDocument++;
					a->ns7__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:notes", &(a->ns7__VeterinaryEvent::notes), "ns3:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_duration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__positiveInteger(soap, "ns7:duration", &(a->ns7__QuarantineEvent::duration), "xsd:positiveInteger"))
				{	soap_flag_duration1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->ns7__VeterinaryEvent::__sizereferencedDocument)
			a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->ns7__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__QuarantineEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__QuarantineEvent, 0, sizeof(ns7__QuarantineEvent), 0, soap_copy_ns7__QuarantineEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__QuarantineEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__QuarantineEvent);
	return this->soap_out(soap, tag?tag:"ns7:QuarantineEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__QuarantineEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__QuarantineEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns7__QuarantineEvent * SOAP_FMAC4 soap_get_ns7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__QuarantineEvent * FASTCALL soap_instantiate_ns7__QuarantineEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__QuarantineEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__QuarantineEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__QuarantineEvent);
		ASSIGN_PTR(size, sizeof(ns7__QuarantineEvent));
		((ns7__QuarantineEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__QuarantineEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__QuarantineEvent));
		for(int i = 0; i < n; i++)
			((ns7__QuarantineEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__QuarantineEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__QuarantineEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__QuarantineEvent %p -> %p\n", q, p));
	*(ns7__QuarantineEvent*)p = *(ns7__QuarantineEvent*)q;
}

void ns7__AnimalMedicationEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__AnimalMedicationEvent::disease = NULL;
	this->ns7__AnimalMedicationEvent::medicinalDrug = NULL;
	this->ns7__AnimalMedicationEvent::effectiveBeforeDate = NULL;
	this->ns7__VeterinaryEvent::ID = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	this->ns7__VeterinaryEvent::type = NULL;
	this->ns7__VeterinaryEvent::actualDateTime = NULL;
	this->ns7__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->ns7__VeterinaryEvent::operator_ = NULL;
	this->ns7__VeterinaryEvent::__sizereferencedDocument = 0;
	this->ns7__VeterinaryEvent::referencedDocument = NULL;
	soap_default_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void ns7__AnimalMedicationEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->ns7__AnimalMedicationEvent::disease);
	soap_serialize_PointerTons6__MedicinalDrug(soap, &this->ns7__AnimalMedicationEvent::medicinalDrug);
	soap_serialize_PointerTotime(soap, &this->ns7__AnimalMedicationEvent::effectiveBeforeDate);
	soap_serialize_PointerTons3__Identifier(soap, &this->ns7__VeterinaryEvent::ID);
	soap_serialize_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	soap_serialize_PointerTons7__VeterinaryEventType(soap, &this->ns7__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->ns7__VeterinaryEvent::actualDateTime);
	soap_serialize__ns7__union_VeterinaryEvent(soap, this->ns7__VeterinaryEvent::__union_VeterinaryEvent, &this->ns7__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__VeterinaryEvent::operator_);
	if(this->ns7__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->ns7__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTons7__Document(soap, this->ns7__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int ns7__AnimalMedicationEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__AnimalMedicationEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, const ns7__AnimalMedicationEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__AnimalMedicationEvent), "ns7:AnimalMedicationEvent"))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns7:ID", -1, &(a->ns7__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTons7__VeterinaryEventType(soap, "ns7:type", -1, &(a->ns7__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:actualDateTime", -1, &(a->ns7__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__ns7__union_VeterinaryEvent(soap, a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:operator", -1, &(a->ns7__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->ns7__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTons7__Document(soap, "ns7:referencedDocument", -1, a->ns7__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_ns3__Text(soap, "ns7:notes", -1, &(a->ns7__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTons6__AnimalDisease(soap, "ns7:disease", -1, &(a->ns7__AnimalMedicationEvent::disease), ""))
		return soap->error;
	if(soap_out_PointerTons6__MedicinalDrug(soap, "ns7:medicinalDrug", -1, &(a->ns7__AnimalMedicationEvent::medicinalDrug), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:effectiveBeforeDate", -1, &(a->ns7__AnimalMedicationEvent::effectiveBeforeDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__AnimalMedicationEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__AnimalMedicationEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns7__AnimalMedicationEvent * FASTCALL soap_in_ns7__AnimalMedicationEvent(struct soap *soap, const char *tag, ns7__AnimalMedicationEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__AnimalMedicationEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__AnimalMedicationEvent, sizeof(ns7__AnimalMedicationEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__AnimalMedicationEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__AnimalMedicationEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	size_t soap_flag_disease1 = 1;
	size_t soap_flag_medicinalDrug1 = 1;
	size_t soap_flag_effectiveBeforeDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns7:ID", &(a->ns7__VeterinaryEvent::ID), "ns3:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__VeterinaryEvent::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VeterinaryEventType(soap, "ns7:type", &(a->ns7__VeterinaryEvent::type), "ns7:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:actualDateTime", &(a->ns7__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_VeterinaryEvent(soap, &a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:operator", &(a->ns7__VeterinaryEvent::operator_), "ns6:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:referencedDocument", 1, NULL)) {
				if(a->ns7__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(ns7__Document *));
					if(a->ns7__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->ns7__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__Document(soap, "ns7:referencedDocument", a->ns7__VeterinaryEvent::referencedDocument, "ns7:Document"))
				{	a->ns7__VeterinaryEvent::__sizereferencedDocument++;
					a->ns7__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:notes", &(a->ns7__VeterinaryEvent::notes), "ns3:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns7:disease", &(a->ns7__AnimalMedicationEvent::disease), "ns6:AnimalDisease"))
				{	soap_flag_disease1--;
					continue;
				}
			if(soap_flag_medicinalDrug1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__MedicinalDrug(soap, "ns7:medicinalDrug", &(a->ns7__AnimalMedicationEvent::medicinalDrug), "ns6:MedicinalDrug"))
				{	soap_flag_medicinalDrug1--;
					continue;
				}
			if(soap_flag_effectiveBeforeDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:effectiveBeforeDate", &(a->ns7__AnimalMedicationEvent::effectiveBeforeDate), "xsd:dateTime"))
				{	soap_flag_effectiveBeforeDate1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->ns7__VeterinaryEvent::__sizereferencedDocument)
			a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->ns7__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__AnimalMedicationEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__AnimalMedicationEvent, 0, sizeof(ns7__AnimalMedicationEvent), 0, soap_copy_ns7__AnimalMedicationEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__AnimalMedicationEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__AnimalMedicationEvent);
	return this->soap_out(soap, tag?tag:"ns7:AnimalMedicationEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__AnimalMedicationEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__AnimalMedicationEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns7__AnimalMedicationEvent * SOAP_FMAC4 soap_get_ns7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__AnimalMedicationEvent * FASTCALL soap_instantiate_ns7__AnimalMedicationEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__AnimalMedicationEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__AnimalMedicationEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__AnimalMedicationEvent);
		ASSIGN_PTR(size, sizeof(ns7__AnimalMedicationEvent));
		((ns7__AnimalMedicationEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__AnimalMedicationEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__AnimalMedicationEvent));
		for(int i = 0; i < n; i++)
			((ns7__AnimalMedicationEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__AnimalMedicationEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__AnimalMedicationEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__AnimalMedicationEvent %p -> %p\n", q, p));
	*(ns7__AnimalMedicationEvent*)p = *(ns7__AnimalMedicationEvent*)q;
}

void ns7__LaboratoryResearchEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__LaboratoryResearchEvent::__sizebatchID = 0;
	this->ns7__LaboratoryResearchEvent::batchID = NULL;
	soap_default_ns3__String255(soap, &this->ns7__LaboratoryResearchEvent::expertiseID);
	this->ns7__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_ = 0;
	this->ns7__LaboratoryResearchEvent::method = NULL;
	this->ns7__LaboratoryResearchEvent::result = NULL;
	soap_default_ns3__Text(soap, &this->ns7__LaboratoryResearchEvent::conclusion);
	this->ns7__VeterinaryEvent::ID = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	this->ns7__VeterinaryEvent::type = NULL;
	this->ns7__VeterinaryEvent::actualDateTime = NULL;
	this->ns7__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->ns7__VeterinaryEvent::operator_ = NULL;
	this->ns7__VeterinaryEvent::__sizereferencedDocument = 0;
	this->ns7__VeterinaryEvent::referencedDocument = NULL;
	soap_default_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void ns7__LaboratoryResearchEvent::soap_serialize(struct soap *soap) const
{
	if(this->ns7__LaboratoryResearchEvent::batchID) {
		for(int i = 0; i < this->ns7__LaboratoryResearchEvent::__sizebatchID; i++) {
			soap_serialize_ns3__Identifier(soap, this->ns7__LaboratoryResearchEvent::batchID + i);
		}
	}
	soap_serialize_ns3__String255(soap, &this->ns7__LaboratoryResearchEvent::expertiseID);
	soap_serialize__ns7__union_LaboratoryResearchEvent_(soap, this->ns7__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &this->ns7__LaboratoryResearchEvent::union_LaboratoryResearchEvent_);
	soap_serialize_PointerTons6__ResearchMethod(soap, &this->ns7__LaboratoryResearchEvent::method);
	soap_serialize_PointerTons6__ResearchResult(soap, &this->ns7__LaboratoryResearchEvent::result);
	soap_serialize_ns3__Text(soap, &this->ns7__LaboratoryResearchEvent::conclusion);
	soap_serialize_PointerTons3__Identifier(soap, &this->ns7__VeterinaryEvent::ID);
	soap_serialize_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	soap_serialize_PointerTons7__VeterinaryEventType(soap, &this->ns7__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->ns7__VeterinaryEvent::actualDateTime);
	soap_serialize__ns7__union_VeterinaryEvent(soap, this->ns7__VeterinaryEvent::__union_VeterinaryEvent, &this->ns7__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__VeterinaryEvent::operator_);
	if(this->ns7__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->ns7__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTons7__Document(soap, this->ns7__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int ns7__LaboratoryResearchEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__LaboratoryResearchEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, const ns7__LaboratoryResearchEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__LaboratoryResearchEvent), "ns7:LaboratoryResearchEvent"))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns7:ID", -1, &(a->ns7__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTons7__VeterinaryEventType(soap, "ns7:type", -1, &(a->ns7__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:actualDateTime", -1, &(a->ns7__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__ns7__union_VeterinaryEvent(soap, a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:operator", -1, &(a->ns7__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->ns7__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTons7__Document(soap, "ns7:referencedDocument", -1, a->ns7__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_ns3__Text(soap, "ns7:notes", -1, &(a->ns7__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__LaboratoryResearchEvent::batchID) {
		int i;
		for(i = 0; i < a->ns7__LaboratoryResearchEvent::__sizebatchID; i++)
			if(soap_out_ns3__Identifier(soap, "ns7:batchID", -1, a->ns7__LaboratoryResearchEvent::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_ns3__String255(soap, "ns7:expertiseID", -1, &(a->ns7__LaboratoryResearchEvent::expertiseID), ""))
		return soap->error;
	if(soap_out__ns7__union_LaboratoryResearchEvent_(soap, a->ns7__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &a->ns7__LaboratoryResearchEvent::union_LaboratoryResearchEvent_))
		return soap->error;
	if(soap_out_PointerTons6__ResearchMethod(soap, "ns7:method", -1, &(a->ns7__LaboratoryResearchEvent::method), ""))
		return soap->error;
	if(soap_out_PointerTons6__ResearchResult(soap, "ns7:result", -1, &(a->ns7__LaboratoryResearchEvent::result), ""))
		return soap->error;
	if(soap_out_ns3__Text(soap, "ns7:conclusion", -1, &(a->ns7__LaboratoryResearchEvent::conclusion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__LaboratoryResearchEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__LaboratoryResearchEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns7__LaboratoryResearchEvent * FASTCALL soap_in_ns7__LaboratoryResearchEvent(struct soap *soap, const char *tag, ns7__LaboratoryResearchEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__LaboratoryResearchEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__LaboratoryResearchEvent, sizeof(ns7__LaboratoryResearchEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__LaboratoryResearchEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__LaboratoryResearchEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	struct soap_blist *soap_blist_batchID1 = NULL;
	size_t soap_flag_expertiseID1 = 1;
	size_t soap_flag_union_LaboratoryResearchEvent_1 = 1;
	size_t soap_flag_method1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_conclusion1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns7:ID", &(a->ns7__VeterinaryEvent::ID), "ns3:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__VeterinaryEvent::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VeterinaryEventType(soap, "ns7:type", &(a->ns7__VeterinaryEvent::type), "ns7:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:actualDateTime", &(a->ns7__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_VeterinaryEvent(soap, &a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:operator", &(a->ns7__VeterinaryEvent::operator_), "ns6:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:referencedDocument", 1, NULL)) {
				if(a->ns7__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(ns7__Document *));
					if(a->ns7__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->ns7__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__Document(soap, "ns7:referencedDocument", a->ns7__VeterinaryEvent::referencedDocument, "ns7:Document"))
				{	a->ns7__VeterinaryEvent::__sizereferencedDocument++;
					a->ns7__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:notes", &(a->ns7__VeterinaryEvent::notes), "ns3:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:batchID", 1, NULL)) {
				if(a->ns7__LaboratoryResearchEvent::batchID == NULL) {
					if(soap_blist_batchID1 == NULL)
						soap_blist_batchID1 = soap_new_block(soap);
					a->ns7__LaboratoryResearchEvent::batchID = (char **)soap_push_block(soap, soap_blist_batchID1, sizeof(char *));
					if(a->ns7__LaboratoryResearchEvent::batchID == NULL)
						return NULL;
					*a->ns7__LaboratoryResearchEvent::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns3__Identifier(soap, "ns7:batchID", a->ns7__LaboratoryResearchEvent::batchID, "ns3:Identifier"))
				{	a->ns7__LaboratoryResearchEvent::__sizebatchID++;
					a->ns7__LaboratoryResearchEvent::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_expertiseID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:expertiseID", &(a->ns7__LaboratoryResearchEvent::expertiseID), "ns3:String255"))
				{	soap_flag_expertiseID1--;
					continue;
				}
			if(soap_flag_union_LaboratoryResearchEvent_1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_LaboratoryResearchEvent_(soap, &a->ns7__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &a->ns7__LaboratoryResearchEvent::union_LaboratoryResearchEvent_))
				{	soap_flag_union_LaboratoryResearchEvent_1 = 0;
					continue;
				}
			if(soap_flag_method1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchMethod(soap, "ns7:method", &(a->ns7__LaboratoryResearchEvent::method), "ns6:ResearchMethod"))
				{	soap_flag_method1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ResearchResult(soap, "ns7:result", &(a->ns7__LaboratoryResearchEvent::result), "ns6:ResearchResult"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_conclusion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:conclusion", &(a->ns7__LaboratoryResearchEvent::conclusion), "ns3:Text"))
				{	soap_flag_conclusion1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->ns7__VeterinaryEvent::__sizereferencedDocument)
			a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->ns7__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(a->ns7__LaboratoryResearchEvent::batchID)
			soap_pop_block(soap, soap_blist_batchID1);
		if(a->ns7__LaboratoryResearchEvent::__sizebatchID)
			a->ns7__LaboratoryResearchEvent::batchID = (char **)soap_save_block(soap, soap_blist_batchID1, NULL, 1);
		else
		{	a->ns7__LaboratoryResearchEvent::batchID = NULL;
			if(soap_blist_batchID1)
				soap_end_block(soap, soap_blist_batchID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__LaboratoryResearchEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__LaboratoryResearchEvent, 0, sizeof(ns7__LaboratoryResearchEvent), 0, soap_copy_ns7__LaboratoryResearchEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2 || soap_flag_union_LaboratoryResearchEvent_1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__LaboratoryResearchEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__LaboratoryResearchEvent);
	return this->soap_out(soap, tag?tag:"ns7:LaboratoryResearchEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__LaboratoryResearchEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__LaboratoryResearchEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns7__LaboratoryResearchEvent * SOAP_FMAC4 soap_get_ns7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__LaboratoryResearchEvent * FASTCALL soap_instantiate_ns7__LaboratoryResearchEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__LaboratoryResearchEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__LaboratoryResearchEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__LaboratoryResearchEvent);
		ASSIGN_PTR(size, sizeof(ns7__LaboratoryResearchEvent));
		((ns7__LaboratoryResearchEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__LaboratoryResearchEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__LaboratoryResearchEvent));
		for(int i = 0; i < n; i++)
			((ns7__LaboratoryResearchEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__LaboratoryResearchEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__LaboratoryResearchEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__LaboratoryResearchEvent %p -> %p\n", q, p));
	*(ns7__LaboratoryResearchEvent*)p = *(ns7__LaboratoryResearchEvent*)q;
}

void ns7__VeterinaryEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__VeterinaryEvent::ID = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	this->ns7__VeterinaryEvent::type = NULL;
	this->ns7__VeterinaryEvent::actualDateTime = NULL;
	this->ns7__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->ns7__VeterinaryEvent::operator_ = NULL;
	this->ns7__VeterinaryEvent::__sizereferencedDocument = 0;
	this->ns7__VeterinaryEvent::referencedDocument = NULL;
	soap_default_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void ns7__VeterinaryEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns7__VeterinaryEvent::ID);
	soap_serialize_ns3__String255(soap, &this->ns7__VeterinaryEvent::name);
	soap_serialize_PointerTons7__VeterinaryEventType(soap, &this->ns7__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->ns7__VeterinaryEvent::actualDateTime);
	soap_serialize__ns7__union_VeterinaryEvent(soap, this->ns7__VeterinaryEvent::__union_VeterinaryEvent, &this->ns7__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__VeterinaryEvent::operator_);
	if(this->ns7__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->ns7__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTons7__Document(soap, this->ns7__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_ns3__Text(soap, &this->ns7__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int ns7__VeterinaryEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__VeterinaryEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VeterinaryEvent(struct soap *soap, const char *tag, int id, const ns7__VeterinaryEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VeterinaryEvent), type))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns7:ID", -1, &(a->ns7__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTons7__VeterinaryEventType(soap, "ns7:type", -1, &(a->ns7__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:actualDateTime", -1, &(a->ns7__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__ns7__union_VeterinaryEvent(soap, a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:operator", -1, &(a->ns7__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->ns7__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->ns7__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTons7__Document(soap, "ns7:referencedDocument", -1, a->ns7__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_ns3__Text(soap, "ns7:notes", -1, &(a->ns7__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__VeterinaryEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__VeterinaryEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns7__VeterinaryEvent * FASTCALL soap_in_ns7__VeterinaryEvent(struct soap *soap, const char *tag, ns7__VeterinaryEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__VeterinaryEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VeterinaryEvent, sizeof(ns7__VeterinaryEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__VeterinaryEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__VeterinaryEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_actualDateTime1 = 1;
	size_t soap_flag_union_VeterinaryEvent1 = 1;
	size_t soap_flag_operator_1 = 1;
	struct soap_blist *soap_blist_referencedDocument1 = NULL;
	size_t soap_flag_notes1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns7:ID", &(a->ns7__VeterinaryEvent::ID), "ns3:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__VeterinaryEvent::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VeterinaryEventType(soap, "ns7:type", &(a->ns7__VeterinaryEvent::type), "ns7:VeterinaryEventType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_actualDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:actualDateTime", &(a->ns7__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime1--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_VeterinaryEvent(soap, &a->ns7__VeterinaryEvent::__union_VeterinaryEvent, &a->ns7__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent1 = 0;
					continue;
				}
			if(soap_flag_operator_1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:operator", &(a->ns7__VeterinaryEvent::operator_), "ns6:Organization"))
				{	soap_flag_operator_1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:referencedDocument", 1, NULL)) {
				if(a->ns7__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument1 == NULL)
						soap_blist_referencedDocument1 = soap_new_block(soap);
					a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_push_block(soap, soap_blist_referencedDocument1, sizeof(ns7__Document *));
					if(a->ns7__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->ns7__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__Document(soap, "ns7:referencedDocument", a->ns7__VeterinaryEvent::referencedDocument, "ns7:Document"))
				{	a->ns7__VeterinaryEvent::__sizereferencedDocument++;
					a->ns7__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:notes", &(a->ns7__VeterinaryEvent::notes), "ns3:Text"))
				{	soap_flag_notes1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument1);
		if(a->ns7__VeterinaryEvent::__sizereferencedDocument)
			a->ns7__VeterinaryEvent::referencedDocument = (ns7__Document **)soap_save_block(soap, soap_blist_referencedDocument1, NULL, 1);
		else
		{	a->ns7__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument1)
				soap_end_block(soap, soap_blist_referencedDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__VeterinaryEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VeterinaryEvent, 0, sizeof(ns7__VeterinaryEvent), 0, soap_copy_ns7__VeterinaryEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__VeterinaryEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__VeterinaryEvent);
	return this->soap_out(soap, tag?tag:"ns7:VeterinaryEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__VeterinaryEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__VeterinaryEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns7__VeterinaryEvent * SOAP_FMAC4 soap_get_ns7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__VeterinaryEvent * FASTCALL soap_instantiate_ns7__VeterinaryEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__VeterinaryEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__VeterinaryEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns7:LaboratoryResearchEvent")) {
		cp->type = SOAP_TYPE_ns7__LaboratoryResearchEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__LaboratoryResearchEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__LaboratoryResearchEvent));
			((ns7__LaboratoryResearchEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__LaboratoryResearchEvent[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__LaboratoryResearchEvent));
			for(int i = 0; i < n; i++)
				((ns7__LaboratoryResearchEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__LaboratoryResearchEvent*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:AnimalMedicationEvent")) {
		cp->type = SOAP_TYPE_ns7__AnimalMedicationEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__AnimalMedicationEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__AnimalMedicationEvent));
			((ns7__AnimalMedicationEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__AnimalMedicationEvent[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__AnimalMedicationEvent));
			for(int i = 0; i < n; i++)
				((ns7__AnimalMedicationEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__AnimalMedicationEvent*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:QuarantineEvent")) {
		cp->type = SOAP_TYPE_ns7__QuarantineEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__QuarantineEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__QuarantineEvent));
			((ns7__QuarantineEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__QuarantineEvent[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__QuarantineEvent));
			for(int i = 0; i < n; i++)
				((ns7__QuarantineEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__QuarantineEvent*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__VeterinaryEvent);
		ASSIGN_PTR(size, sizeof(ns7__VeterinaryEvent));
		((ns7__VeterinaryEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__VeterinaryEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__VeterinaryEvent));
		for(int i = 0; i < n; i++)
			((ns7__VeterinaryEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__VeterinaryEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__VeterinaryEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__VeterinaryEvent %p -> %p\n", q, p));
	*(ns7__VeterinaryEvent*)p = *(ns7__VeterinaryEvent*)q;
}

void ns7__ReferencedDocument::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__ReferenceType(soap, &this->ns7__ReferencedDocument::relationshipType);
	soap_default_ns3__String255(soap, &this->ns7__Document::name);
	soap_default_ns3__String255(soap, &this->ns7__Document::form);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_default_xsd__date(soap, &this->ns7__Document::issueDate);
	this->ns7__Document::type = NULL;
	this->ns7__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->ns7__Document::for_);
	this->ns7__Document::qualifier = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__ReferencedDocument::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns7__Document::name);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::form);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->ns7__Document::issueDate);
	soap_serialize_PointerTons6__DocumentType(soap, &this->ns7__Document::type);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__Document::issuer);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__ReferencedDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ReferencedDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ReferencedDocument(struct soap *soap, const char *tag, int id, const ns7__ReferencedDocument *a, const char *type)
{
	if(((ns7__Document*)a)->for_)
		soap_set_attr(soap, "for", ((ns7__Document*)a)->for_, 1);
	if(((ns7__Document*)a)->qualifier)
		if(*((ns7__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns7__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ReferencedDocument), "ns7:ReferencedDocument"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__Document::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:form", -1, &(a->ns7__Document::form), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueSeries", -1, &(a->ns7__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueNumber", -1, &(a->ns7__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "ns7:issueDate", -1, &(a->ns7__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__DocumentType(soap, "ns7:type", -1, &(a->ns7__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:issuer", -1, &(a->ns7__Document::issuer), ""))
		return soap->error;
	if(soap_out_ns6__ReferenceType(soap, "ns7:relationshipType", -1, &(a->ns7__ReferencedDocument::relationshipType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__ReferencedDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ReferencedDocument(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ReferencedDocument * FASTCALL soap_in_ns7__ReferencedDocument(struct soap *soap, const char *tag, ns7__ReferencedDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ReferencedDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ReferencedDocument, sizeof(ns7__ReferencedDocument), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ReferencedDocument) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ReferencedDocument *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((ns7__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns7__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns7__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_relationshipType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__Document::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:form", &(a->ns7__Document::form), "ns3:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueSeries", &(a->ns7__Document::issueSeries), "ns3:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueNumber", &(a->ns7__Document::issueNumber), "ns3:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "ns7:issueDate", &(a->ns7__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DocumentType(soap, "ns7:type", &(a->ns7__Document::type), "ns6:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:issuer", &(a->ns7__Document::issuer), "ns6:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_relationshipType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__ReferenceType(soap, "ns7:relationshipType", &(a->ns7__ReferencedDocument::relationshipType), "ns6:ReferenceType"))
				{	soap_flag_relationshipType1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ReferencedDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ReferencedDocument, 0, sizeof(ns7__ReferencedDocument), 0, soap_copy_ns7__ReferencedDocument);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_relationshipType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__ReferencedDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ReferencedDocument);
	return this->soap_out(soap, tag?tag:"ns7:ReferencedDocument", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ReferencedDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ReferencedDocument(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ReferencedDocument * SOAP_FMAC4 soap_get_ns7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ReferencedDocument * FASTCALL soap_instantiate_ns7__ReferencedDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ReferencedDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ReferencedDocument, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ReferencedDocument);
		ASSIGN_PTR(size, sizeof(ns7__ReferencedDocument));
		((ns7__ReferencedDocument*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ReferencedDocument[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ReferencedDocument));
		for(int i = 0; i < n; i++)
			((ns7__ReferencedDocument*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ReferencedDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ReferencedDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ReferencedDocument %p -> %p\n", q, p));
	*(ns7__ReferencedDocument*)p = *(ns7__ReferencedDocument*)q;
}

void ns7__CertifiedConsignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__CertifiedConsignment::consignor = NULL;
	this->ns7__CertifiedConsignment::consignee = NULL;
	this->ns7__CertifiedConsignment::broker = NULL;
	this->ns7__CertifiedConsignment::transportInfo = NULL;
	this->ns7__CertifiedConsignment::transportStorageType = NULL;
	this->ns7__CertifiedConsignment::shipmentRoute = NULL;
	this->ns7__CertifiedConsignment::batch = NULL;
	/* transient soap skipped */
}

void ns7__CertifiedConsignment::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__CertifiedConsignment::consignor);
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__CertifiedConsignment::consignee);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__CertifiedConsignment::broker);
	soap_serialize_PointerTons7__TransportInfo(soap, &this->ns7__CertifiedConsignment::transportInfo);
	soap_serialize_PointerTons6__TransportationStorageType(soap, &this->ns7__CertifiedConsignment::transportStorageType);
	soap_serialize_PointerTons7__ShipmentRoute(soap, &this->ns7__CertifiedConsignment::shipmentRoute);
	soap_serialize_PointerTons7__Batch(soap, &this->ns7__CertifiedConsignment::batch);
	/* transient soap skipped */
}

int ns7__CertifiedConsignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__CertifiedConsignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__CertifiedConsignment(struct soap *soap, const char *tag, int id, const ns7__CertifiedConsignment *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__CertifiedConsignment), type))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:consignor", -1, &(a->ns7__CertifiedConsignment::consignor), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:consignee", -1, &(a->ns7__CertifiedConsignment::consignee), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:broker", -1, &(a->ns7__CertifiedConsignment::broker), ""))
		return soap->error;
	if(soap_out_PointerTons7__TransportInfo(soap, "ns7:transportInfo", -1, &(a->ns7__CertifiedConsignment::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerTons6__TransportationStorageType(soap, "ns7:transportStorageType", -1, &(a->ns7__CertifiedConsignment::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", -1, &(a->ns7__CertifiedConsignment::shipmentRoute), ""))
		return soap->error;
	if(soap_out_PointerTons7__Batch(soap, "ns7:batch", -1, &(a->ns7__CertifiedConsignment::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__CertifiedConsignment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__CertifiedConsignment(soap, tag, this, type);
}

SOAP_FMAC3 ns7__CertifiedConsignment * FASTCALL soap_in_ns7__CertifiedConsignment(struct soap *soap, const char *tag, ns7__CertifiedConsignment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__CertifiedConsignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__CertifiedConsignment, sizeof(ns7__CertifiedConsignment), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__CertifiedConsignment) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__CertifiedConsignment *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	size_t soap_flag_batch1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:consignor", &(a->ns7__CertifiedConsignment::consignor), "ns6:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:consignee", &(a->ns7__CertifiedConsignment::consignee), "ns6:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:broker", &(a->ns7__CertifiedConsignment::broker), "ns6:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__TransportInfo(soap, "ns7:transportInfo", &(a->ns7__CertifiedConsignment::transportInfo), "ns7:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__TransportationStorageType(soap, "ns7:transportStorageType", &(a->ns7__CertifiedConsignment::transportStorageType), "ns6:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", &(a->ns7__CertifiedConsignment::shipmentRoute), "ns7:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Batch(soap, "ns7:batch", &(a->ns7__CertifiedConsignment::batch), "ns7:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__CertifiedConsignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__CertifiedConsignment, 0, sizeof(ns7__CertifiedConsignment), 0, soap_copy_ns7__CertifiedConsignment);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__CertifiedConsignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__CertifiedConsignment);
	return this->soap_out(soap, tag?tag:"ns7:CertifiedConsignment", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__CertifiedConsignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__CertifiedConsignment(soap, this, tag, type);
}

SOAP_FMAC3 ns7__CertifiedConsignment * SOAP_FMAC4 soap_get_ns7__CertifiedConsignment(struct soap *soap, ns7__CertifiedConsignment *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__CertifiedConsignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__CertifiedConsignment * FASTCALL soap_instantiate_ns7__CertifiedConsignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__CertifiedConsignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__CertifiedConsignment, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__CertifiedConsignment);
		ASSIGN_PTR(size, sizeof(ns7__CertifiedConsignment));
		((ns7__CertifiedConsignment*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__CertifiedConsignment[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__CertifiedConsignment));
		for(int i = 0; i < n; i++)
			((ns7__CertifiedConsignment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__CertifiedConsignment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__CertifiedConsignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__CertifiedConsignment %p -> %p\n", q, p));
	*(ns7__CertifiedConsignment*)p = *(ns7__CertifiedConsignment*)q;
}

void ns7__CertifiedBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__CertifiedBatch::producer = NULL;
	this->ns7__CertifiedBatch::batch = NULL;
	/* transient soap skipped */
}

void ns7__CertifiedBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__CertifiedBatch::producer);
	soap_serialize_PointerTons7__Batch(soap, &this->ns7__CertifiedBatch::batch);
	/* transient soap skipped */
}

int ns7__CertifiedBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__CertifiedBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__CertifiedBatch(struct soap *soap, const char *tag, int id, const ns7__CertifiedBatch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__CertifiedBatch), type))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:producer", -1, &(a->ns7__CertifiedBatch::producer), ""))
		return soap->error;
	if(soap_out_PointerTons7__Batch(soap, "ns7:batch", -1, &(a->ns7__CertifiedBatch::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__CertifiedBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__CertifiedBatch(soap, tag, this, type);
}

SOAP_FMAC3 ns7__CertifiedBatch * FASTCALL soap_in_ns7__CertifiedBatch(struct soap *soap, const char *tag, ns7__CertifiedBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__CertifiedBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__CertifiedBatch, sizeof(ns7__CertifiedBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__CertifiedBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__CertifiedBatch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_producer1 = 1;
	size_t soap_flag_batch1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:producer", &(a->ns7__CertifiedBatch::producer), "ns6:BusinessMember"))
				{	soap_flag_producer1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Batch(soap, "ns7:batch", &(a->ns7__CertifiedBatch::batch), "ns7:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__CertifiedBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__CertifiedBatch, 0, sizeof(ns7__CertifiedBatch), 0, soap_copy_ns7__CertifiedBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__CertifiedBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__CertifiedBatch);
	return this->soap_out(soap, tag?tag:"ns7:CertifiedBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__CertifiedBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__CertifiedBatch(soap, this, tag, type);
}

SOAP_FMAC3 ns7__CertifiedBatch * SOAP_FMAC4 soap_get_ns7__CertifiedBatch(struct soap *soap, ns7__CertifiedBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__CertifiedBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__CertifiedBatch * FASTCALL soap_instantiate_ns7__CertifiedBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__CertifiedBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__CertifiedBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__CertifiedBatch);
		ASSIGN_PTR(size, sizeof(ns7__CertifiedBatch));
		((ns7__CertifiedBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__CertifiedBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__CertifiedBatch));
		for(int i = 0; i < n; i++)
			((ns7__CertifiedBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__CertifiedBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__CertifiedBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__CertifiedBatch %p -> %p\n", q, p));
	*(ns7__CertifiedBatch*)p = *(ns7__CertifiedBatch*)q;
}

void ns7__ENTModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__RegisterModificationType(soap, &this->ns7__ENTModificationOperation::type);
	this->ns7__ENTModificationOperation::affectedList = NULL;
	this->ns7__ENTModificationOperation::resultingList = NULL;
	soap_default_ns6__ENTModificationReason(soap, &this->ns7__ENTModificationOperation::reason);
	/* transient soap skipped */
}

void ns7__ENTModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->ns7__ENTModificationOperation::type, SOAP_TYPE_ns3__RegisterModificationType);
	soap_serialize_PointerTons6__EnterpriseList(soap, &this->ns7__ENTModificationOperation::affectedList);
	soap_serialize_PointerTons6__EnterpriseList(soap, &this->ns7__ENTModificationOperation::resultingList);
	soap_serialize_ns6__ENTModificationReason(soap, &this->ns7__ENTModificationOperation::reason);
	/* transient soap skipped */
}

int ns7__ENTModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ENTModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ENTModificationOperation(struct soap *soap, const char *tag, int id, const ns7__ENTModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ENTModificationOperation), type))
		return soap->error;
	if(soap_out_ns3__RegisterModificationType(soap, "ns7:type", -1, &(a->ns7__ENTModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseList(soap, "ns7:affectedList", -1, &(a->ns7__ENTModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseList(soap, "ns7:resultingList", -1, &(a->ns7__ENTModificationOperation::resultingList), ""))
		return soap->error;
	if(soap_out_ns6__ENTModificationReason(soap, "ns7:reason", -1, &(a->ns7__ENTModificationOperation::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__ENTModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ENTModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ENTModificationOperation * FASTCALL soap_in_ns7__ENTModificationOperation(struct soap *soap, const char *tag, ns7__ENTModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ENTModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ENTModificationOperation, sizeof(ns7__ENTModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ENTModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ENTModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns3__RegisterModificationType(soap, "ns7:type", &(a->ns7__ENTModificationOperation::type), "ns3:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseList(soap, "ns7:affectedList", &(a->ns7__ENTModificationOperation::affectedList), "ns6:EnterpriseList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseList(soap, "ns7:resultingList", &(a->ns7__ENTModificationOperation::resultingList), "ns6:EnterpriseList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__ENTModificationReason(soap, "ns7:reason", &(a->ns7__ENTModificationOperation::reason), "ns6:ENTModificationReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ENTModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ENTModificationOperation, 0, sizeof(ns7__ENTModificationOperation), 0, soap_copy_ns7__ENTModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__ENTModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ENTModificationOperation);
	return this->soap_out(soap, tag?tag:"ns7:ENTModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ENTModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ENTModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ENTModificationOperation * SOAP_FMAC4 soap_get_ns7__ENTModificationOperation(struct soap *soap, ns7__ENTModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ENTModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ENTModificationOperation * FASTCALL soap_instantiate_ns7__ENTModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ENTModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ENTModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ENTModificationOperation);
		ASSIGN_PTR(size, sizeof(ns7__ENTModificationOperation));
		((ns7__ENTModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ENTModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ENTModificationOperation));
		for(int i = 0; i < n; i++)
			((ns7__ENTModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ENTModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ENTModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ENTModificationOperation %p -> %p\n", q, p));
	*(ns7__ENTModificationOperation*)p = *(ns7__ENTModificationOperation*)q;
}

void ns7__BEActivityLocationsModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__RegisterModificationType(soap, &this->ns7__BEActivityLocationsModificationOperation::type);
	this->ns7__BEActivityLocationsModificationOperation::businessEntity = NULL;
	this->ns7__BEActivityLocationsModificationOperation::__sizeactivityLocation = 0;
	this->ns7__BEActivityLocationsModificationOperation::activityLocation = NULL;
	/* transient soap skipped */
}

void ns7__BEActivityLocationsModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->ns7__BEActivityLocationsModificationOperation::type, SOAP_TYPE_ns3__RegisterModificationType);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__BEActivityLocationsModificationOperation::businessEntity);
	if(this->ns7__BEActivityLocationsModificationOperation::activityLocation) {
		for(int i = 0; i < this->ns7__BEActivityLocationsModificationOperation::__sizeactivityLocation; i++) {
			soap_embedded(soap, this->ns7__BEActivityLocationsModificationOperation::activityLocation + i, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation);
			this->ns7__BEActivityLocationsModificationOperation::activityLocation[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns7__BEActivityLocationsModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__BEActivityLocationsModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, int id, const ns7__BEActivityLocationsModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation), type))
		return soap->error;
	if(soap_out_ns3__RegisterModificationType(soap, "ns7:type", -1, &(a->ns7__BEActivityLocationsModificationOperation::type), ""))
		return soap->error;
	if(a->ns7__BEActivityLocationsModificationOperation::businessEntity) {
		if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:businessEntity", -1, &a->ns7__BEActivityLocationsModificationOperation::businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:businessEntity"))
		return soap->error;
	if(a->ns7__BEActivityLocationsModificationOperation::activityLocation) {
		int i;
		for(i = 0; i < a->ns7__BEActivityLocationsModificationOperation::__sizeactivityLocation; i++)
			if(a->ns7__BEActivityLocationsModificationOperation::activityLocation[i].soap_out(soap, "ns7:activityLocation", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__BEActivityLocationsModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__BEActivityLocationsModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns7__BEActivityLocationsModificationOperation * FASTCALL soap_in_ns7__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, ns7__BEActivityLocationsModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__BEActivityLocationsModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation, sizeof(ns7__BEActivityLocationsModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__BEActivityLocationsModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__BEActivityLocationsModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_businessEntity1 = 1;
	struct soap_blist *soap_blist_activityLocation1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns3__RegisterModificationType(soap, "ns7:type", &(a->ns7__BEActivityLocationsModificationOperation::type), "ns3:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:businessEntity", &(a->ns7__BEActivityLocationsModificationOperation::businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:activityLocation", 1, NULL)) {
				if(a->ns7__BEActivityLocationsModificationOperation::activityLocation == NULL) {
					if(soap_blist_activityLocation1 == NULL)
						soap_blist_activityLocation1 = soap_new_block(soap);
					a->ns7__BEActivityLocationsModificationOperation::activityLocation = (_ns7__BEActivityLocationsModificationOperation_activityLocation *)soap_push_block(soap, soap_blist_activityLocation1, sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation));
					if(a->ns7__BEActivityLocationsModificationOperation::activityLocation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns7__BEActivityLocationsModificationOperation::activityLocation, _ns7__BEActivityLocationsModificationOperation_activityLocation);
					a->ns7__BEActivityLocationsModificationOperation::activityLocation->soap_default(soap);
				}
				soap_revert(soap);
				if(soap_in__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, "ns7:activityLocation", a->ns7__BEActivityLocationsModificationOperation::activityLocation, ""))
				{	a->ns7__BEActivityLocationsModificationOperation::__sizeactivityLocation++;
					a->ns7__BEActivityLocationsModificationOperation::activityLocation = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__BEActivityLocationsModificationOperation::activityLocation)
			soap_pop_block(soap, soap_blist_activityLocation1);
		if(a->ns7__BEActivityLocationsModificationOperation::__sizeactivityLocation)
			a->ns7__BEActivityLocationsModificationOperation::activityLocation = (_ns7__BEActivityLocationsModificationOperation_activityLocation *)soap_save_block(soap, soap_blist_activityLocation1, NULL, 1);
		else
		{	a->ns7__BEActivityLocationsModificationOperation::activityLocation = NULL;
			if(soap_blist_activityLocation1)
				soap_end_block(soap, soap_blist_activityLocation1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__BEActivityLocationsModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation, 0, sizeof(ns7__BEActivityLocationsModificationOperation), 0, soap_copy_ns7__BEActivityLocationsModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_businessEntity1 > 0 || a->ns7__BEActivityLocationsModificationOperation::__sizeactivityLocation < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__BEActivityLocationsModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation);
	return this->soap_out(soap, tag?tag:"ns7:BEActivityLocationsModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__BEActivityLocationsModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__BEActivityLocationsModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns7__BEActivityLocationsModificationOperation * SOAP_FMAC4 soap_get_ns7__BEActivityLocationsModificationOperation(struct soap *soap, ns7__BEActivityLocationsModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__BEActivityLocationsModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__BEActivityLocationsModificationOperation * FASTCALL soap_instantiate_ns7__BEActivityLocationsModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__BEActivityLocationsModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__BEActivityLocationsModificationOperation);
		ASSIGN_PTR(size, sizeof(ns7__BEActivityLocationsModificationOperation));
		((ns7__BEActivityLocationsModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__BEActivityLocationsModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__BEActivityLocationsModificationOperation));
		for(int i = 0; i < n; i++)
			((ns7__BEActivityLocationsModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__BEActivityLocationsModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__BEActivityLocationsModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__BEActivityLocationsModificationOperation %p -> %p\n", q, p));
	*(ns7__BEActivityLocationsModificationOperation*)p = *(ns7__BEActivityLocationsModificationOperation*)q;
}

void ns7__BEModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__RegisterModificationType(soap, &this->ns7__BEModificationOperation::type);
	this->ns7__BEModificationOperation::affectedList = NULL;
	this->ns7__BEModificationOperation::resultingList = NULL;
	soap_default_ns6__BEModificationReason(soap, &this->ns7__BEModificationOperation::reason);
	/* transient soap skipped */
}

void ns7__BEModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->ns7__BEModificationOperation::type, SOAP_TYPE_ns3__RegisterModificationType);
	soap_serialize_PointerTons6__BusinessEntityList(soap, &this->ns7__BEModificationOperation::affectedList);
	soap_serialize_PointerTons6__BusinessEntityList(soap, &this->ns7__BEModificationOperation::resultingList);
	soap_serialize_ns6__BEModificationReason(soap, &this->ns7__BEModificationOperation::reason);
	/* transient soap skipped */
}

int ns7__BEModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__BEModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__BEModificationOperation(struct soap *soap, const char *tag, int id, const ns7__BEModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__BEModificationOperation), type))
		return soap->error;
	if(soap_out_ns3__RegisterModificationType(soap, "ns7:type", -1, &(a->ns7__BEModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntityList(soap, "ns7:affectedList", -1, &(a->ns7__BEModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntityList(soap, "ns7:resultingList", -1, &(a->ns7__BEModificationOperation::resultingList), ""))
		return soap->error;
	if(soap_out_ns6__BEModificationReason(soap, "ns7:reason", -1, &(a->ns7__BEModificationOperation::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__BEModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__BEModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns7__BEModificationOperation * FASTCALL soap_in_ns7__BEModificationOperation(struct soap *soap, const char *tag, ns7__BEModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__BEModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__BEModificationOperation, sizeof(ns7__BEModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__BEModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__BEModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns3__RegisterModificationType(soap, "ns7:type", &(a->ns7__BEModificationOperation::type), "ns3:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntityList(soap, "ns7:affectedList", &(a->ns7__BEModificationOperation::affectedList), "ns6:BusinessEntityList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntityList(soap, "ns7:resultingList", &(a->ns7__BEModificationOperation::resultingList), "ns6:BusinessEntityList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__BEModificationReason(soap, "ns7:reason", &(a->ns7__BEModificationOperation::reason), "ns6:BEModificationReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__BEModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__BEModificationOperation, 0, sizeof(ns7__BEModificationOperation), 0, soap_copy_ns7__BEModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__BEModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__BEModificationOperation);
	return this->soap_out(soap, tag?tag:"ns7:BEModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__BEModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__BEModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns7__BEModificationOperation * SOAP_FMAC4 soap_get_ns7__BEModificationOperation(struct soap *soap, ns7__BEModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__BEModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__BEModificationOperation * FASTCALL soap_instantiate_ns7__BEModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__BEModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__BEModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__BEModificationOperation);
		ASSIGN_PTR(size, sizeof(ns7__BEModificationOperation));
		((ns7__BEModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__BEModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__BEModificationOperation));
		for(int i = 0; i < n; i++)
			((ns7__BEModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__BEModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__BEModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__BEModificationOperation %p -> %p\n", q, p));
	*(ns7__BEModificationOperation*)p = *(ns7__BEModificationOperation*)q;
}

void ns7__PSLModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__RegisterModificationType(soap, &this->ns7__PSLModificationOperation::type);
	this->ns7__PSLModificationOperation::affectedList = NULL;
	this->ns7__PSLModificationOperation::resultingList = NULL;
	/* transient soap skipped */
}

void ns7__PSLModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->ns7__PSLModificationOperation::type, SOAP_TYPE_ns3__RegisterModificationType);
	soap_serialize_PointerTons6__ProductItemList(soap, &this->ns7__PSLModificationOperation::affectedList);
	soap_serialize_PointerTons6__ProductItemList(soap, &this->ns7__PSLModificationOperation::resultingList);
	/* transient soap skipped */
}

int ns7__PSLModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__PSLModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__PSLModificationOperation(struct soap *soap, const char *tag, int id, const ns7__PSLModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__PSLModificationOperation), type))
		return soap->error;
	if(soap_out_ns3__RegisterModificationType(soap, "ns7:type", -1, &(a->ns7__PSLModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductItemList(soap, "ns7:affectedList", -1, &(a->ns7__PSLModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductItemList(soap, "ns7:resultingList", -1, &(a->ns7__PSLModificationOperation::resultingList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__PSLModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__PSLModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns7__PSLModificationOperation * FASTCALL soap_in_ns7__PSLModificationOperation(struct soap *soap, const char *tag, ns7__PSLModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__PSLModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__PSLModificationOperation, sizeof(ns7__PSLModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__PSLModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__PSLModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns3__RegisterModificationType(soap, "ns7:type", &(a->ns7__PSLModificationOperation::type), "ns3:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItemList(soap, "ns7:affectedList", &(a->ns7__PSLModificationOperation::affectedList), "ns6:ProductItemList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItemList(soap, "ns7:resultingList", &(a->ns7__PSLModificationOperation::resultingList), "ns6:ProductItemList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__PSLModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__PSLModificationOperation, 0, sizeof(ns7__PSLModificationOperation), 0, soap_copy_ns7__PSLModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__PSLModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__PSLModificationOperation);
	return this->soap_out(soap, tag?tag:"ns7:PSLModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__PSLModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__PSLModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns7__PSLModificationOperation * SOAP_FMAC4 soap_get_ns7__PSLModificationOperation(struct soap *soap, ns7__PSLModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__PSLModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__PSLModificationOperation * FASTCALL soap_instantiate_ns7__PSLModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__PSLModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__PSLModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__PSLModificationOperation);
		ASSIGN_PTR(size, sizeof(ns7__PSLModificationOperation));
		((ns7__PSLModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__PSLModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__PSLModificationOperation));
		for(int i = 0; i < n; i++)
			((ns7__PSLModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__PSLModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__PSLModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__PSLModificationOperation %p -> %p\n", q, p));
	*(ns7__PSLModificationOperation*)p = *(ns7__PSLModificationOperation*)q;
}

void ns7__MergeStockEntriesOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__MergeStockEntriesOperation::type = NULL;
	this->ns7__MergeStockEntriesOperation::__sizesourceStockEntry = 0;
	this->ns7__MergeStockEntriesOperation::sourceStockEntry = NULL;
	this->ns7__MergeStockEntriesOperation::__sizeresultStockEntry = 0;
	this->ns7__MergeStockEntriesOperation::resultStockEntry = NULL;
	/* transient soap skipped */
}

void ns7__MergeStockEntriesOperation::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__RegisterModificationType(soap, &this->ns7__MergeStockEntriesOperation::type);
	if(this->ns7__MergeStockEntriesOperation::sourceStockEntry) {
		for(int i = 0; i < this->ns7__MergeStockEntriesOperation::__sizesourceStockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns7__MergeStockEntriesOperation::sourceStockEntry + i);
		}
	}
	if(this->ns7__MergeStockEntriesOperation::resultStockEntry) {
		for(int i = 0; i < this->ns7__MergeStockEntriesOperation::__sizeresultStockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns7__MergeStockEntriesOperation::resultStockEntry + i);
		}
	}
	/* transient soap skipped */
}

int ns7__MergeStockEntriesOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__MergeStockEntriesOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__MergeStockEntriesOperation(struct soap *soap, const char *tag, int id, const ns7__MergeStockEntriesOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__MergeStockEntriesOperation), type))
		return soap->error;
	if(soap_out_PointerTons3__RegisterModificationType(soap, "ns7:type", -1, &(a->ns7__MergeStockEntriesOperation::type), ""))
		return soap->error;
	if(a->ns7__MergeStockEntriesOperation::sourceStockEntry) {
		int i;
		for(i = 0; i < a->ns7__MergeStockEntriesOperation::__sizesourceStockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns7:sourceStockEntry", -1, a->ns7__MergeStockEntriesOperation::sourceStockEntry + i, ""))
				return soap->error;
	}
	if(a->ns7__MergeStockEntriesOperation::resultStockEntry) {
		int i;
		for(i = 0; i < a->ns7__MergeStockEntriesOperation::__sizeresultStockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns7:resultStockEntry", -1, a->ns7__MergeStockEntriesOperation::resultStockEntry + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__MergeStockEntriesOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__MergeStockEntriesOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns7__MergeStockEntriesOperation * FASTCALL soap_in_ns7__MergeStockEntriesOperation(struct soap *soap, const char *tag, ns7__MergeStockEntriesOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__MergeStockEntriesOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__MergeStockEntriesOperation, sizeof(ns7__MergeStockEntriesOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__MergeStockEntriesOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__MergeStockEntriesOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	struct soap_blist *soap_blist_sourceStockEntry1 = NULL;
	struct soap_blist *soap_blist_resultStockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__RegisterModificationType(soap, "ns7:type", &(a->ns7__MergeStockEntriesOperation::type), "ns3:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:sourceStockEntry", 1, NULL)) {
				if(a->ns7__MergeStockEntriesOperation::sourceStockEntry == NULL) {
					if(soap_blist_sourceStockEntry1 == NULL)
						soap_blist_sourceStockEntry1 = soap_new_block(soap);
					a->ns7__MergeStockEntriesOperation::sourceStockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_sourceStockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns7__MergeStockEntriesOperation::sourceStockEntry == NULL)
						return NULL;
					*a->ns7__MergeStockEntriesOperation::sourceStockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:sourceStockEntry", a->ns7__MergeStockEntriesOperation::sourceStockEntry, "ns7:StockEntry"))
				{	a->ns7__MergeStockEntriesOperation::__sizesourceStockEntry++;
					a->ns7__MergeStockEntriesOperation::sourceStockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:resultStockEntry", 1, NULL)) {
				if(a->ns7__MergeStockEntriesOperation::resultStockEntry == NULL) {
					if(soap_blist_resultStockEntry1 == NULL)
						soap_blist_resultStockEntry1 = soap_new_block(soap);
					a->ns7__MergeStockEntriesOperation::resultStockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_resultStockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns7__MergeStockEntriesOperation::resultStockEntry == NULL)
						return NULL;
					*a->ns7__MergeStockEntriesOperation::resultStockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:resultStockEntry", a->ns7__MergeStockEntriesOperation::resultStockEntry, "ns7:StockEntry"))
				{	a->ns7__MergeStockEntriesOperation::__sizeresultStockEntry++;
					a->ns7__MergeStockEntriesOperation::resultStockEntry = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__MergeStockEntriesOperation::sourceStockEntry)
			soap_pop_block(soap, soap_blist_sourceStockEntry1);
		if(a->ns7__MergeStockEntriesOperation::__sizesourceStockEntry)
			a->ns7__MergeStockEntriesOperation::sourceStockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_sourceStockEntry1, NULL, 1);
		else
		{	a->ns7__MergeStockEntriesOperation::sourceStockEntry = NULL;
			if(soap_blist_sourceStockEntry1)
				soap_end_block(soap, soap_blist_sourceStockEntry1);
		}
		if(a->ns7__MergeStockEntriesOperation::resultStockEntry)
			soap_pop_block(soap, soap_blist_resultStockEntry1);
		if(a->ns7__MergeStockEntriesOperation::__sizeresultStockEntry)
			a->ns7__MergeStockEntriesOperation::resultStockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_resultStockEntry1, NULL, 1);
		else
		{	a->ns7__MergeStockEntriesOperation::resultStockEntry = NULL;
			if(soap_blist_resultStockEntry1)
				soap_end_block(soap, soap_blist_resultStockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__MergeStockEntriesOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__MergeStockEntriesOperation, 0, sizeof(ns7__MergeStockEntriesOperation), 0, soap_copy_ns7__MergeStockEntriesOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (a->ns7__MergeStockEntriesOperation::__sizesourceStockEntry < 2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__MergeStockEntriesOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__MergeStockEntriesOperation);
	return this->soap_out(soap, tag?tag:"ns7:MergeStockEntriesOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__MergeStockEntriesOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__MergeStockEntriesOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns7__MergeStockEntriesOperation * SOAP_FMAC4 soap_get_ns7__MergeStockEntriesOperation(struct soap *soap, ns7__MergeStockEntriesOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__MergeStockEntriesOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__MergeStockEntriesOperation * FASTCALL soap_instantiate_ns7__MergeStockEntriesOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__MergeStockEntriesOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__MergeStockEntriesOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__MergeStockEntriesOperation);
		ASSIGN_PTR(size, sizeof(ns7__MergeStockEntriesOperation));
		((ns7__MergeStockEntriesOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__MergeStockEntriesOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__MergeStockEntriesOperation));
		for(int i = 0; i < n; i++)
			((ns7__MergeStockEntriesOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__MergeStockEntriesOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__MergeStockEntriesOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__MergeStockEntriesOperation %p -> %p\n", q, p));
	*(ns7__MergeStockEntriesOperation*)p = *(ns7__MergeStockEntriesOperation*)q;
}

void ns7__ProductionOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ProductionOperation::operationId = NULL;
	this->ns7__ProductionOperation::__sizerawBatch = 0;
	this->ns7__ProductionOperation::rawBatch = NULL;
	this->ns7__ProductionOperation::__sizeproductiveBatch = 0;
	this->ns7__ProductionOperation::productiveBatch = NULL;
	this->ns7__ProductionOperation::finalizeOperation = NULL;
	this->ns7__ProductionOperation::__sizeappliedProcess = 0;
	this->ns7__ProductionOperation::appliedProcess = NULL;
	/* transient soap skipped */
}

void ns7__ProductionOperation::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns7__ProductionOperation::operationId);
	if(this->ns7__ProductionOperation::rawBatch) {
		for(int i = 0; i < this->ns7__ProductionOperation::__sizerawBatch; i++) {
			soap_serialize_PointerTons7__RawBatch(soap, this->ns7__ProductionOperation::rawBatch + i);
		}
	}
	if(this->ns7__ProductionOperation::productiveBatch) {
		for(int i = 0; i < this->ns7__ProductionOperation::__sizeproductiveBatch; i++) {
			soap_serialize_PointerTons7__ProductiveBatch(soap, this->ns7__ProductionOperation::productiveBatch + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->ns7__ProductionOperation::finalizeOperation);
	if(this->ns7__ProductionOperation::appliedProcess) {
		for(int i = 0; i < this->ns7__ProductionOperation::__sizeappliedProcess; i++) {
			soap_serialize_PointerTons7__ProcessingProcedure(soap, this->ns7__ProductionOperation::appliedProcess + i);
		}
	}
	/* transient soap skipped */
}

int ns7__ProductionOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ProductionOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ProductionOperation(struct soap *soap, const char *tag, int id, const ns7__ProductionOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ProductionOperation), type))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns7:operationId", -1, &(a->ns7__ProductionOperation::operationId), ""))
		return soap->error;
	if(a->ns7__ProductionOperation::rawBatch) {
		int i;
		for(i = 0; i < a->ns7__ProductionOperation::__sizerawBatch; i++)
			if(soap_out_PointerTons7__RawBatch(soap, "ns7:rawBatch", -1, a->ns7__ProductionOperation::rawBatch + i, ""))
				return soap->error;
	}
	if(a->ns7__ProductionOperation::productiveBatch) {
		int i;
		for(i = 0; i < a->ns7__ProductionOperation::__sizeproductiveBatch; i++)
			if(soap_out_PointerTons7__ProductiveBatch(soap, "ns7:productiveBatch", -1, a->ns7__ProductionOperation::productiveBatch + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "ns7:finalizeOperation", -1, &(a->ns7__ProductionOperation::finalizeOperation), ""))
		return soap->error;
	if(a->ns7__ProductionOperation::appliedProcess) {
		int i;
		for(i = 0; i < a->ns7__ProductionOperation::__sizeappliedProcess; i++)
			if(soap_out_PointerTons7__ProcessingProcedure(soap, "ns7:appliedProcess", -1, a->ns7__ProductionOperation::appliedProcess + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__ProductionOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ProductionOperation(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ProductionOperation * FASTCALL soap_in_ns7__ProductionOperation(struct soap *soap, const char *tag, ns7__ProductionOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ProductionOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ProductionOperation, sizeof(ns7__ProductionOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ProductionOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ProductionOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_operationId1 = 1;
	struct soap_blist *soap_blist_rawBatch1 = NULL;
	struct soap_blist *soap_blist_productiveBatch1 = NULL;
	size_t soap_flag_finalizeOperation1 = 1;
	struct soap_blist *soap_blist_appliedProcess1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_operationId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns7:operationId", &(a->ns7__ProductionOperation::operationId), "ns3:Identifier"))
				{	soap_flag_operationId1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:rawBatch", 1, NULL)) {
				if(a->ns7__ProductionOperation::rawBatch == NULL) {
					if(soap_blist_rawBatch1 == NULL)
						soap_blist_rawBatch1 = soap_new_block(soap);
					a->ns7__ProductionOperation::rawBatch = (ns7__RawBatch **)soap_push_block(soap, soap_blist_rawBatch1, sizeof(ns7__RawBatch *));
					if(a->ns7__ProductionOperation::rawBatch == NULL)
						return NULL;
					*a->ns7__ProductionOperation::rawBatch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__RawBatch(soap, "ns7:rawBatch", a->ns7__ProductionOperation::rawBatch, "ns7:RawBatch"))
				{	a->ns7__ProductionOperation::__sizerawBatch++;
					a->ns7__ProductionOperation::rawBatch = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:productiveBatch", 1, NULL)) {
				if(a->ns7__ProductionOperation::productiveBatch == NULL) {
					if(soap_blist_productiveBatch1 == NULL)
						soap_blist_productiveBatch1 = soap_new_block(soap);
					a->ns7__ProductionOperation::productiveBatch = (ns7__ProductiveBatch **)soap_push_block(soap, soap_blist_productiveBatch1, sizeof(ns7__ProductiveBatch *));
					if(a->ns7__ProductionOperation::productiveBatch == NULL)
						return NULL;
					*a->ns7__ProductionOperation::productiveBatch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__ProductiveBatch(soap, "ns7:productiveBatch", a->ns7__ProductionOperation::productiveBatch, "ns7:ProductiveBatch"))
				{	a->ns7__ProductionOperation::__sizeproductiveBatch++;
					a->ns7__ProductionOperation::productiveBatch = NULL;
					continue;
				}
			}
			if(soap_flag_finalizeOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:finalizeOperation", &(a->ns7__ProductionOperation::finalizeOperation), "xsd:boolean"))
				{	soap_flag_finalizeOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:appliedProcess", 1, NULL)) {
				if(a->ns7__ProductionOperation::appliedProcess == NULL) {
					if(soap_blist_appliedProcess1 == NULL)
						soap_blist_appliedProcess1 = soap_new_block(soap);
					a->ns7__ProductionOperation::appliedProcess = (ns7__ProcessingProcedure **)soap_push_block(soap, soap_blist_appliedProcess1, sizeof(ns7__ProcessingProcedure *));
					if(a->ns7__ProductionOperation::appliedProcess == NULL)
						return NULL;
					*a->ns7__ProductionOperation::appliedProcess = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__ProcessingProcedure(soap, "ns7:appliedProcess", a->ns7__ProductionOperation::appliedProcess, "ns7:ProcessingProcedure"))
				{	a->ns7__ProductionOperation::__sizeappliedProcess++;
					a->ns7__ProductionOperation::appliedProcess = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__ProductionOperation::rawBatch)
			soap_pop_block(soap, soap_blist_rawBatch1);
		if(a->ns7__ProductionOperation::__sizerawBatch)
			a->ns7__ProductionOperation::rawBatch = (ns7__RawBatch **)soap_save_block(soap, soap_blist_rawBatch1, NULL, 1);
		else
		{	a->ns7__ProductionOperation::rawBatch = NULL;
			if(soap_blist_rawBatch1)
				soap_end_block(soap, soap_blist_rawBatch1);
		}
		if(a->ns7__ProductionOperation::productiveBatch)
			soap_pop_block(soap, soap_blist_productiveBatch1);
		if(a->ns7__ProductionOperation::__sizeproductiveBatch)
			a->ns7__ProductionOperation::productiveBatch = (ns7__ProductiveBatch **)soap_save_block(soap, soap_blist_productiveBatch1, NULL, 1);
		else
		{	a->ns7__ProductionOperation::productiveBatch = NULL;
			if(soap_blist_productiveBatch1)
				soap_end_block(soap, soap_blist_productiveBatch1);
		}
		if(a->ns7__ProductionOperation::appliedProcess)
			soap_pop_block(soap, soap_blist_appliedProcess1);
		if(a->ns7__ProductionOperation::__sizeappliedProcess)
			a->ns7__ProductionOperation::appliedProcess = (ns7__ProcessingProcedure **)soap_save_block(soap, soap_blist_appliedProcess1, NULL, 1);
		else
		{	a->ns7__ProductionOperation::appliedProcess = NULL;
			if(soap_blist_appliedProcess1)
				soap_end_block(soap, soap_blist_appliedProcess1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ProductionOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ProductionOperation, 0, sizeof(ns7__ProductionOperation), 0, soap_copy_ns7__ProductionOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__ProductionOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ProductionOperation);
	return this->soap_out(soap, tag?tag:"ns7:ProductionOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ProductionOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ProductionOperation(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ProductionOperation * SOAP_FMAC4 soap_get_ns7__ProductionOperation(struct soap *soap, ns7__ProductionOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ProductionOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ProductionOperation * FASTCALL soap_instantiate_ns7__ProductionOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ProductionOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ProductionOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ProductionOperation);
		ASSIGN_PTR(size, sizeof(ns7__ProductionOperation));
		((ns7__ProductionOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ProductionOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ProductionOperation));
		for(int i = 0; i < n; i++)
			((ns7__ProductionOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ProductionOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ProductionOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ProductionOperation %p -> %p\n", q, p));
	*(ns7__ProductionOperation*)p = *(ns7__ProductionOperation*)q;
}

void ns7__ShipmentRoute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ShipmentRoute::__sizeroutePoint = 0;
	this->ns7__ShipmentRoute::routePoint = NULL;
	/* transient soap skipped */
}

void ns7__ShipmentRoute::soap_serialize(struct soap *soap) const
{
	if(this->ns7__ShipmentRoute::routePoint) {
		for(int i = 0; i < this->ns7__ShipmentRoute::__sizeroutePoint; i++) {
			soap_serialize_PointerTons7__ShipmentRoutePoint(soap, this->ns7__ShipmentRoute::routePoint + i);
		}
	}
	/* transient soap skipped */
}

int ns7__ShipmentRoute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ShipmentRoute(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ShipmentRoute(struct soap *soap, const char *tag, int id, const ns7__ShipmentRoute *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ShipmentRoute), type))
		return soap->error;
	if(a->ns7__ShipmentRoute::routePoint) {
		int i;
		for(i = 0; i < a->ns7__ShipmentRoute::__sizeroutePoint; i++)
			if(soap_out_PointerTons7__ShipmentRoutePoint(soap, "ns7:routePoint", -1, a->ns7__ShipmentRoute::routePoint + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__ShipmentRoute::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ShipmentRoute(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ShipmentRoute * FASTCALL soap_in_ns7__ShipmentRoute(struct soap *soap, const char *tag, ns7__ShipmentRoute *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ShipmentRoute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ShipmentRoute, sizeof(ns7__ShipmentRoute), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ShipmentRoute) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ShipmentRoute *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_routePoint1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:routePoint", 1, NULL)) {
				if(a->ns7__ShipmentRoute::routePoint == NULL) {
					if(soap_blist_routePoint1 == NULL)
						soap_blist_routePoint1 = soap_new_block(soap);
					a->ns7__ShipmentRoute::routePoint = (ns7__ShipmentRoutePoint **)soap_push_block(soap, soap_blist_routePoint1, sizeof(ns7__ShipmentRoutePoint *));
					if(a->ns7__ShipmentRoute::routePoint == NULL)
						return NULL;
					*a->ns7__ShipmentRoute::routePoint = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__ShipmentRoutePoint(soap, "ns7:routePoint", a->ns7__ShipmentRoute::routePoint, "ns7:ShipmentRoutePoint"))
				{	a->ns7__ShipmentRoute::__sizeroutePoint++;
					a->ns7__ShipmentRoute::routePoint = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__ShipmentRoute::routePoint)
			soap_pop_block(soap, soap_blist_routePoint1);
		if(a->ns7__ShipmentRoute::__sizeroutePoint)
			a->ns7__ShipmentRoute::routePoint = (ns7__ShipmentRoutePoint **)soap_save_block(soap, soap_blist_routePoint1, NULL, 1);
		else
		{	a->ns7__ShipmentRoute::routePoint = NULL;
			if(soap_blist_routePoint1)
				soap_end_block(soap, soap_blist_routePoint1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ShipmentRoute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ShipmentRoute, 0, sizeof(ns7__ShipmentRoute), 0, soap_copy_ns7__ShipmentRoute);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__ShipmentRoute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ShipmentRoute);
	return this->soap_out(soap, tag?tag:"ns7:ShipmentRoute", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ShipmentRoute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ShipmentRoute(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ShipmentRoute * SOAP_FMAC4 soap_get_ns7__ShipmentRoute(struct soap *soap, ns7__ShipmentRoute *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ShipmentRoute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ShipmentRoute * FASTCALL soap_instantiate_ns7__ShipmentRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ShipmentRoute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ShipmentRoute, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ShipmentRoute);
		ASSIGN_PTR(size, sizeof(ns7__ShipmentRoute));
		((ns7__ShipmentRoute*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ShipmentRoute[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ShipmentRoute));
		for(int i = 0; i < n; i++)
			((ns7__ShipmentRoute*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ShipmentRoute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ShipmentRoute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ShipmentRoute %p -> %p\n", q, p));
	*(ns7__ShipmentRoute*)p = *(ns7__ShipmentRoute*)q;
}

void ns7__ShipmentRoutePoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ShipmentRoutePoint::sqnId = NULL;
	this->ns7__ShipmentRoutePoint::__union_ShipmentRoutePoint = 0;
	this->ns7__ShipmentRoutePoint::transshipment = NULL;
	this->ns7__ShipmentRoutePoint::nextTransport = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__ShipmentRoutePoint::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__SequenceNumber(soap, &this->ns7__ShipmentRoutePoint::sqnId);
	soap_serialize__ns7__union_ShipmentRoutePoint(soap, this->ns7__ShipmentRoutePoint::__union_ShipmentRoutePoint, &this->ns7__ShipmentRoutePoint::union_ShipmentRoutePoint);
	soap_serialize_PointerTobool(soap, &this->ns7__ShipmentRoutePoint::transshipment);
	soap_serialize_PointerTons7__TransportInfo(soap, &this->ns7__ShipmentRoutePoint::nextTransport);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__ShipmentRoutePoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ShipmentRoutePoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, const ns7__ShipmentRoutePoint *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ShipmentRoutePoint), "ns7:ShipmentRoutePoint"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTons3__SequenceNumber(soap, "ns7:sqnId", -1, &(a->ns7__ShipmentRoutePoint::sqnId), ""))
		return soap->error;
	if(soap_out__ns7__union_ShipmentRoutePoint(soap, a->ns7__ShipmentRoutePoint::__union_ShipmentRoutePoint, &a->ns7__ShipmentRoutePoint::union_ShipmentRoutePoint))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:transshipment", -1, &(a->ns7__ShipmentRoutePoint::transshipment), ""))
		return soap->error;
	if(soap_out_PointerTons7__TransportInfo(soap, "ns7:nextTransport", -1, &(a->ns7__ShipmentRoutePoint::nextTransport), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__ShipmentRoutePoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ShipmentRoutePoint(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ShipmentRoutePoint * FASTCALL soap_in_ns7__ShipmentRoutePoint(struct soap *soap, const char *tag, ns7__ShipmentRoutePoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ShipmentRoutePoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ShipmentRoutePoint, sizeof(ns7__ShipmentRoutePoint), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ShipmentRoutePoint) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ShipmentRoutePoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_sqnId1 = 1;
	size_t soap_flag_union_ShipmentRoutePoint1 = 1;
	size_t soap_flag_transshipment1 = 1;
	size_t soap_flag_nextTransport1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_sqnId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__SequenceNumber(soap, "ns7:sqnId", &(a->ns7__ShipmentRoutePoint::sqnId), "ns3:SequenceNumber"))
				{	soap_flag_sqnId1--;
					continue;
				}
			if(soap_flag_union_ShipmentRoutePoint1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_ShipmentRoutePoint(soap, &a->ns7__ShipmentRoutePoint::__union_ShipmentRoutePoint, &a->ns7__ShipmentRoutePoint::union_ShipmentRoutePoint))
				{	soap_flag_union_ShipmentRoutePoint1 = 0;
					continue;
				}
			if(soap_flag_transshipment1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:transshipment", &(a->ns7__ShipmentRoutePoint::transshipment), "xsd:boolean"))
				{	soap_flag_transshipment1--;
					continue;
				}
			if(soap_flag_nextTransport1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__TransportInfo(soap, "ns7:nextTransport", &(a->ns7__ShipmentRoutePoint::nextTransport), "ns7:TransportInfo"))
				{	soap_flag_nextTransport1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ShipmentRoutePoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ShipmentRoutePoint, 0, sizeof(ns7__ShipmentRoutePoint), 0, soap_copy_ns7__ShipmentRoutePoint);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__ShipmentRoutePoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ShipmentRoutePoint);
	return this->soap_out(soap, tag?tag:"ns7:ShipmentRoutePoint", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ShipmentRoutePoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ShipmentRoutePoint(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ShipmentRoutePoint * SOAP_FMAC4 soap_get_ns7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ShipmentRoutePoint * FASTCALL soap_instantiate_ns7__ShipmentRoutePoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ShipmentRoutePoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ShipmentRoutePoint, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ShipmentRoutePoint);
		ASSIGN_PTR(size, sizeof(ns7__ShipmentRoutePoint));
		((ns7__ShipmentRoutePoint*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ShipmentRoutePoint[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ShipmentRoutePoint));
		for(int i = 0; i < n; i++)
			((ns7__ShipmentRoutePoint*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ShipmentRoutePoint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ShipmentRoutePoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ShipmentRoutePoint %p -> %p\n", q, p));
	*(ns7__ShipmentRoutePoint*)p = *(ns7__ShipmentRoutePoint*)q;
}

void ns7__TransportNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns7__TransportNumber::containerNumber);
	soap_default_ns3__String255(soap, &this->ns7__TransportNumber::wagonNumber);
	soap_default_ns3__String255(soap, &this->ns7__TransportNumber::vehicleNumber);
	soap_default_ns3__String255(soap, &this->ns7__TransportNumber::trailerNumber);
	soap_default_ns3__String255(soap, &this->ns7__TransportNumber::shipName);
	soap_default_ns3__String255(soap, &this->ns7__TransportNumber::flightNumber);
	/* transient soap skipped */
}

void ns7__TransportNumber::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns7__TransportNumber::containerNumber);
	soap_serialize_ns3__String255(soap, &this->ns7__TransportNumber::wagonNumber);
	soap_serialize_ns3__String255(soap, &this->ns7__TransportNumber::vehicleNumber);
	soap_serialize_ns3__String255(soap, &this->ns7__TransportNumber::trailerNumber);
	soap_serialize_ns3__String255(soap, &this->ns7__TransportNumber::shipName);
	soap_serialize_ns3__String255(soap, &this->ns7__TransportNumber::flightNumber);
	/* transient soap skipped */
}

int ns7__TransportNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__TransportNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__TransportNumber(struct soap *soap, const char *tag, int id, const ns7__TransportNumber *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__TransportNumber), type))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:containerNumber", -1, &(a->ns7__TransportNumber::containerNumber), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:wagonNumber", -1, &(a->ns7__TransportNumber::wagonNumber), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:vehicleNumber", -1, &(a->ns7__TransportNumber::vehicleNumber), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:trailerNumber", -1, &(a->ns7__TransportNumber::trailerNumber), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:shipName", -1, &(a->ns7__TransportNumber::shipName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:flightNumber", -1, &(a->ns7__TransportNumber::flightNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__TransportNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__TransportNumber(soap, tag, this, type);
}

SOAP_FMAC3 ns7__TransportNumber * FASTCALL soap_in_ns7__TransportNumber(struct soap *soap, const char *tag, ns7__TransportNumber *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__TransportNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__TransportNumber, sizeof(ns7__TransportNumber), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__TransportNumber) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__TransportNumber *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_containerNumber1 = 1;
	size_t soap_flag_wagonNumber1 = 1;
	size_t soap_flag_vehicleNumber1 = 1;
	size_t soap_flag_trailerNumber1 = 1;
	size_t soap_flag_shipName1 = 1;
	size_t soap_flag_flightNumber1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_containerNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:containerNumber", &(a->ns7__TransportNumber::containerNumber), "ns3:String255"))
				{	soap_flag_containerNumber1--;
					continue;
				}
			if(soap_flag_wagonNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:wagonNumber", &(a->ns7__TransportNumber::wagonNumber), "ns3:String255"))
				{	soap_flag_wagonNumber1--;
					continue;
				}
			if(soap_flag_vehicleNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:vehicleNumber", &(a->ns7__TransportNumber::vehicleNumber), "ns3:String255"))
				{	soap_flag_vehicleNumber1--;
					continue;
				}
			if(soap_flag_trailerNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:trailerNumber", &(a->ns7__TransportNumber::trailerNumber), "ns3:String255"))
				{	soap_flag_trailerNumber1--;
					continue;
				}
			if(soap_flag_shipName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:shipName", &(a->ns7__TransportNumber::shipName), "ns3:String255"))
				{	soap_flag_shipName1--;
					continue;
				}
			if(soap_flag_flightNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:flightNumber", &(a->ns7__TransportNumber::flightNumber), "ns3:String255"))
				{	soap_flag_flightNumber1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__TransportNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__TransportNumber, 0, sizeof(ns7__TransportNumber), 0, soap_copy_ns7__TransportNumber);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__TransportNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__TransportNumber);
	return this->soap_out(soap, tag?tag:"ns7:TransportNumber", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__TransportNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__TransportNumber(soap, this, tag, type);
}

SOAP_FMAC3 ns7__TransportNumber * SOAP_FMAC4 soap_get_ns7__TransportNumber(struct soap *soap, ns7__TransportNumber *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__TransportNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__TransportNumber * FASTCALL soap_instantiate_ns7__TransportNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__TransportNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__TransportNumber, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__TransportNumber);
		ASSIGN_PTR(size, sizeof(ns7__TransportNumber));
		((ns7__TransportNumber*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__TransportNumber[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__TransportNumber));
		for(int i = 0; i < n; i++)
			((ns7__TransportNumber*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__TransportNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__TransportNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__TransportNumber %p -> %p\n", q, p));
	*(ns7__TransportNumber*)p = *(ns7__TransportNumber*)q;
}

void ns7__TransportInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__TransportInfo::transportType = NULL;
	this->ns7__TransportInfo::transportNumber = NULL;
	/* transient soap skipped */
}

void ns7__TransportInfo::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__TransportType(soap, &this->ns7__TransportInfo::transportType);
	soap_serialize_PointerTons7__TransportNumber(soap, &this->ns7__TransportInfo::transportNumber);
	/* transient soap skipped */
}

int ns7__TransportInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__TransportInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__TransportInfo(struct soap *soap, const char *tag, int id, const ns7__TransportInfo *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__TransportInfo), type))
		return soap->error;
	if(soap_out_PointerTons6__TransportType(soap, "ns7:transportType", -1, &(a->ns7__TransportInfo::transportType), ""))
		return soap->error;
	if(soap_out_PointerTons7__TransportNumber(soap, "ns7:transportNumber", -1, &(a->ns7__TransportInfo::transportNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__TransportInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__TransportInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns7__TransportInfo * FASTCALL soap_in_ns7__TransportInfo(struct soap *soap, const char *tag, ns7__TransportInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__TransportInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__TransportInfo, sizeof(ns7__TransportInfo), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__TransportInfo) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__TransportInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_transportType1 = 1;
	size_t soap_flag_transportNumber1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_transportType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__TransportType(soap, "ns7:transportType", &(a->ns7__TransportInfo::transportType), "ns6:TransportType"))
				{	soap_flag_transportType1--;
					continue;
				}
			if(soap_flag_transportNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__TransportNumber(soap, "ns7:transportNumber", &(a->ns7__TransportInfo::transportNumber), "ns7:TransportNumber"))
				{	soap_flag_transportNumber1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__TransportInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__TransportInfo, 0, sizeof(ns7__TransportInfo), 0, soap_copy_ns7__TransportInfo);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__TransportInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__TransportInfo);
	return this->soap_out(soap, tag?tag:"ns7:TransportInfo", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__TransportInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__TransportInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns7__TransportInfo * SOAP_FMAC4 soap_get_ns7__TransportInfo(struct soap *soap, ns7__TransportInfo *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__TransportInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__TransportInfo * FASTCALL soap_instantiate_ns7__TransportInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__TransportInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__TransportInfo, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__TransportInfo);
		ASSIGN_PTR(size, sizeof(ns7__TransportInfo));
		((ns7__TransportInfo*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__TransportInfo[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__TransportInfo));
		for(int i = 0; i < n; i++)
			((ns7__TransportInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__TransportInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__TransportInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__TransportInfo %p -> %p\n", q, p));
	*(ns7__TransportInfo*)p = *(ns7__TransportInfo*)q;
}

void ns7__Waybill::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__Waybill::consignor = NULL;
	this->ns7__Waybill::consignee = NULL;
	this->ns7__Waybill::broker = NULL;
	this->ns7__Waybill::transportInfo = NULL;
	this->ns7__Waybill::transportStorageType = NULL;
	this->ns7__Waybill::shipmentRoute = NULL;
	soap_default_ns3__String255(soap, &this->ns7__Document::name);
	soap_default_ns3__String255(soap, &this->ns7__Document::form);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_default_xsd__date(soap, &this->ns7__Document::issueDate);
	this->ns7__Document::type = NULL;
	this->ns7__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->ns7__Document::for_);
	this->ns7__Document::qualifier = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__Waybill::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__Waybill::consignor);
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__Waybill::consignee);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__Waybill::broker);
	soap_serialize_PointerTons7__TransportInfo(soap, &this->ns7__Waybill::transportInfo);
	soap_serialize_PointerTons6__TransportationStorageType(soap, &this->ns7__Waybill::transportStorageType);
	soap_serialize_PointerTons7__ShipmentRoute(soap, &this->ns7__Waybill::shipmentRoute);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::name);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::form);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->ns7__Document::issueDate);
	soap_serialize_PointerTons6__DocumentType(soap, &this->ns7__Document::type);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__Document::issuer);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__Waybill::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Waybill(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__Waybill(struct soap *soap, const char *tag, int id, const ns7__Waybill *a, const char *type)
{
	if(((ns7__Document*)a)->for_)
		soap_set_attr(soap, "for", ((ns7__Document*)a)->for_, 1);
	if(((ns7__Document*)a)->qualifier)
		if(*((ns7__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns7__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Waybill), "ns7:Waybill"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__Document::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:form", -1, &(a->ns7__Document::form), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueSeries", -1, &(a->ns7__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueNumber", -1, &(a->ns7__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "ns7:issueDate", -1, &(a->ns7__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__DocumentType(soap, "ns7:type", -1, &(a->ns7__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:issuer", -1, &(a->ns7__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:consignor", -1, &(a->ns7__Waybill::consignor), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:consignee", -1, &(a->ns7__Waybill::consignee), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:broker", -1, &(a->ns7__Waybill::broker), ""))
		return soap->error;
	if(soap_out_PointerTons7__TransportInfo(soap, "ns7:transportInfo", -1, &(a->ns7__Waybill::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerTons6__TransportationStorageType(soap, "ns7:transportStorageType", -1, &(a->ns7__Waybill::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", -1, &(a->ns7__Waybill::shipmentRoute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Waybill::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__Waybill(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Waybill * FASTCALL soap_in_ns7__Waybill(struct soap *soap, const char *tag, ns7__Waybill *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Waybill *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Waybill, sizeof(ns7__Waybill), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__Waybill) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__Waybill *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((ns7__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns7__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns7__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__Document::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:form", &(a->ns7__Document::form), "ns3:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueSeries", &(a->ns7__Document::issueSeries), "ns3:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueNumber", &(a->ns7__Document::issueNumber), "ns3:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "ns7:issueDate", &(a->ns7__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DocumentType(soap, "ns7:type", &(a->ns7__Document::type), "ns6:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:issuer", &(a->ns7__Document::issuer), "ns6:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:consignor", &(a->ns7__Waybill::consignor), "ns6:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:consignee", &(a->ns7__Waybill::consignee), "ns6:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:broker", &(a->ns7__Waybill::broker), "ns6:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__TransportInfo(soap, "ns7:transportInfo", &(a->ns7__Waybill::transportInfo), "ns7:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__TransportationStorageType(soap, "ns7:transportStorageType", &(a->ns7__Waybill::transportStorageType), "ns6:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", &(a->ns7__Waybill::shipmentRoute), "ns7:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__Waybill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Waybill, 0, sizeof(ns7__Waybill), 0, soap_copy_ns7__Waybill);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__Waybill::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__Waybill);
	return this->soap_out(soap, tag?tag:"ns7:Waybill", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__Waybill::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Waybill(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Waybill * SOAP_FMAC4 soap_get_ns7__Waybill(struct soap *soap, ns7__Waybill *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__Waybill(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__Waybill * FASTCALL soap_instantiate_ns7__Waybill(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Waybill(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__Waybill, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__Waybill);
		ASSIGN_PTR(size, sizeof(ns7__Waybill));
		((ns7__Waybill*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__Waybill[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__Waybill));
		for(int i = 0; i < n; i++)
			((ns7__Waybill*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__Waybill*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__Waybill(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__Waybill %p -> %p\n", q, p));
	*(ns7__Waybill*)p = *(ns7__Waybill*)q;
}

void ns7__Document::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns7__Document::name);
	soap_default_ns3__String255(soap, &this->ns7__Document::form);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_default_xsd__date(soap, &this->ns7__Document::issueDate);
	this->ns7__Document::type = NULL;
	this->ns7__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->ns7__Document::for_);
	this->ns7__Document::qualifier = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__Document::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns7__Document::name);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::form);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->ns7__Document::issueDate);
	soap_serialize_PointerTons6__DocumentType(soap, &this->ns7__Document::type);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__Document::issuer);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__Document::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Document(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__Document(struct soap *soap, const char *tag, int id, const ns7__Document *a, const char *type)
{
	if(((ns7__Document*)a)->for_)
		soap_set_attr(soap, "for", ((ns7__Document*)a)->for_, 1);
	if(((ns7__Document*)a)->qualifier)
		if(*((ns7__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns7__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Document), "ns7:Document"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__Document::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:form", -1, &(a->ns7__Document::form), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueSeries", -1, &(a->ns7__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueNumber", -1, &(a->ns7__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "ns7:issueDate", -1, &(a->ns7__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__DocumentType(soap, "ns7:type", -1, &(a->ns7__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:issuer", -1, &(a->ns7__Document::issuer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Document::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__Document(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Document * FASTCALL soap_in_ns7__Document(struct soap *soap, const char *tag, ns7__Document *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Document *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Document, sizeof(ns7__Document), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__Document) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__Document *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((ns7__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns7__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns7__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_form1 = 1;
	size_t soap_flag_issueSeries1 = 1;
	size_t soap_flag_issueNumber1 = 1;
	size_t soap_flag_issueDate1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_issuer1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__Document::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_form1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:form", &(a->ns7__Document::form), "ns3:String255"))
				{	soap_flag_form1--;
					continue;
				}
			if(soap_flag_issueSeries1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueSeries", &(a->ns7__Document::issueSeries), "ns3:String255"))
				{	soap_flag_issueSeries1--;
					continue;
				}
			if(soap_flag_issueNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueNumber", &(a->ns7__Document::issueNumber), "ns3:String255"))
				{	soap_flag_issueNumber1--;
					continue;
				}
			if(soap_flag_issueDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "ns7:issueDate", &(a->ns7__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DocumentType(soap, "ns7:type", &(a->ns7__Document::type), "ns6:DocumentType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_issuer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:issuer", &(a->ns7__Document::issuer), "ns6:Organization"))
				{	soap_flag_issuer1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__Document *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Document, 0, sizeof(ns7__Document), 0, soap_copy_ns7__Document);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__Document::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__Document);
	return this->soap_out(soap, tag?tag:"ns7:Document", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__Document::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Document(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Document * SOAP_FMAC4 soap_get_ns7__Document(struct soap *soap, ns7__Document *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__Document * FASTCALL soap_instantiate_ns7__Document(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Document(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__Document, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns7:VetDocument")) {
		cp->type = SOAP_TYPE_ns7__VetDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__VetDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__VetDocument));
			((ns7__VetDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__VetDocument[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__VetDocument));
			for(int i = 0; i < n; i++)
				((ns7__VetDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__VetDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:DiscrepancyReport")) {
		cp->type = SOAP_TYPE_ns7__DiscrepancyReport;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReport);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__DiscrepancyReport));
			((ns7__DiscrepancyReport*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReport[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__DiscrepancyReport));
			for(int i = 0; i < n; i++)
				((ns7__DiscrepancyReport*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__DiscrepancyReport*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:Waybill")) {
		cp->type = SOAP_TYPE_ns7__Waybill;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__Waybill);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__Waybill));
			((ns7__Waybill*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__Waybill[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__Waybill));
			for(int i = 0; i < n; i++)
				((ns7__Waybill*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__Waybill*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:ReferencedDocument")) {
		cp->type = SOAP_TYPE_ns7__ReferencedDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__ReferencedDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__ReferencedDocument));
			((ns7__ReferencedDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__ReferencedDocument[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__ReferencedDocument));
			for(int i = 0; i < n; i++)
				((ns7__ReferencedDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ReferencedDocument*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__Document);
		ASSIGN_PTR(size, sizeof(ns7__Document));
		((ns7__Document*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__Document[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__Document));
		for(int i = 0; i < n; i++)
			((ns7__Document*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__Document*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__Document(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__Document %p -> %p\n", q, p));
	*(ns7__Document*)p = *(ns7__Document*)q;
}

void ns7__StockEntrySearchPattern::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__StockEntrySearchPattern::blankFilter = NULL;
	soap_default_ns7__StockEntryNumber(soap, &this->ns7__StockEntry::entryNumber);
	this->ns7__StockEntry::batch = NULL;
	this->ns7__StockEntry::__sizevetDocument = 0;
	this->ns7__StockEntry::vetDocument = NULL;
	this->ns7__StockEntry::vetEventList = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__StockEntrySearchPattern::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryBlankFilter(soap, &this->ns7__StockEntrySearchPattern::blankFilter);
	soap_serialize_ns7__StockEntryNumber(soap, &this->ns7__StockEntry::entryNumber);
	soap_serialize_PointerTons7__Batch(soap, &this->ns7__StockEntry::batch);
	if(this->ns7__StockEntry::vetDocument) {
		for(int i = 0; i < this->ns7__StockEntry::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns7__StockEntry::vetDocument + i);
		}
	}
	soap_serialize_PointerTons7__StockEntryEventList(soap, &this->ns7__StockEntry::vetEventList);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__StockEntrySearchPattern::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__StockEntrySearchPattern(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockEntrySearchPattern(struct soap *soap, const char *tag, int id, const ns7__StockEntrySearchPattern *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__StockEntrySearchPattern), "ns7:StockEntrySearchPattern"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns7__StockEntryNumber(soap, "ns7:entryNumber", -1, &(a->ns7__StockEntry::entryNumber), ""))
		return soap->error;
	if(soap_out_PointerTons7__Batch(soap, "ns7:batch", -1, &(a->ns7__StockEntry::batch), ""))
		return soap->error;
	if(a->ns7__StockEntry::vetDocument) {
		int i;
		for(i = 0; i < a->ns7__StockEntry::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns7:vetDocument", -1, a->ns7__StockEntry::vetDocument + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons7__StockEntryEventList(soap, "ns7:vetEventList", -1, &(a->ns7__StockEntry::vetEventList), ""))
		return soap->error;
	if(soap_out_PointerTons7__StockEntryBlankFilter(soap, "ns7:blankFilter", -1, &(a->ns7__StockEntrySearchPattern::blankFilter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__StockEntrySearchPattern::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__StockEntrySearchPattern(soap, tag, this, type);
}

SOAP_FMAC3 ns7__StockEntrySearchPattern * FASTCALL soap_in_ns7__StockEntrySearchPattern(struct soap *soap, const char *tag, ns7__StockEntrySearchPattern *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__StockEntrySearchPattern *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__StockEntrySearchPattern, sizeof(ns7__StockEntrySearchPattern), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__StockEntrySearchPattern) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__StockEntrySearchPattern *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_entryNumber2 = 1;
	size_t soap_flag_batch2 = 1;
	struct soap_blist *soap_blist_vetDocument2 = NULL;
	size_t soap_flag_vetEventList2 = 1;
	size_t soap_flag_blankFilter1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_entryNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns7__StockEntryNumber(soap, "ns7:entryNumber", &(a->ns7__StockEntry::entryNumber), "ns7:StockEntryNumber"))
				{	soap_flag_entryNumber2--;
					continue;
				}
			if(soap_flag_batch2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Batch(soap, "ns7:batch", &(a->ns7__StockEntry::batch), "ns7:Batch"))
				{	soap_flag_batch2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:vetDocument", 1, NULL)) {
				if(a->ns7__StockEntry::vetDocument == NULL) {
					if(soap_blist_vetDocument2 == NULL)
						soap_blist_vetDocument2 = soap_new_block(soap);
					a->ns7__StockEntry::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument2, sizeof(ns7__VetDocument *));
					if(a->ns7__StockEntry::vetDocument == NULL)
						return NULL;
					*a->ns7__StockEntry::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns7:vetDocument", a->ns7__StockEntry::vetDocument, "ns7:VetDocument"))
				{	a->ns7__StockEntry::__sizevetDocument++;
					a->ns7__StockEntry::vetDocument = NULL;
					continue;
				}
			}
			if(soap_flag_vetEventList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryEventList(soap, "ns7:vetEventList", &(a->ns7__StockEntry::vetEventList), "ns7:StockEntryEventList"))
				{	soap_flag_vetEventList2--;
					continue;
				}
			if(soap_flag_blankFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryBlankFilter(soap, "ns7:blankFilter", &(a->ns7__StockEntrySearchPattern::blankFilter), "ns7:StockEntryBlankFilter"))
				{	soap_flag_blankFilter1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__StockEntry::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument2);
		if(a->ns7__StockEntry::__sizevetDocument)
			a->ns7__StockEntry::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument2, NULL, 1);
		else
		{	a->ns7__StockEntry::vetDocument = NULL;
			if(soap_blist_vetDocument2)
				soap_end_block(soap, soap_blist_vetDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__StockEntrySearchPattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__StockEntrySearchPattern, 0, sizeof(ns7__StockEntrySearchPattern), 0, soap_copy_ns7__StockEntrySearchPattern);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__StockEntrySearchPattern::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__StockEntrySearchPattern);
	return this->soap_out(soap, tag?tag:"ns7:StockEntrySearchPattern", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__StockEntrySearchPattern::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__StockEntrySearchPattern(soap, this, tag, type);
}

SOAP_FMAC3 ns7__StockEntrySearchPattern * SOAP_FMAC4 soap_get_ns7__StockEntrySearchPattern(struct soap *soap, ns7__StockEntrySearchPattern *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockEntrySearchPattern(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__StockEntrySearchPattern * FASTCALL soap_instantiate_ns7__StockEntrySearchPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__StockEntrySearchPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__StockEntrySearchPattern, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern);
		ASSIGN_PTR(size, sizeof(ns7__StockEntrySearchPattern));
		((ns7__StockEntrySearchPattern*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__StockEntrySearchPattern));
		for(int i = 0; i < n; i++)
			((ns7__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__StockEntrySearchPattern*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__StockEntrySearchPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__StockEntrySearchPattern %p -> %p\n", q, p));
	*(ns7__StockEntrySearchPattern*)p = *(ns7__StockEntrySearchPattern*)q;
}

void ns7__StockDiscrepancy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__StockDiscrepancy::affectedList = NULL;
	this->ns7__StockDiscrepancy::resultingList = NULL;
	soap_default_string(soap, &this->ns7__StockDiscrepancy::reason);
	soap_default_xsd__ID(soap, &this->ns7__StockDiscrepancy::id);
	/* transient soap skipped */
}

void ns7__StockDiscrepancy::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns7__StockDiscrepancy::affectedList);
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns7__StockDiscrepancy::resultingList);
	soap_serialize_string(soap, &this->ns7__StockDiscrepancy::reason);
	/* transient soap skipped */
}

int ns7__StockDiscrepancy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__StockDiscrepancy(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockDiscrepancy(struct soap *soap, const char *tag, int id, const ns7__StockDiscrepancy *a, const char *type)
{
	if(((ns7__StockDiscrepancy*)a)->id)
		soap_set_attr(soap, "id", ((ns7__StockDiscrepancy*)a)->id, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__StockDiscrepancy), type))
		return soap->error;
	if(soap_out_PointerTons7__StockEntryList(soap, "ns7:affectedList", -1, &(a->ns7__StockDiscrepancy::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTons7__StockEntryList(soap, "ns7:resultingList", -1, &(a->ns7__StockDiscrepancy::resultingList), ""))
		return soap->error;
	if(soap_out_string(soap, "ns7:reason", -1, &(a->ns7__StockDiscrepancy::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__StockDiscrepancy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__StockDiscrepancy(soap, tag, this, type);
}

SOAP_FMAC3 ns7__StockDiscrepancy * FASTCALL soap_in_ns7__StockDiscrepancy(struct soap *soap, const char *tag, ns7__StockDiscrepancy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__StockDiscrepancy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__StockDiscrepancy, sizeof(ns7__StockDiscrepancy), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__StockDiscrepancy) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__StockDiscrepancy *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((ns7__StockDiscrepancy*)a)->id, 0, -1))
		return NULL;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns7:affectedList", &(a->ns7__StockDiscrepancy::affectedList), "ns7:StockEntryList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns7:resultingList", &(a->ns7__StockDiscrepancy::resultingList), "ns7:StockEntryList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns7:reason", &(a->ns7__StockDiscrepancy::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__StockDiscrepancy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__StockDiscrepancy, 0, sizeof(ns7__StockDiscrepancy), 0, soap_copy_ns7__StockDiscrepancy);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__StockDiscrepancy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__StockDiscrepancy);
	return this->soap_out(soap, tag?tag:"ns7:StockDiscrepancy", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__StockDiscrepancy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__StockDiscrepancy(soap, this, tag, type);
}

SOAP_FMAC3 ns7__StockDiscrepancy * SOAP_FMAC4 soap_get_ns7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__StockDiscrepancy * FASTCALL soap_instantiate_ns7__StockDiscrepancy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__StockDiscrepancy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__StockDiscrepancy, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__StockDiscrepancy);
		ASSIGN_PTR(size, sizeof(ns7__StockDiscrepancy));
		((ns7__StockDiscrepancy*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__StockDiscrepancy[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__StockDiscrepancy));
		for(int i = 0; i < n; i++)
			((ns7__StockDiscrepancy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__StockDiscrepancy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__StockDiscrepancy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__StockDiscrepancy %p -> %p\n", q, p));
	*(ns7__StockDiscrepancy*)p = *(ns7__StockDiscrepancy*)q;
}

void ns7__StockEntryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__StockEntryList::__sizestockEntry = 0;
	this->ns7__StockEntryList::stockEntry = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns7__StockEntryList::soap_serialize(struct soap *soap) const
{
	if(this->ns7__StockEntryList::stockEntry) {
		for(int i = 0; i < this->ns7__StockEntryList::__sizestockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns7__StockEntryList::stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int ns7__StockEntryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__StockEntryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockEntryList(struct soap *soap, const char *tag, int id, const ns7__StockEntryList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__StockEntryList), "ns7:StockEntryList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__StockEntryList::stockEntry) {
		int i;
		for(i = 0; i < a->ns7__StockEntryList::__sizestockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns7:stockEntry", -1, a->ns7__StockEntryList::stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__StockEntryList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__StockEntryList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__StockEntryList * FASTCALL soap_in_ns7__StockEntryList(struct soap *soap, const char *tag, ns7__StockEntryList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__StockEntryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__StockEntryList, sizeof(ns7__StockEntryList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__StockEntryList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__StockEntryList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:stockEntry", 1, NULL)) {
				if(a->ns7__StockEntryList::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->ns7__StockEntryList::stockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns7__StockEntryList::stockEntry == NULL)
						return NULL;
					*a->ns7__StockEntryList::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:stockEntry", a->ns7__StockEntryList::stockEntry, "ns7:StockEntry"))
				{	a->ns7__StockEntryList::__sizestockEntry++;
					a->ns7__StockEntryList::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__StockEntryList::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->ns7__StockEntryList::__sizestockEntry)
			a->ns7__StockEntryList::stockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->ns7__StockEntryList::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__StockEntryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__StockEntryList, 0, sizeof(ns7__StockEntryList), 0, soap_copy_ns7__StockEntryList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__StockEntryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__StockEntryList);
	return this->soap_out(soap, tag?tag:"ns7:StockEntryList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__StockEntryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__StockEntryList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__StockEntryList * SOAP_FMAC4 soap_get_ns7__StockEntryList(struct soap *soap, ns7__StockEntryList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockEntryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__StockEntryList * FASTCALL soap_instantiate_ns7__StockEntryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__StockEntryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__StockEntryList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntryList);
		ASSIGN_PTR(size, sizeof(ns7__StockEntryList));
		((ns7__StockEntryList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntryList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__StockEntryList));
		for(int i = 0; i < n; i++)
			((ns7__StockEntryList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__StockEntryList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__StockEntryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__StockEntryList %p -> %p\n", q, p));
	*(ns7__StockEntryList*)p = *(ns7__StockEntryList*)q;
}

void ns7__StockEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns7__StockEntryNumber(soap, &this->ns7__StockEntry::entryNumber);
	this->ns7__StockEntry::batch = NULL;
	this->ns7__StockEntry::__sizevetDocument = 0;
	this->ns7__StockEntry::vetDocument = NULL;
	this->ns7__StockEntry::vetEventList = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__StockEntry::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns7__StockEntryNumber(soap, &this->ns7__StockEntry::entryNumber);
	soap_serialize_PointerTons7__Batch(soap, &this->ns7__StockEntry::batch);
	if(this->ns7__StockEntry::vetDocument) {
		for(int i = 0; i < this->ns7__StockEntry::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns7__StockEntry::vetDocument + i);
		}
	}
	soap_serialize_PointerTons7__StockEntryEventList(soap, &this->ns7__StockEntry::vetEventList);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__StockEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__StockEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockEntry(struct soap *soap, const char *tag, int id, const ns7__StockEntry *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__StockEntry), "ns7:StockEntry"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns7__StockEntryNumber(soap, "ns7:entryNumber", -1, &(a->ns7__StockEntry::entryNumber), ""))
		return soap->error;
	if(soap_out_PointerTons7__Batch(soap, "ns7:batch", -1, &(a->ns7__StockEntry::batch), ""))
		return soap->error;
	if(a->ns7__StockEntry::vetDocument) {
		int i;
		for(i = 0; i < a->ns7__StockEntry::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns7:vetDocument", -1, a->ns7__StockEntry::vetDocument + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons7__StockEntryEventList(soap, "ns7:vetEventList", -1, &(a->ns7__StockEntry::vetEventList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__StockEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__StockEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns7__StockEntry * FASTCALL soap_in_ns7__StockEntry(struct soap *soap, const char *tag, ns7__StockEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__StockEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__StockEntry, sizeof(ns7__StockEntry), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__StockEntry) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__StockEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_entryNumber1 = 1;
	size_t soap_flag_batch1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	size_t soap_flag_vetEventList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_entryNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns7__StockEntryNumber(soap, "ns7:entryNumber", &(a->ns7__StockEntry::entryNumber), "ns7:StockEntryNumber"))
				{	soap_flag_entryNumber1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Batch(soap, "ns7:batch", &(a->ns7__StockEntry::batch), "ns7:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:vetDocument", 1, NULL)) {
				if(a->ns7__StockEntry::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->ns7__StockEntry::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns7__StockEntry::vetDocument == NULL)
						return NULL;
					*a->ns7__StockEntry::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns7:vetDocument", a->ns7__StockEntry::vetDocument, "ns7:VetDocument"))
				{	a->ns7__StockEntry::__sizevetDocument++;
					a->ns7__StockEntry::vetDocument = NULL;
					continue;
				}
			}
			if(soap_flag_vetEventList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryEventList(soap, "ns7:vetEventList", &(a->ns7__StockEntry::vetEventList), "ns7:StockEntryEventList"))
				{	soap_flag_vetEventList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__StockEntry::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->ns7__StockEntry::__sizevetDocument)
			a->ns7__StockEntry::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->ns7__StockEntry::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__StockEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__StockEntry, 0, sizeof(ns7__StockEntry), 0, soap_copy_ns7__StockEntry);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__StockEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__StockEntry);
	return this->soap_out(soap, tag?tag:"ns7:StockEntry", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__StockEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__StockEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns7__StockEntry * SOAP_FMAC4 soap_get_ns7__StockEntry(struct soap *soap, ns7__StockEntry *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__StockEntry * FASTCALL soap_instantiate_ns7__StockEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__StockEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__StockEntry, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns7:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_ns7__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__StockEntrySearchPattern));
			((ns7__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((ns7__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntry);
		ASSIGN_PTR(size, sizeof(ns7__StockEntry));
		((ns7__StockEntry*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__StockEntry[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__StockEntry));
		for(int i = 0; i < n; i++)
			((ns7__StockEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__StockEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__StockEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__StockEntry %p -> %p\n", q, p));
	*(ns7__StockEntry*)p = *(ns7__StockEntry*)q;
}

void ns7__DiscrepancyReason::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns7__DiscrepancyReason::name);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__DiscrepancyReason::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns7__DiscrepancyReason::name);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__DiscrepancyReason::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__DiscrepancyReason(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__DiscrepancyReason(struct soap *soap, const char *tag, int id, const ns7__DiscrepancyReason *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__DiscrepancyReason), "ns7:DiscrepancyReason"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__DiscrepancyReason::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__DiscrepancyReason::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__DiscrepancyReason(soap, tag, this, type);
}

SOAP_FMAC3 ns7__DiscrepancyReason * FASTCALL soap_in_ns7__DiscrepancyReason(struct soap *soap, const char *tag, ns7__DiscrepancyReason *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__DiscrepancyReason *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__DiscrepancyReason, sizeof(ns7__DiscrepancyReason), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__DiscrepancyReason) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__DiscrepancyReason *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__DiscrepancyReason::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__DiscrepancyReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__DiscrepancyReason, 0, sizeof(ns7__DiscrepancyReason), 0, soap_copy_ns7__DiscrepancyReason);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__DiscrepancyReason::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__DiscrepancyReason);
	return this->soap_out(soap, tag?tag:"ns7:DiscrepancyReason", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__DiscrepancyReason::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__DiscrepancyReason(soap, this, tag, type);
}

SOAP_FMAC3 ns7__DiscrepancyReason * SOAP_FMAC4 soap_get_ns7__DiscrepancyReason(struct soap *soap, ns7__DiscrepancyReason *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__DiscrepancyReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__DiscrepancyReason * FASTCALL soap_instantiate_ns7__DiscrepancyReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__DiscrepancyReason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__DiscrepancyReason, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReason);
		ASSIGN_PTR(size, sizeof(ns7__DiscrepancyReason));
		((ns7__DiscrepancyReason*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReason[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__DiscrepancyReason));
		for(int i = 0; i < n; i++)
			((ns7__DiscrepancyReason*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__DiscrepancyReason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__DiscrepancyReason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__DiscrepancyReason %p -> %p\n", q, p));
	*(ns7__DiscrepancyReason*)p = *(ns7__DiscrepancyReason*)q;
}

void ns7__DiscrepancyReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__DiscrepancyReport::reason = NULL;
	soap_default_string(soap, &this->ns7__DiscrepancyReport::description);
	soap_default_ns3__String255(soap, &this->ns7__Document::name);
	soap_default_ns3__String255(soap, &this->ns7__Document::form);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_default_xsd__date(soap, &this->ns7__Document::issueDate);
	this->ns7__Document::type = NULL;
	this->ns7__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->ns7__Document::for_);
	this->ns7__Document::qualifier = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__DiscrepancyReport::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__DiscrepancyReason(soap, &this->ns7__DiscrepancyReport::reason);
	soap_serialize_string(soap, &this->ns7__DiscrepancyReport::description);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::name);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::form);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->ns7__Document::issueDate);
	soap_serialize_PointerTons6__DocumentType(soap, &this->ns7__Document::type);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__Document::issuer);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__DiscrepancyReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__DiscrepancyReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__DiscrepancyReport(struct soap *soap, const char *tag, int id, const ns7__DiscrepancyReport *a, const char *type)
{
	if(((ns7__Document*)a)->for_)
		soap_set_attr(soap, "for", ((ns7__Document*)a)->for_, 1);
	if(((ns7__Document*)a)->qualifier)
		if(*((ns7__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns7__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__DiscrepancyReport), "ns7:DiscrepancyReport"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__Document::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:form", -1, &(a->ns7__Document::form), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueSeries", -1, &(a->ns7__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueNumber", -1, &(a->ns7__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "ns7:issueDate", -1, &(a->ns7__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__DocumentType(soap, "ns7:type", -1, &(a->ns7__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:issuer", -1, &(a->ns7__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTons7__DiscrepancyReason(soap, "ns7:reason", -1, &(a->ns7__DiscrepancyReport::reason), ""))
		return soap->error;
	if(soap_out_string(soap, "ns7:description", -1, &(a->ns7__DiscrepancyReport::description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__DiscrepancyReport::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__DiscrepancyReport(soap, tag, this, type);
}

SOAP_FMAC3 ns7__DiscrepancyReport * FASTCALL soap_in_ns7__DiscrepancyReport(struct soap *soap, const char *tag, ns7__DiscrepancyReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__DiscrepancyReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__DiscrepancyReport, sizeof(ns7__DiscrepancyReport), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__DiscrepancyReport) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__DiscrepancyReport *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((ns7__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns7__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns7__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_description1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__Document::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:form", &(a->ns7__Document::form), "ns3:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueSeries", &(a->ns7__Document::issueSeries), "ns3:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueNumber", &(a->ns7__Document::issueNumber), "ns3:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "ns7:issueDate", &(a->ns7__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DocumentType(soap, "ns7:type", &(a->ns7__Document::type), "ns6:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:issuer", &(a->ns7__Document::issuer), "ns6:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_reason1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__DiscrepancyReason(soap, "ns7:reason", &(a->ns7__DiscrepancyReport::reason), "ns7:DiscrepancyReason"))
				{	soap_flag_reason1--;
					continue;
				}
			if(soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns7:description", &(a->ns7__DiscrepancyReport::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__DiscrepancyReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__DiscrepancyReport, 0, sizeof(ns7__DiscrepancyReport), 0, soap_copy_ns7__DiscrepancyReport);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__DiscrepancyReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__DiscrepancyReport);
	return this->soap_out(soap, tag?tag:"ns7:DiscrepancyReport", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__DiscrepancyReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__DiscrepancyReport(soap, this, tag, type);
}

SOAP_FMAC3 ns7__DiscrepancyReport * SOAP_FMAC4 soap_get_ns7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__DiscrepancyReport * FASTCALL soap_instantiate_ns7__DiscrepancyReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__DiscrepancyReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__DiscrepancyReport, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReport);
		ASSIGN_PTR(size, sizeof(ns7__DiscrepancyReport));
		((ns7__DiscrepancyReport*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReport[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__DiscrepancyReport));
		for(int i = 0; i < n; i++)
			((ns7__DiscrepancyReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__DiscrepancyReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__DiscrepancyReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__DiscrepancyReport %p -> %p\n", q, p));
	*(ns7__DiscrepancyReport*)p = *(ns7__DiscrepancyReport*)q;
}

void ns7__VetDocumentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__VetDocumentList::__sizevetDocument = 0;
	this->ns7__VetDocumentList::vetDocument = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns7__VetDocumentList::soap_serialize(struct soap *soap) const
{
	if(this->ns7__VetDocumentList::vetDocument) {
		for(int i = 0; i < this->ns7__VetDocumentList::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns7__VetDocumentList::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int ns7__VetDocumentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__VetDocumentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocumentList(struct soap *soap, const char *tag, int id, const ns7__VetDocumentList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VetDocumentList), "ns7:VetDocumentList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__VetDocumentList::vetDocument) {
		int i;
		for(i = 0; i < a->ns7__VetDocumentList::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns7:vetDocument", -1, a->ns7__VetDocumentList::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__VetDocumentList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__VetDocumentList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__VetDocumentList * FASTCALL soap_in_ns7__VetDocumentList(struct soap *soap, const char *tag, ns7__VetDocumentList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__VetDocumentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VetDocumentList, sizeof(ns7__VetDocumentList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__VetDocumentList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__VetDocumentList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:vetDocument", 1, NULL)) {
				if(a->ns7__VetDocumentList::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->ns7__VetDocumentList::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns7__VetDocumentList::vetDocument == NULL)
						return NULL;
					*a->ns7__VetDocumentList::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns7:vetDocument", a->ns7__VetDocumentList::vetDocument, "ns7:VetDocument"))
				{	a->ns7__VetDocumentList::__sizevetDocument++;
					a->ns7__VetDocumentList::vetDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VetDocumentList::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->ns7__VetDocumentList::__sizevetDocument)
			a->ns7__VetDocumentList::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->ns7__VetDocumentList::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__VetDocumentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VetDocumentList, 0, sizeof(ns7__VetDocumentList), 0, soap_copy_ns7__VetDocumentList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__VetDocumentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__VetDocumentList);
	return this->soap_out(soap, tag?tag:"ns7:VetDocumentList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__VetDocumentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__VetDocumentList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__VetDocumentList * SOAP_FMAC4 soap_get_ns7__VetDocumentList(struct soap *soap, ns7__VetDocumentList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__VetDocumentList * FASTCALL soap_instantiate_ns7__VetDocumentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__VetDocumentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__VetDocumentList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__VetDocumentList);
		ASSIGN_PTR(size, sizeof(ns7__VetDocumentList));
		((ns7__VetDocumentList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__VetDocumentList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__VetDocumentList));
		for(int i = 0; i < n; i++)
			((ns7__VetDocumentList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__VetDocumentList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__VetDocumentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__VetDocumentList %p -> %p\n", q, p));
	*(ns7__VetDocumentList*)p = *(ns7__VetDocumentList*)q;
}

void ns7__GoodsDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__GoodsDate::firstDate = NULL;
	this->ns7__GoodsDate::secondDate = NULL;
	soap_default_ns3__String255(soap, &this->ns7__GoodsDate::informalDate);
	/* transient soap skipped */
}

void ns7__GoodsDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ComplexDate(soap, &this->ns7__GoodsDate::firstDate);
	soap_serialize_PointerTons6__ComplexDate(soap, &this->ns7__GoodsDate::secondDate);
	soap_serialize_ns3__String255(soap, &this->ns7__GoodsDate::informalDate);
	/* transient soap skipped */
}

int ns7__GoodsDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__GoodsDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__GoodsDate(struct soap *soap, const char *tag, int id, const ns7__GoodsDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__GoodsDate), type))
		return soap->error;
	if(soap_out_PointerTons6__ComplexDate(soap, "ns7:firstDate", -1, &(a->ns7__GoodsDate::firstDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__ComplexDate(soap, "ns7:secondDate", -1, &(a->ns7__GoodsDate::secondDate), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:informalDate", -1, &(a->ns7__GoodsDate::informalDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__GoodsDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__GoodsDate(soap, tag, this, type);
}

SOAP_FMAC3 ns7__GoodsDate * FASTCALL soap_in_ns7__GoodsDate(struct soap *soap, const char *tag, ns7__GoodsDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__GoodsDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__GoodsDate, sizeof(ns7__GoodsDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__GoodsDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__GoodsDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_firstDate1 = 1;
	size_t soap_flag_secondDate1 = 1;
	size_t soap_flag_informalDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_firstDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ComplexDate(soap, "ns7:firstDate", &(a->ns7__GoodsDate::firstDate), "ns6:ComplexDate"))
				{	soap_flag_firstDate1--;
					continue;
				}
			if(soap_flag_secondDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ComplexDate(soap, "ns7:secondDate", &(a->ns7__GoodsDate::secondDate), "ns6:ComplexDate"))
				{	soap_flag_secondDate1--;
					continue;
				}
			if(soap_flag_informalDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:informalDate", &(a->ns7__GoodsDate::informalDate), "ns3:String255"))
				{	soap_flag_informalDate1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__GoodsDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__GoodsDate, 0, sizeof(ns7__GoodsDate), 0, soap_copy_ns7__GoodsDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__GoodsDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__GoodsDate);
	return this->soap_out(soap, tag?tag:"ns7:GoodsDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__GoodsDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__GoodsDate(soap, this, tag, type);
}

SOAP_FMAC3 ns7__GoodsDate * SOAP_FMAC4 soap_get_ns7__GoodsDate(struct soap *soap, ns7__GoodsDate *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__GoodsDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__GoodsDate * FASTCALL soap_instantiate_ns7__GoodsDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__GoodsDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__GoodsDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__GoodsDate);
		ASSIGN_PTR(size, sizeof(ns7__GoodsDate));
		((ns7__GoodsDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__GoodsDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__GoodsDate));
		for(int i = 0; i < n; i++)
			((ns7__GoodsDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__GoodsDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__GoodsDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__GoodsDate %p -> %p\n", q, p));
	*(ns7__GoodsDate*)p = *(ns7__GoodsDate*)q;
}

void ns7__ConsignmentDocumentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__ConsignmentDocumentList::waybill = NULL;
	this->ns7__ConsignmentDocumentList::__sizevetCertificate = 0;
	this->ns7__ConsignmentDocumentList::vetCertificate = NULL;
	this->ns7__ConsignmentDocumentList::__sizerelatedDocument = 0;
	this->ns7__ConsignmentDocumentList::relatedDocument = NULL;
	/* transient soap skipped */
}

void ns7__ConsignmentDocumentList::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__Waybill(soap, &this->ns7__ConsignmentDocumentList::waybill);
	if(this->ns7__ConsignmentDocumentList::vetCertificate) {
		for(int i = 0; i < this->ns7__ConsignmentDocumentList::__sizevetCertificate; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns7__ConsignmentDocumentList::vetCertificate + i);
		}
	}
	if(this->ns7__ConsignmentDocumentList::relatedDocument) {
		for(int i = 0; i < this->ns7__ConsignmentDocumentList::__sizerelatedDocument; i++) {
			soap_serialize_PointerTons7__ReferencedDocument(soap, this->ns7__ConsignmentDocumentList::relatedDocument + i);
		}
	}
	/* transient soap skipped */
}

int ns7__ConsignmentDocumentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ConsignmentDocumentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ConsignmentDocumentList(struct soap *soap, const char *tag, int id, const ns7__ConsignmentDocumentList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ConsignmentDocumentList), type))
		return soap->error;
	if(soap_out_PointerTons7__Waybill(soap, "ns7:waybill", -1, &(a->ns7__ConsignmentDocumentList::waybill), ""))
		return soap->error;
	if(a->ns7__ConsignmentDocumentList::vetCertificate) {
		int i;
		for(i = 0; i < a->ns7__ConsignmentDocumentList::__sizevetCertificate; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns7:vetCertificate", -1, a->ns7__ConsignmentDocumentList::vetCertificate + i, ""))
				return soap->error;
	}
	if(a->ns7__ConsignmentDocumentList::relatedDocument) {
		int i;
		for(i = 0; i < a->ns7__ConsignmentDocumentList::__sizerelatedDocument; i++)
			if(soap_out_PointerTons7__ReferencedDocument(soap, "ns7:relatedDocument", -1, a->ns7__ConsignmentDocumentList::relatedDocument + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__ConsignmentDocumentList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ConsignmentDocumentList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ConsignmentDocumentList * FASTCALL soap_in_ns7__ConsignmentDocumentList(struct soap *soap, const char *tag, ns7__ConsignmentDocumentList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ConsignmentDocumentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ConsignmentDocumentList, sizeof(ns7__ConsignmentDocumentList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ConsignmentDocumentList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ConsignmentDocumentList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_waybill1 = 1;
	struct soap_blist *soap_blist_vetCertificate1 = NULL;
	struct soap_blist *soap_blist_relatedDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_waybill1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Waybill(soap, "ns7:waybill", &(a->ns7__ConsignmentDocumentList::waybill), "ns7:Waybill"))
				{	soap_flag_waybill1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:vetCertificate", 1, NULL)) {
				if(a->ns7__ConsignmentDocumentList::vetCertificate == NULL) {
					if(soap_blist_vetCertificate1 == NULL)
						soap_blist_vetCertificate1 = soap_new_block(soap);
					a->ns7__ConsignmentDocumentList::vetCertificate = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetCertificate1, sizeof(ns7__VetDocument *));
					if(a->ns7__ConsignmentDocumentList::vetCertificate == NULL)
						return NULL;
					*a->ns7__ConsignmentDocumentList::vetCertificate = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns7:vetCertificate", a->ns7__ConsignmentDocumentList::vetCertificate, "ns7:VetDocument"))
				{	a->ns7__ConsignmentDocumentList::__sizevetCertificate++;
					a->ns7__ConsignmentDocumentList::vetCertificate = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:relatedDocument", 1, NULL)) {
				if(a->ns7__ConsignmentDocumentList::relatedDocument == NULL) {
					if(soap_blist_relatedDocument1 == NULL)
						soap_blist_relatedDocument1 = soap_new_block(soap);
					a->ns7__ConsignmentDocumentList::relatedDocument = (ns7__ReferencedDocument **)soap_push_block(soap, soap_blist_relatedDocument1, sizeof(ns7__ReferencedDocument *));
					if(a->ns7__ConsignmentDocumentList::relatedDocument == NULL)
						return NULL;
					*a->ns7__ConsignmentDocumentList::relatedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__ReferencedDocument(soap, "ns7:relatedDocument", a->ns7__ConsignmentDocumentList::relatedDocument, "ns7:ReferencedDocument"))
				{	a->ns7__ConsignmentDocumentList::__sizerelatedDocument++;
					a->ns7__ConsignmentDocumentList::relatedDocument = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__ConsignmentDocumentList::vetCertificate)
			soap_pop_block(soap, soap_blist_vetCertificate1);
		if(a->ns7__ConsignmentDocumentList::__sizevetCertificate)
			a->ns7__ConsignmentDocumentList::vetCertificate = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetCertificate1, NULL, 1);
		else
		{	a->ns7__ConsignmentDocumentList::vetCertificate = NULL;
			if(soap_blist_vetCertificate1)
				soap_end_block(soap, soap_blist_vetCertificate1);
		}
		if(a->ns7__ConsignmentDocumentList::relatedDocument)
			soap_pop_block(soap, soap_blist_relatedDocument1);
		if(a->ns7__ConsignmentDocumentList::__sizerelatedDocument)
			a->ns7__ConsignmentDocumentList::relatedDocument = (ns7__ReferencedDocument **)soap_save_block(soap, soap_blist_relatedDocument1, NULL, 1);
		else
		{	a->ns7__ConsignmentDocumentList::relatedDocument = NULL;
			if(soap_blist_relatedDocument1)
				soap_end_block(soap, soap_blist_relatedDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ConsignmentDocumentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ConsignmentDocumentList, 0, sizeof(ns7__ConsignmentDocumentList), 0, soap_copy_ns7__ConsignmentDocumentList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__ConsignmentDocumentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ConsignmentDocumentList);
	return this->soap_out(soap, tag?tag:"ns7:ConsignmentDocumentList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ConsignmentDocumentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ConsignmentDocumentList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ConsignmentDocumentList * SOAP_FMAC4 soap_get_ns7__ConsignmentDocumentList(struct soap *soap, ns7__ConsignmentDocumentList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ConsignmentDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ConsignmentDocumentList * FASTCALL soap_instantiate_ns7__ConsignmentDocumentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ConsignmentDocumentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ConsignmentDocumentList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ConsignmentDocumentList);
		ASSIGN_PTR(size, sizeof(ns7__ConsignmentDocumentList));
		((ns7__ConsignmentDocumentList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ConsignmentDocumentList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ConsignmentDocumentList));
		for(int i = 0; i < n; i++)
			((ns7__ConsignmentDocumentList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ConsignmentDocumentList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ConsignmentDocumentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ConsignmentDocumentList %p -> %p\n", q, p));
	*(ns7__ConsignmentDocumentList*)p = *(ns7__ConsignmentDocumentList*)q;
}

void ns7__DeliveryInspection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__DeliveryInspection::responsible = NULL;
	soap_default_ns7__DeliveryInspectionResult(soap, &this->ns7__DeliveryInspection::result);
	soap_default_ns3__Text(soap, &this->ns7__DeliveryInspection::info);
	/* transient soap skipped */
}

void ns7__DeliveryInspection::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__User(soap, &this->ns7__DeliveryInspection::responsible);
	soap_serialize_ns3__Text(soap, &this->ns7__DeliveryInspection::info);
	/* transient soap skipped */
}

int ns7__DeliveryInspection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__DeliveryInspection(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__DeliveryInspection(struct soap *soap, const char *tag, int id, const ns7__DeliveryInspection *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__DeliveryInspection), type))
		return soap->error;
	if(soap_out_PointerTons7__User(soap, "ns7:responsible", -1, &(a->ns7__DeliveryInspection::responsible), ""))
		return soap->error;
	if(soap_out_ns7__DeliveryInspectionResult(soap, "ns7:result", -1, &(a->ns7__DeliveryInspection::result), ""))
		return soap->error;
	if(soap_out_ns3__Text(soap, "ns7:info", -1, &(a->ns7__DeliveryInspection::info), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__DeliveryInspection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__DeliveryInspection(soap, tag, this, type);
}

SOAP_FMAC3 ns7__DeliveryInspection * FASTCALL soap_in_ns7__DeliveryInspection(struct soap *soap, const char *tag, ns7__DeliveryInspection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__DeliveryInspection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__DeliveryInspection, sizeof(ns7__DeliveryInspection), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__DeliveryInspection) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__DeliveryInspection *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_responsible1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_info1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_responsible1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns7:responsible", &(a->ns7__DeliveryInspection::responsible), "ns7:User"))
				{	soap_flag_responsible1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns7__DeliveryInspectionResult(soap, "ns7:result", &(a->ns7__DeliveryInspection::result), "ns7:DeliveryInspectionResult"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_info1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns7:info", &(a->ns7__DeliveryInspection::info), "ns3:Text"))
				{	soap_flag_info1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__DeliveryInspection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__DeliveryInspection, 0, sizeof(ns7__DeliveryInspection), 0, soap_copy_ns7__DeliveryInspection);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__DeliveryInspection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__DeliveryInspection);
	return this->soap_out(soap, tag?tag:"ns7:DeliveryInspection", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__DeliveryInspection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__DeliveryInspection(soap, this, tag, type);
}

SOAP_FMAC3 ns7__DeliveryInspection * SOAP_FMAC4 soap_get_ns7__DeliveryInspection(struct soap *soap, ns7__DeliveryInspection *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__DeliveryInspection(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__DeliveryInspection * FASTCALL soap_instantiate_ns7__DeliveryInspection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__DeliveryInspection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__DeliveryInspection, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__DeliveryInspection);
		ASSIGN_PTR(size, sizeof(ns7__DeliveryInspection));
		((ns7__DeliveryInspection*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__DeliveryInspection[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__DeliveryInspection));
		for(int i = 0; i < n; i++)
			((ns7__DeliveryInspection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__DeliveryInspection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__DeliveryInspection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__DeliveryInspection %p -> %p\n", q, p));
	*(ns7__DeliveryInspection*)p = *(ns7__DeliveryInspection*)q;
}

void ns7__DeliveryFactList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__DocumentNature(soap, &this->ns7__DeliveryFactList::vetCertificatePresence);
	this->ns7__DeliveryFactList::docInspection = NULL;
	this->ns7__DeliveryFactList::vetInspection = NULL;
	soap_default_ns7__DeliveryDecision(soap, &this->ns7__DeliveryFactList::decision);
	/* transient soap skipped */
}

void ns7__DeliveryFactList::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__DeliveryInspection(soap, &this->ns7__DeliveryFactList::docInspection);
	soap_serialize_PointerTons7__DeliveryInspection(soap, &this->ns7__DeliveryFactList::vetInspection);
	/* transient soap skipped */
}

int ns7__DeliveryFactList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__DeliveryFactList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__DeliveryFactList(struct soap *soap, const char *tag, int id, const ns7__DeliveryFactList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__DeliveryFactList), type))
		return soap->error;
	if(soap_out_ns6__DocumentNature(soap, "ns7:vetCertificatePresence", -1, &(a->ns7__DeliveryFactList::vetCertificatePresence), ""))
		return soap->error;
	if(a->ns7__DeliveryFactList::docInspection) {
		if(soap_out_PointerTons7__DeliveryInspection(soap, "ns7:docInspection", -1, &a->ns7__DeliveryFactList::docInspection, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:docInspection"))
		return soap->error;
	if(a->ns7__DeliveryFactList::vetInspection) {
		if(soap_out_PointerTons7__DeliveryInspection(soap, "ns7:vetInspection", -1, &a->ns7__DeliveryFactList::vetInspection, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:vetInspection"))
		return soap->error;
	if(soap_out_ns7__DeliveryDecision(soap, "ns7:decision", -1, &(a->ns7__DeliveryFactList::decision), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__DeliveryFactList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__DeliveryFactList(soap, tag, this, type);
}

SOAP_FMAC3 ns7__DeliveryFactList * FASTCALL soap_in_ns7__DeliveryFactList(struct soap *soap, const char *tag, ns7__DeliveryFactList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__DeliveryFactList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__DeliveryFactList, sizeof(ns7__DeliveryFactList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__DeliveryFactList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__DeliveryFactList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vetCertificatePresence1 = 1;
	size_t soap_flag_docInspection1 = 1;
	size_t soap_flag_vetInspection1 = 1;
	size_t soap_flag_decision1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_vetCertificatePresence1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__DocumentNature(soap, "ns7:vetCertificatePresence", &(a->ns7__DeliveryFactList::vetCertificatePresence), "ns6:DocumentNature"))
				{	soap_flag_vetCertificatePresence1--;
					continue;
				}
			if(soap_flag_docInspection1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__DeliveryInspection(soap, "ns7:docInspection", &(a->ns7__DeliveryFactList::docInspection), "ns7:DeliveryInspection"))
				{	soap_flag_docInspection1--;
					continue;
				}
			if(soap_flag_vetInspection1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__DeliveryInspection(soap, "ns7:vetInspection", &(a->ns7__DeliveryFactList::vetInspection), "ns7:DeliveryInspection"))
				{	soap_flag_vetInspection1--;
					continue;
				}
			if(soap_flag_decision1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns7__DeliveryDecision(soap, "ns7:decision", &(a->ns7__DeliveryFactList::decision), "ns7:DeliveryDecision"))
				{	soap_flag_decision1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__DeliveryFactList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__DeliveryFactList, 0, sizeof(ns7__DeliveryFactList), 0, soap_copy_ns7__DeliveryFactList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vetCertificatePresence1 > 0 || soap_flag_docInspection1 > 0 || soap_flag_vetInspection1 > 0 || soap_flag_decision1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__DeliveryFactList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__DeliveryFactList);
	return this->soap_out(soap, tag?tag:"ns7:DeliveryFactList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__DeliveryFactList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__DeliveryFactList(soap, this, tag, type);
}

SOAP_FMAC3 ns7__DeliveryFactList * SOAP_FMAC4 soap_get_ns7__DeliveryFactList(struct soap *soap, ns7__DeliveryFactList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__DeliveryFactList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__DeliveryFactList * FASTCALL soap_instantiate_ns7__DeliveryFactList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__DeliveryFactList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__DeliveryFactList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__DeliveryFactList);
		ASSIGN_PTR(size, sizeof(ns7__DeliveryFactList));
		((ns7__DeliveryFactList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__DeliveryFactList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__DeliveryFactList));
		for(int i = 0; i < n; i++)
			((ns7__DeliveryFactList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__DeliveryFactList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__DeliveryFactList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__DeliveryFactList %p -> %p\n", q, p));
	*(ns7__DeliveryFactList*)p = *(ns7__DeliveryFactList*)q;
}

void ns7__Delivery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__Delivery::deliveryDate = NULL;
	this->ns7__Delivery::consignor = NULL;
	this->ns7__Delivery::consignee = NULL;
	this->ns7__Delivery::__sizeconsignment = 0;
	this->ns7__Delivery::consignment = NULL;
	this->ns7__Delivery::broker = NULL;
	this->ns7__Delivery::transportInfo = NULL;
	this->ns7__Delivery::transportStorageType = NULL;
	this->ns7__Delivery::shipmentRoute = NULL;
	this->ns7__Delivery::accompanyingForms = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__Delivery::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->ns7__Delivery::deliveryDate);
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__Delivery::consignor);
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns7__Delivery::consignee);
	if(this->ns7__Delivery::consignment) {
		for(int i = 0; i < this->ns7__Delivery::__sizeconsignment; i++) {
			soap_serialize_PointerTons7__Consignment(soap, this->ns7__Delivery::consignment + i);
		}
	}
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__Delivery::broker);
	soap_serialize_PointerTons7__TransportInfo(soap, &this->ns7__Delivery::transportInfo);
	soap_serialize_PointerTons6__TransportationStorageType(soap, &this->ns7__Delivery::transportStorageType);
	soap_serialize_PointerTons7__ShipmentRoute(soap, &this->ns7__Delivery::shipmentRoute);
	soap_serialize_PointerTons7__ConsignmentDocumentList(soap, &this->ns7__Delivery::accompanyingForms);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__Delivery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Delivery(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__Delivery(struct soap *soap, const char *tag, int id, const ns7__Delivery *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Delivery), "ns7:Delivery"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTotime(soap, "ns7:deliveryDate", -1, &(a->ns7__Delivery::deliveryDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:consignor", -1, &(a->ns7__Delivery::consignor), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns7:consignee", -1, &(a->ns7__Delivery::consignee), ""))
		return soap->error;
	if(a->ns7__Delivery::consignment) {
		int i;
		for(i = 0; i < a->ns7__Delivery::__sizeconsignment; i++)
			if(soap_out_PointerTons7__Consignment(soap, "ns7:consignment", -1, a->ns7__Delivery::consignment + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:broker", -1, &(a->ns7__Delivery::broker), ""))
		return soap->error;
	if(soap_out_PointerTons7__TransportInfo(soap, "ns7:transportInfo", -1, &(a->ns7__Delivery::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerTons6__TransportationStorageType(soap, "ns7:transportStorageType", -1, &(a->ns7__Delivery::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", -1, &(a->ns7__Delivery::shipmentRoute), ""))
		return soap->error;
	if(soap_out_PointerTons7__ConsignmentDocumentList(soap, "ns7:accompanyingForms", -1, &(a->ns7__Delivery::accompanyingForms), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Delivery::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__Delivery(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Delivery * FASTCALL soap_in_ns7__Delivery(struct soap *soap, const char *tag, ns7__Delivery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Delivery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Delivery, sizeof(ns7__Delivery), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__Delivery) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__Delivery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_deliveryDate1 = 1;
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	struct soap_blist *soap_blist_consignment1 = NULL;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	size_t soap_flag_accompanyingForms1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_deliveryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:deliveryDate", &(a->ns7__Delivery::deliveryDate), "xsd:dateTime"))
				{	soap_flag_deliveryDate1--;
					continue;
				}
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:consignor", &(a->ns7__Delivery::consignor), "ns6:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:consignee", &(a->ns7__Delivery::consignee), "ns6:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:consignment", 1, NULL)) {
				if(a->ns7__Delivery::consignment == NULL) {
					if(soap_blist_consignment1 == NULL)
						soap_blist_consignment1 = soap_new_block(soap);
					a->ns7__Delivery::consignment = (ns7__Consignment **)soap_push_block(soap, soap_blist_consignment1, sizeof(ns7__Consignment *));
					if(a->ns7__Delivery::consignment == NULL)
						return NULL;
					*a->ns7__Delivery::consignment = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__Consignment(soap, "ns7:consignment", a->ns7__Delivery::consignment, "ns7:Consignment"))
				{	a->ns7__Delivery::__sizeconsignment++;
					a->ns7__Delivery::consignment = NULL;
					continue;
				}
			}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:broker", &(a->ns7__Delivery::broker), "ns6:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__TransportInfo(soap, "ns7:transportInfo", &(a->ns7__Delivery::transportInfo), "ns7:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__TransportationStorageType(soap, "ns7:transportStorageType", &(a->ns7__Delivery::transportStorageType), "ns6:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", &(a->ns7__Delivery::shipmentRoute), "ns7:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap_flag_accompanyingForms1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ConsignmentDocumentList(soap, "ns7:accompanyingForms", &(a->ns7__Delivery::accompanyingForms), "ns7:ConsignmentDocumentList"))
				{	soap_flag_accompanyingForms1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__Delivery::consignment)
			soap_pop_block(soap, soap_blist_consignment1);
		if(a->ns7__Delivery::__sizeconsignment)
			a->ns7__Delivery::consignment = (ns7__Consignment **)soap_save_block(soap, soap_blist_consignment1, NULL, 1);
		else
		{	a->ns7__Delivery::consignment = NULL;
			if(soap_blist_consignment1)
				soap_end_block(soap, soap_blist_consignment1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__Delivery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Delivery, 0, sizeof(ns7__Delivery), 0, soap_copy_ns7__Delivery);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__Delivery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__Delivery);
	return this->soap_out(soap, tag?tag:"ns7:Delivery", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__Delivery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Delivery(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Delivery * SOAP_FMAC4 soap_get_ns7__Delivery(struct soap *soap, ns7__Delivery *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__Delivery * FASTCALL soap_instantiate_ns7__Delivery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Delivery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__Delivery, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__Delivery);
		ASSIGN_PTR(size, sizeof(ns7__Delivery));
		((ns7__Delivery*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__Delivery[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__Delivery));
		for(int i = 0; i < n; i++)
			((ns7__Delivery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__Delivery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__Delivery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__Delivery %p -> %p\n", q, p));
	*(ns7__Delivery*)p = *(ns7__Delivery*)q;
}

void ns7__ProductiveBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__ID(soap, &this->ns7__ProductiveBatch::id);
	this->ns7__Batch::productType = NULL;
	this->ns7__Batch::product = NULL;
	this->ns7__Batch::subProduct = NULL;
	this->ns7__Batch::productItem = NULL;
	this->ns7__Batch::volume = NULL;
	this->ns7__Batch::unit = NULL;
	this->ns7__Batch::dateOfProduction = NULL;
	this->ns7__Batch::expiryDate = NULL;
	this->ns7__Batch::__sizebatchID = 0;
	this->ns7__Batch::batchID = NULL;
	this->ns7__Batch::perishable = NULL;
	this->ns7__Batch::origin = NULL;
	this->ns7__Batch::lowGradeCargo = NULL;
	this->ns7__Batch::packageList = NULL;
	this->ns7__Batch::owner = NULL;
	/* transient soap skipped */
}

void ns7__ProductiveBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductType(soap, &this->ns7__Batch::productType);
	soap_serialize_PointerTons6__Product(soap, &this->ns7__Batch::product);
	soap_serialize_PointerTons6__SubProduct(soap, &this->ns7__Batch::subProduct);
	soap_serialize_PointerTons6__ProductItem(soap, &this->ns7__Batch::productItem);
	soap_serialize_PointerTons3__Decimal(soap, &this->ns7__Batch::volume);
	soap_serialize_PointerTons6__Unit(soap, &this->ns7__Batch::unit);
	soap_serialize_PointerTons7__GoodsDate(soap, &this->ns7__Batch::dateOfProduction);
	soap_serialize_PointerTons7__GoodsDate(soap, &this->ns7__Batch::expiryDate);
	if(this->ns7__Batch::batchID) {
		for(int i = 0; i < this->ns7__Batch::__sizebatchID; i++) {
			soap_serialize_ns3__Identifier(soap, this->ns7__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->ns7__Batch::perishable);
	soap_serialize_PointerTons7__BatchOrigin(soap, &this->ns7__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->ns7__Batch::lowGradeCargo);
	soap_serialize_PointerTons6__PackageList(soap, &this->ns7__Batch::packageList);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__Batch::owner);
	/* transient soap skipped */
}

int ns7__ProductiveBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__ProductiveBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__ProductiveBatch(struct soap *soap, const char *tag, int id, const ns7__ProductiveBatch *a, const char *type)
{
	if(((ns7__ProductiveBatch*)a)->id)
		soap_set_attr(soap, "id", ((ns7__ProductiveBatch*)a)->id, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ProductiveBatch), "ns7:ProductiveBatch"))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns7:productType", -1, &(a->ns7__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerTons6__Product(soap, "ns7:product", -1, &(a->ns7__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerTons6__SubProduct(soap, "ns7:subProduct", -1, &(a->ns7__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductItem(soap, "ns7:productItem", -1, &(a->ns7__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTons3__Decimal(soap, "ns7:volume", -1, &(a->ns7__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerTons6__Unit(soap, "ns7:unit", -1, &(a->ns7__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTons7__GoodsDate(soap, "ns7:dateOfProduction", -1, &(a->ns7__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTons7__GoodsDate(soap, "ns7:expiryDate", -1, &(a->ns7__Batch::expiryDate), ""))
		return soap->error;
	if(a->ns7__Batch::batchID) {
		int i;
		for(i = 0; i < a->ns7__Batch::__sizebatchID; i++)
			if(soap_out_ns3__Identifier(soap, "ns7:batchID", -1, a->ns7__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "ns7:perishable", -1, &(a->ns7__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTons7__BatchOrigin(soap, "ns7:origin", -1, &(a->ns7__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:lowGradeCargo", -1, &(a->ns7__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerTons6__PackageList(soap, "ns7:packageList", -1, &(a->ns7__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:owner", -1, &(a->ns7__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__ProductiveBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__ProductiveBatch(soap, tag, this, type);
}

SOAP_FMAC3 ns7__ProductiveBatch * FASTCALL soap_in_ns7__ProductiveBatch(struct soap *soap, const char *tag, ns7__ProductiveBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__ProductiveBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ProductiveBatch, sizeof(ns7__ProductiveBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__ProductiveBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__ProductiveBatch *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((ns7__ProductiveBatch*)a)->id, 0, -1))
		return NULL;
	size_t soap_flag_productType2 = 1;
	size_t soap_flag_product2 = 1;
	size_t soap_flag_subProduct2 = 1;
	size_t soap_flag_productItem2 = 1;
	size_t soap_flag_volume2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_dateOfProduction2 = 1;
	size_t soap_flag_expiryDate2 = 1;
	struct soap_blist *soap_blist_batchID2 = NULL;
	size_t soap_flag_perishable2 = 1;
	size_t soap_flag_origin2 = 1;
	size_t soap_flag_lowGradeCargo2 = 1;
	size_t soap_flag_packageList2 = 1;
	size_t soap_flag_owner2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns7:productType", &(a->ns7__Batch::productType), "ns6:ProductType"))
				{	soap_flag_productType2--;
					continue;
				}
			if(soap_flag_product2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns7:product", &(a->ns7__Batch::product), "ns6:Product"))
				{	soap_flag_product2--;
					continue;
				}
			if(soap_flag_subProduct2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns7:subProduct", &(a->ns7__Batch::subProduct), "ns6:SubProduct"))
				{	soap_flag_subProduct2--;
					continue;
				}
			if(soap_flag_productItem2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItem(soap, "ns7:productItem", &(a->ns7__Batch::productItem), "ns6:ProductItem"))
				{	soap_flag_productItem2--;
					continue;
				}
			if(soap_flag_volume2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Decimal(soap, "ns7:volume", &(a->ns7__Batch::volume), "ns3:Decimal"))
				{	soap_flag_volume2--;
					continue;
				}
			if(soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns7:unit", &(a->ns7__Batch::unit), "ns6:Unit"))
				{	soap_flag_unit2--;
					continue;
				}
			if(soap_flag_dateOfProduction2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__GoodsDate(soap, "ns7:dateOfProduction", &(a->ns7__Batch::dateOfProduction), "ns7:GoodsDate"))
				{	soap_flag_dateOfProduction2--;
					continue;
				}
			if(soap_flag_expiryDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__GoodsDate(soap, "ns7:expiryDate", &(a->ns7__Batch::expiryDate), "ns7:GoodsDate"))
				{	soap_flag_expiryDate2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:batchID", 1, NULL)) {
				if(a->ns7__Batch::batchID == NULL) {
					if(soap_blist_batchID2 == NULL)
						soap_blist_batchID2 = soap_new_block(soap);
					a->ns7__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID2, sizeof(char *));
					if(a->ns7__Batch::batchID == NULL)
						return NULL;
					*a->ns7__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns3__Identifier(soap, "ns7:batchID", a->ns7__Batch::batchID, "ns3:Identifier"))
				{	a->ns7__Batch::__sizebatchID++;
					a->ns7__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:perishable", &(a->ns7__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable2--;
					continue;
				}
			if(soap_flag_origin2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__BatchOrigin(soap, "ns7:origin", &(a->ns7__Batch::origin), "ns7:BatchOrigin"))
				{	soap_flag_origin2--;
					continue;
				}
			if(soap_flag_lowGradeCargo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:lowGradeCargo", &(a->ns7__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo2--;
					continue;
				}
			if(soap_flag_packageList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackageList(soap, "ns7:packageList", &(a->ns7__Batch::packageList), "ns6:PackageList"))
				{	soap_flag_packageList2--;
					continue;
				}
			if(soap_flag_owner2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:owner", &(a->ns7__Batch::owner), "ns6:BusinessEntity"))
				{	soap_flag_owner2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID2);
		if(a->ns7__Batch::__sizebatchID)
			a->ns7__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID2, NULL, 1);
		else
		{	a->ns7__Batch::batchID = NULL;
			if(soap_blist_batchID2)
				soap_end_block(soap, soap_blist_batchID2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__ProductiveBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ProductiveBatch, 0, sizeof(ns7__ProductiveBatch), 0, soap_copy_ns7__ProductiveBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__ProductiveBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__ProductiveBatch);
	return this->soap_out(soap, tag?tag:"ns7:ProductiveBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__ProductiveBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__ProductiveBatch(soap, this, tag, type);
}

SOAP_FMAC3 ns7__ProductiveBatch * SOAP_FMAC4 soap_get_ns7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__ProductiveBatch * FASTCALL soap_instantiate_ns7__ProductiveBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__ProductiveBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__ProductiveBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__ProductiveBatch);
		ASSIGN_PTR(size, sizeof(ns7__ProductiveBatch));
		((ns7__ProductiveBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__ProductiveBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__ProductiveBatch));
		for(int i = 0; i < n; i++)
			((ns7__ProductiveBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__ProductiveBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__ProductiveBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__ProductiveBatch %p -> %p\n", q, p));
	*(ns7__ProductiveBatch*)p = *(ns7__ProductiveBatch*)q;
}

void ns7__RawBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__RawBatch::sourceStockEntry = NULL;
	this->ns7__RawBatch::volume = NULL;
	this->ns7__RawBatch::unit = NULL;
	this->ns7__RawBatch::packageList = NULL;
	/* transient soap skipped */
}

void ns7__RawBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntry(soap, &this->ns7__RawBatch::sourceStockEntry);
	soap_serialize_PointerTons3__Decimal(soap, &this->ns7__RawBatch::volume);
	soap_serialize_PointerTons6__Unit(soap, &this->ns7__RawBatch::unit);
	soap_serialize_PointerTons6__PackageList(soap, &this->ns7__RawBatch::packageList);
	/* transient soap skipped */
}

int ns7__RawBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__RawBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__RawBatch(struct soap *soap, const char *tag, int id, const ns7__RawBatch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__RawBatch), type))
		return soap->error;
	if(soap_out_PointerTons7__StockEntry(soap, "ns7:sourceStockEntry", -1, &(a->ns7__RawBatch::sourceStockEntry), ""))
		return soap->error;
	if(soap_out_PointerTons3__Decimal(soap, "ns7:volume", -1, &(a->ns7__RawBatch::volume), ""))
		return soap->error;
	if(soap_out_PointerTons6__Unit(soap, "ns7:unit", -1, &(a->ns7__RawBatch::unit), ""))
		return soap->error;
	if(soap_out_PointerTons6__PackageList(soap, "ns7:packageList", -1, &(a->ns7__RawBatch::packageList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__RawBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__RawBatch(soap, tag, this, type);
}

SOAP_FMAC3 ns7__RawBatch * FASTCALL soap_in_ns7__RawBatch(struct soap *soap, const char *tag, ns7__RawBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__RawBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__RawBatch, sizeof(ns7__RawBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__RawBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__RawBatch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sourceStockEntry1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_packageList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_sourceStockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:sourceStockEntry", &(a->ns7__RawBatch::sourceStockEntry), "ns7:StockEntry"))
				{	soap_flag_sourceStockEntry1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Decimal(soap, "ns7:volume", &(a->ns7__RawBatch::volume), "ns3:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns7:unit", &(a->ns7__RawBatch::unit), "ns6:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if(soap_flag_packageList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackageList(soap, "ns7:packageList", &(a->ns7__RawBatch::packageList), "ns6:PackageList"))
				{	soap_flag_packageList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__RawBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__RawBatch, 0, sizeof(ns7__RawBatch), 0, soap_copy_ns7__RawBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__RawBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__RawBatch);
	return this->soap_out(soap, tag?tag:"ns7:RawBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__RawBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__RawBatch(soap, this, tag, type);
}

SOAP_FMAC3 ns7__RawBatch * SOAP_FMAC4 soap_get_ns7__RawBatch(struct soap *soap, ns7__RawBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__RawBatch * FASTCALL soap_instantiate_ns7__RawBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__RawBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__RawBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__RawBatch);
		ASSIGN_PTR(size, sizeof(ns7__RawBatch));
		((ns7__RawBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__RawBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__RawBatch));
		for(int i = 0; i < n; i++)
			((ns7__RawBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__RawBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__RawBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__RawBatch %p -> %p\n", q, p));
	*(ns7__RawBatch*)p = *(ns7__RawBatch*)q;
}

void ns7__Consignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__Consignment::sourceStockEntry = NULL;
	soap_default_xsd__ID(soap, &this->ns7__Consignment::id);
	soap_default_xsd__IDREF(soap, &this->ns7__Consignment::partOf);
	this->ns7__Batch::productType = NULL;
	this->ns7__Batch::product = NULL;
	this->ns7__Batch::subProduct = NULL;
	this->ns7__Batch::productItem = NULL;
	this->ns7__Batch::volume = NULL;
	this->ns7__Batch::unit = NULL;
	this->ns7__Batch::dateOfProduction = NULL;
	this->ns7__Batch::expiryDate = NULL;
	this->ns7__Batch::__sizebatchID = 0;
	this->ns7__Batch::batchID = NULL;
	this->ns7__Batch::perishable = NULL;
	this->ns7__Batch::origin = NULL;
	this->ns7__Batch::lowGradeCargo = NULL;
	this->ns7__Batch::packageList = NULL;
	this->ns7__Batch::owner = NULL;
	/* transient soap skipped */
}

void ns7__Consignment::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntry(soap, &this->ns7__Consignment::sourceStockEntry);
	soap_serialize_PointerTons6__ProductType(soap, &this->ns7__Batch::productType);
	soap_serialize_PointerTons6__Product(soap, &this->ns7__Batch::product);
	soap_serialize_PointerTons6__SubProduct(soap, &this->ns7__Batch::subProduct);
	soap_serialize_PointerTons6__ProductItem(soap, &this->ns7__Batch::productItem);
	soap_serialize_PointerTons3__Decimal(soap, &this->ns7__Batch::volume);
	soap_serialize_PointerTons6__Unit(soap, &this->ns7__Batch::unit);
	soap_serialize_PointerTons7__GoodsDate(soap, &this->ns7__Batch::dateOfProduction);
	soap_serialize_PointerTons7__GoodsDate(soap, &this->ns7__Batch::expiryDate);
	if(this->ns7__Batch::batchID) {
		for(int i = 0; i < this->ns7__Batch::__sizebatchID; i++) {
			soap_serialize_ns3__Identifier(soap, this->ns7__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->ns7__Batch::perishable);
	soap_serialize_PointerTons7__BatchOrigin(soap, &this->ns7__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->ns7__Batch::lowGradeCargo);
	soap_serialize_PointerTons6__PackageList(soap, &this->ns7__Batch::packageList);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__Batch::owner);
	/* transient soap skipped */
}

int ns7__Consignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Consignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__Consignment(struct soap *soap, const char *tag, int id, const ns7__Consignment *a, const char *type)
{
	if(((ns7__Consignment*)a)->id)
		soap_set_attr(soap, "id", ((ns7__Consignment*)a)->id, 1);
	if(((ns7__Consignment*)a)->partOf)
		soap_set_attr(soap, "partOf", ((ns7__Consignment*)a)->partOf, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Consignment), "ns7:Consignment"))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns7:productType", -1, &(a->ns7__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerTons6__Product(soap, "ns7:product", -1, &(a->ns7__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerTons6__SubProduct(soap, "ns7:subProduct", -1, &(a->ns7__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductItem(soap, "ns7:productItem", -1, &(a->ns7__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTons3__Decimal(soap, "ns7:volume", -1, &(a->ns7__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerTons6__Unit(soap, "ns7:unit", -1, &(a->ns7__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTons7__GoodsDate(soap, "ns7:dateOfProduction", -1, &(a->ns7__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTons7__GoodsDate(soap, "ns7:expiryDate", -1, &(a->ns7__Batch::expiryDate), ""))
		return soap->error;
	if(a->ns7__Batch::batchID) {
		int i;
		for(i = 0; i < a->ns7__Batch::__sizebatchID; i++)
			if(soap_out_ns3__Identifier(soap, "ns7:batchID", -1, a->ns7__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "ns7:perishable", -1, &(a->ns7__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTons7__BatchOrigin(soap, "ns7:origin", -1, &(a->ns7__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:lowGradeCargo", -1, &(a->ns7__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerTons6__PackageList(soap, "ns7:packageList", -1, &(a->ns7__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:owner", -1, &(a->ns7__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTons7__StockEntry(soap, "ns7:sourceStockEntry", -1, &(a->ns7__Consignment::sourceStockEntry), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Consignment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__Consignment(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Consignment * FASTCALL soap_in_ns7__Consignment(struct soap *soap, const char *tag, ns7__Consignment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Consignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Consignment, sizeof(ns7__Consignment), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__Consignment) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__Consignment *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((ns7__Consignment*)a)->id, 0, -1))
		return NULL;
	if(soap_s2string(soap, soap_attr_value(soap, "partOf", 0), &((ns7__Consignment*)a)->partOf, 0, -1))
		return NULL;
	size_t soap_flag_productType2 = 1;
	size_t soap_flag_product2 = 1;
	size_t soap_flag_subProduct2 = 1;
	size_t soap_flag_productItem2 = 1;
	size_t soap_flag_volume2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_dateOfProduction2 = 1;
	size_t soap_flag_expiryDate2 = 1;
	struct soap_blist *soap_blist_batchID2 = NULL;
	size_t soap_flag_perishable2 = 1;
	size_t soap_flag_origin2 = 1;
	size_t soap_flag_lowGradeCargo2 = 1;
	size_t soap_flag_packageList2 = 1;
	size_t soap_flag_owner2 = 1;
	size_t soap_flag_sourceStockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns7:productType", &(a->ns7__Batch::productType), "ns6:ProductType"))
				{	soap_flag_productType2--;
					continue;
				}
			if(soap_flag_product2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns7:product", &(a->ns7__Batch::product), "ns6:Product"))
				{	soap_flag_product2--;
					continue;
				}
			if(soap_flag_subProduct2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns7:subProduct", &(a->ns7__Batch::subProduct), "ns6:SubProduct"))
				{	soap_flag_subProduct2--;
					continue;
				}
			if(soap_flag_productItem2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItem(soap, "ns7:productItem", &(a->ns7__Batch::productItem), "ns6:ProductItem"))
				{	soap_flag_productItem2--;
					continue;
				}
			if(soap_flag_volume2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Decimal(soap, "ns7:volume", &(a->ns7__Batch::volume), "ns3:Decimal"))
				{	soap_flag_volume2--;
					continue;
				}
			if(soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns7:unit", &(a->ns7__Batch::unit), "ns6:Unit"))
				{	soap_flag_unit2--;
					continue;
				}
			if(soap_flag_dateOfProduction2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__GoodsDate(soap, "ns7:dateOfProduction", &(a->ns7__Batch::dateOfProduction), "ns7:GoodsDate"))
				{	soap_flag_dateOfProduction2--;
					continue;
				}
			if(soap_flag_expiryDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__GoodsDate(soap, "ns7:expiryDate", &(a->ns7__Batch::expiryDate), "ns7:GoodsDate"))
				{	soap_flag_expiryDate2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:batchID", 1, NULL)) {
				if(a->ns7__Batch::batchID == NULL) {
					if(soap_blist_batchID2 == NULL)
						soap_blist_batchID2 = soap_new_block(soap);
					a->ns7__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID2, sizeof(char *));
					if(a->ns7__Batch::batchID == NULL)
						return NULL;
					*a->ns7__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns3__Identifier(soap, "ns7:batchID", a->ns7__Batch::batchID, "ns3:Identifier"))
				{	a->ns7__Batch::__sizebatchID++;
					a->ns7__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:perishable", &(a->ns7__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable2--;
					continue;
				}
			if(soap_flag_origin2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__BatchOrigin(soap, "ns7:origin", &(a->ns7__Batch::origin), "ns7:BatchOrigin"))
				{	soap_flag_origin2--;
					continue;
				}
			if(soap_flag_lowGradeCargo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:lowGradeCargo", &(a->ns7__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo2--;
					continue;
				}
			if(soap_flag_packageList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackageList(soap, "ns7:packageList", &(a->ns7__Batch::packageList), "ns6:PackageList"))
				{	soap_flag_packageList2--;
					continue;
				}
			if(soap_flag_owner2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:owner", &(a->ns7__Batch::owner), "ns6:BusinessEntity"))
				{	soap_flag_owner2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_sourceStockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:sourceStockEntry", &(a->ns7__Consignment::sourceStockEntry), "ns7:StockEntry"))
				{	soap_flag_sourceStockEntry1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID2);
		if(a->ns7__Batch::__sizebatchID)
			a->ns7__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID2, NULL, 1);
		else
		{	a->ns7__Batch::batchID = NULL;
			if(soap_blist_batchID2)
				soap_end_block(soap, soap_blist_batchID2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__Consignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Consignment, 0, sizeof(ns7__Consignment), 0, soap_copy_ns7__Consignment);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__Consignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__Consignment);
	return this->soap_out(soap, tag?tag:"ns7:Consignment", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__Consignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Consignment(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Consignment * SOAP_FMAC4 soap_get_ns7__Consignment(struct soap *soap, ns7__Consignment *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__Consignment * FASTCALL soap_instantiate_ns7__Consignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Consignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__Consignment, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__Consignment);
		ASSIGN_PTR(size, sizeof(ns7__Consignment));
		((ns7__Consignment*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__Consignment[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__Consignment));
		for(int i = 0; i < n; i++)
			((ns7__Consignment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__Consignment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__Consignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__Consignment %p -> %p\n", q, p));
	*(ns7__Consignment*)p = *(ns7__Consignment*)q;
}

void ns7__Batch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__Batch::productType = NULL;
	this->ns7__Batch::product = NULL;
	this->ns7__Batch::subProduct = NULL;
	this->ns7__Batch::productItem = NULL;
	this->ns7__Batch::volume = NULL;
	this->ns7__Batch::unit = NULL;
	this->ns7__Batch::dateOfProduction = NULL;
	this->ns7__Batch::expiryDate = NULL;
	this->ns7__Batch::__sizebatchID = 0;
	this->ns7__Batch::batchID = NULL;
	this->ns7__Batch::perishable = NULL;
	this->ns7__Batch::origin = NULL;
	this->ns7__Batch::lowGradeCargo = NULL;
	this->ns7__Batch::packageList = NULL;
	this->ns7__Batch::owner = NULL;
	/* transient soap skipped */
}

void ns7__Batch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductType(soap, &this->ns7__Batch::productType);
	soap_serialize_PointerTons6__Product(soap, &this->ns7__Batch::product);
	soap_serialize_PointerTons6__SubProduct(soap, &this->ns7__Batch::subProduct);
	soap_serialize_PointerTons6__ProductItem(soap, &this->ns7__Batch::productItem);
	soap_serialize_PointerTons3__Decimal(soap, &this->ns7__Batch::volume);
	soap_serialize_PointerTons6__Unit(soap, &this->ns7__Batch::unit);
	soap_serialize_PointerTons7__GoodsDate(soap, &this->ns7__Batch::dateOfProduction);
	soap_serialize_PointerTons7__GoodsDate(soap, &this->ns7__Batch::expiryDate);
	if(this->ns7__Batch::batchID) {
		for(int i = 0; i < this->ns7__Batch::__sizebatchID; i++) {
			soap_serialize_ns3__Identifier(soap, this->ns7__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->ns7__Batch::perishable);
	soap_serialize_PointerTons7__BatchOrigin(soap, &this->ns7__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->ns7__Batch::lowGradeCargo);
	soap_serialize_PointerTons6__PackageList(soap, &this->ns7__Batch::packageList);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns7__Batch::owner);
	/* transient soap skipped */
}

int ns7__Batch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Batch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__Batch(struct soap *soap, const char *tag, int id, const ns7__Batch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Batch), type))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns7:productType", -1, &(a->ns7__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerTons6__Product(soap, "ns7:product", -1, &(a->ns7__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerTons6__SubProduct(soap, "ns7:subProduct", -1, &(a->ns7__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductItem(soap, "ns7:productItem", -1, &(a->ns7__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTons3__Decimal(soap, "ns7:volume", -1, &(a->ns7__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerTons6__Unit(soap, "ns7:unit", -1, &(a->ns7__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTons7__GoodsDate(soap, "ns7:dateOfProduction", -1, &(a->ns7__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTons7__GoodsDate(soap, "ns7:expiryDate", -1, &(a->ns7__Batch::expiryDate), ""))
		return soap->error;
	if(a->ns7__Batch::batchID) {
		int i;
		for(i = 0; i < a->ns7__Batch::__sizebatchID; i++)
			if(soap_out_ns3__Identifier(soap, "ns7:batchID", -1, a->ns7__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "ns7:perishable", -1, &(a->ns7__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTons7__BatchOrigin(soap, "ns7:origin", -1, &(a->ns7__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:lowGradeCargo", -1, &(a->ns7__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerTons6__PackageList(soap, "ns7:packageList", -1, &(a->ns7__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns7:owner", -1, &(a->ns7__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns7__Batch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__Batch(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Batch * FASTCALL soap_in_ns7__Batch(struct soap *soap, const char *tag, ns7__Batch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Batch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Batch, sizeof(ns7__Batch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__Batch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__Batch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_subProduct1 = 1;
	size_t soap_flag_productItem1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_dateOfProduction1 = 1;
	size_t soap_flag_expiryDate1 = 1;
	struct soap_blist *soap_blist_batchID1 = NULL;
	size_t soap_flag_perishable1 = 1;
	size_t soap_flag_origin1 = 1;
	size_t soap_flag_lowGradeCargo1 = 1;
	size_t soap_flag_packageList1 = 1;
	size_t soap_flag_owner1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns7:productType", &(a->ns7__Batch::productType), "ns6:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap_flag_product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns7:product", &(a->ns7__Batch::product), "ns6:Product"))
				{	soap_flag_product1--;
					continue;
				}
			if(soap_flag_subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns7:subProduct", &(a->ns7__Batch::subProduct), "ns6:SubProduct"))
				{	soap_flag_subProduct1--;
					continue;
				}
			if(soap_flag_productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItem(soap, "ns7:productItem", &(a->ns7__Batch::productItem), "ns6:ProductItem"))
				{	soap_flag_productItem1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Decimal(soap, "ns7:volume", &(a->ns7__Batch::volume), "ns3:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns7:unit", &(a->ns7__Batch::unit), "ns6:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if(soap_flag_dateOfProduction1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__GoodsDate(soap, "ns7:dateOfProduction", &(a->ns7__Batch::dateOfProduction), "ns7:GoodsDate"))
				{	soap_flag_dateOfProduction1--;
					continue;
				}
			if(soap_flag_expiryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__GoodsDate(soap, "ns7:expiryDate", &(a->ns7__Batch::expiryDate), "ns7:GoodsDate"))
				{	soap_flag_expiryDate1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:batchID", 1, NULL)) {
				if(a->ns7__Batch::batchID == NULL) {
					if(soap_blist_batchID1 == NULL)
						soap_blist_batchID1 = soap_new_block(soap);
					a->ns7__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID1, sizeof(char *));
					if(a->ns7__Batch::batchID == NULL)
						return NULL;
					*a->ns7__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns3__Identifier(soap, "ns7:batchID", a->ns7__Batch::batchID, "ns3:Identifier"))
				{	a->ns7__Batch::__sizebatchID++;
					a->ns7__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:perishable", &(a->ns7__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable1--;
					continue;
				}
			if(soap_flag_origin1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__BatchOrigin(soap, "ns7:origin", &(a->ns7__Batch::origin), "ns7:BatchOrigin"))
				{	soap_flag_origin1--;
					continue;
				}
			if(soap_flag_lowGradeCargo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:lowGradeCargo", &(a->ns7__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo1--;
					continue;
				}
			if(soap_flag_packageList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackageList(soap, "ns7:packageList", &(a->ns7__Batch::packageList), "ns6:PackageList"))
				{	soap_flag_packageList1--;
					continue;
				}
			if(soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns7:owner", &(a->ns7__Batch::owner), "ns6:BusinessEntity"))
				{	soap_flag_owner1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID1);
		if(a->ns7__Batch::__sizebatchID)
			a->ns7__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID1, NULL, 1);
		else
		{	a->ns7__Batch::batchID = NULL;
			if(soap_blist_batchID1)
				soap_end_block(soap, soap_blist_batchID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__Batch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Batch, 0, sizeof(ns7__Batch), 0, soap_copy_ns7__Batch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns7__Batch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__Batch);
	return this->soap_out(soap, tag?tag:"ns7:Batch", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__Batch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Batch(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Batch * SOAP_FMAC4 soap_get_ns7__Batch(struct soap *soap, ns7__Batch *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__Batch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__Batch * FASTCALL soap_instantiate_ns7__Batch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Batch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__Batch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns7:Consignment")) {
		cp->type = SOAP_TYPE_ns7__Consignment;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__Consignment);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__Consignment));
			((ns7__Consignment*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__Consignment[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__Consignment));
			for(int i = 0; i < n; i++)
				((ns7__Consignment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__Consignment*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:ProductiveBatch")) {
		cp->type = SOAP_TYPE_ns7__ProductiveBatch;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__ProductiveBatch);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__ProductiveBatch));
			((ns7__ProductiveBatch*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__ProductiveBatch[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__ProductiveBatch));
			for(int i = 0; i < n; i++)
				((ns7__ProductiveBatch*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ProductiveBatch*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__Batch);
		ASSIGN_PTR(size, sizeof(ns7__Batch));
		((ns7__Batch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__Batch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__Batch));
		for(int i = 0; i < n; i++)
			((ns7__Batch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__Batch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__Batch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__Batch %p -> %p\n", q, p));
	*(ns7__Batch*)p = *(ns7__Batch*)q;
}

void ns7__VetDocument::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__VetDocument::vetDForm = NULL;
	this->ns7__VetDocument::vetDType = NULL;
	this->ns7__VetDocument::vetDStatus = NULL;
	this->ns7__VetDocument::finalized = NULL;
	this->ns7__VetDocument::lastUpdateDate = NULL;
	this->ns7__VetDocument::__union_VetDocument = 0;
	this->ns7__VetDocument::authentication = NULL;
	soap_default_ns3__String255(soap, &this->ns7__VetDocument::precedingVetDocuments);
	this->ns7__VetDocument::__sizereferencedDocument = 0;
	this->ns7__VetDocument::referencedDocument = NULL;
	this->ns7__VetDocument::__sizestatusChange = 0;
	this->ns7__VetDocument::statusChange = NULL;
	soap_default_ns3__String255(soap, &this->ns7__Document::name);
	soap_default_ns3__String255(soap, &this->ns7__Document::form);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_default_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_default_xsd__date(soap, &this->ns7__Document::issueDate);
	this->ns7__Document::type = NULL;
	this->ns7__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->ns7__Document::for_);
	this->ns7__Document::qualifier = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns7__VetDocument::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__VetDocumentForm(soap, &this->ns7__VetDocument::vetDForm);
	soap_serialize_PointerTons7__VetDocumentType(soap, &this->ns7__VetDocument::vetDType);
	soap_serialize_PointerTons7__VetDocumentStatus(soap, &this->ns7__VetDocument::vetDStatus);
	soap_serialize_PointerTobool(soap, &this->ns7__VetDocument::finalized);
	soap_serialize_PointerTotime(soap, &this->ns7__VetDocument::lastUpdateDate);
	soap_serialize__ns7__union_VetDocument(soap, this->ns7__VetDocument::__union_VetDocument, &this->ns7__VetDocument::union_VetDocument);
	soap_serialize_PointerTons7__VeterinaryAuthentication(soap, &this->ns7__VetDocument::authentication);
	soap_serialize_ns3__String255(soap, &this->ns7__VetDocument::precedingVetDocuments);
	if(this->ns7__VetDocument::referencedDocument) {
		for(int i = 0; i < this->ns7__VetDocument::__sizereferencedDocument; i++) {
			soap_serialize_PointerTons7__ReferencedDocument(soap, this->ns7__VetDocument::referencedDocument + i);
		}
	}
	if(this->ns7__VetDocument::statusChange) {
		for(int i = 0; i < this->ns7__VetDocument::__sizestatusChange; i++) {
			soap_serialize_PointerTons7__VetDocumentStatusChange(soap, this->ns7__VetDocument::statusChange + i);
		}
	}
	soap_serialize_ns3__String255(soap, &this->ns7__Document::name);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::form);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueSeries);
	soap_serialize_ns3__String255(soap, &this->ns7__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->ns7__Document::issueDate);
	soap_serialize_PointerTons6__DocumentType(soap, &this->ns7__Document::type);
	soap_serialize_PointerTons6__Organization(soap, &this->ns7__Document::issuer);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns7__VetDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__VetDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocument(struct soap *soap, const char *tag, int id, const ns7__VetDocument *a, const char *type)
{
	if(((ns7__Document*)a)->for_)
		soap_set_attr(soap, "for", ((ns7__Document*)a)->for_, 1);
	if(((ns7__Document*)a)->qualifier)
		if(*((ns7__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns7__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VetDocument), "ns7:VetDocument"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns7:name", -1, &(a->ns7__Document::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:form", -1, &(a->ns7__Document::form), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueSeries", -1, &(a->ns7__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:issueNumber", -1, &(a->ns7__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "ns7:issueDate", -1, &(a->ns7__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTons6__DocumentType(soap, "ns7:type", -1, &(a->ns7__Document::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__Organization(soap, "ns7:issuer", -1, &(a->ns7__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTons7__VetDocumentForm(soap, "ns7:vetDForm", -1, &(a->ns7__VetDocument::vetDForm), ""))
		return soap->error;
	if(soap_out_PointerTons7__VetDocumentType(soap, "ns7:vetDType", -1, &(a->ns7__VetDocument::vetDType), ""))
		return soap->error;
	if(soap_out_PointerTons7__VetDocumentStatus(soap, "ns7:vetDStatus", -1, &(a->ns7__VetDocument::vetDStatus), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns7:finalized", -1, &(a->ns7__VetDocument::finalized), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns7:lastUpdateDate", -1, &(a->ns7__VetDocument::lastUpdateDate), ""))
		return soap->error;
	if(soap_out__ns7__union_VetDocument(soap, a->ns7__VetDocument::__union_VetDocument, &a->ns7__VetDocument::union_VetDocument))
		return soap->error;
	if(soap_out_PointerTons7__VeterinaryAuthentication(soap, "ns7:authentication", -1, &(a->ns7__VetDocument::authentication), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns7:precedingVetDocuments", -1, &(a->ns7__VetDocument::precedingVetDocuments), ""))
		return soap->error;
	if(a->ns7__VetDocument::referencedDocument) {
		int i;
		for(i = 0; i < a->ns7__VetDocument::__sizereferencedDocument; i++)
			if(soap_out_PointerTons7__ReferencedDocument(soap, "ns7:referencedDocument", -1, a->ns7__VetDocument::referencedDocument + i, ""))
				return soap->error;
	}
	if(a->ns7__VetDocument::statusChange) {
		int i;
		for(i = 0; i < a->ns7__VetDocument::__sizestatusChange; i++)
			if(soap_out_PointerTons7__VetDocumentStatusChange(soap, "ns7:statusChange", -1, a->ns7__VetDocument::statusChange + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns7__VetDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns7__VetDocument(soap, tag, this, type);
}

SOAP_FMAC3 ns7__VetDocument * FASTCALL soap_in_ns7__VetDocument(struct soap *soap, const char *tag, ns7__VetDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__VetDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VetDocument, sizeof(ns7__VetDocument), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns7__VetDocument) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns7__VetDocument *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((ns7__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns7__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns7__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_vetDForm1 = 1;
	size_t soap_flag_vetDType1 = 1;
	size_t soap_flag_vetDStatus1 = 1;
	size_t soap_flag_finalized1 = 1;
	size_t soap_flag_lastUpdateDate1 = 1;
	size_t soap_flag_union_VetDocument1 = 1;
	size_t soap_flag_authentication1 = 1;
	size_t soap_flag_precedingVetDocuments1 = 1;
	struct soap_blist *soap_blist_referencedDocument1 = NULL;
	struct soap_blist *soap_blist_statusChange1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:name", &(a->ns7__Document::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:form", &(a->ns7__Document::form), "ns3:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueSeries", &(a->ns7__Document::issueSeries), "ns3:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:issueNumber", &(a->ns7__Document::issueNumber), "ns3:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "ns7:issueDate", &(a->ns7__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__DocumentType(soap, "ns7:type", &(a->ns7__Document::type), "ns6:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Organization(soap, "ns7:issuer", &(a->ns7__Document::issuer), "ns6:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_vetDForm1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentForm(soap, "ns7:vetDForm", &(a->ns7__VetDocument::vetDForm), "ns7:VetDocumentForm"))
				{	soap_flag_vetDForm1--;
					continue;
				}
			if(soap_flag_vetDType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentType(soap, "ns7:vetDType", &(a->ns7__VetDocument::vetDType), "ns7:VetDocumentType"))
				{	soap_flag_vetDType1--;
					continue;
				}
			if(soap_flag_vetDStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentStatus(soap, "ns7:vetDStatus", &(a->ns7__VetDocument::vetDStatus), "ns7:VetDocumentStatus"))
				{	soap_flag_vetDStatus1--;
					continue;
				}
			if(soap_flag_finalized1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns7:finalized", &(a->ns7__VetDocument::finalized), "xsd:boolean"))
				{	soap_flag_finalized1--;
					continue;
				}
			if(soap_flag_lastUpdateDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns7:lastUpdateDate", &(a->ns7__VetDocument::lastUpdateDate), "xsd:dateTime"))
				{	soap_flag_lastUpdateDate1--;
					continue;
				}
			if(soap_flag_union_VetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__ns7__union_VetDocument(soap, &a->ns7__VetDocument::__union_VetDocument, &a->ns7__VetDocument::union_VetDocument))
				{	soap_flag_union_VetDocument1 = 0;
					continue;
				}
			if(soap_flag_authentication1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VeterinaryAuthentication(soap, "ns7:authentication", &(a->ns7__VetDocument::authentication), "ns7:VeterinaryAuthentication"))
				{	soap_flag_authentication1--;
					continue;
				}
			if(soap_flag_precedingVetDocuments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns7:precedingVetDocuments", &(a->ns7__VetDocument::precedingVetDocuments), "ns3:String255"))
				{	soap_flag_precedingVetDocuments1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:referencedDocument", 1, NULL)) {
				if(a->ns7__VetDocument::referencedDocument == NULL) {
					if(soap_blist_referencedDocument1 == NULL)
						soap_blist_referencedDocument1 = soap_new_block(soap);
					a->ns7__VetDocument::referencedDocument = (ns7__ReferencedDocument **)soap_push_block(soap, soap_blist_referencedDocument1, sizeof(ns7__ReferencedDocument *));
					if(a->ns7__VetDocument::referencedDocument == NULL)
						return NULL;
					*a->ns7__VetDocument::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__ReferencedDocument(soap, "ns7:referencedDocument", a->ns7__VetDocument::referencedDocument, "ns7:ReferencedDocument"))
				{	a->ns7__VetDocument::__sizereferencedDocument++;
					a->ns7__VetDocument::referencedDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:statusChange", 1, NULL)) {
				if(a->ns7__VetDocument::statusChange == NULL) {
					if(soap_blist_statusChange1 == NULL)
						soap_blist_statusChange1 = soap_new_block(soap);
					a->ns7__VetDocument::statusChange = (ns7__VetDocumentStatusChange **)soap_push_block(soap, soap_blist_statusChange1, sizeof(ns7__VetDocumentStatusChange *));
					if(a->ns7__VetDocument::statusChange == NULL)
						return NULL;
					*a->ns7__VetDocument::statusChange = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocumentStatusChange(soap, "ns7:statusChange", a->ns7__VetDocument::statusChange, "ns7:VetDocumentStatusChange"))
				{	a->ns7__VetDocument::__sizestatusChange++;
					a->ns7__VetDocument::statusChange = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns7__VetDocument::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument1);
		if(a->ns7__VetDocument::__sizereferencedDocument)
			a->ns7__VetDocument::referencedDocument = (ns7__ReferencedDocument **)soap_save_block(soap, soap_blist_referencedDocument1, NULL, 1);
		else
		{	a->ns7__VetDocument::referencedDocument = NULL;
			if(soap_blist_referencedDocument1)
				soap_end_block(soap, soap_blist_referencedDocument1);
		}
		if(a->ns7__VetDocument::statusChange)
			soap_pop_block(soap, soap_blist_statusChange1);
		if(a->ns7__VetDocument::__sizestatusChange)
			a->ns7__VetDocument::statusChange = (ns7__VetDocumentStatusChange **)soap_save_block(soap, soap_blist_statusChange1, NULL, 1);
		else
		{	a->ns7__VetDocument::statusChange = NULL;
			if(soap_blist_statusChange1)
				soap_end_block(soap, soap_blist_statusChange1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns7__VetDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VetDocument, 0, sizeof(ns7__VetDocument), 0, soap_copy_ns7__VetDocument);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VetDocument1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns7__VetDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__VetDocument);
	return this->soap_out(soap, tag?tag:"ns7:VetDocument", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns7__VetDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__VetDocument(soap, this, tag, type);
}

SOAP_FMAC3 ns7__VetDocument * SOAP_FMAC4 soap_get_ns7__VetDocument(struct soap *soap, ns7__VetDocument *p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns7__VetDocument * FASTCALL soap_instantiate_ns7__VetDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__VetDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__VetDocument, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns7__VetDocument);
		ASSIGN_PTR(size, sizeof(ns7__VetDocument));
		((ns7__VetDocument*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns7__VetDocument[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns7__VetDocument));
		for(int i = 0; i < n; i++)
			((ns7__VetDocument*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__VetDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__VetDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__VetDocument %p -> %p\n", q, p));
	*(ns7__VetDocument*)p = *(ns7__VetDocument*)q;
}

void ns6__ActivityLocationList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ActivityLocationList::__sizelocation = 0;
	this->ns6__ActivityLocationList::location = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__ActivityLocationList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__ActivityLocationList::location) {
		for(int i = 0; i < this->ns6__ActivityLocationList::__sizelocation; i++) {
			soap_serialize_PointerTons6__BusinessMember(soap, this->ns6__ActivityLocationList::location + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ActivityLocationList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ActivityLocationList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ActivityLocationList(struct soap *soap, const char *tag, int id, const ns6__ActivityLocationList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ActivityLocationList), "ns6:ActivityLocationList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__ActivityLocationList::location) {
		int i;
		for(i = 0; i < a->ns6__ActivityLocationList::__sizelocation; i++)
			if(soap_out_PointerTons6__BusinessMember(soap, "ns6:location", -1, a->ns6__ActivityLocationList::location + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ActivityLocationList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ActivityLocationList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ActivityLocationList * FASTCALL soap_in_ns6__ActivityLocationList(struct soap *soap, const char *tag, ns6__ActivityLocationList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ActivityLocationList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ActivityLocationList, sizeof(ns6__ActivityLocationList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ActivityLocationList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ActivityLocationList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_location1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:location", 1, NULL)) {
				if(a->ns6__ActivityLocationList::location == NULL) {
					if(soap_blist_location1 == NULL)
						soap_blist_location1 = soap_new_block(soap);
					a->ns6__ActivityLocationList::location = (ns6__BusinessMember **)soap_push_block(soap, soap_blist_location1, sizeof(ns6__BusinessMember *));
					if(a->ns6__ActivityLocationList::location == NULL)
						return NULL;
					*a->ns6__ActivityLocationList::location = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__BusinessMember(soap, "ns6:location", a->ns6__ActivityLocationList::location, "ns6:BusinessMember"))
				{	a->ns6__ActivityLocationList::__sizelocation++;
					a->ns6__ActivityLocationList::location = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__ActivityLocationList::location)
			soap_pop_block(soap, soap_blist_location1);
		if(a->ns6__ActivityLocationList::__sizelocation)
			a->ns6__ActivityLocationList::location = (ns6__BusinessMember **)soap_save_block(soap, soap_blist_location1, NULL, 1);
		else
		{	a->ns6__ActivityLocationList::location = NULL;
			if(soap_blist_location1)
				soap_end_block(soap, soap_blist_location1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ActivityLocationList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ActivityLocationList, 0, sizeof(ns6__ActivityLocationList), 0, soap_copy_ns6__ActivityLocationList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ActivityLocationList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ActivityLocationList);
	return this->soap_out(soap, tag?tag:"ns6:ActivityLocationList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ActivityLocationList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ActivityLocationList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ActivityLocationList * SOAP_FMAC4 soap_get_ns6__ActivityLocationList(struct soap *soap, ns6__ActivityLocationList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ActivityLocationList * FASTCALL soap_instantiate_ns6__ActivityLocationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ActivityLocationList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ActivityLocationList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ActivityLocationList);
		ASSIGN_PTR(size, sizeof(ns6__ActivityLocationList));
		((ns6__ActivityLocationList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ActivityLocationList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ActivityLocationList));
		for(int i = 0; i < n; i++)
			((ns6__ActivityLocationList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ActivityLocationList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ActivityLocationList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ActivityLocationList %p -> %p\n", q, p));
	*(ns6__ActivityLocationList*)p = *(ns6__ActivityLocationList*)q;
}

void ns6__ResearchMethodList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ResearchMethodList::__sizemethod = 0;
	this->ns6__ResearchMethodList::method = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__ResearchMethodList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__ResearchMethodList::method) {
		for(int i = 0; i < this->ns6__ResearchMethodList::__sizemethod; i++) {
			soap_serialize_PointerTons6__ResearchMethod(soap, this->ns6__ResearchMethodList::method + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ResearchMethodList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ResearchMethodList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ResearchMethodList(struct soap *soap, const char *tag, int id, const ns6__ResearchMethodList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ResearchMethodList), "ns6:ResearchMethodList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__ResearchMethodList::method) {
		int i;
		for(i = 0; i < a->ns6__ResearchMethodList::__sizemethod; i++)
			if(soap_out_PointerTons6__ResearchMethod(soap, "ns6:method", -1, a->ns6__ResearchMethodList::method + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ResearchMethodList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ResearchMethodList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ResearchMethodList * FASTCALL soap_in_ns6__ResearchMethodList(struct soap *soap, const char *tag, ns6__ResearchMethodList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ResearchMethodList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ResearchMethodList, sizeof(ns6__ResearchMethodList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ResearchMethodList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ResearchMethodList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_method1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:method", 1, NULL)) {
				if(a->ns6__ResearchMethodList::method == NULL) {
					if(soap_blist_method1 == NULL)
						soap_blist_method1 = soap_new_block(soap);
					a->ns6__ResearchMethodList::method = (ns6__ResearchMethod **)soap_push_block(soap, soap_blist_method1, sizeof(ns6__ResearchMethod *));
					if(a->ns6__ResearchMethodList::method == NULL)
						return NULL;
					*a->ns6__ResearchMethodList::method = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__ResearchMethod(soap, "ns6:method", a->ns6__ResearchMethodList::method, "ns6:ResearchMethod"))
				{	a->ns6__ResearchMethodList::__sizemethod++;
					a->ns6__ResearchMethodList::method = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__ResearchMethodList::method)
			soap_pop_block(soap, soap_blist_method1);
		if(a->ns6__ResearchMethodList::__sizemethod)
			a->ns6__ResearchMethodList::method = (ns6__ResearchMethod **)soap_save_block(soap, soap_blist_method1, NULL, 1);
		else
		{	a->ns6__ResearchMethodList::method = NULL;
			if(soap_blist_method1)
				soap_end_block(soap, soap_blist_method1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ResearchMethodList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ResearchMethodList, 0, sizeof(ns6__ResearchMethodList), 0, soap_copy_ns6__ResearchMethodList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ResearchMethodList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ResearchMethodList);
	return this->soap_out(soap, tag?tag:"ns6:ResearchMethodList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ResearchMethodList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ResearchMethodList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ResearchMethodList * SOAP_FMAC4 soap_get_ns6__ResearchMethodList(struct soap *soap, ns6__ResearchMethodList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ResearchMethodList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ResearchMethodList * FASTCALL soap_instantiate_ns6__ResearchMethodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ResearchMethodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ResearchMethodList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethodList);
		ASSIGN_PTR(size, sizeof(ns6__ResearchMethodList));
		((ns6__ResearchMethodList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethodList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ResearchMethodList));
		for(int i = 0; i < n; i++)
			((ns6__ResearchMethodList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ResearchMethodList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ResearchMethodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ResearchMethodList %p -> %p\n", q, p));
	*(ns6__ResearchMethodList*)p = *(ns6__ResearchMethodList*)q;
}

void ns6__AnimalDiseaseList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__AnimalDiseaseList::__sizedisease = 0;
	this->ns6__AnimalDiseaseList::disease = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__AnimalDiseaseList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__AnimalDiseaseList::disease) {
		for(int i = 0; i < this->ns6__AnimalDiseaseList::__sizedisease; i++) {
			soap_serialize_PointerTons6__AnimalDisease(soap, this->ns6__AnimalDiseaseList::disease + i);
		}
	}
	/* transient soap skipped */
}

int ns6__AnimalDiseaseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AnimalDiseaseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__AnimalDiseaseList(struct soap *soap, const char *tag, int id, const ns6__AnimalDiseaseList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AnimalDiseaseList), "ns6:AnimalDiseaseList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__AnimalDiseaseList::disease) {
		int i;
		for(i = 0; i < a->ns6__AnimalDiseaseList::__sizedisease; i++)
			if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:disease", -1, a->ns6__AnimalDiseaseList::disease + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__AnimalDiseaseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__AnimalDiseaseList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AnimalDiseaseList * FASTCALL soap_in_ns6__AnimalDiseaseList(struct soap *soap, const char *tag, ns6__AnimalDiseaseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AnimalDiseaseList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AnimalDiseaseList, sizeof(ns6__AnimalDiseaseList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__AnimalDiseaseList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AnimalDiseaseList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_disease1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:disease", 1, NULL)) {
				if(a->ns6__AnimalDiseaseList::disease == NULL) {
					if(soap_blist_disease1 == NULL)
						soap_blist_disease1 = soap_new_block(soap);
					a->ns6__AnimalDiseaseList::disease = (ns6__AnimalDisease **)soap_push_block(soap, soap_blist_disease1, sizeof(ns6__AnimalDisease *));
					if(a->ns6__AnimalDiseaseList::disease == NULL)
						return NULL;
					*a->ns6__AnimalDiseaseList::disease = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:disease", a->ns6__AnimalDiseaseList::disease, "ns6:AnimalDisease"))
				{	a->ns6__AnimalDiseaseList::__sizedisease++;
					a->ns6__AnimalDiseaseList::disease = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__AnimalDiseaseList::disease)
			soap_pop_block(soap, soap_blist_disease1);
		if(a->ns6__AnimalDiseaseList::__sizedisease)
			a->ns6__AnimalDiseaseList::disease = (ns6__AnimalDisease **)soap_save_block(soap, soap_blist_disease1, NULL, 1);
		else
		{	a->ns6__AnimalDiseaseList::disease = NULL;
			if(soap_blist_disease1)
				soap_end_block(soap, soap_blist_disease1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__AnimalDiseaseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AnimalDiseaseList, 0, sizeof(ns6__AnimalDiseaseList), 0, soap_copy_ns6__AnimalDiseaseList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__AnimalDiseaseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AnimalDiseaseList);
	return this->soap_out(soap, tag?tag:"ns6:AnimalDiseaseList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__AnimalDiseaseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AnimalDiseaseList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AnimalDiseaseList * SOAP_FMAC4 soap_get_ns6__AnimalDiseaseList(struct soap *soap, ns6__AnimalDiseaseList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__AnimalDiseaseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__AnimalDiseaseList * FASTCALL soap_instantiate_ns6__AnimalDiseaseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AnimalDiseaseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AnimalDiseaseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__AnimalDiseaseList);
		ASSIGN_PTR(size, sizeof(ns6__AnimalDiseaseList));
		((ns6__AnimalDiseaseList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__AnimalDiseaseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__AnimalDiseaseList));
		for(int i = 0; i < n; i++)
			((ns6__AnimalDiseaseList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AnimalDiseaseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AnimalDiseaseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AnimalDiseaseList %p -> %p\n", q, p));
	*(ns6__AnimalDiseaseList*)p = *(ns6__AnimalDiseaseList*)q;
}

void ns6__RegionalizationShippingRuleList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationShippingRuleList::__sizerule = 0;
	this->ns6__RegionalizationShippingRuleList::rule = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__RegionalizationShippingRuleList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__RegionalizationShippingRuleList::rule) {
		for(int i = 0; i < this->ns6__RegionalizationShippingRuleList::__sizerule; i++) {
			soap_serialize_PointerTons6__RegionalizationShippingRule(soap, this->ns6__RegionalizationShippingRuleList::rule + i);
		}
	}
	/* transient soap skipped */
}

int ns6__RegionalizationShippingRuleList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationShippingRuleList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationShippingRuleList(struct soap *soap, const char *tag, int id, const ns6__RegionalizationShippingRuleList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationShippingRuleList), "ns6:RegionalizationShippingRuleList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__RegionalizationShippingRuleList::rule) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationShippingRuleList::__sizerule; i++)
			if(soap_out_PointerTons6__RegionalizationShippingRule(soap, "ns6:rule", -1, a->ns6__RegionalizationShippingRuleList::rule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationShippingRuleList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationShippingRuleList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRuleList * FASTCALL soap_in_ns6__RegionalizationShippingRuleList(struct soap *soap, const char *tag, ns6__RegionalizationShippingRuleList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationShippingRuleList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationShippingRuleList, sizeof(ns6__RegionalizationShippingRuleList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationShippingRuleList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationShippingRuleList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_rule1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:rule", 1, NULL)) {
				if(a->ns6__RegionalizationShippingRuleList::rule == NULL) {
					if(soap_blist_rule1 == NULL)
						soap_blist_rule1 = soap_new_block(soap);
					a->ns6__RegionalizationShippingRuleList::rule = (ns6__RegionalizationShippingRule **)soap_push_block(soap, soap_blist_rule1, sizeof(ns6__RegionalizationShippingRule *));
					if(a->ns6__RegionalizationShippingRuleList::rule == NULL)
						return NULL;
					*a->ns6__RegionalizationShippingRuleList::rule = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationShippingRule(soap, "ns6:rule", a->ns6__RegionalizationShippingRuleList::rule, "ns6:RegionalizationShippingRule"))
				{	a->ns6__RegionalizationShippingRuleList::__sizerule++;
					a->ns6__RegionalizationShippingRuleList::rule = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationShippingRuleList::rule)
			soap_pop_block(soap, soap_blist_rule1);
		if(a->ns6__RegionalizationShippingRuleList::__sizerule)
			a->ns6__RegionalizationShippingRuleList::rule = (ns6__RegionalizationShippingRule **)soap_save_block(soap, soap_blist_rule1, NULL, 1);
		else
		{	a->ns6__RegionalizationShippingRuleList::rule = NULL;
			if(soap_blist_rule1)
				soap_end_block(soap, soap_blist_rule1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationShippingRuleList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationShippingRuleList, 0, sizeof(ns6__RegionalizationShippingRuleList), 0, soap_copy_ns6__RegionalizationShippingRuleList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationShippingRuleList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationShippingRuleList);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationShippingRuleList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationShippingRuleList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationShippingRuleList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRuleList * SOAP_FMAC4 soap_get_ns6__RegionalizationShippingRuleList(struct soap *soap, ns6__RegionalizationShippingRuleList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationShippingRuleList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationShippingRuleList * FASTCALL soap_instantiate_ns6__RegionalizationShippingRuleList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationShippingRuleList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationShippingRuleList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRuleList);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationShippingRuleList));
		((ns6__RegionalizationShippingRuleList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRuleList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationShippingRuleList));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationShippingRuleList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationShippingRuleList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationShippingRuleList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationShippingRuleList %p -> %p\n", q, p));
	*(ns6__RegionalizationShippingRuleList*)p = *(ns6__RegionalizationShippingRuleList*)q;
}

void ns6__RegionalizationRegionStatusList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationRegionStatusList::__sizestatus = 0;
	this->ns6__RegionalizationRegionStatusList::status = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__RegionalizationRegionStatusList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__RegionalizationRegionStatusList::status) {
		for(int i = 0; i < this->ns6__RegionalizationRegionStatusList::__sizestatus; i++) {
			soap_serialize_PointerTons6__RegionalizationRegionStatus(soap, this->ns6__RegionalizationRegionStatusList::status + i);
		}
	}
	/* transient soap skipped */
}

int ns6__RegionalizationRegionStatusList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationRegionStatusList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationRegionStatusList(struct soap *soap, const char *tag, int id, const ns6__RegionalizationRegionStatusList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationRegionStatusList), "ns6:RegionalizationRegionStatusList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__RegionalizationRegionStatusList::status) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationRegionStatusList::__sizestatus; i++)
			if(soap_out_PointerTons6__RegionalizationRegionStatus(soap, "ns6:status", -1, a->ns6__RegionalizationRegionStatusList::status + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationRegionStatusList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationRegionStatusList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatusList * FASTCALL soap_in_ns6__RegionalizationRegionStatusList(struct soap *soap, const char *tag, ns6__RegionalizationRegionStatusList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationRegionStatusList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationRegionStatusList, sizeof(ns6__RegionalizationRegionStatusList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationRegionStatusList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationRegionStatusList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_status1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:status", 1, NULL)) {
				if(a->ns6__RegionalizationRegionStatusList::status == NULL) {
					if(soap_blist_status1 == NULL)
						soap_blist_status1 = soap_new_block(soap);
					a->ns6__RegionalizationRegionStatusList::status = (ns6__RegionalizationRegionStatus **)soap_push_block(soap, soap_blist_status1, sizeof(ns6__RegionalizationRegionStatus *));
					if(a->ns6__RegionalizationRegionStatusList::status == NULL)
						return NULL;
					*a->ns6__RegionalizationRegionStatusList::status = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationRegionStatus(soap, "ns6:status", a->ns6__RegionalizationRegionStatusList::status, "ns6:RegionalizationRegionStatus"))
				{	a->ns6__RegionalizationRegionStatusList::__sizestatus++;
					a->ns6__RegionalizationRegionStatusList::status = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationRegionStatusList::status)
			soap_pop_block(soap, soap_blist_status1);
		if(a->ns6__RegionalizationRegionStatusList::__sizestatus)
			a->ns6__RegionalizationRegionStatusList::status = (ns6__RegionalizationRegionStatus **)soap_save_block(soap, soap_blist_status1, NULL, 1);
		else
		{	a->ns6__RegionalizationRegionStatusList::status = NULL;
			if(soap_blist_status1)
				soap_end_block(soap, soap_blist_status1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationRegionStatusList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationRegionStatusList, 0, sizeof(ns6__RegionalizationRegionStatusList), 0, soap_copy_ns6__RegionalizationRegionStatusList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationRegionStatusList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationRegionStatusList);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationRegionStatusList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationRegionStatusList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationRegionStatusList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatusList * SOAP_FMAC4 soap_get_ns6__RegionalizationRegionStatusList(struct soap *soap, ns6__RegionalizationRegionStatusList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationRegionStatusList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationRegionStatusList * FASTCALL soap_instantiate_ns6__RegionalizationRegionStatusList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationRegionStatusList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationRegionStatusList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatusList);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationRegionStatusList));
		((ns6__RegionalizationRegionStatusList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatusList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationRegionStatusList));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationRegionStatusList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationRegionStatusList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationRegionStatusList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationRegionStatusList %p -> %p\n", q, p));
	*(ns6__RegionalizationRegionStatusList*)p = *(ns6__RegionalizationRegionStatusList*)q;
}

void ns6__RegionalizationConditionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationConditionList::__sizecondition = 0;
	this->ns6__RegionalizationConditionList::condition = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__RegionalizationConditionList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__RegionalizationConditionList::condition) {
		for(int i = 0; i < this->ns6__RegionalizationConditionList::__sizecondition; i++) {
			soap_serialize_PointerTons6__RegionalizationCondition(soap, this->ns6__RegionalizationConditionList::condition + i);
		}
	}
	/* transient soap skipped */
}

int ns6__RegionalizationConditionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationConditionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationConditionList(struct soap *soap, const char *tag, int id, const ns6__RegionalizationConditionList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationConditionList), "ns6:RegionalizationConditionList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__RegionalizationConditionList::condition) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationConditionList::__sizecondition; i++)
			if(soap_out_PointerTons6__RegionalizationCondition(soap, "ns6:condition", -1, a->ns6__RegionalizationConditionList::condition + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationConditionList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationConditionList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionList * FASTCALL soap_in_ns6__RegionalizationConditionList(struct soap *soap, const char *tag, ns6__RegionalizationConditionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationConditionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationConditionList, sizeof(ns6__RegionalizationConditionList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationConditionList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationConditionList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_condition1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:condition", 1, NULL)) {
				if(a->ns6__RegionalizationConditionList::condition == NULL) {
					if(soap_blist_condition1 == NULL)
						soap_blist_condition1 = soap_new_block(soap);
					a->ns6__RegionalizationConditionList::condition = (ns6__RegionalizationCondition **)soap_push_block(soap, soap_blist_condition1, sizeof(ns6__RegionalizationCondition *));
					if(a->ns6__RegionalizationConditionList::condition == NULL)
						return NULL;
					*a->ns6__RegionalizationConditionList::condition = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationCondition(soap, "ns6:condition", a->ns6__RegionalizationConditionList::condition, "ns6:RegionalizationCondition"))
				{	a->ns6__RegionalizationConditionList::__sizecondition++;
					a->ns6__RegionalizationConditionList::condition = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationConditionList::condition)
			soap_pop_block(soap, soap_blist_condition1);
		if(a->ns6__RegionalizationConditionList::__sizecondition)
			a->ns6__RegionalizationConditionList::condition = (ns6__RegionalizationCondition **)soap_save_block(soap, soap_blist_condition1, NULL, 1);
		else
		{	a->ns6__RegionalizationConditionList::condition = NULL;
			if(soap_blist_condition1)
				soap_end_block(soap, soap_blist_condition1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationConditionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationConditionList, 0, sizeof(ns6__RegionalizationConditionList), 0, soap_copy_ns6__RegionalizationConditionList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationConditionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationConditionList);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationConditionList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationConditionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationConditionList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionList * SOAP_FMAC4 soap_get_ns6__RegionalizationConditionList(struct soap *soap, ns6__RegionalizationConditionList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationConditionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationConditionList * FASTCALL soap_instantiate_ns6__RegionalizationConditionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationConditionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationConditionList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationConditionList);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationConditionList));
		((ns6__RegionalizationConditionList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationConditionList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationConditionList));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationConditionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationConditionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationConditionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationConditionList %p -> %p\n", q, p));
	*(ns6__RegionalizationConditionList*)p = *(ns6__RegionalizationConditionList*)q;
}

void ns6__Area::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Address::country = NULL;
	this->ns6__Address::federalDistrict = NULL;
	this->ns6__Address::region = NULL;
	this->ns6__Address::district = NULL;
	this->ns6__Address::locality = NULL;
	this->ns6__Address::subLocality = NULL;
	this->ns6__Address::street = NULL;
	soap_default_ns3__String255(soap, &this->ns6__Address::house);
	soap_default_ns3__String255(soap, &this->ns6__Address::building);
	soap_default_ns3__String255(soap, &this->ns6__Address::room);
	soap_default_ns3__String255(soap, &this->ns6__Address::postIndex);
	soap_default_ns3__String255(soap, &this->ns6__Address::postBox);
	this->ns6__Address::additionalInfo = NULL;
	this->ns6__Address::addressView = NULL;
	this->ns6__Address::enAddressView = NULL;
	/* transient soap skipped */
}

void ns6__Area::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Country(soap, &this->ns6__Address::country);
	soap_serialize_PointerTons6__FederalDistrict(soap, &this->ns6__Address::federalDistrict);
	soap_serialize_PointerTons6__Region(soap, &this->ns6__Address::region);
	soap_serialize_PointerTons6__District(soap, &this->ns6__Address::district);
	soap_serialize_PointerTons6__Locality(soap, &this->ns6__Address::locality);
	soap_serialize_PointerTons6__Locality(soap, &this->ns6__Address::subLocality);
	soap_serialize_PointerTons6__Street(soap, &this->ns6__Address::street);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::house);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::building);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::room);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::postIndex);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::postBox);
	soap_serialize_PointerTons3__NText(soap, &this->ns6__Address::additionalInfo);
	soap_serialize_PointerTons3__NText(soap, &this->ns6__Address::addressView);
	soap_serialize_PointerTons3__NText(soap, &this->ns6__Address::enAddressView);
	/* transient soap skipped */
}

int ns6__Area::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Area(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Area(struct soap *soap, const char *tag, int id, const ns6__Area *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Area), "ns6:Area"))
		return soap->error;
	if(soap_out_PointerTons6__Country(soap, "ns6:country", -1, &(a->ns6__Address::country), ""))
		return soap->error;
	if(soap_out_PointerTons6__FederalDistrict(soap, "ns6:federalDistrict", -1, &(a->ns6__Address::federalDistrict), ""))
		return soap->error;
	if(soap_out_PointerTons6__Region(soap, "ns6:region", -1, &(a->ns6__Address::region), ""))
		return soap->error;
	if(soap_out_PointerTons6__District(soap, "ns6:district", -1, &(a->ns6__Address::district), ""))
		return soap->error;
	if(soap_out_PointerTons6__Locality(soap, "ns6:locality", -1, &(a->ns6__Address::locality), ""))
		return soap->error;
	if(soap_out_PointerTons6__Locality(soap, "ns6:subLocality", -1, &(a->ns6__Address::subLocality), ""))
		return soap->error;
	if(soap_out_PointerTons6__Street(soap, "ns6:street", -1, &(a->ns6__Address::street), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:house", -1, &(a->ns6__Address::house), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:building", -1, &(a->ns6__Address::building), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:room", -1, &(a->ns6__Address::room), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:postIndex", -1, &(a->ns6__Address::postIndex), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:postBox", -1, &(a->ns6__Address::postBox), ""))
		return soap->error;
	if(soap_out_PointerTons3__NText(soap, "ns6:additionalInfo", -1, &(a->ns6__Address::additionalInfo), ""))
		return soap->error;
	if(soap_out_PointerTons3__NText(soap, "ns6:addressView", -1, &(a->ns6__Address::addressView), ""))
		return soap->error;
	if(soap_out_PointerTons3__NText(soap, "ns6:enAddressView", -1, &(a->ns6__Address::enAddressView), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Area::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Area(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Area * FASTCALL soap_in_ns6__Area(struct soap *soap, const char *tag, ns6__Area *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Area *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Area, sizeof(ns6__Area), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Area) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Area *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country2 = 1;
	size_t soap_flag_federalDistrict2 = 1;
	size_t soap_flag_region2 = 1;
	size_t soap_flag_district2 = 1;
	size_t soap_flag_locality2 = 1;
	size_t soap_flag_subLocality2 = 1;
	size_t soap_flag_street2 = 1;
	size_t soap_flag_house2 = 1;
	size_t soap_flag_building2 = 1;
	size_t soap_flag_room2 = 1;
	size_t soap_flag_postIndex2 = 1;
	size_t soap_flag_postBox2 = 1;
	size_t soap_flag_additionalInfo2 = 1;
	size_t soap_flag_addressView2 = 1;
	size_t soap_flag_enAddressView2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Country(soap, "ns6:country", &(a->ns6__Address::country), "ns6:Country"))
				{	soap_flag_country2--;
					continue;
				}
			if(soap_flag_federalDistrict2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__FederalDistrict(soap, "ns6:federalDistrict", &(a->ns6__Address::federalDistrict), "ns6:FederalDistrict"))
				{	soap_flag_federalDistrict2--;
					continue;
				}
			if(soap_flag_region2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Region(soap, "ns6:region", &(a->ns6__Address::region), "ns6:Region"))
				{	soap_flag_region2--;
					continue;
				}
			if(soap_flag_district2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__District(soap, "ns6:district", &(a->ns6__Address::district), "ns6:District"))
				{	soap_flag_district2--;
					continue;
				}
			if(soap_flag_locality2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Locality(soap, "ns6:locality", &(a->ns6__Address::locality), "ns6:Locality"))
				{	soap_flag_locality2--;
					continue;
				}
			if(soap_flag_subLocality2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Locality(soap, "ns6:subLocality", &(a->ns6__Address::subLocality), "ns6:Locality"))
				{	soap_flag_subLocality2--;
					continue;
				}
			if(soap_flag_street2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Street(soap, "ns6:street", &(a->ns6__Address::street), "ns6:Street"))
				{	soap_flag_street2--;
					continue;
				}
			if(soap_flag_house2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:house", &(a->ns6__Address::house), "ns3:String255"))
				{	soap_flag_house2--;
					continue;
				}
			if(soap_flag_building2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:building", &(a->ns6__Address::building), "ns3:String255"))
				{	soap_flag_building2--;
					continue;
				}
			if(soap_flag_room2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:room", &(a->ns6__Address::room), "ns3:String255"))
				{	soap_flag_room2--;
					continue;
				}
			if(soap_flag_postIndex2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:postIndex", &(a->ns6__Address::postIndex), "ns3:String255"))
				{	soap_flag_postIndex2--;
					continue;
				}
			if(soap_flag_postBox2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:postBox", &(a->ns6__Address::postBox), "ns3:String255"))
				{	soap_flag_postBox2--;
					continue;
				}
			if(soap_flag_additionalInfo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:additionalInfo", &(a->ns6__Address::additionalInfo), "ns3:NText"))
				{	soap_flag_additionalInfo2--;
					continue;
				}
			if(soap_flag_addressView2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:addressView", &(a->ns6__Address::addressView), "ns3:NText"))
				{	soap_flag_addressView2--;
					continue;
				}
			if(soap_flag_enAddressView2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:enAddressView", &(a->ns6__Address::enAddressView), "ns3:NText"))
				{	soap_flag_enAddressView2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Area *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Area, 0, sizeof(ns6__Area), 0, soap_copy_ns6__Area);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Area::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Area);
	return this->soap_out(soap, tag?tag:"ns6:Area", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Area::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Area(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Area * SOAP_FMAC4 soap_get_ns6__Area(struct soap *soap, ns6__Area *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Area * FASTCALL soap_instantiate_ns6__Area(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Area(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Area, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Area);
		ASSIGN_PTR(size, sizeof(ns6__Area));
		((ns6__Area*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Area[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Area));
		for(int i = 0; i < n; i++)
			((ns6__Area*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Area*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Area(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Area %p -> %p\n", q, p));
	*(ns6__Area*)p = *(ns6__Area*)q;
}

void ns6__RegionalizationRegionStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationRegionStatus::referenceNumber = NULL;
	this->ns6__RegionalizationRegionStatus::r13nZone = NULL;
	this->ns6__RegionalizationRegionStatus::__sizeexcludedR13nZone = 0;
	this->ns6__RegionalizationRegionStatus::excludedR13nZone = NULL;
	this->ns6__RegionalizationRegionStatus::__sizer13nStatus = 0;
	this->ns6__RegionalizationRegionStatus::r13nStatus = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__RegionalizationRegionStatus::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns6__RegionalizationRegionStatus::referenceNumber);
	soap_serialize_PointerTons6__Area(soap, &this->ns6__RegionalizationRegionStatus::r13nZone);
	if(this->ns6__RegionalizationRegionStatus::excludedR13nZone) {
		for(int i = 0; i < this->ns6__RegionalizationRegionStatus::__sizeexcludedR13nZone; i++) {
			soap_serialize_PointerTons6__Area(soap, this->ns6__RegionalizationRegionStatus::excludedR13nZone + i);
		}
	}
	if(this->ns6__RegionalizationRegionStatus::r13nStatus) {
		for(int i = 0; i < this->ns6__RegionalizationRegionStatus::__sizer13nStatus; i++) {
			soap_serialize_PointerTons6__RegionalizationStatus(soap, this->ns6__RegionalizationRegionStatus::r13nStatus + i);
		}
	}
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__RegionalizationRegionStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationRegionStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, const ns6__RegionalizationRegionStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationRegionStatus), "ns6:RegionalizationRegionStatus"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns6:referenceNumber", -1, &(a->ns6__RegionalizationRegionStatus::referenceNumber), ""))
		return soap->error;
	if(soap_out_PointerTons6__Area(soap, "ns6:r13nZone", -1, &(a->ns6__RegionalizationRegionStatus::r13nZone), ""))
		return soap->error;
	if(a->ns6__RegionalizationRegionStatus::excludedR13nZone) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationRegionStatus::__sizeexcludedR13nZone; i++)
			if(soap_out_PointerTons6__Area(soap, "ns6:excludedR13nZone", -1, a->ns6__RegionalizationRegionStatus::excludedR13nZone + i, ""))
				return soap->error;
	}
	if(a->ns6__RegionalizationRegionStatus::r13nStatus) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationRegionStatus::__sizer13nStatus; i++)
			if(soap_out_PointerTons6__RegionalizationStatus(soap, "ns6:r13nStatus", -1, a->ns6__RegionalizationRegionStatus::r13nStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationRegionStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationRegionStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatus * FASTCALL soap_in_ns6__RegionalizationRegionStatus(struct soap *soap, const char *tag, ns6__RegionalizationRegionStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationRegionStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationRegionStatus, sizeof(ns6__RegionalizationRegionStatus), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationRegionStatus) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationRegionStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_r13nZone1 = 1;
	struct soap_blist *soap_blist_excludedR13nZone1 = NULL;
	struct soap_blist *soap_blist_r13nStatus1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns6:referenceNumber", &(a->ns6__RegionalizationRegionStatus::referenceNumber), "ns3:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_r13nZone1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Area(soap, "ns6:r13nZone", &(a->ns6__RegionalizationRegionStatus::r13nZone), "ns6:Area"))
				{	soap_flag_r13nZone1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:excludedR13nZone", 1, NULL)) {
				if(a->ns6__RegionalizationRegionStatus::excludedR13nZone == NULL) {
					if(soap_blist_excludedR13nZone1 == NULL)
						soap_blist_excludedR13nZone1 = soap_new_block(soap);
					a->ns6__RegionalizationRegionStatus::excludedR13nZone = (ns6__Area **)soap_push_block(soap, soap_blist_excludedR13nZone1, sizeof(ns6__Area *));
					if(a->ns6__RegionalizationRegionStatus::excludedR13nZone == NULL)
						return NULL;
					*a->ns6__RegionalizationRegionStatus::excludedR13nZone = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Area(soap, "ns6:excludedR13nZone", a->ns6__RegionalizationRegionStatus::excludedR13nZone, "ns6:Area"))
				{	a->ns6__RegionalizationRegionStatus::__sizeexcludedR13nZone++;
					a->ns6__RegionalizationRegionStatus::excludedR13nZone = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:r13nStatus", 1, NULL)) {
				if(a->ns6__RegionalizationRegionStatus::r13nStatus == NULL) {
					if(soap_blist_r13nStatus1 == NULL)
						soap_blist_r13nStatus1 = soap_new_block(soap);
					a->ns6__RegionalizationRegionStatus::r13nStatus = (ns6__RegionalizationStatus **)soap_push_block(soap, soap_blist_r13nStatus1, sizeof(ns6__RegionalizationStatus *));
					if(a->ns6__RegionalizationRegionStatus::r13nStatus == NULL)
						return NULL;
					*a->ns6__RegionalizationRegionStatus::r13nStatus = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationStatus(soap, "ns6:r13nStatus", a->ns6__RegionalizationRegionStatus::r13nStatus, "ns6:RegionalizationStatus"))
				{	a->ns6__RegionalizationRegionStatus::__sizer13nStatus++;
					a->ns6__RegionalizationRegionStatus::r13nStatus = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationRegionStatus::excludedR13nZone)
			soap_pop_block(soap, soap_blist_excludedR13nZone1);
		if(a->ns6__RegionalizationRegionStatus::__sizeexcludedR13nZone)
			a->ns6__RegionalizationRegionStatus::excludedR13nZone = (ns6__Area **)soap_save_block(soap, soap_blist_excludedR13nZone1, NULL, 1);
		else
		{	a->ns6__RegionalizationRegionStatus::excludedR13nZone = NULL;
			if(soap_blist_excludedR13nZone1)
				soap_end_block(soap, soap_blist_excludedR13nZone1);
		}
		if(a->ns6__RegionalizationRegionStatus::r13nStatus)
			soap_pop_block(soap, soap_blist_r13nStatus1);
		if(a->ns6__RegionalizationRegionStatus::__sizer13nStatus)
			a->ns6__RegionalizationRegionStatus::r13nStatus = (ns6__RegionalizationStatus **)soap_save_block(soap, soap_blist_r13nStatus1, NULL, 1);
		else
		{	a->ns6__RegionalizationRegionStatus::r13nStatus = NULL;
			if(soap_blist_r13nStatus1)
				soap_end_block(soap, soap_blist_r13nStatus1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationRegionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationRegionStatus, 0, sizeof(ns6__RegionalizationRegionStatus), 0, soap_copy_ns6__RegionalizationRegionStatus);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationRegionStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationRegionStatus);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationRegionStatus", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationRegionStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationRegionStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatus * SOAP_FMAC4 soap_get_ns6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationRegionStatus * FASTCALL soap_instantiate_ns6__RegionalizationRegionStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationRegionStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationRegionStatus, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatus);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationRegionStatus));
		((ns6__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatus[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationRegionStatus));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationRegionStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationRegionStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationRegionStatus %p -> %p\n", q, p));
	*(ns6__RegionalizationRegionStatus*)p = *(ns6__RegionalizationRegionStatus*)q;
}

void ns6__RegionalizationStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationStatus::relatedDisease = NULL;
	soap_default_ns6__ProsperityType(soap, &this->ns6__RegionalizationStatus::prosperity);
	soap_default_ns6__VaccinationType(soap, &this->ns6__RegionalizationStatus::vaccination);
	/* transient soap skipped */
}

void ns6__RegionalizationStatus::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->ns6__RegionalizationStatus::relatedDisease);
	/* transient soap skipped */
}

int ns6__RegionalizationStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationStatus(struct soap *soap, const char *tag, int id, const ns6__RegionalizationStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationStatus), type))
		return soap->error;
	if(a->ns6__RegionalizationStatus::relatedDisease) {
		if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:relatedDisease", -1, &a->ns6__RegionalizationStatus::relatedDisease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:relatedDisease"))
		return soap->error;
	if(soap_out_ns6__ProsperityType(soap, "ns6:prosperity", -1, &(a->ns6__RegionalizationStatus::prosperity), ""))
		return soap->error;
	if(soap_out_ns6__VaccinationType(soap, "ns6:vaccination", -1, &(a->ns6__RegionalizationStatus::vaccination), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationStatus * FASTCALL soap_in_ns6__RegionalizationStatus(struct soap *soap, const char *tag, ns6__RegionalizationStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationStatus, sizeof(ns6__RegionalizationStatus), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationStatus) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_relatedDisease1 = 1;
	size_t soap_flag_prosperity1 = 1;
	size_t soap_flag_vaccination1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_relatedDisease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:relatedDisease", &(a->ns6__RegionalizationStatus::relatedDisease), "ns6:AnimalDisease"))
				{	soap_flag_relatedDisease1--;
					continue;
				}
			if(soap_flag_prosperity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__ProsperityType(soap, "ns6:prosperity", &(a->ns6__RegionalizationStatus::prosperity), "ns6:ProsperityType"))
				{	soap_flag_prosperity1--;
					continue;
				}
			if(soap_flag_vaccination1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__VaccinationType(soap, "ns6:vaccination", &(a->ns6__RegionalizationStatus::vaccination), "ns6:VaccinationType"))
				{	soap_flag_vaccination1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationStatus, 0, sizeof(ns6__RegionalizationStatus), 0, soap_copy_ns6__RegionalizationStatus);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_relatedDisease1 > 0 || soap_flag_prosperity1 > 0 || soap_flag_vaccination1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__RegionalizationStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationStatus);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationStatus", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationStatus * SOAP_FMAC4 soap_get_ns6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationStatus * FASTCALL soap_instantiate_ns6__RegionalizationStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationStatus, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationStatus);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationStatus));
		((ns6__RegionalizationStatus*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationStatus[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationStatus));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationStatus %p -> %p\n", q, p));
	*(ns6__RegionalizationStatus*)p = *(ns6__RegionalizationStatus*)q;
}

void ns6__RegionalizationShippingRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationShippingRule::referenceNumber = NULL;
	this->ns6__RegionalizationShippingRule::fromR13nStatus = NULL;
	this->ns6__RegionalizationShippingRule::toR13nStatus = NULL;
	this->ns6__RegionalizationShippingRule::__sizecargoType = 0;
	this->ns6__RegionalizationShippingRule::cargoType = NULL;
	this->ns6__RegionalizationShippingRule::decision = NULL;
	this->ns6__RegionalizationShippingRule::__sizerequirement = 0;
	this->ns6__RegionalizationShippingRule::requirement = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__RegionalizationShippingRule::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns6__RegionalizationShippingRule::referenceNumber);
	soap_serialize_PointerTons6__RegionalizationStatus(soap, &this->ns6__RegionalizationShippingRule::fromR13nStatus);
	soap_serialize_PointerTons6__RegionalizationStatus(soap, &this->ns6__RegionalizationShippingRule::toR13nStatus);
	if(this->ns6__RegionalizationShippingRule::cargoType) {
		for(int i = 0; i < this->ns6__RegionalizationShippingRule::__sizecargoType; i++) {
			soap_serialize_PointerTons6__SubProduct(soap, this->ns6__RegionalizationShippingRule::cargoType + i);
		}
	}
	soap_serialize_PointerTons6__RegionalizationDecision(soap, &this->ns6__RegionalizationShippingRule::decision);
	if(this->ns6__RegionalizationShippingRule::requirement) {
		for(int i = 0; i < this->ns6__RegionalizationShippingRule::__sizerequirement; i++) {
			soap_serialize_PointerTons6__RegionalizationRequirement(soap, this->ns6__RegionalizationShippingRule::requirement + i);
		}
	}
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__RegionalizationShippingRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationShippingRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, const ns6__RegionalizationShippingRule *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationShippingRule), "ns6:RegionalizationShippingRule"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns6:referenceNumber", -1, &(a->ns6__RegionalizationShippingRule::referenceNumber), ""))
		return soap->error;
	if(soap_out_PointerTons6__RegionalizationStatus(soap, "ns6:fromR13nStatus", -1, &(a->ns6__RegionalizationShippingRule::fromR13nStatus), ""))
		return soap->error;
	if(soap_out_PointerTons6__RegionalizationStatus(soap, "ns6:toR13nStatus", -1, &(a->ns6__RegionalizationShippingRule::toR13nStatus), ""))
		return soap->error;
	if(a->ns6__RegionalizationShippingRule::cargoType) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationShippingRule::__sizecargoType; i++)
			if(soap_out_PointerTons6__SubProduct(soap, "ns6:cargoType", -1, a->ns6__RegionalizationShippingRule::cargoType + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons6__RegionalizationDecision(soap, "ns6:decision", -1, &(a->ns6__RegionalizationShippingRule::decision), ""))
		return soap->error;
	if(a->ns6__RegionalizationShippingRule::requirement) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationShippingRule::__sizerequirement; i++)
			if(soap_out_PointerTons6__RegionalizationRequirement(soap, "ns6:requirement", -1, a->ns6__RegionalizationShippingRule::requirement + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationShippingRule::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationShippingRule(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRule * FASTCALL soap_in_ns6__RegionalizationShippingRule(struct soap *soap, const char *tag, ns6__RegionalizationShippingRule *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationShippingRule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationShippingRule, sizeof(ns6__RegionalizationShippingRule), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationShippingRule) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationShippingRule *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_fromR13nStatus1 = 1;
	size_t soap_flag_toR13nStatus1 = 1;
	struct soap_blist *soap_blist_cargoType1 = NULL;
	size_t soap_flag_decision1 = 1;
	struct soap_blist *soap_blist_requirement1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns6:referenceNumber", &(a->ns6__RegionalizationShippingRule::referenceNumber), "ns3:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_fromR13nStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationStatus(soap, "ns6:fromR13nStatus", &(a->ns6__RegionalizationShippingRule::fromR13nStatus), "ns6:RegionalizationStatus"))
				{	soap_flag_fromR13nStatus1--;
					continue;
				}
			if(soap_flag_toR13nStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationStatus(soap, "ns6:toR13nStatus", &(a->ns6__RegionalizationShippingRule::toR13nStatus), "ns6:RegionalizationStatus"))
				{	soap_flag_toR13nStatus1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:cargoType", 1, NULL)) {
				if(a->ns6__RegionalizationShippingRule::cargoType == NULL) {
					if(soap_blist_cargoType1 == NULL)
						soap_blist_cargoType1 = soap_new_block(soap);
					a->ns6__RegionalizationShippingRule::cargoType = (ns6__SubProduct **)soap_push_block(soap, soap_blist_cargoType1, sizeof(ns6__SubProduct *));
					if(a->ns6__RegionalizationShippingRule::cargoType == NULL)
						return NULL;
					*a->ns6__RegionalizationShippingRule::cargoType = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:cargoType", a->ns6__RegionalizationShippingRule::cargoType, "ns6:SubProduct"))
				{	a->ns6__RegionalizationShippingRule::__sizecargoType++;
					a->ns6__RegionalizationShippingRule::cargoType = NULL;
					continue;
				}
			}
			if(soap_flag_decision1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__RegionalizationDecision(soap, "ns6:decision", &(a->ns6__RegionalizationShippingRule::decision), "ns6:RegionalizationDecision"))
				{	soap_flag_decision1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:requirement", 1, NULL)) {
				if(a->ns6__RegionalizationShippingRule::requirement == NULL) {
					if(soap_blist_requirement1 == NULL)
						soap_blist_requirement1 = soap_new_block(soap);
					a->ns6__RegionalizationShippingRule::requirement = (ns6__RegionalizationRequirement **)soap_push_block(soap, soap_blist_requirement1, sizeof(ns6__RegionalizationRequirement *));
					if(a->ns6__RegionalizationShippingRule::requirement == NULL)
						return NULL;
					*a->ns6__RegionalizationShippingRule::requirement = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationRequirement(soap, "ns6:requirement", a->ns6__RegionalizationShippingRule::requirement, "ns6:RegionalizationRequirement"))
				{	a->ns6__RegionalizationShippingRule::__sizerequirement++;
					a->ns6__RegionalizationShippingRule::requirement = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationShippingRule::cargoType)
			soap_pop_block(soap, soap_blist_cargoType1);
		if(a->ns6__RegionalizationShippingRule::__sizecargoType)
			a->ns6__RegionalizationShippingRule::cargoType = (ns6__SubProduct **)soap_save_block(soap, soap_blist_cargoType1, NULL, 1);
		else
		{	a->ns6__RegionalizationShippingRule::cargoType = NULL;
			if(soap_blist_cargoType1)
				soap_end_block(soap, soap_blist_cargoType1);
		}
		if(a->ns6__RegionalizationShippingRule::requirement)
			soap_pop_block(soap, soap_blist_requirement1);
		if(a->ns6__RegionalizationShippingRule::__sizerequirement)
			a->ns6__RegionalizationShippingRule::requirement = (ns6__RegionalizationRequirement **)soap_save_block(soap, soap_blist_requirement1, NULL, 1);
		else
		{	a->ns6__RegionalizationShippingRule::requirement = NULL;
			if(soap_blist_requirement1)
				soap_end_block(soap, soap_blist_requirement1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationShippingRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationShippingRule, 0, sizeof(ns6__RegionalizationShippingRule), 0, soap_copy_ns6__RegionalizationShippingRule);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationShippingRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationShippingRule);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationShippingRule", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationShippingRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationShippingRule(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRule * SOAP_FMAC4 soap_get_ns6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationShippingRule * FASTCALL soap_instantiate_ns6__RegionalizationShippingRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationShippingRule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationShippingRule, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRule);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationShippingRule));
		((ns6__RegionalizationShippingRule*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRule[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationShippingRule));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationShippingRule*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationShippingRule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationShippingRule %p -> %p\n", q, p));
	*(ns6__RegionalizationShippingRule*)p = *(ns6__RegionalizationShippingRule*)q;
}

void ns6__RegionalizationRequirement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationRequirement::relatedDisease = NULL;
	soap_default_ns6__RegionalizationDecision(soap, &this->ns6__RegionalizationRequirement::type);
	this->ns6__RegionalizationRequirement::__sizeconditionGroup = 0;
	this->ns6__RegionalizationRequirement::conditionGroup = NULL;
	/* transient soap skipped */
}

void ns6__RegionalizationRequirement::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__AnimalDisease(soap, &this->ns6__RegionalizationRequirement::relatedDisease);
	soap_embedded(soap, &this->ns6__RegionalizationRequirement::type, SOAP_TYPE_ns6__RegionalizationDecision);
	if(this->ns6__RegionalizationRequirement::conditionGroup) {
		for(int i = 0; i < this->ns6__RegionalizationRequirement::__sizeconditionGroup; i++) {
			soap_serialize_PointerTons6__RegionalizationConditionGroup(soap, this->ns6__RegionalizationRequirement::conditionGroup + i);
		}
	}
	/* transient soap skipped */
}

int ns6__RegionalizationRequirement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationRequirement(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationRequirement(struct soap *soap, const char *tag, int id, const ns6__RegionalizationRequirement *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationRequirement), type))
		return soap->error;
	if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:relatedDisease", -1, &(a->ns6__RegionalizationRequirement::relatedDisease), ""))
		return soap->error;
	if(soap_out_ns6__RegionalizationDecision(soap, "ns6:type", -1, &(a->ns6__RegionalizationRequirement::type), ""))
		return soap->error;
	if(a->ns6__RegionalizationRequirement::conditionGroup) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationRequirement::__sizeconditionGroup; i++)
			if(soap_out_PointerTons6__RegionalizationConditionGroup(soap, "ns6:conditionGroup", -1, a->ns6__RegionalizationRequirement::conditionGroup + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationRequirement::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationRequirement(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationRequirement * FASTCALL soap_in_ns6__RegionalizationRequirement(struct soap *soap, const char *tag, ns6__RegionalizationRequirement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationRequirement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationRequirement, sizeof(ns6__RegionalizationRequirement), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationRequirement) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationRequirement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_relatedDisease1 = 1;
	size_t soap_flag_type1 = 1;
	struct soap_blist *soap_blist_conditionGroup1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_relatedDisease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:relatedDisease", &(a->ns6__RegionalizationRequirement::relatedDisease), "ns6:AnimalDisease"))
				{	soap_flag_relatedDisease1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__RegionalizationDecision(soap, "ns6:type", &(a->ns6__RegionalizationRequirement::type), "ns6:RegionalizationDecision"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:conditionGroup", 1, NULL)) {
				if(a->ns6__RegionalizationRequirement::conditionGroup == NULL) {
					if(soap_blist_conditionGroup1 == NULL)
						soap_blist_conditionGroup1 = soap_new_block(soap);
					a->ns6__RegionalizationRequirement::conditionGroup = (ns6__RegionalizationConditionGroup **)soap_push_block(soap, soap_blist_conditionGroup1, sizeof(ns6__RegionalizationConditionGroup *));
					if(a->ns6__RegionalizationRequirement::conditionGroup == NULL)
						return NULL;
					*a->ns6__RegionalizationRequirement::conditionGroup = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationConditionGroup(soap, "ns6:conditionGroup", a->ns6__RegionalizationRequirement::conditionGroup, "ns6:RegionalizationConditionGroup"))
				{	a->ns6__RegionalizationRequirement::__sizeconditionGroup++;
					a->ns6__RegionalizationRequirement::conditionGroup = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationRequirement::conditionGroup)
			soap_pop_block(soap, soap_blist_conditionGroup1);
		if(a->ns6__RegionalizationRequirement::__sizeconditionGroup)
			a->ns6__RegionalizationRequirement::conditionGroup = (ns6__RegionalizationConditionGroup **)soap_save_block(soap, soap_blist_conditionGroup1, NULL, 1);
		else
		{	a->ns6__RegionalizationRequirement::conditionGroup = NULL;
			if(soap_blist_conditionGroup1)
				soap_end_block(soap, soap_blist_conditionGroup1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationRequirement, 0, sizeof(ns6__RegionalizationRequirement), 0, soap_copy_ns6__RegionalizationRequirement);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__RegionalizationRequirement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationRequirement);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationRequirement", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationRequirement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationRequirement(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationRequirement * SOAP_FMAC4 soap_get_ns6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationRequirement * FASTCALL soap_instantiate_ns6__RegionalizationRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationRequirement, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRequirement);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationRequirement));
		((ns6__RegionalizationRequirement*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRequirement[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationRequirement));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationRequirement*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationRequirement %p -> %p\n", q, p));
	*(ns6__RegionalizationRequirement*)p = *(ns6__RegionalizationRequirement*)q;
}

void ns6__RegionalizationConditionGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationConditionGroup::__sizecondition = 0;
	this->ns6__RegionalizationConditionGroup::condition = NULL;
	/* transient soap skipped */
}

void ns6__RegionalizationConditionGroup::soap_serialize(struct soap *soap) const
{
	if(this->ns6__RegionalizationConditionGroup::condition) {
		for(int i = 0; i < this->ns6__RegionalizationConditionGroup::__sizecondition; i++) {
			soap_serialize_PointerTons6__RegionalizationCondition(soap, this->ns6__RegionalizationConditionGroup::condition + i);
		}
	}
	/* transient soap skipped */
}

int ns6__RegionalizationConditionGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationConditionGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, const ns6__RegionalizationConditionGroup *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationConditionGroup), type))
		return soap->error;
	if(a->ns6__RegionalizationConditionGroup::condition) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationConditionGroup::__sizecondition; i++)
			if(soap_out_PointerTons6__RegionalizationCondition(soap, "ns6:condition", -1, a->ns6__RegionalizationConditionGroup::condition + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationConditionGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationConditionGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionGroup * FASTCALL soap_in_ns6__RegionalizationConditionGroup(struct soap *soap, const char *tag, ns6__RegionalizationConditionGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationConditionGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationConditionGroup, sizeof(ns6__RegionalizationConditionGroup), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationConditionGroup) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationConditionGroup *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_condition1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:condition", 1, NULL)) {
				if(a->ns6__RegionalizationConditionGroup::condition == NULL) {
					if(soap_blist_condition1 == NULL)
						soap_blist_condition1 = soap_new_block(soap);
					a->ns6__RegionalizationConditionGroup::condition = (ns6__RegionalizationCondition **)soap_push_block(soap, soap_blist_condition1, sizeof(ns6__RegionalizationCondition *));
					if(a->ns6__RegionalizationConditionGroup::condition == NULL)
						return NULL;
					*a->ns6__RegionalizationConditionGroup::condition = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__RegionalizationCondition(soap, "ns6:condition", a->ns6__RegionalizationConditionGroup::condition, "ns6:RegionalizationCondition"))
				{	a->ns6__RegionalizationConditionGroup::__sizecondition++;
					a->ns6__RegionalizationConditionGroup::condition = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationConditionGroup::condition)
			soap_pop_block(soap, soap_blist_condition1);
		if(a->ns6__RegionalizationConditionGroup::__sizecondition)
			a->ns6__RegionalizationConditionGroup::condition = (ns6__RegionalizationCondition **)soap_save_block(soap, soap_blist_condition1, NULL, 1);
		else
		{	a->ns6__RegionalizationConditionGroup::condition = NULL;
			if(soap_blist_condition1)
				soap_end_block(soap, soap_blist_condition1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationConditionGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationConditionGroup, 0, sizeof(ns6__RegionalizationConditionGroup), 0, soap_copy_ns6__RegionalizationConditionGroup);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationConditionGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationConditionGroup);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationConditionGroup", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationConditionGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationConditionGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionGroup * SOAP_FMAC4 soap_get_ns6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationConditionGroup * FASTCALL soap_instantiate_ns6__RegionalizationConditionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationConditionGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationConditionGroup, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationConditionGroup);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationConditionGroup));
		((ns6__RegionalizationConditionGroup*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationConditionGroup[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationConditionGroup));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationConditionGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationConditionGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationConditionGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationConditionGroup %p -> %p\n", q, p));
	*(ns6__RegionalizationConditionGroup*)p = *(ns6__RegionalizationConditionGroup*)q;
}

void ns6__RegionalizationCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionalizationCondition::referenceNumber = NULL;
	soap_default_ns3__Text(soap, &this->ns6__RegionalizationCondition::text);
	this->ns6__RegionalizationCondition::strict = NULL;
	this->ns6__RegionalizationCondition::__sizerelatedDisease = 0;
	this->ns6__RegionalizationCondition::relatedDisease = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__RegionalizationCondition::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns6__RegionalizationCondition::referenceNumber);
	soap_serialize_ns3__Text(soap, &this->ns6__RegionalizationCondition::text);
	soap_serialize_PointerTobool(soap, &this->ns6__RegionalizationCondition::strict);
	if(this->ns6__RegionalizationCondition::relatedDisease) {
		for(int i = 0; i < this->ns6__RegionalizationCondition::__sizerelatedDisease; i++) {
			soap_serialize_PointerTons6__AnimalDisease(soap, this->ns6__RegionalizationCondition::relatedDisease + i);
		}
	}
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__RegionalizationCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionalizationCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionalizationCondition(struct soap *soap, const char *tag, int id, const ns6__RegionalizationCondition *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionalizationCondition), "ns6:RegionalizationCondition"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns6:referenceNumber", -1, &(a->ns6__RegionalizationCondition::referenceNumber), ""))
		return soap->error;
	if(soap_out_ns3__Text(soap, "ns6:text", -1, &(a->ns6__RegionalizationCondition::text), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:strict", -1, &(a->ns6__RegionalizationCondition::strict), ""))
		return soap->error;
	if(a->ns6__RegionalizationCondition::relatedDisease) {
		int i;
		for(i = 0; i < a->ns6__RegionalizationCondition::__sizerelatedDisease; i++)
			if(soap_out_PointerTons6__AnimalDisease(soap, "ns6:relatedDisease", -1, a->ns6__RegionalizationCondition::relatedDisease + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionalizationCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionalizationCondition(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionalizationCondition * FASTCALL soap_in_ns6__RegionalizationCondition(struct soap *soap, const char *tag, ns6__RegionalizationCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionalizationCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionalizationCondition, sizeof(ns6__RegionalizationCondition), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionalizationCondition) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionalizationCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_strict1 = 1;
	struct soap_blist *soap_blist_relatedDisease1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns6:referenceNumber", &(a->ns6__RegionalizationCondition::referenceNumber), "ns3:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Text(soap, "ns6:text", &(a->ns6__RegionalizationCondition::text), "ns3:Text"))
				{	soap_flag_text1--;
					continue;
				}
			if(soap_flag_strict1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:strict", &(a->ns6__RegionalizationCondition::strict), "xsd:boolean"))
				{	soap_flag_strict1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:relatedDisease", 1, NULL)) {
				if(a->ns6__RegionalizationCondition::relatedDisease == NULL) {
					if(soap_blist_relatedDisease1 == NULL)
						soap_blist_relatedDisease1 = soap_new_block(soap);
					a->ns6__RegionalizationCondition::relatedDisease = (ns6__AnimalDisease **)soap_push_block(soap, soap_blist_relatedDisease1, sizeof(ns6__AnimalDisease *));
					if(a->ns6__RegionalizationCondition::relatedDisease == NULL)
						return NULL;
					*a->ns6__RegionalizationCondition::relatedDisease = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__AnimalDisease(soap, "ns6:relatedDisease", a->ns6__RegionalizationCondition::relatedDisease, "ns6:AnimalDisease"))
				{	a->ns6__RegionalizationCondition::__sizerelatedDisease++;
					a->ns6__RegionalizationCondition::relatedDisease = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionalizationCondition::relatedDisease)
			soap_pop_block(soap, soap_blist_relatedDisease1);
		if(a->ns6__RegionalizationCondition::__sizerelatedDisease)
			a->ns6__RegionalizationCondition::relatedDisease = (ns6__AnimalDisease **)soap_save_block(soap, soap_blist_relatedDisease1, NULL, 1);
		else
		{	a->ns6__RegionalizationCondition::relatedDisease = NULL;
			if(soap_blist_relatedDisease1)
				soap_end_block(soap, soap_blist_relatedDisease1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionalizationCondition, 0, sizeof(ns6__RegionalizationCondition), 0, soap_copy_ns6__RegionalizationCondition);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionalizationCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionalizationCondition);
	return this->soap_out(soap, tag?tag:"ns6:RegionalizationCondition", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionalizationCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionalizationCondition(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionalizationCondition * SOAP_FMAC4 soap_get_ns6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionalizationCondition * FASTCALL soap_instantiate_ns6__RegionalizationCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionalizationCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionalizationCondition, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationCondition);
		ASSIGN_PTR(size, sizeof(ns6__RegionalizationCondition));
		((ns6__RegionalizationCondition*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationCondition[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationCondition));
		for(int i = 0; i < n; i++)
			((ns6__RegionalizationCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionalizationCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionalizationCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionalizationCondition %p -> %p\n", q, p));
	*(ns6__RegionalizationCondition*)p = *(ns6__RegionalizationCondition*)q;
}

void ns6__MedicinalDrug::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__MedicinalDrug::ID = NULL;
	soap_default_ns3__String255(soap, &this->ns6__MedicinalDrug::name);
	soap_default_ns3__String255(soap, &this->ns6__MedicinalDrug::series);
	this->ns6__MedicinalDrug::producer = NULL;
	/* transient soap skipped */
}

void ns6__MedicinalDrug::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns6__MedicinalDrug::ID);
	soap_serialize_ns3__String255(soap, &this->ns6__MedicinalDrug::name);
	soap_serialize_ns3__String255(soap, &this->ns6__MedicinalDrug::series);
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns6__MedicinalDrug::producer);
	/* transient soap skipped */
}

int ns6__MedicinalDrug::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__MedicinalDrug(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__MedicinalDrug(struct soap *soap, const char *tag, int id, const ns6__MedicinalDrug *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__MedicinalDrug), type))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns6:ID", -1, &(a->ns6__MedicinalDrug::ID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__MedicinalDrug::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:series", -1, &(a->ns6__MedicinalDrug::series), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessMember(soap, "ns6:producer", -1, &(a->ns6__MedicinalDrug::producer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__MedicinalDrug::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__MedicinalDrug(soap, tag, this, type);
}

SOAP_FMAC3 ns6__MedicinalDrug * FASTCALL soap_in_ns6__MedicinalDrug(struct soap *soap, const char *tag, ns6__MedicinalDrug *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__MedicinalDrug *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__MedicinalDrug, sizeof(ns6__MedicinalDrug), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__MedicinalDrug) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__MedicinalDrug *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_series1 = 1;
	size_t soap_flag_producer1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns6:ID", &(a->ns6__MedicinalDrug::ID), "ns3:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__MedicinalDrug::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_series1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:series", &(a->ns6__MedicinalDrug::series), "ns3:String255"))
				{	soap_flag_series1--;
					continue;
				}
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns6:producer", &(a->ns6__MedicinalDrug::producer), "ns6:BusinessMember"))
				{	soap_flag_producer1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__MedicinalDrug *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__MedicinalDrug, 0, sizeof(ns6__MedicinalDrug), 0, soap_copy_ns6__MedicinalDrug);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__MedicinalDrug::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__MedicinalDrug);
	return this->soap_out(soap, tag?tag:"ns6:MedicinalDrug", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__MedicinalDrug::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__MedicinalDrug(soap, this, tag, type);
}

SOAP_FMAC3 ns6__MedicinalDrug * SOAP_FMAC4 soap_get_ns6__MedicinalDrug(struct soap *soap, ns6__MedicinalDrug *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__MedicinalDrug(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__MedicinalDrug * FASTCALL soap_instantiate_ns6__MedicinalDrug(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__MedicinalDrug(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__MedicinalDrug, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__MedicinalDrug);
		ASSIGN_PTR(size, sizeof(ns6__MedicinalDrug));
		((ns6__MedicinalDrug*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__MedicinalDrug[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__MedicinalDrug));
		for(int i = 0; i < n; i++)
			((ns6__MedicinalDrug*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__MedicinalDrug*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__MedicinalDrug(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__MedicinalDrug %p -> %p\n", q, p));
	*(ns6__MedicinalDrug*)p = *(ns6__MedicinalDrug*)q;
}

void ns6__ResearchMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__ResearchMethod::name);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__ResearchMethod::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__ResearchMethod::name);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__ResearchMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ResearchMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ResearchMethod(struct soap *soap, const char *tag, int id, const ns6__ResearchMethod *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ResearchMethod), "ns6:ResearchMethod"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__ResearchMethod::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ResearchMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ResearchMethod(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ResearchMethod * FASTCALL soap_in_ns6__ResearchMethod(struct soap *soap, const char *tag, ns6__ResearchMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ResearchMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ResearchMethod, sizeof(ns6__ResearchMethod), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ResearchMethod) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ResearchMethod *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__ResearchMethod::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ResearchMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ResearchMethod, 0, sizeof(ns6__ResearchMethod), 0, soap_copy_ns6__ResearchMethod);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ResearchMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ResearchMethod);
	return this->soap_out(soap, tag?tag:"ns6:ResearchMethod", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ResearchMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ResearchMethod(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ResearchMethod * SOAP_FMAC4 soap_get_ns6__ResearchMethod(struct soap *soap, ns6__ResearchMethod *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ResearchMethod * FASTCALL soap_instantiate_ns6__ResearchMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ResearchMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ResearchMethod, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethod);
		ASSIGN_PTR(size, sizeof(ns6__ResearchMethod));
		((ns6__ResearchMethod*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethod[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ResearchMethod));
		for(int i = 0; i < n; i++)
			((ns6__ResearchMethod*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ResearchMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ResearchMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ResearchMethod %p -> %p\n", q, p));
	*(ns6__ResearchMethod*)p = *(ns6__ResearchMethod*)q;
}

void ns6__AnimalDisease::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__AnimalDisease::name);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__AnimalDisease::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__AnimalDisease::name);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__AnimalDisease::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AnimalDisease(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__AnimalDisease(struct soap *soap, const char *tag, int id, const ns6__AnimalDisease *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AnimalDisease), "ns6:AnimalDisease"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__AnimalDisease::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__AnimalDisease::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__AnimalDisease(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AnimalDisease * FASTCALL soap_in_ns6__AnimalDisease(struct soap *soap, const char *tag, ns6__AnimalDisease *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AnimalDisease *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AnimalDisease, sizeof(ns6__AnimalDisease), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__AnimalDisease) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AnimalDisease *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__AnimalDisease::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__AnimalDisease *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AnimalDisease, 0, sizeof(ns6__AnimalDisease), 0, soap_copy_ns6__AnimalDisease);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__AnimalDisease::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AnimalDisease);
	return this->soap_out(soap, tag?tag:"ns6:AnimalDisease", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__AnimalDisease::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AnimalDisease(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AnimalDisease * SOAP_FMAC4 soap_get_ns6__AnimalDisease(struct soap *soap, ns6__AnimalDisease *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__AnimalDisease * FASTCALL soap_instantiate_ns6__AnimalDisease(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AnimalDisease(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AnimalDisease, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__AnimalDisease);
		ASSIGN_PTR(size, sizeof(ns6__AnimalDisease));
		((ns6__AnimalDisease*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__AnimalDisease[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__AnimalDisease));
		for(int i = 0; i < n; i++)
			((ns6__AnimalDisease*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AnimalDisease*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AnimalDisease(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AnimalDisease %p -> %p\n", q, p));
	*(ns6__AnimalDisease*)p = *(ns6__AnimalDisease*)q;
}

void ns6__Indicator::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Indicator::name);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Indicator::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Indicator::name);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Indicator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Indicator(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Indicator(struct soap *soap, const char *tag, int id, const ns6__Indicator *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Indicator), "ns6:Indicator"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Indicator::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Indicator::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Indicator(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Indicator * FASTCALL soap_in_ns6__Indicator(struct soap *soap, const char *tag, ns6__Indicator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Indicator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Indicator, sizeof(ns6__Indicator), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Indicator) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Indicator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Indicator::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Indicator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Indicator, 0, sizeof(ns6__Indicator), 0, soap_copy_ns6__Indicator);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Indicator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Indicator);
	return this->soap_out(soap, tag?tag:"ns6:Indicator", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Indicator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Indicator(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Indicator * SOAP_FMAC4 soap_get_ns6__Indicator(struct soap *soap, ns6__Indicator *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Indicator(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Indicator * FASTCALL soap_instantiate_ns6__Indicator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Indicator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Indicator, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Indicator);
		ASSIGN_PTR(size, sizeof(ns6__Indicator));
		((ns6__Indicator*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Indicator[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Indicator));
		for(int i = 0; i < n; i++)
			((ns6__Indicator*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Indicator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Indicator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Indicator %p -> %p\n", q, p));
	*(ns6__Indicator*)p = *(ns6__Indicator*)q;
}

void ns6__Organization::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Organization::ID = NULL;
	soap_default_ns3__String255(soap, &this->ns6__Organization::name);
	this->ns6__Organization::address = NULL;
	/* transient soap skipped */
}

void ns6__Organization::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__Identifier(soap, &this->ns6__Organization::ID);
	soap_serialize_ns3__String255(soap, &this->ns6__Organization::name);
	soap_serialize_PointerTons6__Address(soap, &this->ns6__Organization::address);
	/* transient soap skipped */
}

int ns6__Organization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Organization(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Organization(struct soap *soap, const char *tag, int id, const ns6__Organization *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Organization), type))
		return soap->error;
	if(soap_out_PointerTons3__Identifier(soap, "ns6:ID", -1, &(a->ns6__Organization::ID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Organization::name), ""))
		return soap->error;
	if(soap_out_PointerTons6__Address(soap, "ns6:address", -1, &(a->ns6__Organization::address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Organization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Organization(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Organization * FASTCALL soap_in_ns6__Organization(struct soap *soap, const char *tag, ns6__Organization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Organization *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Organization, sizeof(ns6__Organization), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Organization) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Organization *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Identifier(soap, "ns6:ID", &(a->ns6__Organization::ID), "ns3:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Organization::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Address(soap, "ns6:address", &(a->ns6__Organization::address), "ns6:Address"))
				{	soap_flag_address1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Organization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Organization, 0, sizeof(ns6__Organization), 0, soap_copy_ns6__Organization);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Organization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Organization);
	return this->soap_out(soap, tag?tag:"ns6:Organization", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Organization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Organization(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Organization * SOAP_FMAC4 soap_get_ns6__Organization(struct soap *soap, ns6__Organization *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Organization(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Organization * FASTCALL soap_instantiate_ns6__Organization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Organization(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Organization, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Organization);
		ASSIGN_PTR(size, sizeof(ns6__Organization));
		((ns6__Organization*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Organization[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Organization));
		for(int i = 0; i < n; i++)
			((ns6__Organization*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Organization*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Organization(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Organization %p -> %p\n", q, p));
	*(ns6__Organization*)p = *(ns6__Organization*)q;
}

void ns6__EnterpriseOfficialRegistration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__GRNType(soap, &this->ns6__EnterpriseOfficialRegistration::ID);
	this->ns6__EnterpriseOfficialRegistration::businessEntity = NULL;
	soap_default_ns3__String255(soap, &this->ns6__EnterpriseOfficialRegistration::kpp);
	/* transient soap skipped */
}

void ns6__EnterpriseOfficialRegistration::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns6__GRNType(soap, &this->ns6__EnterpriseOfficialRegistration::ID);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns6__EnterpriseOfficialRegistration::businessEntity);
	soap_serialize_ns3__String255(soap, &this->ns6__EnterpriseOfficialRegistration::kpp);
	/* transient soap skipped */
}

int ns6__EnterpriseOfficialRegistration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EnterpriseOfficialRegistration(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, const ns6__EnterpriseOfficialRegistration *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseOfficialRegistration), type))
		return soap->error;
	if(soap_out_ns6__GRNType(soap, "ns6:ID", -1, &(a->ns6__EnterpriseOfficialRegistration::ID), ""))
		return soap->error;
	if(a->ns6__EnterpriseOfficialRegistration::businessEntity) {
		if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &a->ns6__EnterpriseOfficialRegistration::businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:businessEntity"))
		return soap->error;
	if(a->ns6__EnterpriseOfficialRegistration::kpp) {
		if(soap_out_ns3__String255(soap, "ns6:kpp", -1, &a->ns6__EnterpriseOfficialRegistration::kpp, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:kpp"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__EnterpriseOfficialRegistration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__EnterpriseOfficialRegistration(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EnterpriseOfficialRegistration * FASTCALL soap_in_ns6__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, ns6__EnterpriseOfficialRegistration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__EnterpriseOfficialRegistration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseOfficialRegistration, sizeof(ns6__EnterpriseOfficialRegistration), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__EnterpriseOfficialRegistration) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__EnterpriseOfficialRegistration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_businessEntity1 = 1;
	size_t soap_flag_kpp1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__GRNType(soap, "ns6:ID", &(a->ns6__EnterpriseOfficialRegistration::ID), "ns6:GRNType"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->ns6__EnterpriseOfficialRegistration::businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap_flag_kpp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:kpp", &(a->ns6__EnterpriseOfficialRegistration::kpp), "ns3:String255"))
				{	soap_flag_kpp1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseOfficialRegistration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseOfficialRegistration, 0, sizeof(ns6__EnterpriseOfficialRegistration), 0, soap_copy_ns6__EnterpriseOfficialRegistration);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_businessEntity1 > 0 || soap_flag_kpp1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__EnterpriseOfficialRegistration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseOfficialRegistration);
	return this->soap_out(soap, tag?tag:"ns6:EnterpriseOfficialRegistration", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__EnterpriseOfficialRegistration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EnterpriseOfficialRegistration(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EnterpriseOfficialRegistration * SOAP_FMAC4 soap_get_ns6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__EnterpriseOfficialRegistration * FASTCALL soap_instantiate_ns6__EnterpriseOfficialRegistration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__EnterpriseOfficialRegistration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__EnterpriseOfficialRegistration, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseOfficialRegistration);
		ASSIGN_PTR(size, sizeof(ns6__EnterpriseOfficialRegistration));
		((ns6__EnterpriseOfficialRegistration*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseOfficialRegistration[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseOfficialRegistration));
		for(int i = 0; i < n; i++)
			((ns6__EnterpriseOfficialRegistration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__EnterpriseOfficialRegistration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__EnterpriseOfficialRegistration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__EnterpriseOfficialRegistration %p -> %p\n", q, p));
	*(ns6__EnterpriseOfficialRegistration*)p = *(ns6__EnterpriseOfficialRegistration*)q;
}

void ns6__Location::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Location::name);
	this->ns6__Location::address = NULL;
	/* transient soap skipped */
}

void ns6__Location::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Location::name);
	soap_serialize_PointerTons6__Address(soap, &this->ns6__Location::address);
	/* transient soap skipped */
}

int ns6__Location::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Location(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Location(struct soap *soap, const char *tag, int id, const ns6__Location *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Location), type))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Location::name), ""))
		return soap->error;
	if(soap_out_PointerTons6__Address(soap, "ns6:address", -1, &(a->ns6__Location::address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Location::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Location(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Location * FASTCALL soap_in_ns6__Location(struct soap *soap, const char *tag, ns6__Location *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Location *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Location, sizeof(ns6__Location), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Location) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Location *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Location::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Address(soap, "ns6:address", &(a->ns6__Location::address), "ns6:Address"))
				{	soap_flag_address1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Location *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Location, 0, sizeof(ns6__Location), 0, soap_copy_ns6__Location);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Location::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Location);
	return this->soap_out(soap, tag?tag:"ns6:Location", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Location::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Location(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Location * SOAP_FMAC4 soap_get_ns6__Location(struct soap *soap, ns6__Location *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Location(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Location * FASTCALL soap_instantiate_ns6__Location(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Location(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Location, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Location);
		ASSIGN_PTR(size, sizeof(ns6__Location));
		((ns6__Location*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Location[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Location));
		for(int i = 0; i < n; i++)
			((ns6__Location*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Location*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Location(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Location %p -> %p\n", q, p));
	*(ns6__Location*)p = *(ns6__Location*)q;
}

void ns6__Packaging::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Packaging::packagingType = NULL;
	soap_default_xsd__integer(soap, &this->ns6__Packaging::quantity);
	this->ns6__Packaging::volume = NULL;
	this->ns6__Packaging::unit = NULL;
	/* transient soap skipped */
}

void ns6__Packaging::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__PackingType(soap, &this->ns6__Packaging::packagingType);
	soap_serialize_xsd__integer(soap, &this->ns6__Packaging::quantity);
	soap_serialize_PointerTons3__Decimal(soap, &this->ns6__Packaging::volume);
	soap_serialize_PointerTons6__Unit(soap, &this->ns6__Packaging::unit);
	/* transient soap skipped */
}

int ns6__Packaging::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Packaging(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Packaging(struct soap *soap, const char *tag, int id, const ns6__Packaging *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Packaging), type))
		return soap->error;
	if(a->ns6__Packaging::packagingType) {
		if(soap_out_PointerTons6__PackingType(soap, "ns6:packagingType", -1, &a->ns6__Packaging::packagingType, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:packagingType"))
		return soap->error;
	if(soap_out_xsd__integer(soap, "ns6:quantity", -1, &(a->ns6__Packaging::quantity), ""))
		return soap->error;
	if(soap_out_PointerTons3__Decimal(soap, "ns6:volume", -1, &(a->ns6__Packaging::volume), ""))
		return soap->error;
	if(soap_out_PointerTons6__Unit(soap, "ns6:unit", -1, &(a->ns6__Packaging::unit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Packaging::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Packaging(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Packaging * FASTCALL soap_in_ns6__Packaging(struct soap *soap, const char *tag, ns6__Packaging *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Packaging *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Packaging, sizeof(ns6__Packaging), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Packaging) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Packaging *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_packagingType1 = 1;
	size_t soap_flag_quantity1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_packagingType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackingType(soap, "ns6:packagingType", &(a->ns6__Packaging::packagingType), "ns6:PackingType"))
				{	soap_flag_packagingType1--;
					continue;
				}
			if(soap_flag_quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "ns6:quantity", &(a->ns6__Packaging::quantity), "xsd:integer"))
				{	soap_flag_quantity1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__Decimal(soap, "ns6:volume", &(a->ns6__Packaging::volume), "ns3:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Unit(soap, "ns6:unit", &(a->ns6__Packaging::unit), "ns6:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Packaging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Packaging, 0, sizeof(ns6__Packaging), 0, soap_copy_ns6__Packaging);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_packagingType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__Packaging::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Packaging);
	return this->soap_out(soap, tag?tag:"ns6:Packaging", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Packaging::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Packaging(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Packaging * SOAP_FMAC4 soap_get_ns6__Packaging(struct soap *soap, ns6__Packaging *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Packaging(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Packaging * FASTCALL soap_instantiate_ns6__Packaging(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Packaging(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Packaging, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Packaging);
		ASSIGN_PTR(size, sizeof(ns6__Packaging));
		((ns6__Packaging*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Packaging[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Packaging));
		for(int i = 0; i < n; i++)
			((ns6__Packaging*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Packaging*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Packaging(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Packaging %p -> %p\n", q, p));
	*(ns6__Packaging*)p = *(ns6__Packaging*)q;
}

void ns6__ProductItemProducing::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ProductItemProducing::location = NULL;
	/* transient soap skipped */
}

void ns6__ProductItemProducing::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns6__ProductItemProducing::location);
	/* transient soap skipped */
}

int ns6__ProductItemProducing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProductItemProducing(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductItemProducing(struct soap *soap, const char *tag, int id, const ns6__ProductItemProducing *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProductItemProducing), type))
		return soap->error;
	if(a->ns6__ProductItemProducing::location) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns6:location", -1, &a->ns6__ProductItemProducing::location, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:location"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ProductItemProducing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ProductItemProducing(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProductItemProducing * FASTCALL soap_in_ns6__ProductItemProducing(struct soap *soap, const char *tag, ns6__ProductItemProducing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ProductItemProducing *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductItemProducing, sizeof(ns6__ProductItemProducing), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ProductItemProducing) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ProductItemProducing *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_location1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_location1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:location", &(a->ns6__ProductItemProducing::location), "ns6:Enterprise"))
				{	soap_flag_location1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ProductItemProducing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProductItemProducing, 0, sizeof(ns6__ProductItemProducing), 0, soap_copy_ns6__ProductItemProducing);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_location1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__ProductItemProducing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ProductItemProducing);
	return this->soap_out(soap, tag?tag:"ns6:ProductItemProducing", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ProductItemProducing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProductItemProducing(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProductItemProducing * SOAP_FMAC4 soap_get_ns6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ProductItemProducing * FASTCALL soap_instantiate_ns6__ProductItemProducing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProductItemProducing(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ProductItemProducing, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductItemProducing);
		ASSIGN_PTR(size, sizeof(ns6__ProductItemProducing));
		((ns6__ProductItemProducing*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductItemProducing[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ProductItemProducing));
		for(int i = 0; i < n; i++)
			((ns6__ProductItemProducing*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ProductItemProducing*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ProductItemProducing(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ProductItemProducing %p -> %p\n", q, p));
	*(ns6__ProductItemProducing*)p = *(ns6__ProductItemProducing*)q;
}

void ns6__ComplexDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ComplexDate::year = NULL;
	this->ns6__ComplexDate::month = NULL;
	this->ns6__ComplexDate::day = NULL;
	this->ns6__ComplexDate::hour = NULL;
	this->ns6__ComplexDate::minute = NULL;
	/* transient soap skipped */
}

void ns6__ComplexDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Year(soap, &this->ns6__ComplexDate::year);
	soap_serialize_PointerTons6__Month(soap, &this->ns6__ComplexDate::month);
	soap_serialize_PointerTons6__Day(soap, &this->ns6__ComplexDate::day);
	soap_serialize_PointerTons6__Hour(soap, &this->ns6__ComplexDate::hour);
	soap_serialize_PointerTons6__Minute(soap, &this->ns6__ComplexDate::minute);
	/* transient soap skipped */
}

int ns6__ComplexDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ComplexDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ComplexDate(struct soap *soap, const char *tag, int id, const ns6__ComplexDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ComplexDate), type))
		return soap->error;
	if(soap_out_PointerTons6__Year(soap, "ns6:year", -1, &(a->ns6__ComplexDate::year), ""))
		return soap->error;
	if(soap_out_PointerTons6__Month(soap, "ns6:month", -1, &(a->ns6__ComplexDate::month), ""))
		return soap->error;
	if(soap_out_PointerTons6__Day(soap, "ns6:day", -1, &(a->ns6__ComplexDate::day), ""))
		return soap->error;
	if(soap_out_PointerTons6__Hour(soap, "ns6:hour", -1, &(a->ns6__ComplexDate::hour), ""))
		return soap->error;
	if(soap_out_PointerTons6__Minute(soap, "ns6:minute", -1, &(a->ns6__ComplexDate::minute), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ComplexDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ComplexDate(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ComplexDate * FASTCALL soap_in_ns6__ComplexDate(struct soap *soap, const char *tag, ns6__ComplexDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ComplexDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ComplexDate, sizeof(ns6__ComplexDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ComplexDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ComplexDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_year1 = 1;
	size_t soap_flag_month1 = 1;
	size_t soap_flag_day1 = 1;
	size_t soap_flag_hour1 = 1;
	size_t soap_flag_minute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_year1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Year(soap, "ns6:year", &(a->ns6__ComplexDate::year), "ns6:Year"))
				{	soap_flag_year1--;
					continue;
				}
			if(soap_flag_month1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Month(soap, "ns6:month", &(a->ns6__ComplexDate::month), "ns6:Month"))
				{	soap_flag_month1--;
					continue;
				}
			if(soap_flag_day1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Day(soap, "ns6:day", &(a->ns6__ComplexDate::day), "ns6:Day"))
				{	soap_flag_day1--;
					continue;
				}
			if(soap_flag_hour1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Hour(soap, "ns6:hour", &(a->ns6__ComplexDate::hour), "ns6:Hour"))
				{	soap_flag_hour1--;
					continue;
				}
			if(soap_flag_minute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Minute(soap, "ns6:minute", &(a->ns6__ComplexDate::minute), "ns6:Minute"))
				{	soap_flag_minute1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ComplexDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ComplexDate, 0, sizeof(ns6__ComplexDate), 0, soap_copy_ns6__ComplexDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ComplexDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ComplexDate);
	return this->soap_out(soap, tag?tag:"ns6:ComplexDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ComplexDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ComplexDate(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ComplexDate * SOAP_FMAC4 soap_get_ns6__ComplexDate(struct soap *soap, ns6__ComplexDate *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ComplexDate * FASTCALL soap_instantiate_ns6__ComplexDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ComplexDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ComplexDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ComplexDate);
		ASSIGN_PTR(size, sizeof(ns6__ComplexDate));
		((ns6__ComplexDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ComplexDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ComplexDate));
		for(int i = 0; i < n; i++)
			((ns6__ComplexDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ComplexDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ComplexDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ComplexDate %p -> %p\n", q, p));
	*(ns6__ComplexDate*)p = *(ns6__ComplexDate*)q;
}

void ns6__PackageList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__PackageList::__sizepackage = 0;
	this->ns6__PackageList::package = NULL;
	/* transient soap skipped */
}

void ns6__PackageList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__PackageList::package) {
		for(int i = 0; i < this->ns6__PackageList::__sizepackage; i++) {
			soap_serialize_PointerTons6__Package(soap, this->ns6__PackageList::package + i);
		}
	}
	/* transient soap skipped */
}

int ns6__PackageList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__PackageList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__PackageList(struct soap *soap, const char *tag, int id, const ns6__PackageList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PackageList), type))
		return soap->error;
	if(a->ns6__PackageList::package) {
		int i;
		for(i = 0; i < a->ns6__PackageList::__sizepackage; i++)
			if(soap_out_PointerTons6__Package(soap, "ns6:package", -1, a->ns6__PackageList::package + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__PackageList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__PackageList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__PackageList * FASTCALL soap_in_ns6__PackageList(struct soap *soap, const char *tag, ns6__PackageList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__PackageList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PackageList, sizeof(ns6__PackageList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__PackageList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__PackageList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_package1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:package", 1, NULL)) {
				if(a->ns6__PackageList::package == NULL) {
					if(soap_blist_package1 == NULL)
						soap_blist_package1 = soap_new_block(soap);
					a->ns6__PackageList::package = (ns6__Package **)soap_push_block(soap, soap_blist_package1, sizeof(ns6__Package *));
					if(a->ns6__PackageList::package == NULL)
						return NULL;
					*a->ns6__PackageList::package = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Package(soap, "ns6:package", a->ns6__PackageList::package, "ns6:Package"))
				{	a->ns6__PackageList::__sizepackage++;
					a->ns6__PackageList::package = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__PackageList::package)
			soap_pop_block(soap, soap_blist_package1);
		if(a->ns6__PackageList::__sizepackage)
			a->ns6__PackageList::package = (ns6__Package **)soap_save_block(soap, soap_blist_package1, NULL, 1);
		else
		{	a->ns6__PackageList::package = NULL;
			if(soap_blist_package1)
				soap_end_block(soap, soap_blist_package1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__PackageList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PackageList, 0, sizeof(ns6__PackageList), 0, soap_copy_ns6__PackageList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__PackageList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__PackageList);
	return this->soap_out(soap, tag?tag:"ns6:PackageList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__PackageList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__PackageList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__PackageList * SOAP_FMAC4 soap_get_ns6__PackageList(struct soap *soap, ns6__PackageList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__PackageList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__PackageList * FASTCALL soap_instantiate_ns6__PackageList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__PackageList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__PackageList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__PackageList);
		ASSIGN_PTR(size, sizeof(ns6__PackageList));
		((ns6__PackageList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__PackageList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__PackageList));
		for(int i = 0; i < n; i++)
			((ns6__PackageList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__PackageList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__PackageList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__PackageList %p -> %p\n", q, p));
	*(ns6__PackageList*)p = *(ns6__PackageList*)q;
}

void ns6__Package::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__PackageLevelType(soap, &this->ns6__Package::level);
	this->ns6__Package::packingType = NULL;
	soap_default_xsd__integer(soap, &this->ns6__Package::quantity);
	this->ns6__Package::__sizeproductMarks = 0;
	this->ns6__Package::productMarks = NULL;
	/* transient soap skipped */
}

void ns6__Package::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__PackingType(soap, &this->ns6__Package::packingType);
	soap_serialize_xsd__integer(soap, &this->ns6__Package::quantity);
	if(this->ns6__Package::productMarks) {
		for(int i = 0; i < this->ns6__Package::__sizeproductMarks; i++) {
			soap_serialize_PointerTons6__ProductMarks(soap, this->ns6__Package::productMarks + i);
		}
	}
	/* transient soap skipped */
}

int ns6__Package::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Package(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Package(struct soap *soap, const char *tag, int id, const ns6__Package *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Package), type))
		return soap->error;
	if(soap_out_ns6__PackageLevelType(soap, "ns6:level", -1, &(a->ns6__Package::level), ""))
		return soap->error;
	if(a->ns6__Package::packingType) {
		if(soap_out_PointerTons6__PackingType(soap, "ns6:packingType", -1, &a->ns6__Package::packingType, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:packingType"))
		return soap->error;
	if(soap_out_xsd__integer(soap, "ns6:quantity", -1, &(a->ns6__Package::quantity), ""))
		return soap->error;
	if(a->ns6__Package::productMarks) {
		int i;
		for(i = 0; i < a->ns6__Package::__sizeproductMarks; i++)
			if(soap_out_PointerTons6__ProductMarks(soap, "ns6:productMarks", -1, a->ns6__Package::productMarks + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Package::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Package(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Package * FASTCALL soap_in_ns6__Package(struct soap *soap, const char *tag, ns6__Package *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Package *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Package, sizeof(ns6__Package), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Package) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Package *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_level1 = 1;
	size_t soap_flag_packingType1 = 1;
	size_t soap_flag_quantity1 = 1;
	struct soap_blist *soap_blist_productMarks1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ns6__PackageLevelType(soap, "ns6:level", &(a->ns6__Package::level), "ns6:PackageLevelType"))
				{	soap_flag_level1--;
					continue;
				}
			if(soap_flag_packingType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackingType(soap, "ns6:packingType", &(a->ns6__Package::packingType), "ns6:PackingType"))
				{	soap_flag_packingType1--;
					continue;
				}
			if(soap_flag_quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "ns6:quantity", &(a->ns6__Package::quantity), "xsd:integer"))
				{	soap_flag_quantity1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:productMarks", 1, NULL)) {
				if(a->ns6__Package::productMarks == NULL) {
					if(soap_blist_productMarks1 == NULL)
						soap_blist_productMarks1 = soap_new_block(soap);
					a->ns6__Package::productMarks = (ns6__ProductMarks **)soap_push_block(soap, soap_blist_productMarks1, sizeof(ns6__ProductMarks *));
					if(a->ns6__Package::productMarks == NULL)
						return NULL;
					*a->ns6__Package::productMarks = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__ProductMarks(soap, "ns6:productMarks", a->ns6__Package::productMarks, "ns6:ProductMarks"))
				{	a->ns6__Package::__sizeproductMarks++;
					a->ns6__Package::productMarks = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__Package::productMarks)
			soap_pop_block(soap, soap_blist_productMarks1);
		if(a->ns6__Package::__sizeproductMarks)
			a->ns6__Package::productMarks = (ns6__ProductMarks **)soap_save_block(soap, soap_blist_productMarks1, NULL, 1);
		else
		{	a->ns6__Package::productMarks = NULL;
			if(soap_blist_productMarks1)
				soap_end_block(soap, soap_blist_productMarks1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Package *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Package, 0, sizeof(ns6__Package), 0, soap_copy_ns6__Package);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0 || soap_flag_packingType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__Package::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Package);
	return this->soap_out(soap, tag?tag:"ns6:Package", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Package::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Package(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Package * SOAP_FMAC4 soap_get_ns6__Package(struct soap *soap, ns6__Package *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Package * FASTCALL soap_instantiate_ns6__Package(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Package(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Package, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Package);
		ASSIGN_PTR(size, sizeof(ns6__Package));
		((ns6__Package*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Package[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Package));
		for(int i = 0; i < n; i++)
			((ns6__Package*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Package*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Package(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Package %p -> %p\n", q, p));
	*(ns6__Package*)p = *(ns6__Package*)q;
}

void ns6__ProductMarks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__ProductMarks::__item);
	this->ns6__ProductMarks::class_ = (enum ns6__ProductMarkingClass)0;
	/* transient soap skipped */
}

void ns6__ProductMarks::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__ProductMarks::__item);
	/* transient soap skipped */
}

int ns6__ProductMarks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProductMarks(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductMarks(struct soap *soap, const char *tag, int id, const ns6__ProductMarks *a, const char *type)
{
	soap_set_attr(soap, "class", soap_ns6__ProductMarkingClass2s(soap, ((ns6__ProductMarks*)a)->class_), 1);
	return soap_out_ns3__String255(soap, tag, id, &a->ns6__ProductMarks::__item, "");
}

void *ns6__ProductMarks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ProductMarks(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProductMarks * FASTCALL soap_in_ns6__ProductMarks(struct soap *soap, const char *tag, ns6__ProductMarks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (ns6__ProductMarks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductMarks, sizeof(ns6__ProductMarks), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ProductMarks)
			return (ns6__ProductMarks *)a->soap_in(soap, tag, type);
	}
	if(soap_s2ns6__ProductMarkingClass(soap, soap_attr_value(soap, "class", 0), &((ns6__ProductMarks*)a)->class_))
		return NULL;
	if(!soap_in_ns3__String255(soap, tag, &(a->ns6__ProductMarks::__item), "ns6:ProductMarks"))
		return NULL;
	return a;
}

int ns6__ProductMarks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ProductMarks);
	return this->soap_out(soap, tag?tag:"ns6:ProductMarks", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ProductMarks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProductMarks(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProductMarks * SOAP_FMAC4 soap_get_ns6__ProductMarks(struct soap *soap, ns6__ProductMarks *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ProductMarks * FASTCALL soap_instantiate_ns6__ProductMarks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProductMarks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ProductMarks, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductMarks);
		ASSIGN_PTR(size, sizeof(ns6__ProductMarks));
		((ns6__ProductMarks*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductMarks[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ProductMarks));
		for(int i = 0; i < n; i++)
			((ns6__ProductMarks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ProductMarks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ProductMarks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ProductMarks %p -> %p\n", q, p));
	*(ns6__ProductMarks*)p = *(ns6__ProductMarks*)q;
}

void ns6__ProductItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ProductItemList::__sizeproductItem = 0;
	this->ns6__ProductItemList::productItem = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__ProductItemList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__ProductItemList::productItem) {
		for(int i = 0; i < this->ns6__ProductItemList::__sizeproductItem; i++) {
			soap_serialize_PointerTons6__ProductItem(soap, this->ns6__ProductItemList::productItem + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ProductItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProductItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductItemList(struct soap *soap, const char *tag, int id, const ns6__ProductItemList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProductItemList), "ns6:ProductItemList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__ProductItemList::productItem) {
		int i;
		for(i = 0; i < a->ns6__ProductItemList::__sizeproductItem; i++)
			if(soap_out_PointerTons6__ProductItem(soap, "ns6:productItem", -1, a->ns6__ProductItemList::productItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ProductItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ProductItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProductItemList * FASTCALL soap_in_ns6__ProductItemList(struct soap *soap, const char *tag, ns6__ProductItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ProductItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductItemList, sizeof(ns6__ProductItemList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ProductItemList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ProductItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_productItem1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:productItem", 1, NULL)) {
				if(a->ns6__ProductItemList::productItem == NULL) {
					if(soap_blist_productItem1 == NULL)
						soap_blist_productItem1 = soap_new_block(soap);
					a->ns6__ProductItemList::productItem = (ns6__ProductItem **)soap_push_block(soap, soap_blist_productItem1, sizeof(ns6__ProductItem *));
					if(a->ns6__ProductItemList::productItem == NULL)
						return NULL;
					*a->ns6__ProductItemList::productItem = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__ProductItem(soap, "ns6:productItem", a->ns6__ProductItemList::productItem, "ns6:ProductItem"))
				{	a->ns6__ProductItemList::__sizeproductItem++;
					a->ns6__ProductItemList::productItem = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__ProductItemList::productItem)
			soap_pop_block(soap, soap_blist_productItem1);
		if(a->ns6__ProductItemList::__sizeproductItem)
			a->ns6__ProductItemList::productItem = (ns6__ProductItem **)soap_save_block(soap, soap_blist_productItem1, NULL, 1);
		else
		{	a->ns6__ProductItemList::productItem = NULL;
			if(soap_blist_productItem1)
				soap_end_block(soap, soap_blist_productItem1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ProductItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProductItemList, 0, sizeof(ns6__ProductItemList), 0, soap_copy_ns6__ProductItemList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ProductItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ProductItemList);
	return this->soap_out(soap, tag?tag:"ns6:ProductItemList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ProductItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProductItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProductItemList * SOAP_FMAC4 soap_get_ns6__ProductItemList(struct soap *soap, ns6__ProductItemList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ProductItemList * FASTCALL soap_instantiate_ns6__ProductItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProductItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ProductItemList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductItemList);
		ASSIGN_PTR(size, sizeof(ns6__ProductItemList));
		((ns6__ProductItemList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductItemList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ProductItemList));
		for(int i = 0; i < n; i++)
			((ns6__ProductItemList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ProductItemList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ProductItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ProductItemList %p -> %p\n", q, p));
	*(ns6__ProductItemList*)p = *(ns6__ProductItemList*)q;
}

void ns6__SubProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__SubProductList::__sizesubProduct = 0;
	this->ns6__SubProductList::subProduct = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__SubProductList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__SubProductList::subProduct) {
		for(int i = 0; i < this->ns6__SubProductList::__sizesubProduct; i++) {
			soap_serialize_PointerTons6__SubProduct(soap, this->ns6__SubProductList::subProduct + i);
		}
	}
	/* transient soap skipped */
}

int ns6__SubProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SubProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__SubProductList(struct soap *soap, const char *tag, int id, const ns6__SubProductList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SubProductList), "ns6:SubProductList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__SubProductList::subProduct) {
		int i;
		for(i = 0; i < a->ns6__SubProductList::__sizesubProduct; i++)
			if(soap_out_PointerTons6__SubProduct(soap, "ns6:subProduct", -1, a->ns6__SubProductList::subProduct + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__SubProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__SubProductList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SubProductList * FASTCALL soap_in_ns6__SubProductList(struct soap *soap, const char *tag, ns6__SubProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SubProductList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SubProductList, sizeof(ns6__SubProductList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__SubProductList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SubProductList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_subProduct1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:subProduct", 1, NULL)) {
				if(a->ns6__SubProductList::subProduct == NULL) {
					if(soap_blist_subProduct1 == NULL)
						soap_blist_subProduct1 = soap_new_block(soap);
					a->ns6__SubProductList::subProduct = (ns6__SubProduct **)soap_push_block(soap, soap_blist_subProduct1, sizeof(ns6__SubProduct *));
					if(a->ns6__SubProductList::subProduct == NULL)
						return NULL;
					*a->ns6__SubProductList::subProduct = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:subProduct", a->ns6__SubProductList::subProduct, "ns6:SubProduct"))
				{	a->ns6__SubProductList::__sizesubProduct++;
					a->ns6__SubProductList::subProduct = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__SubProductList::subProduct)
			soap_pop_block(soap, soap_blist_subProduct1);
		if(a->ns6__SubProductList::__sizesubProduct)
			a->ns6__SubProductList::subProduct = (ns6__SubProduct **)soap_save_block(soap, soap_blist_subProduct1, NULL, 1);
		else
		{	a->ns6__SubProductList::subProduct = NULL;
			if(soap_blist_subProduct1)
				soap_end_block(soap, soap_blist_subProduct1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__SubProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SubProductList, 0, sizeof(ns6__SubProductList), 0, soap_copy_ns6__SubProductList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__SubProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SubProductList);
	return this->soap_out(soap, tag?tag:"ns6:SubProductList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__SubProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SubProductList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SubProductList * SOAP_FMAC4 soap_get_ns6__SubProductList(struct soap *soap, ns6__SubProductList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__SubProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__SubProductList * FASTCALL soap_instantiate_ns6__SubProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SubProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SubProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__SubProductList);
		ASSIGN_PTR(size, sizeof(ns6__SubProductList));
		((ns6__SubProductList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__SubProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__SubProductList));
		for(int i = 0; i < n; i++)
			((ns6__SubProductList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SubProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SubProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SubProductList %p -> %p\n", q, p));
	*(ns6__SubProductList*)p = *(ns6__SubProductList*)q;
}

void ns6__ProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ProductList::__sizeproduct = 0;
	this->ns6__ProductList::product = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__ProductList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__ProductList::product) {
		for(int i = 0; i < this->ns6__ProductList::__sizeproduct; i++) {
			soap_serialize_PointerTons6__Product(soap, this->ns6__ProductList::product + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductList(struct soap *soap, const char *tag, int id, const ns6__ProductList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProductList), "ns6:ProductList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__ProductList::product) {
		int i;
		for(i = 0; i < a->ns6__ProductList::__sizeproduct; i++)
			if(soap_out_PointerTons6__Product(soap, "ns6:product", -1, a->ns6__ProductList::product + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__ProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ProductList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProductList * FASTCALL soap_in_ns6__ProductList(struct soap *soap, const char *tag, ns6__ProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ProductList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductList, sizeof(ns6__ProductList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ProductList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ProductList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_product1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:product", 1, NULL)) {
				if(a->ns6__ProductList::product == NULL) {
					if(soap_blist_product1 == NULL)
						soap_blist_product1 = soap_new_block(soap);
					a->ns6__ProductList::product = (ns6__Product **)soap_push_block(soap, soap_blist_product1, sizeof(ns6__Product *));
					if(a->ns6__ProductList::product == NULL)
						return NULL;
					*a->ns6__ProductList::product = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Product(soap, "ns6:product", a->ns6__ProductList::product, "ns6:Product"))
				{	a->ns6__ProductList::__sizeproduct++;
					a->ns6__ProductList::product = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__ProductList::product)
			soap_pop_block(soap, soap_blist_product1);
		if(a->ns6__ProductList::__sizeproduct)
			a->ns6__ProductList::product = (ns6__Product **)soap_save_block(soap, soap_blist_product1, NULL, 1);
		else
		{	a->ns6__ProductList::product = NULL;
			if(soap_blist_product1)
				soap_end_block(soap, soap_blist_product1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProductList, 0, sizeof(ns6__ProductList), 0, soap_copy_ns6__ProductList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ProductList);
	return this->soap_out(soap, tag?tag:"ns6:ProductList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProductList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProductList * SOAP_FMAC4 soap_get_ns6__ProductList(struct soap *soap, ns6__ProductList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ProductList * FASTCALL soap_instantiate_ns6__ProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductList);
		ASSIGN_PTR(size, sizeof(ns6__ProductList));
		((ns6__ProductList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ProductList));
		for(int i = 0; i < n; i++)
			((ns6__ProductList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ProductList %p -> %p\n", q, p));
	*(ns6__ProductList*)p = *(ns6__ProductList*)q;
}

void ns6__SubProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__SubProduct::name);
	soap_default_ns3__String255(soap, &this->ns6__SubProduct::code);
	soap_default_ns3__String255(soap, &this->ns6__SubProduct::englishName);
	soap_default_ns3__UUID(soap, &this->ns6__SubProduct::productGuid);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__SubProduct::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__SubProduct::name);
	soap_serialize_ns3__String255(soap, &this->ns6__SubProduct::code);
	soap_serialize_ns3__String255(soap, &this->ns6__SubProduct::englishName);
	soap_serialize_ns3__UUID(soap, &this->ns6__SubProduct::productGuid);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__SubProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__SubProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__SubProduct(struct soap *soap, const char *tag, int id, const ns6__SubProduct *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SubProduct), "ns6:SubProduct"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__SubProduct::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:code", -1, &(a->ns6__SubProduct::code), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__SubProduct::englishName), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:productGuid", -1, &(a->ns6__SubProduct::productGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__SubProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__SubProduct(soap, tag, this, type);
}

SOAP_FMAC3 ns6__SubProduct * FASTCALL soap_in_ns6__SubProduct(struct soap *soap, const char *tag, ns6__SubProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__SubProduct *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SubProduct, sizeof(ns6__SubProduct), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__SubProduct) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__SubProduct *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_productGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__SubProduct::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:code", &(a->ns6__SubProduct::code), "ns3:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__SubProduct::englishName), "ns3:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_productGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:productGuid", &(a->ns6__SubProduct::productGuid), "ns3:UUID"))
				{	soap_flag_productGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__SubProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SubProduct, 0, sizeof(ns6__SubProduct), 0, soap_copy_ns6__SubProduct);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__SubProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__SubProduct);
	return this->soap_out(soap, tag?tag:"ns6:SubProduct", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__SubProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__SubProduct(soap, this, tag, type);
}

SOAP_FMAC3 ns6__SubProduct * SOAP_FMAC4 soap_get_ns6__SubProduct(struct soap *soap, ns6__SubProduct *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__SubProduct * FASTCALL soap_instantiate_ns6__SubProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__SubProduct(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__SubProduct, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__SubProduct);
		ASSIGN_PTR(size, sizeof(ns6__SubProduct));
		((ns6__SubProduct*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__SubProduct[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__SubProduct));
		for(int i = 0; i < n; i++)
			((ns6__SubProduct*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__SubProduct*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__SubProduct(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__SubProduct %p -> %p\n", q, p));
	*(ns6__SubProduct*)p = *(ns6__SubProduct*)q;
}

void ns6__Product::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Product::name);
	soap_default_ns3__String255(soap, &this->ns6__Product::code);
	soap_default_ns3__String255(soap, &this->ns6__Product::englishName);
	this->ns6__Product::productType = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Product::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Product::name);
	soap_serialize_ns3__String255(soap, &this->ns6__Product::code);
	soap_serialize_ns3__String255(soap, &this->ns6__Product::englishName);
	soap_serialize_PointerTons6__ProductType(soap, &this->ns6__Product::productType);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Product::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Product(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Product(struct soap *soap, const char *tag, int id, const ns6__Product *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Product), "ns6:Product"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Product::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:code", -1, &(a->ns6__Product::code), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__Product::englishName), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns6:productType", -1, &(a->ns6__Product::productType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Product::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Product(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Product * FASTCALL soap_in_ns6__Product(struct soap *soap, const char *tag, ns6__Product *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Product *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Product, sizeof(ns6__Product), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Product) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Product *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_productType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Product::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:code", &(a->ns6__Product::code), "ns3:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__Product::englishName), "ns3:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns6:productType", &(a->ns6__Product::productType), "ns6:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Product *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Product, 0, sizeof(ns6__Product), 0, soap_copy_ns6__Product);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Product::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Product);
	return this->soap_out(soap, tag?tag:"ns6:Product", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Product::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Product(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Product * SOAP_FMAC4 soap_get_ns6__Product(struct soap *soap, ns6__Product *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Product * FASTCALL soap_instantiate_ns6__Product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Product(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Product, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Product);
		ASSIGN_PTR(size, sizeof(ns6__Product));
		((ns6__Product*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Product[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Product));
		for(int i = 0; i < n; i++)
			((ns6__Product*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Product*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Product(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Product %p -> %p\n", q, p));
	*(ns6__Product*)p = *(ns6__Product*)q;
}

void ns6__ProductItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__GTINType(soap, &this->ns6__ProductItem::globalID);
	soap_default_ns3__String255(soap, &this->ns6__ProductItem::name);
	soap_default_ns3__String255(soap, &this->ns6__ProductItem::code);
	this->ns6__ProductItem::productType = NULL;
	this->ns6__ProductItem::product = NULL;
	this->ns6__ProductItem::subProduct = NULL;
	this->ns6__ProductItem::correspondsToGost = NULL;
	soap_default_ns3__String255(soap, &this->ns6__ProductItem::gost);
	this->ns6__ProductItem::producer = NULL;
	this->ns6__ProductItem::tmOwner = NULL;
	this->ns6__ProductItem::__sizeproducing = 0;
	this->ns6__ProductItem::producing = NULL;
	this->ns6__ProductItem::packaging = NULL;
	this->ns6__ProductItem::isPublic = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__ProductItem::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns6__GTINType(soap, &this->ns6__ProductItem::globalID);
	soap_serialize_ns3__String255(soap, &this->ns6__ProductItem::name);
	soap_serialize_ns3__String255(soap, &this->ns6__ProductItem::code);
	soap_serialize_PointerTons6__ProductType(soap, &this->ns6__ProductItem::productType);
	soap_serialize_PointerTons6__Product(soap, &this->ns6__ProductItem::product);
	soap_serialize_PointerTons6__SubProduct(soap, &this->ns6__ProductItem::subProduct);
	soap_serialize_PointerTobool(soap, &this->ns6__ProductItem::correspondsToGost);
	soap_serialize_ns3__String255(soap, &this->ns6__ProductItem::gost);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns6__ProductItem::producer);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns6__ProductItem::tmOwner);
	if(this->ns6__ProductItem::producing) {
		for(int i = 0; i < this->ns6__ProductItem::__sizeproducing; i++) {
			soap_serialize_PointerTons6__ProductItemProducing(soap, this->ns6__ProductItem::producing + i);
		}
	}
	soap_serialize_PointerTons6__Packaging(soap, &this->ns6__ProductItem::packaging);
	soap_serialize_PointerTobool(soap, &this->ns6__ProductItem::isPublic);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__ProductItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProductItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProductItem(struct soap *soap, const char *tag, int id, const ns6__ProductItem *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProductItem), "ns6:ProductItem"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns6__GTINType(soap, "ns6:globalID", -1, &(a->ns6__ProductItem::globalID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__ProductItem::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:code", -1, &(a->ns6__ProductItem::code), ""))
		return soap->error;
	if(soap_out_PointerTons6__ProductType(soap, "ns6:productType", -1, &(a->ns6__ProductItem::productType), ""))
		return soap->error;
	if(soap_out_PointerTons6__Product(soap, "ns6:product", -1, &(a->ns6__ProductItem::product), ""))
		return soap->error;
	if(soap_out_PointerTons6__SubProduct(soap, "ns6:subProduct", -1, &(a->ns6__ProductItem::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:correspondsToGost", -1, &(a->ns6__ProductItem::correspondsToGost), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:gost", -1, &(a->ns6__ProductItem::gost), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:producer", -1, &(a->ns6__ProductItem::producer), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:tmOwner", -1, &(a->ns6__ProductItem::tmOwner), ""))
		return soap->error;
	if(a->ns6__ProductItem::producing) {
		int i;
		for(i = 0; i < a->ns6__ProductItem::__sizeproducing; i++)
			if(soap_out_PointerTons6__ProductItemProducing(soap, "ns6:producing", -1, a->ns6__ProductItem::producing + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons6__Packaging(soap, "ns6:packaging", -1, &(a->ns6__ProductItem::packaging), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:isPublic", -1, &(a->ns6__ProductItem::isPublic), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ProductItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ProductItem(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProductItem * FASTCALL soap_in_ns6__ProductItem(struct soap *soap, const char *tag, ns6__ProductItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ProductItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProductItem, sizeof(ns6__ProductItem), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ProductItem) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ProductItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_globalID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_subProduct1 = 1;
	size_t soap_flag_correspondsToGost1 = 1;
	size_t soap_flag_gost1 = 1;
	size_t soap_flag_producer1 = 1;
	size_t soap_flag_tmOwner1 = 1;
	struct soap_blist *soap_blist_producing1 = NULL;
	size_t soap_flag_packaging1 = 1;
	size_t soap_flag_isPublic1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__GTINType(soap, "ns6:globalID", &(a->ns6__ProductItem::globalID), "ns6:GTINType"))
				{	soap_flag_globalID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__ProductItem::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:code", &(a->ns6__ProductItem::code), "ns3:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductType(soap, "ns6:productType", &(a->ns6__ProductItem::productType), "ns6:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap_flag_product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Product(soap, "ns6:product", &(a->ns6__ProductItem::product), "ns6:Product"))
				{	soap_flag_product1--;
					continue;
				}
			if(soap_flag_subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:subProduct", &(a->ns6__ProductItem::subProduct), "ns6:SubProduct"))
				{	soap_flag_subProduct1--;
					continue;
				}
			if(soap_flag_correspondsToGost1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:correspondsToGost", &(a->ns6__ProductItem::correspondsToGost), "xsd:boolean"))
				{	soap_flag_correspondsToGost1--;
					continue;
				}
			if(soap_flag_gost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:gost", &(a->ns6__ProductItem::gost), "ns3:String255"))
				{	soap_flag_gost1--;
					continue;
				}
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:producer", &(a->ns6__ProductItem::producer), "ns6:BusinessEntity"))
				{	soap_flag_producer1--;
					continue;
				}
			if(soap_flag_tmOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:tmOwner", &(a->ns6__ProductItem::tmOwner), "ns6:BusinessEntity"))
				{	soap_flag_tmOwner1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:producing", 1, NULL)) {
				if(a->ns6__ProductItem::producing == NULL) {
					if(soap_blist_producing1 == NULL)
						soap_blist_producing1 = soap_new_block(soap);
					a->ns6__ProductItem::producing = (ns6__ProductItemProducing **)soap_push_block(soap, soap_blist_producing1, sizeof(ns6__ProductItemProducing *));
					if(a->ns6__ProductItem::producing == NULL)
						return NULL;
					*a->ns6__ProductItem::producing = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__ProductItemProducing(soap, "ns6:producing", a->ns6__ProductItem::producing, "ns6:ProductItemProducing"))
				{	a->ns6__ProductItem::__sizeproducing++;
					a->ns6__ProductItem::producing = NULL;
					continue;
				}
			}
			if(soap_flag_packaging1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Packaging(soap, "ns6:packaging", &(a->ns6__ProductItem::packaging), "ns6:Packaging"))
				{	soap_flag_packaging1--;
					continue;
				}
			if(soap_flag_isPublic1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:isPublic", &(a->ns6__ProductItem::isPublic), "xsd:boolean"))
				{	soap_flag_isPublic1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__ProductItem::producing)
			soap_pop_block(soap, soap_blist_producing1);
		if(a->ns6__ProductItem::__sizeproducing)
			a->ns6__ProductItem::producing = (ns6__ProductItemProducing **)soap_save_block(soap, soap_blist_producing1, NULL, 1);
		else
		{	a->ns6__ProductItem::producing = NULL;
			if(soap_blist_producing1)
				soap_end_block(soap, soap_blist_producing1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ProductItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProductItem, 0, sizeof(ns6__ProductItem), 0, soap_copy_ns6__ProductItem);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ProductItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ProductItem);
	return this->soap_out(soap, tag?tag:"ns6:ProductItem", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ProductItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProductItem(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProductItem * SOAP_FMAC4 soap_get_ns6__ProductItem(struct soap *soap, ns6__ProductItem *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ProductItem * FASTCALL soap_instantiate_ns6__ProductItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProductItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ProductItem, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductItem);
		ASSIGN_PTR(size, sizeof(ns6__ProductItem));
		((ns6__ProductItem*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ProductItem[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ProductItem));
		for(int i = 0; i < n; i++)
			((ns6__ProductItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ProductItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ProductItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ProductItem %p -> %p\n", q, p));
	*(ns6__ProductItem*)p = *(ns6__ProductItem*)q;
}

void ns6__BusinessEntityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__BusinessEntityList::__sizebusinessEntity = 0;
	this->ns6__BusinessEntityList::businessEntity = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__BusinessEntityList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__BusinessEntityList::businessEntity) {
		for(int i = 0; i < this->ns6__BusinessEntityList::__sizebusinessEntity; i++) {
			soap_serialize_PointerTons6__BusinessEntity(soap, this->ns6__BusinessEntityList::businessEntity + i);
		}
	}
	/* transient soap skipped */
}

int ns6__BusinessEntityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__BusinessEntityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__BusinessEntityList(struct soap *soap, const char *tag, int id, const ns6__BusinessEntityList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BusinessEntityList), "ns6:BusinessEntityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__BusinessEntityList::businessEntity) {
		int i;
		for(i = 0; i < a->ns6__BusinessEntityList::__sizebusinessEntity; i++)
			if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, a->ns6__BusinessEntityList::businessEntity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__BusinessEntityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__BusinessEntityList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__BusinessEntityList * FASTCALL soap_in_ns6__BusinessEntityList(struct soap *soap, const char *tag, ns6__BusinessEntityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__BusinessEntityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BusinessEntityList, sizeof(ns6__BusinessEntityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__BusinessEntityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__BusinessEntityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_businessEntity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:businessEntity", 1, NULL)) {
				if(a->ns6__BusinessEntityList::businessEntity == NULL) {
					if(soap_blist_businessEntity1 == NULL)
						soap_blist_businessEntity1 = soap_new_block(soap);
					a->ns6__BusinessEntityList::businessEntity = (ns6__BusinessEntity **)soap_push_block(soap, soap_blist_businessEntity1, sizeof(ns6__BusinessEntity *));
					if(a->ns6__BusinessEntityList::businessEntity == NULL)
						return NULL;
					*a->ns6__BusinessEntityList::businessEntity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", a->ns6__BusinessEntityList::businessEntity, "ns6:BusinessEntity"))
				{	a->ns6__BusinessEntityList::__sizebusinessEntity++;
					a->ns6__BusinessEntityList::businessEntity = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__BusinessEntityList::businessEntity)
			soap_pop_block(soap, soap_blist_businessEntity1);
		if(a->ns6__BusinessEntityList::__sizebusinessEntity)
			a->ns6__BusinessEntityList::businessEntity = (ns6__BusinessEntity **)soap_save_block(soap, soap_blist_businessEntity1, NULL, 1);
		else
		{	a->ns6__BusinessEntityList::businessEntity = NULL;
			if(soap_blist_businessEntity1)
				soap_end_block(soap, soap_blist_businessEntity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__BusinessEntityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BusinessEntityList, 0, sizeof(ns6__BusinessEntityList), 0, soap_copy_ns6__BusinessEntityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__BusinessEntityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__BusinessEntityList);
	return this->soap_out(soap, tag?tag:"ns6:BusinessEntityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__BusinessEntityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__BusinessEntityList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__BusinessEntityList * SOAP_FMAC4 soap_get_ns6__BusinessEntityList(struct soap *soap, ns6__BusinessEntityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__BusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__BusinessEntityList * FASTCALL soap_instantiate_ns6__BusinessEntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__BusinessEntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__BusinessEntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntityList);
		ASSIGN_PTR(size, sizeof(ns6__BusinessEntityList));
		((ns6__BusinessEntityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__BusinessEntityList));
		for(int i = 0; i < n; i++)
			((ns6__BusinessEntityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__BusinessEntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__BusinessEntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__BusinessEntityList %p -> %p\n", q, p));
	*(ns6__BusinessEntityList*)p = *(ns6__BusinessEntityList*)q;
}

void ns6__IncorporationForm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__IncorporationForm::name);
	soap_default_ns3__String255(soap, &this->ns6__IncorporationForm::code);
	soap_default_ns3__String255(soap, &this->ns6__IncorporationForm::shortName);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__IncorporationForm::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__IncorporationForm::name);
	soap_serialize_ns3__String255(soap, &this->ns6__IncorporationForm::code);
	soap_serialize_ns3__String255(soap, &this->ns6__IncorporationForm::shortName);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__IncorporationForm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__IncorporationForm(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__IncorporationForm(struct soap *soap, const char *tag, int id, const ns6__IncorporationForm *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__IncorporationForm), "ns6:IncorporationForm"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__IncorporationForm::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:code", -1, &(a->ns6__IncorporationForm::code), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:shortName", -1, &(a->ns6__IncorporationForm::shortName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__IncorporationForm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__IncorporationForm(soap, tag, this, type);
}

SOAP_FMAC3 ns6__IncorporationForm * FASTCALL soap_in_ns6__IncorporationForm(struct soap *soap, const char *tag, ns6__IncorporationForm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__IncorporationForm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__IncorporationForm, sizeof(ns6__IncorporationForm), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__IncorporationForm) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__IncorporationForm *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_shortName1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__IncorporationForm::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:code", &(a->ns6__IncorporationForm::code), "ns3:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:shortName", &(a->ns6__IncorporationForm::shortName), "ns3:String255"))
				{	soap_flag_shortName1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__IncorporationForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__IncorporationForm, 0, sizeof(ns6__IncorporationForm), 0, soap_copy_ns6__IncorporationForm);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__IncorporationForm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__IncorporationForm);
	return this->soap_out(soap, tag?tag:"ns6:IncorporationForm", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__IncorporationForm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__IncorporationForm(soap, this, tag, type);
}

SOAP_FMAC3 ns6__IncorporationForm * SOAP_FMAC4 soap_get_ns6__IncorporationForm(struct soap *soap, ns6__IncorporationForm *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__IncorporationForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__IncorporationForm * FASTCALL soap_instantiate_ns6__IncorporationForm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__IncorporationForm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__IncorporationForm, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__IncorporationForm);
		ASSIGN_PTR(size, sizeof(ns6__IncorporationForm));
		((ns6__IncorporationForm*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__IncorporationForm[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__IncorporationForm));
		for(int i = 0; i < n; i++)
			((ns6__IncorporationForm*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__IncorporationForm*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__IncorporationForm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__IncorporationForm %p -> %p\n", q, p));
	*(ns6__IncorporationForm*)p = *(ns6__IncorporationForm*)q;
}

void ns6__BusinessEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__BusinessEntity::type = NULL;
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::name);
	this->ns6__BusinessEntity::incorporationForm = NULL;
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::fullName);
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::fio);
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::passport);
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::inn);
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::kpp);
	soap_default_ns3__String255(soap, &this->ns6__BusinessEntity::ogrn);
	this->ns6__BusinessEntity::juridicalAddress = NULL;
	this->ns6__BusinessEntity::__sizeactivityLocation = 0;
	this->ns6__BusinessEntity::activityLocation = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__BusinessEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntityType(soap, &this->ns6__BusinessEntity::type);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::name);
	soap_serialize_PointerTons6__IncorporationForm(soap, &this->ns6__BusinessEntity::incorporationForm);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::fullName);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::fio);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::passport);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::inn);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::kpp);
	soap_serialize_ns3__String255(soap, &this->ns6__BusinessEntity::ogrn);
	soap_serialize_PointerTons6__Address(soap, &this->ns6__BusinessEntity::juridicalAddress);
	if(this->ns6__BusinessEntity::activityLocation) {
		for(int i = 0; i < this->ns6__BusinessEntity::__sizeactivityLocation; i++) {
			soap_embedded(soap, this->ns6__BusinessEntity::activityLocation + i, SOAP_TYPE__ns6__BusinessEntity_activityLocation);
			this->ns6__BusinessEntity::activityLocation[i].soap_serialize(soap);
		}
	}
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__BusinessEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__BusinessEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__BusinessEntity(struct soap *soap, const char *tag, int id, const ns6__BusinessEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BusinessEntity), "ns6:BusinessEntity"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntityType(soap, "ns6:type", -1, &(a->ns6__BusinessEntity::type), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__BusinessEntity::name), ""))
		return soap->error;
	if(soap_out_PointerTons6__IncorporationForm(soap, "ns6:incorporationForm", -1, &(a->ns6__BusinessEntity::incorporationForm), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:fullName", -1, &(a->ns6__BusinessEntity::fullName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:fio", -1, &(a->ns6__BusinessEntity::fio), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:passport", -1, &(a->ns6__BusinessEntity::passport), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:inn", -1, &(a->ns6__BusinessEntity::inn), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:kpp", -1, &(a->ns6__BusinessEntity::kpp), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:ogrn", -1, &(a->ns6__BusinessEntity::ogrn), ""))
		return soap->error;
	if(soap_out_PointerTons6__Address(soap, "ns6:juridicalAddress", -1, &(a->ns6__BusinessEntity::juridicalAddress), ""))
		return soap->error;
	if(a->ns6__BusinessEntity::activityLocation) {
		int i;
		for(i = 0; i < a->ns6__BusinessEntity::__sizeactivityLocation; i++)
			if(a->ns6__BusinessEntity::activityLocation[i].soap_out(soap, "ns6:activityLocation", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__BusinessEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__BusinessEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns6__BusinessEntity * FASTCALL soap_in_ns6__BusinessEntity(struct soap *soap, const char *tag, ns6__BusinessEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__BusinessEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BusinessEntity, sizeof(ns6__BusinessEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__BusinessEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__BusinessEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_incorporationForm1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_fio1 = 1;
	size_t soap_flag_passport1 = 1;
	size_t soap_flag_inn1 = 1;
	size_t soap_flag_kpp1 = 1;
	size_t soap_flag_ogrn1 = 1;
	size_t soap_flag_juridicalAddress1 = 1;
	struct soap_blist *soap_blist_activityLocation1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntityType(soap, "ns6:type", &(a->ns6__BusinessEntity::type), "ns6:BusinessEntityType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__BusinessEntity::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_incorporationForm1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__IncorporationForm(soap, "ns6:incorporationForm", &(a->ns6__BusinessEntity::incorporationForm), "ns6:IncorporationForm"))
				{	soap_flag_incorporationForm1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:fullName", &(a->ns6__BusinessEntity::fullName), "ns3:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_fio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:fio", &(a->ns6__BusinessEntity::fio), "ns3:String255"))
				{	soap_flag_fio1--;
					continue;
				}
			if(soap_flag_passport1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:passport", &(a->ns6__BusinessEntity::passport), "ns3:String255"))
				{	soap_flag_passport1--;
					continue;
				}
			if(soap_flag_inn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:inn", &(a->ns6__BusinessEntity::inn), "ns3:String255"))
				{	soap_flag_inn1--;
					continue;
				}
			if(soap_flag_kpp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:kpp", &(a->ns6__BusinessEntity::kpp), "ns3:String255"))
				{	soap_flag_kpp1--;
					continue;
				}
			if(soap_flag_ogrn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:ogrn", &(a->ns6__BusinessEntity::ogrn), "ns3:String255"))
				{	soap_flag_ogrn1--;
					continue;
				}
			if(soap_flag_juridicalAddress1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Address(soap, "ns6:juridicalAddress", &(a->ns6__BusinessEntity::juridicalAddress), "ns6:Address"))
				{	soap_flag_juridicalAddress1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:activityLocation", 1, NULL)) {
				if(a->ns6__BusinessEntity::activityLocation == NULL) {
					if(soap_blist_activityLocation1 == NULL)
						soap_blist_activityLocation1 = soap_new_block(soap);
					a->ns6__BusinessEntity::activityLocation = (_ns6__BusinessEntity_activityLocation *)soap_push_block(soap, soap_blist_activityLocation1, sizeof(_ns6__BusinessEntity_activityLocation));
					if(a->ns6__BusinessEntity::activityLocation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ns6__BusinessEntity::activityLocation, _ns6__BusinessEntity_activityLocation);
					a->ns6__BusinessEntity::activityLocation->soap_default(soap);
				}
				soap_revert(soap);
				if(soap_in__ns6__BusinessEntity_activityLocation(soap, "ns6:activityLocation", a->ns6__BusinessEntity::activityLocation, ""))
				{	a->ns6__BusinessEntity::__sizeactivityLocation++;
					a->ns6__BusinessEntity::activityLocation = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__BusinessEntity::activityLocation)
			soap_pop_block(soap, soap_blist_activityLocation1);
		if(a->ns6__BusinessEntity::__sizeactivityLocation)
			a->ns6__BusinessEntity::activityLocation = (_ns6__BusinessEntity_activityLocation *)soap_save_block(soap, soap_blist_activityLocation1, NULL, 1);
		else
		{	a->ns6__BusinessEntity::activityLocation = NULL;
			if(soap_blist_activityLocation1)
				soap_end_block(soap, soap_blist_activityLocation1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__BusinessEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BusinessEntity, 0, sizeof(ns6__BusinessEntity), 0, soap_copy_ns6__BusinessEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__BusinessEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__BusinessEntity);
	return this->soap_out(soap, tag?tag:"ns6:BusinessEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__BusinessEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__BusinessEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns6__BusinessEntity * SOAP_FMAC4 soap_get_ns6__BusinessEntity(struct soap *soap, ns6__BusinessEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__BusinessEntity * FASTCALL soap_instantiate_ns6__BusinessEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__BusinessEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__BusinessEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntity);
		ASSIGN_PTR(size, sizeof(ns6__BusinessEntity));
		((ns6__BusinessEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__BusinessEntity));
		for(int i = 0; i < n; i++)
			((ns6__BusinessEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__BusinessEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__BusinessEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__BusinessEntity %p -> %p\n", q, p));
	*(ns6__BusinessEntity*)p = *(ns6__BusinessEntity*)q;
}

void ns6__BusinessMember::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__BusinessMember::businessEntity = NULL;
	this->ns6__BusinessMember::enterprise = NULL;
	soap_default_ns6__GLNType(soap, &this->ns6__BusinessMember::globalID);
	/* transient soap skipped */
}

void ns6__BusinessMember::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns6__BusinessMember::businessEntity);
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns6__BusinessMember::enterprise);
	soap_serialize_ns6__GLNType(soap, &this->ns6__BusinessMember::globalID);
	/* transient soap skipped */
}

int ns6__BusinessMember::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__BusinessMember(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__BusinessMember(struct soap *soap, const char *tag, int id, const ns6__BusinessMember *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BusinessMember), type))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", -1, &(a->ns6__BusinessMember::businessEntity), ""))
		return soap->error;
	if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &(a->ns6__BusinessMember::enterprise), ""))
		return soap->error;
	if(soap_out_ns6__GLNType(soap, "ns6:globalID", -1, &(a->ns6__BusinessMember::globalID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__BusinessMember::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__BusinessMember(soap, tag, this, type);
}

SOAP_FMAC3 ns6__BusinessMember * FASTCALL soap_in_ns6__BusinessMember(struct soap *soap, const char *tag, ns6__BusinessMember *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__BusinessMember *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BusinessMember, sizeof(ns6__BusinessMember), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__BusinessMember) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__BusinessMember *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessEntity1 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_globalID1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:businessEntity", &(a->ns6__BusinessMember::businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->ns6__BusinessMember::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__GLNType(soap, "ns6:globalID", &(a->ns6__BusinessMember::globalID), "ns6:GLNType"))
				{	soap_flag_globalID1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__BusinessMember *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BusinessMember, 0, sizeof(ns6__BusinessMember), 0, soap_copy_ns6__BusinessMember);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__BusinessMember::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__BusinessMember);
	return this->soap_out(soap, tag?tag:"ns6:BusinessMember", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__BusinessMember::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__BusinessMember(soap, this, tag, type);
}

SOAP_FMAC3 ns6__BusinessMember * SOAP_FMAC4 soap_get_ns6__BusinessMember(struct soap *soap, ns6__BusinessMember *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__BusinessMember * FASTCALL soap_instantiate_ns6__BusinessMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__BusinessMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__BusinessMember, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__BusinessMember);
		ASSIGN_PTR(size, sizeof(ns6__BusinessMember));
		((ns6__BusinessMember*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__BusinessMember[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__BusinessMember));
		for(int i = 0; i < n; i++)
			((ns6__BusinessMember*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__BusinessMember*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__BusinessMember(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__BusinessMember %p -> %p\n", q, p));
	*(ns6__BusinessMember*)p = *(ns6__BusinessMember*)q;
}

void ns6__EnterpriseList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EnterpriseList::__sizeenterprise = 0;
	this->ns6__EnterpriseList::enterprise = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__EnterpriseList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__EnterpriseList::enterprise) {
		for(int i = 0; i < this->ns6__EnterpriseList::__sizeenterprise; i++) {
			soap_serialize_PointerTons6__Enterprise(soap, this->ns6__EnterpriseList::enterprise + i);
		}
	}
	/* transient soap skipped */
}

int ns6__EnterpriseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EnterpriseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseList(struct soap *soap, const char *tag, int id, const ns6__EnterpriseList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseList), "ns6:EnterpriseList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__EnterpriseList::enterprise) {
		int i;
		for(i = 0; i < a->ns6__EnterpriseList::__sizeenterprise; i++)
			if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, a->ns6__EnterpriseList::enterprise + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__EnterpriseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__EnterpriseList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EnterpriseList * FASTCALL soap_in_ns6__EnterpriseList(struct soap *soap, const char *tag, ns6__EnterpriseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__EnterpriseList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseList, sizeof(ns6__EnterpriseList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__EnterpriseList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__EnterpriseList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_enterprise1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:enterprise", 1, NULL)) {
				if(a->ns6__EnterpriseList::enterprise == NULL) {
					if(soap_blist_enterprise1 == NULL)
						soap_blist_enterprise1 = soap_new_block(soap);
					a->ns6__EnterpriseList::enterprise = (ns6__Enterprise **)soap_push_block(soap, soap_blist_enterprise1, sizeof(ns6__Enterprise *));
					if(a->ns6__EnterpriseList::enterprise == NULL)
						return NULL;
					*a->ns6__EnterpriseList::enterprise = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", a->ns6__EnterpriseList::enterprise, "ns6:Enterprise"))
				{	a->ns6__EnterpriseList::__sizeenterprise++;
					a->ns6__EnterpriseList::enterprise = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__EnterpriseList::enterprise)
			soap_pop_block(soap, soap_blist_enterprise1);
		if(a->ns6__EnterpriseList::__sizeenterprise)
			a->ns6__EnterpriseList::enterprise = (ns6__Enterprise **)soap_save_block(soap, soap_blist_enterprise1, NULL, 1);
		else
		{	a->ns6__EnterpriseList::enterprise = NULL;
			if(soap_blist_enterprise1)
				soap_end_block(soap, soap_blist_enterprise1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseList, 0, sizeof(ns6__EnterpriseList), 0, soap_copy_ns6__EnterpriseList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__EnterpriseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseList);
	return this->soap_out(soap, tag?tag:"ns6:EnterpriseList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__EnterpriseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EnterpriseList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EnterpriseList * SOAP_FMAC4 soap_get_ns6__EnterpriseList(struct soap *soap, ns6__EnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__EnterpriseList * FASTCALL soap_instantiate_ns6__EnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__EnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__EnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseList);
		ASSIGN_PTR(size, sizeof(ns6__EnterpriseList));
		((ns6__EnterpriseList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseList));
		for(int i = 0; i < n; i++)
			((ns6__EnterpriseList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__EnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__EnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__EnterpriseList %p -> %p\n", q, p));
	*(ns6__EnterpriseList*)p = *(ns6__EnterpriseList*)q;
}

void ns6__EnterpriseNumberList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EnterpriseNumberList::__sizeenterpriseNumber = 0;
	this->ns6__EnterpriseNumberList::enterpriseNumber = NULL;
	/* transient soap skipped */
}

void ns6__EnterpriseNumberList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__EnterpriseNumberList::enterpriseNumber) {
		for(int i = 0; i < this->ns6__EnterpriseNumberList::__sizeenterpriseNumber; i++) {
			soap_serialize_ns3__String255(soap, this->ns6__EnterpriseNumberList::enterpriseNumber + i);
		}
	}
	/* transient soap skipped */
}

int ns6__EnterpriseNumberList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EnterpriseNumberList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseNumberList(struct soap *soap, const char *tag, int id, const ns6__EnterpriseNumberList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseNumberList), type))
		return soap->error;
	if(a->ns6__EnterpriseNumberList::enterpriseNumber) {
		int i;
		for(i = 0; i < a->ns6__EnterpriseNumberList::__sizeenterpriseNumber; i++)
			if(soap_out_ns3__String255(soap, "ns6:enterpriseNumber", -1, a->ns6__EnterpriseNumberList::enterpriseNumber + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__EnterpriseNumberList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__EnterpriseNumberList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EnterpriseNumberList * FASTCALL soap_in_ns6__EnterpriseNumberList(struct soap *soap, const char *tag, ns6__EnterpriseNumberList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__EnterpriseNumberList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseNumberList, sizeof(ns6__EnterpriseNumberList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__EnterpriseNumberList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__EnterpriseNumberList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_enterpriseNumber1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:enterpriseNumber", 1, NULL)) {
				if(a->ns6__EnterpriseNumberList::enterpriseNumber == NULL) {
					if(soap_blist_enterpriseNumber1 == NULL)
						soap_blist_enterpriseNumber1 = soap_new_block(soap);
					a->ns6__EnterpriseNumberList::enterpriseNumber = (char **)soap_push_block(soap, soap_blist_enterpriseNumber1, sizeof(char *));
					if(a->ns6__EnterpriseNumberList::enterpriseNumber == NULL)
						return NULL;
					*a->ns6__EnterpriseNumberList::enterpriseNumber = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns3__String255(soap, "ns6:enterpriseNumber", a->ns6__EnterpriseNumberList::enterpriseNumber, "ns3:String255"))
				{	a->ns6__EnterpriseNumberList::__sizeenterpriseNumber++;
					a->ns6__EnterpriseNumberList::enterpriseNumber = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__EnterpriseNumberList::enterpriseNumber)
			soap_pop_block(soap, soap_blist_enterpriseNumber1);
		if(a->ns6__EnterpriseNumberList::__sizeenterpriseNumber)
			a->ns6__EnterpriseNumberList::enterpriseNumber = (char **)soap_save_block(soap, soap_blist_enterpriseNumber1, NULL, 1);
		else
		{	a->ns6__EnterpriseNumberList::enterpriseNumber = NULL;
			if(soap_blist_enterpriseNumber1)
				soap_end_block(soap, soap_blist_enterpriseNumber1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseNumberList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseNumberList, 0, sizeof(ns6__EnterpriseNumberList), 0, soap_copy_ns6__EnterpriseNumberList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__EnterpriseNumberList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseNumberList);
	return this->soap_out(soap, tag?tag:"ns6:EnterpriseNumberList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__EnterpriseNumberList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EnterpriseNumberList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EnterpriseNumberList * SOAP_FMAC4 soap_get_ns6__EnterpriseNumberList(struct soap *soap, ns6__EnterpriseNumberList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseNumberList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__EnterpriseNumberList * FASTCALL soap_instantiate_ns6__EnterpriseNumberList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__EnterpriseNumberList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__EnterpriseNumberList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseNumberList);
		ASSIGN_PTR(size, sizeof(ns6__EnterpriseNumberList));
		((ns6__EnterpriseNumberList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseNumberList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseNumberList));
		for(int i = 0; i < n; i++)
			((ns6__EnterpriseNumberList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__EnterpriseNumberList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__EnterpriseNumberList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__EnterpriseNumberList %p -> %p\n", q, p));
	*(ns6__EnterpriseNumberList*)p = *(ns6__EnterpriseNumberList*)q;
}

void ns6__ProducerList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__ProducerList::__sizeproducer = 0;
	this->ns6__ProducerList::producer = NULL;
	/* transient soap skipped */
}

void ns6__ProducerList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__ProducerList::producer) {
		for(int i = 0; i < this->ns6__ProducerList::__sizeproducer; i++) {
			soap_serialize_PointerTons6__Producer(soap, this->ns6__ProducerList::producer + i);
		}
	}
	/* transient soap skipped */
}

int ns6__ProducerList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ProducerList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ProducerList(struct soap *soap, const char *tag, int id, const ns6__ProducerList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProducerList), type))
		return soap->error;
	if(a->ns6__ProducerList::producer) {
		int i;
		for(i = 0; i < a->ns6__ProducerList::__sizeproducer; i++)
			if(soap_out_PointerTons6__Producer(soap, "ns6:producer", -1, a->ns6__ProducerList::producer + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ProducerList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__ProducerList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ProducerList * FASTCALL soap_in_ns6__ProducerList(struct soap *soap, const char *tag, ns6__ProducerList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ProducerList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProducerList, sizeof(ns6__ProducerList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__ProducerList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ProducerList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_producer1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:producer", 1, NULL)) {
				if(a->ns6__ProducerList::producer == NULL) {
					if(soap_blist_producer1 == NULL)
						soap_blist_producer1 = soap_new_block(soap);
					a->ns6__ProducerList::producer = (ns6__Producer **)soap_push_block(soap, soap_blist_producer1, sizeof(ns6__Producer *));
					if(a->ns6__ProducerList::producer == NULL)
						return NULL;
					*a->ns6__ProducerList::producer = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Producer(soap, "ns6:producer", a->ns6__ProducerList::producer, "ns6:Producer"))
				{	a->ns6__ProducerList::__sizeproducer++;
					a->ns6__ProducerList::producer = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__ProducerList::producer)
			soap_pop_block(soap, soap_blist_producer1);
		if(a->ns6__ProducerList::__sizeproducer)
			a->ns6__ProducerList::producer = (ns6__Producer **)soap_save_block(soap, soap_blist_producer1, NULL, 1);
		else
		{	a->ns6__ProducerList::producer = NULL;
			if(soap_blist_producer1)
				soap_end_block(soap, soap_blist_producer1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__ProducerList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProducerList, 0, sizeof(ns6__ProducerList), 0, soap_copy_ns6__ProducerList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__ProducerList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ProducerList);
	return this->soap_out(soap, tag?tag:"ns6:ProducerList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__ProducerList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ProducerList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ProducerList * SOAP_FMAC4 soap_get_ns6__ProducerList(struct soap *soap, ns6__ProducerList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ProducerList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ProducerList * FASTCALL soap_instantiate_ns6__ProducerList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ProducerList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ProducerList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__ProducerList);
		ASSIGN_PTR(size, sizeof(ns6__ProducerList));
		((ns6__ProducerList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__ProducerList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__ProducerList));
		for(int i = 0; i < n; i++)
			((ns6__ProducerList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ProducerList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ProducerList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ProducerList %p -> %p\n", q, p));
	*(ns6__ProducerList*)p = *(ns6__ProducerList*)q;
}

void ns6__Producer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Producer::enterprise = NULL;
	this->ns6__Producer::role = NULL;
	/* transient soap skipped */
}

void ns6__Producer::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns6__Producer::enterprise);
	soap_serialize_PointerTons6__EnterpriseRole(soap, &this->ns6__Producer::role);
	/* transient soap skipped */
}

int ns6__Producer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Producer(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Producer(struct soap *soap, const char *tag, int id, const ns6__Producer *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Producer), type))
		return soap->error;
	if(a->ns6__Producer::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns6:enterprise", -1, &a->ns6__Producer::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterprise"))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseRole(soap, "ns6:role", -1, &(a->ns6__Producer::role), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Producer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Producer(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Producer * FASTCALL soap_in_ns6__Producer(struct soap *soap, const char *tag, ns6__Producer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Producer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Producer, sizeof(ns6__Producer), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Producer) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Producer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_role1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns6:enterprise", &(a->ns6__Producer::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseRole(soap, "ns6:role", &(a->ns6__Producer::role), "ns6:EnterpriseRole"))
				{	soap_flag_role1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Producer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Producer, 0, sizeof(ns6__Producer), 0, soap_copy_ns6__Producer);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__Producer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Producer);
	return this->soap_out(soap, tag?tag:"ns6:Producer", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Producer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Producer(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Producer * SOAP_FMAC4 soap_get_ns6__Producer(struct soap *soap, ns6__Producer *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Producer * FASTCALL soap_instantiate_ns6__Producer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Producer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Producer, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Producer);
		ASSIGN_PTR(size, sizeof(ns6__Producer));
		((ns6__Producer*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Producer[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Producer));
		for(int i = 0; i < n; i++)
			((ns6__Producer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Producer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Producer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Producer %p -> %p\n", q, p));
	*(ns6__Producer*)p = *(ns6__Producer*)q;
}

void ns6__EnterpriseActivity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EnterpriseActivity::name = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__EnterpriseActivity::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__NText(soap, &this->ns6__EnterpriseActivity::name);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__EnterpriseActivity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EnterpriseActivity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseActivity(struct soap *soap, const char *tag, int id, const ns6__EnterpriseActivity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseActivity), "ns6:EnterpriseActivity"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTons3__NText(soap, "ns6:name", -1, &(a->ns6__EnterpriseActivity::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__EnterpriseActivity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__EnterpriseActivity(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EnterpriseActivity * FASTCALL soap_in_ns6__EnterpriseActivity(struct soap *soap, const char *tag, ns6__EnterpriseActivity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__EnterpriseActivity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseActivity, sizeof(ns6__EnterpriseActivity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__EnterpriseActivity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__EnterpriseActivity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:name", &(a->ns6__EnterpriseActivity::name), "ns3:NText"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseActivity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseActivity, 0, sizeof(ns6__EnterpriseActivity), 0, soap_copy_ns6__EnterpriseActivity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__EnterpriseActivity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseActivity);
	return this->soap_out(soap, tag?tag:"ns6:EnterpriseActivity", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__EnterpriseActivity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EnterpriseActivity(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EnterpriseActivity * SOAP_FMAC4 soap_get_ns6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__EnterpriseActivity * FASTCALL soap_instantiate_ns6__EnterpriseActivity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__EnterpriseActivity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__EnterpriseActivity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivity);
		ASSIGN_PTR(size, sizeof(ns6__EnterpriseActivity));
		((ns6__EnterpriseActivity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseActivity));
		for(int i = 0; i < n; i++)
			((ns6__EnterpriseActivity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__EnterpriseActivity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__EnterpriseActivity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__EnterpriseActivity %p -> %p\n", q, p));
	*(ns6__EnterpriseActivity*)p = *(ns6__EnterpriseActivity*)q;
}

void ns6__EnterpriseActivityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__EnterpriseActivityList::__sizeactivity = 0;
	this->ns6__EnterpriseActivityList::activity = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__EnterpriseActivityList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__EnterpriseActivityList::activity) {
		for(int i = 0; i < this->ns6__EnterpriseActivityList::__sizeactivity; i++) {
			soap_serialize_PointerTons6__EnterpriseActivity(soap, this->ns6__EnterpriseActivityList::activity + i);
		}
	}
	/* transient soap skipped */
}

int ns6__EnterpriseActivityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__EnterpriseActivityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseActivityList(struct soap *soap, const char *tag, int id, const ns6__EnterpriseActivityList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EnterpriseActivityList), "ns6:EnterpriseActivityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__EnterpriseActivityList::activity) {
		int i;
		for(i = 0; i < a->ns6__EnterpriseActivityList::__sizeactivity; i++)
			if(soap_out_PointerTons6__EnterpriseActivity(soap, "ns6:activity", -1, a->ns6__EnterpriseActivityList::activity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__EnterpriseActivityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__EnterpriseActivityList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__EnterpriseActivityList * FASTCALL soap_in_ns6__EnterpriseActivityList(struct soap *soap, const char *tag, ns6__EnterpriseActivityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__EnterpriseActivityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EnterpriseActivityList, sizeof(ns6__EnterpriseActivityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__EnterpriseActivityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__EnterpriseActivityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_activity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:activity", 1, NULL)) {
				if(a->ns6__EnterpriseActivityList::activity == NULL) {
					if(soap_blist_activity1 == NULL)
						soap_blist_activity1 = soap_new_block(soap);
					a->ns6__EnterpriseActivityList::activity = (ns6__EnterpriseActivity **)soap_push_block(soap, soap_blist_activity1, sizeof(ns6__EnterpriseActivity *));
					if(a->ns6__EnterpriseActivityList::activity == NULL)
						return NULL;
					*a->ns6__EnterpriseActivityList::activity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__EnterpriseActivity(soap, "ns6:activity", a->ns6__EnterpriseActivityList::activity, "ns6:EnterpriseActivity"))
				{	a->ns6__EnterpriseActivityList::__sizeactivity++;
					a->ns6__EnterpriseActivityList::activity = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__EnterpriseActivityList::activity)
			soap_pop_block(soap, soap_blist_activity1);
		if(a->ns6__EnterpriseActivityList::__sizeactivity)
			a->ns6__EnterpriseActivityList::activity = (ns6__EnterpriseActivity **)soap_save_block(soap, soap_blist_activity1, NULL, 1);
		else
		{	a->ns6__EnterpriseActivityList::activity = NULL;
			if(soap_blist_activity1)
				soap_end_block(soap, soap_blist_activity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseActivityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EnterpriseActivityList, 0, sizeof(ns6__EnterpriseActivityList), 0, soap_copy_ns6__EnterpriseActivityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__EnterpriseActivityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseActivityList);
	return this->soap_out(soap, tag?tag:"ns6:EnterpriseActivityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__EnterpriseActivityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__EnterpriseActivityList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__EnterpriseActivityList * SOAP_FMAC4 soap_get_ns6__EnterpriseActivityList(struct soap *soap, ns6__EnterpriseActivityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseActivityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__EnterpriseActivityList * FASTCALL soap_instantiate_ns6__EnterpriseActivityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__EnterpriseActivityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__EnterpriseActivityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivityList);
		ASSIGN_PTR(size, sizeof(ns6__EnterpriseActivityList));
		((ns6__EnterpriseActivityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseActivityList));
		for(int i = 0; i < n; i++)
			((ns6__EnterpriseActivityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__EnterpriseActivityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__EnterpriseActivityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__EnterpriseActivityList %p -> %p\n", q, p));
	*(ns6__EnterpriseActivityList*)p = *(ns6__EnterpriseActivityList*)q;
}

void ns6__Enterprise::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Enterprise::name);
	soap_default_ns3__String255(soap, &this->ns6__Enterprise::englishName);
	this->ns6__Enterprise::type = NULL;
	this->ns6__Enterprise::numberList = NULL;
	this->ns6__Enterprise::address = NULL;
	this->ns6__Enterprise::activityList = NULL;
	this->ns6__Enterprise::owner = NULL;
	this->ns6__Enterprise::__sizeofficialRegistration = 0;
	this->ns6__Enterprise::officialRegistration = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Enterprise::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Enterprise::name);
	soap_serialize_ns3__String255(soap, &this->ns6__Enterprise::englishName);
	soap_serialize_PointerTons6__EnterpriseType(soap, &this->ns6__Enterprise::type);
	soap_serialize_PointerTons6__EnterpriseNumberList(soap, &this->ns6__Enterprise::numberList);
	soap_serialize_PointerTons6__Address(soap, &this->ns6__Enterprise::address);
	soap_serialize_PointerTons6__EnterpriseActivityList(soap, &this->ns6__Enterprise::activityList);
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns6__Enterprise::owner);
	if(this->ns6__Enterprise::officialRegistration) {
		for(int i = 0; i < this->ns6__Enterprise::__sizeofficialRegistration; i++) {
			soap_serialize_PointerTons6__EnterpriseOfficialRegistration(soap, this->ns6__Enterprise::officialRegistration + i);
		}
	}
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Enterprise::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Enterprise(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Enterprise(struct soap *soap, const char *tag, int id, const ns6__Enterprise *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Enterprise), "ns6:Enterprise"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Enterprise::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__Enterprise::englishName), ""))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseType(soap, "ns6:type", -1, &(a->ns6__Enterprise::type), ""))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseNumberList(soap, "ns6:numberList", -1, &(a->ns6__Enterprise::numberList), ""))
		return soap->error;
	if(soap_out_PointerTons6__Address(soap, "ns6:address", -1, &(a->ns6__Enterprise::address), ""))
		return soap->error;
	if(soap_out_PointerTons6__EnterpriseActivityList(soap, "ns6:activityList", -1, &(a->ns6__Enterprise::activityList), ""))
		return soap->error;
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns6:owner", -1, &(a->ns6__Enterprise::owner), ""))
		return soap->error;
	if(a->ns6__Enterprise::officialRegistration) {
		int i;
		for(i = 0; i < a->ns6__Enterprise::__sizeofficialRegistration; i++)
			if(soap_out_PointerTons6__EnterpriseOfficialRegistration(soap, "ns6:officialRegistration", -1, a->ns6__Enterprise::officialRegistration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__Enterprise::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Enterprise(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Enterprise * FASTCALL soap_in_ns6__Enterprise(struct soap *soap, const char *tag, ns6__Enterprise *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Enterprise *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Enterprise, sizeof(ns6__Enterprise), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Enterprise) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Enterprise *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_numberList1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_activityList1 = 1;
	size_t soap_flag_owner1 = 1;
	struct soap_blist *soap_blist_officialRegistration1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Enterprise::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__Enterprise::englishName), "ns3:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseType(soap, "ns6:type", &(a->ns6__Enterprise::type), "ns6:EnterpriseType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_numberList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseNumberList(soap, "ns6:numberList", &(a->ns6__Enterprise::numberList), "ns6:EnterpriseNumberList"))
				{	soap_flag_numberList1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Address(soap, "ns6:address", &(a->ns6__Enterprise::address), "ns6:Address"))
				{	soap_flag_address1--;
					continue;
				}
			if(soap_flag_activityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__EnterpriseActivityList(soap, "ns6:activityList", &(a->ns6__Enterprise::activityList), "ns6:EnterpriseActivityList"))
				{	soap_flag_activityList1--;
					continue;
				}
			if(soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns6:owner", &(a->ns6__Enterprise::owner), "ns6:BusinessEntity"))
				{	soap_flag_owner1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:officialRegistration", 1, NULL)) {
				if(a->ns6__Enterprise::officialRegistration == NULL) {
					if(soap_blist_officialRegistration1 == NULL)
						soap_blist_officialRegistration1 = soap_new_block(soap);
					a->ns6__Enterprise::officialRegistration = (ns6__EnterpriseOfficialRegistration **)soap_push_block(soap, soap_blist_officialRegistration1, sizeof(ns6__EnterpriseOfficialRegistration *));
					if(a->ns6__Enterprise::officialRegistration == NULL)
						return NULL;
					*a->ns6__Enterprise::officialRegistration = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__EnterpriseOfficialRegistration(soap, "ns6:officialRegistration", a->ns6__Enterprise::officialRegistration, "ns6:EnterpriseOfficialRegistration"))
				{	a->ns6__Enterprise::__sizeofficialRegistration++;
					a->ns6__Enterprise::officialRegistration = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__Enterprise::officialRegistration)
			soap_pop_block(soap, soap_blist_officialRegistration1);
		if(a->ns6__Enterprise::__sizeofficialRegistration)
			a->ns6__Enterprise::officialRegistration = (ns6__EnterpriseOfficialRegistration **)soap_save_block(soap, soap_blist_officialRegistration1, NULL, 1);
		else
		{	a->ns6__Enterprise::officialRegistration = NULL;
			if(soap_blist_officialRegistration1)
				soap_end_block(soap, soap_blist_officialRegistration1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Enterprise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Enterprise, 0, sizeof(ns6__Enterprise), 0, soap_copy_ns6__Enterprise);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Enterprise::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Enterprise);
	return this->soap_out(soap, tag?tag:"ns6:Enterprise", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Enterprise::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Enterprise(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Enterprise * SOAP_FMAC4 soap_get_ns6__Enterprise(struct soap *soap, ns6__Enterprise *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Enterprise * FASTCALL soap_instantiate_ns6__Enterprise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Enterprise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Enterprise, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Enterprise);
		ASSIGN_PTR(size, sizeof(ns6__Enterprise));
		((ns6__Enterprise*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Enterprise[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Enterprise));
		for(int i = 0; i < n; i++)
			((ns6__Enterprise*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Enterprise*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Enterprise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Enterprise %p -> %p\n", q, p));
	*(ns6__Enterprise*)p = *(ns6__Enterprise*)q;
}

void ns6__StreetList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__StreetList::__sizestreet = 0;
	this->ns6__StreetList::street = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__StreetList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__StreetList::street) {
		for(int i = 0; i < this->ns6__StreetList::__sizestreet; i++) {
			soap_serialize_PointerTons6__Street(soap, this->ns6__StreetList::street + i);
		}
	}
	/* transient soap skipped */
}

int ns6__StreetList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__StreetList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__StreetList(struct soap *soap, const char *tag, int id, const ns6__StreetList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__StreetList), "ns6:StreetList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__StreetList::street) {
		int i;
		for(i = 0; i < a->ns6__StreetList::__sizestreet; i++)
			if(soap_out_PointerTons6__Street(soap, "ns6:street", -1, a->ns6__StreetList::street + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__StreetList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__StreetList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__StreetList * FASTCALL soap_in_ns6__StreetList(struct soap *soap, const char *tag, ns6__StreetList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__StreetList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StreetList, sizeof(ns6__StreetList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__StreetList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__StreetList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_street1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:street", 1, NULL)) {
				if(a->ns6__StreetList::street == NULL) {
					if(soap_blist_street1 == NULL)
						soap_blist_street1 = soap_new_block(soap);
					a->ns6__StreetList::street = (ns6__Street **)soap_push_block(soap, soap_blist_street1, sizeof(ns6__Street *));
					if(a->ns6__StreetList::street == NULL)
						return NULL;
					*a->ns6__StreetList::street = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Street(soap, "ns6:street", a->ns6__StreetList::street, "ns6:Street"))
				{	a->ns6__StreetList::__sizestreet++;
					a->ns6__StreetList::street = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__StreetList::street)
			soap_pop_block(soap, soap_blist_street1);
		if(a->ns6__StreetList::__sizestreet)
			a->ns6__StreetList::street = (ns6__Street **)soap_save_block(soap, soap_blist_street1, NULL, 1);
		else
		{	a->ns6__StreetList::street = NULL;
			if(soap_blist_street1)
				soap_end_block(soap, soap_blist_street1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__StreetList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__StreetList, 0, sizeof(ns6__StreetList), 0, soap_copy_ns6__StreetList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__StreetList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__StreetList);
	return this->soap_out(soap, tag?tag:"ns6:StreetList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__StreetList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__StreetList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__StreetList * SOAP_FMAC4 soap_get_ns6__StreetList(struct soap *soap, ns6__StreetList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__StreetList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__StreetList * FASTCALL soap_instantiate_ns6__StreetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__StreetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__StreetList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__StreetList);
		ASSIGN_PTR(size, sizeof(ns6__StreetList));
		((ns6__StreetList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__StreetList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__StreetList));
		for(int i = 0; i < n; i++)
			((ns6__StreetList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__StreetList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__StreetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__StreetList %p -> %p\n", q, p));
	*(ns6__StreetList*)p = *(ns6__StreetList*)q;
}

void ns6__LocalityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__LocalityList::__sizelocality = 0;
	this->ns6__LocalityList::locality = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__LocalityList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__LocalityList::locality) {
		for(int i = 0; i < this->ns6__LocalityList::__sizelocality; i++) {
			soap_serialize_PointerTons6__Locality(soap, this->ns6__LocalityList::locality + i);
		}
	}
	/* transient soap skipped */
}

int ns6__LocalityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__LocalityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__LocalityList(struct soap *soap, const char *tag, int id, const ns6__LocalityList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__LocalityList), "ns6:LocalityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__LocalityList::locality) {
		int i;
		for(i = 0; i < a->ns6__LocalityList::__sizelocality; i++)
			if(soap_out_PointerTons6__Locality(soap, "ns6:locality", -1, a->ns6__LocalityList::locality + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__LocalityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__LocalityList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__LocalityList * FASTCALL soap_in_ns6__LocalityList(struct soap *soap, const char *tag, ns6__LocalityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__LocalityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__LocalityList, sizeof(ns6__LocalityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__LocalityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__LocalityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_locality1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:locality", 1, NULL)) {
				if(a->ns6__LocalityList::locality == NULL) {
					if(soap_blist_locality1 == NULL)
						soap_blist_locality1 = soap_new_block(soap);
					a->ns6__LocalityList::locality = (ns6__Locality **)soap_push_block(soap, soap_blist_locality1, sizeof(ns6__Locality *));
					if(a->ns6__LocalityList::locality == NULL)
						return NULL;
					*a->ns6__LocalityList::locality = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Locality(soap, "ns6:locality", a->ns6__LocalityList::locality, "ns6:Locality"))
				{	a->ns6__LocalityList::__sizelocality++;
					a->ns6__LocalityList::locality = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__LocalityList::locality)
			soap_pop_block(soap, soap_blist_locality1);
		if(a->ns6__LocalityList::__sizelocality)
			a->ns6__LocalityList::locality = (ns6__Locality **)soap_save_block(soap, soap_blist_locality1, NULL, 1);
		else
		{	a->ns6__LocalityList::locality = NULL;
			if(soap_blist_locality1)
				soap_end_block(soap, soap_blist_locality1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__LocalityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__LocalityList, 0, sizeof(ns6__LocalityList), 0, soap_copy_ns6__LocalityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__LocalityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__LocalityList);
	return this->soap_out(soap, tag?tag:"ns6:LocalityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__LocalityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__LocalityList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__LocalityList * SOAP_FMAC4 soap_get_ns6__LocalityList(struct soap *soap, ns6__LocalityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__LocalityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__LocalityList * FASTCALL soap_instantiate_ns6__LocalityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__LocalityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__LocalityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__LocalityList);
		ASSIGN_PTR(size, sizeof(ns6__LocalityList));
		((ns6__LocalityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__LocalityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__LocalityList));
		for(int i = 0; i < n; i++)
			((ns6__LocalityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__LocalityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__LocalityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__LocalityList %p -> %p\n", q, p));
	*(ns6__LocalityList*)p = *(ns6__LocalityList*)q;
}

void ns6__DistrictList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__DistrictList::__sizedistrict = 0;
	this->ns6__DistrictList::district = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__DistrictList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__DistrictList::district) {
		for(int i = 0; i < this->ns6__DistrictList::__sizedistrict; i++) {
			soap_serialize_PointerTons6__District(soap, this->ns6__DistrictList::district + i);
		}
	}
	/* transient soap skipped */
}

int ns6__DistrictList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DistrictList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__DistrictList(struct soap *soap, const char *tag, int id, const ns6__DistrictList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DistrictList), "ns6:DistrictList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__DistrictList::district) {
		int i;
		for(i = 0; i < a->ns6__DistrictList::__sizedistrict; i++)
			if(soap_out_PointerTons6__District(soap, "ns6:district", -1, a->ns6__DistrictList::district + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__DistrictList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__DistrictList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DistrictList * FASTCALL soap_in_ns6__DistrictList(struct soap *soap, const char *tag, ns6__DistrictList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DistrictList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DistrictList, sizeof(ns6__DistrictList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__DistrictList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DistrictList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_district1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:district", 1, NULL)) {
				if(a->ns6__DistrictList::district == NULL) {
					if(soap_blist_district1 == NULL)
						soap_blist_district1 = soap_new_block(soap);
					a->ns6__DistrictList::district = (ns6__District **)soap_push_block(soap, soap_blist_district1, sizeof(ns6__District *));
					if(a->ns6__DistrictList::district == NULL)
						return NULL;
					*a->ns6__DistrictList::district = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__District(soap, "ns6:district", a->ns6__DistrictList::district, "ns6:District"))
				{	a->ns6__DistrictList::__sizedistrict++;
					a->ns6__DistrictList::district = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__DistrictList::district)
			soap_pop_block(soap, soap_blist_district1);
		if(a->ns6__DistrictList::__sizedistrict)
			a->ns6__DistrictList::district = (ns6__District **)soap_save_block(soap, soap_blist_district1, NULL, 1);
		else
		{	a->ns6__DistrictList::district = NULL;
			if(soap_blist_district1)
				soap_end_block(soap, soap_blist_district1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__DistrictList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DistrictList, 0, sizeof(ns6__DistrictList), 0, soap_copy_ns6__DistrictList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__DistrictList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DistrictList);
	return this->soap_out(soap, tag?tag:"ns6:DistrictList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__DistrictList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DistrictList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DistrictList * SOAP_FMAC4 soap_get_ns6__DistrictList(struct soap *soap, ns6__DistrictList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__DistrictList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__DistrictList * FASTCALL soap_instantiate_ns6__DistrictList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DistrictList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DistrictList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__DistrictList);
		ASSIGN_PTR(size, sizeof(ns6__DistrictList));
		((ns6__DistrictList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__DistrictList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__DistrictList));
		for(int i = 0; i < n; i++)
			((ns6__DistrictList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DistrictList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DistrictList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DistrictList %p -> %p\n", q, p));
	*(ns6__DistrictList*)p = *(ns6__DistrictList*)q;
}

void ns6__RegionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__RegionList::__sizeregion = 0;
	this->ns6__RegionList::region = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__RegionList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__RegionList::region) {
		for(int i = 0; i < this->ns6__RegionList::__sizeregion; i++) {
			soap_serialize_PointerTons6__Region(soap, this->ns6__RegionList::region + i);
		}
	}
	/* transient soap skipped */
}

int ns6__RegionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RegionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__RegionList(struct soap *soap, const char *tag, int id, const ns6__RegionList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RegionList), "ns6:RegionList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__RegionList::region) {
		int i;
		for(i = 0; i < a->ns6__RegionList::__sizeregion; i++)
			if(soap_out_PointerTons6__Region(soap, "ns6:region", -1, a->ns6__RegionList::region + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__RegionList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__RegionList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RegionList * FASTCALL soap_in_ns6__RegionList(struct soap *soap, const char *tag, ns6__RegionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RegionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RegionList, sizeof(ns6__RegionList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__RegionList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RegionList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_region1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:region", 1, NULL)) {
				if(a->ns6__RegionList::region == NULL) {
					if(soap_blist_region1 == NULL)
						soap_blist_region1 = soap_new_block(soap);
					a->ns6__RegionList::region = (ns6__Region **)soap_push_block(soap, soap_blist_region1, sizeof(ns6__Region *));
					if(a->ns6__RegionList::region == NULL)
						return NULL;
					*a->ns6__RegionList::region = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Region(soap, "ns6:region", a->ns6__RegionList::region, "ns6:Region"))
				{	a->ns6__RegionList::__sizeregion++;
					a->ns6__RegionList::region = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__RegionList::region)
			soap_pop_block(soap, soap_blist_region1);
		if(a->ns6__RegionList::__sizeregion)
			a->ns6__RegionList::region = (ns6__Region **)soap_save_block(soap, soap_blist_region1, NULL, 1);
		else
		{	a->ns6__RegionList::region = NULL;
			if(soap_blist_region1)
				soap_end_block(soap, soap_blist_region1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__RegionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RegionList, 0, sizeof(ns6__RegionList), 0, soap_copy_ns6__RegionList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__RegionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RegionList);
	return this->soap_out(soap, tag?tag:"ns6:RegionList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__RegionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RegionList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RegionList * SOAP_FMAC4 soap_get_ns6__RegionList(struct soap *soap, ns6__RegionList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__RegionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__RegionList * FASTCALL soap_instantiate_ns6__RegionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RegionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RegionList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionList);
		ASSIGN_PTR(size, sizeof(ns6__RegionList));
		((ns6__RegionList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__RegionList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__RegionList));
		for(int i = 0; i < n; i++)
			((ns6__RegionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RegionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RegionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RegionList %p -> %p\n", q, p));
	*(ns6__RegionList*)p = *(ns6__RegionList*)q;
}

void ns6__CountryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__CountryList::__sizecountry = 0;
	this->ns6__CountryList::country = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__CountryList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__CountryList::country) {
		for(int i = 0; i < this->ns6__CountryList::__sizecountry; i++) {
			soap_serialize_PointerTons6__Country(soap, this->ns6__CountryList::country + i);
		}
	}
	/* transient soap skipped */
}

int ns6__CountryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__CountryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__CountryList(struct soap *soap, const char *tag, int id, const ns6__CountryList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__CountryList), "ns6:CountryList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__CountryList::country) {
		int i;
		for(i = 0; i < a->ns6__CountryList::__sizecountry; i++)
			if(soap_out_PointerTons6__Country(soap, "ns6:country", -1, a->ns6__CountryList::country + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__CountryList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__CountryList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__CountryList * FASTCALL soap_in_ns6__CountryList(struct soap *soap, const char *tag, ns6__CountryList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__CountryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__CountryList, sizeof(ns6__CountryList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__CountryList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__CountryList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_country1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:country", 1, NULL)) {
				if(a->ns6__CountryList::country == NULL) {
					if(soap_blist_country1 == NULL)
						soap_blist_country1 = soap_new_block(soap);
					a->ns6__CountryList::country = (ns6__Country **)soap_push_block(soap, soap_blist_country1, sizeof(ns6__Country *));
					if(a->ns6__CountryList::country == NULL)
						return NULL;
					*a->ns6__CountryList::country = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Country(soap, "ns6:country", a->ns6__CountryList::country, "ns6:Country"))
				{	a->ns6__CountryList::__sizecountry++;
					a->ns6__CountryList::country = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__CountryList::country)
			soap_pop_block(soap, soap_blist_country1);
		if(a->ns6__CountryList::__sizecountry)
			a->ns6__CountryList::country = (ns6__Country **)soap_save_block(soap, soap_blist_country1, NULL, 1);
		else
		{	a->ns6__CountryList::country = NULL;
			if(soap_blist_country1)
				soap_end_block(soap, soap_blist_country1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__CountryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__CountryList, 0, sizeof(ns6__CountryList), 0, soap_copy_ns6__CountryList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__CountryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__CountryList);
	return this->soap_out(soap, tag?tag:"ns6:CountryList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__CountryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__CountryList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__CountryList * SOAP_FMAC4 soap_get_ns6__CountryList(struct soap *soap, ns6__CountryList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__CountryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__CountryList * FASTCALL soap_instantiate_ns6__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__CountryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__CountryList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__CountryList);
		ASSIGN_PTR(size, sizeof(ns6__CountryList));
		((ns6__CountryList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__CountryList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__CountryList));
		for(int i = 0; i < n; i++)
			((ns6__CountryList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__CountryList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__CountryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__CountryList %p -> %p\n", q, p));
	*(ns6__CountryList*)p = *(ns6__CountryList*)q;
}

void ns6__Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Address::country = NULL;
	this->ns6__Address::federalDistrict = NULL;
	this->ns6__Address::region = NULL;
	this->ns6__Address::district = NULL;
	this->ns6__Address::locality = NULL;
	this->ns6__Address::subLocality = NULL;
	this->ns6__Address::street = NULL;
	soap_default_ns3__String255(soap, &this->ns6__Address::house);
	soap_default_ns3__String255(soap, &this->ns6__Address::building);
	soap_default_ns3__String255(soap, &this->ns6__Address::room);
	soap_default_ns3__String255(soap, &this->ns6__Address::postIndex);
	soap_default_ns3__String255(soap, &this->ns6__Address::postBox);
	this->ns6__Address::additionalInfo = NULL;
	this->ns6__Address::addressView = NULL;
	this->ns6__Address::enAddressView = NULL;
	/* transient soap skipped */
}

void ns6__Address::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Country(soap, &this->ns6__Address::country);
	soap_serialize_PointerTons6__FederalDistrict(soap, &this->ns6__Address::federalDistrict);
	soap_serialize_PointerTons6__Region(soap, &this->ns6__Address::region);
	soap_serialize_PointerTons6__District(soap, &this->ns6__Address::district);
	soap_serialize_PointerTons6__Locality(soap, &this->ns6__Address::locality);
	soap_serialize_PointerTons6__Locality(soap, &this->ns6__Address::subLocality);
	soap_serialize_PointerTons6__Street(soap, &this->ns6__Address::street);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::house);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::building);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::room);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::postIndex);
	soap_serialize_ns3__String255(soap, &this->ns6__Address::postBox);
	soap_serialize_PointerTons3__NText(soap, &this->ns6__Address::additionalInfo);
	soap_serialize_PointerTons3__NText(soap, &this->ns6__Address::addressView);
	soap_serialize_PointerTons3__NText(soap, &this->ns6__Address::enAddressView);
	/* transient soap skipped */
}

int ns6__Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Address(struct soap *soap, const char *tag, int id, const ns6__Address *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Address), type))
		return soap->error;
	if(soap_out_PointerTons6__Country(soap, "ns6:country", -1, &(a->ns6__Address::country), ""))
		return soap->error;
	if(soap_out_PointerTons6__FederalDistrict(soap, "ns6:federalDistrict", -1, &(a->ns6__Address::federalDistrict), ""))
		return soap->error;
	if(soap_out_PointerTons6__Region(soap, "ns6:region", -1, &(a->ns6__Address::region), ""))
		return soap->error;
	if(soap_out_PointerTons6__District(soap, "ns6:district", -1, &(a->ns6__Address::district), ""))
		return soap->error;
	if(soap_out_PointerTons6__Locality(soap, "ns6:locality", -1, &(a->ns6__Address::locality), ""))
		return soap->error;
	if(soap_out_PointerTons6__Locality(soap, "ns6:subLocality", -1, &(a->ns6__Address::subLocality), ""))
		return soap->error;
	if(soap_out_PointerTons6__Street(soap, "ns6:street", -1, &(a->ns6__Address::street), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:house", -1, &(a->ns6__Address::house), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:building", -1, &(a->ns6__Address::building), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:room", -1, &(a->ns6__Address::room), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:postIndex", -1, &(a->ns6__Address::postIndex), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:postBox", -1, &(a->ns6__Address::postBox), ""))
		return soap->error;
	if(soap_out_PointerTons3__NText(soap, "ns6:additionalInfo", -1, &(a->ns6__Address::additionalInfo), ""))
		return soap->error;
	if(soap_out_PointerTons3__NText(soap, "ns6:addressView", -1, &(a->ns6__Address::addressView), ""))
		return soap->error;
	if(soap_out_PointerTons3__NText(soap, "ns6:enAddressView", -1, &(a->ns6__Address::enAddressView), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Address(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Address * FASTCALL soap_in_ns6__Address(struct soap *soap, const char *tag, ns6__Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Address, sizeof(ns6__Address), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Address) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country1 = 1;
	size_t soap_flag_federalDistrict1 = 1;
	size_t soap_flag_region1 = 1;
	size_t soap_flag_district1 = 1;
	size_t soap_flag_locality1 = 1;
	size_t soap_flag_subLocality1 = 1;
	size_t soap_flag_street1 = 1;
	size_t soap_flag_house1 = 1;
	size_t soap_flag_building1 = 1;
	size_t soap_flag_room1 = 1;
	size_t soap_flag_postIndex1 = 1;
	size_t soap_flag_postBox1 = 1;
	size_t soap_flag_additionalInfo1 = 1;
	size_t soap_flag_addressView1 = 1;
	size_t soap_flag_enAddressView1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Country(soap, "ns6:country", &(a->ns6__Address::country), "ns6:Country"))
				{	soap_flag_country1--;
					continue;
				}
			if(soap_flag_federalDistrict1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__FederalDistrict(soap, "ns6:federalDistrict", &(a->ns6__Address::federalDistrict), "ns6:FederalDistrict"))
				{	soap_flag_federalDistrict1--;
					continue;
				}
			if(soap_flag_region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Region(soap, "ns6:region", &(a->ns6__Address::region), "ns6:Region"))
				{	soap_flag_region1--;
					continue;
				}
			if(soap_flag_district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__District(soap, "ns6:district", &(a->ns6__Address::district), "ns6:District"))
				{	soap_flag_district1--;
					continue;
				}
			if(soap_flag_locality1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Locality(soap, "ns6:locality", &(a->ns6__Address::locality), "ns6:Locality"))
				{	soap_flag_locality1--;
					continue;
				}
			if(soap_flag_subLocality1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Locality(soap, "ns6:subLocality", &(a->ns6__Address::subLocality), "ns6:Locality"))
				{	soap_flag_subLocality1--;
					continue;
				}
			if(soap_flag_street1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Street(soap, "ns6:street", &(a->ns6__Address::street), "ns6:Street"))
				{	soap_flag_street1--;
					continue;
				}
			if(soap_flag_house1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:house", &(a->ns6__Address::house), "ns3:String255"))
				{	soap_flag_house1--;
					continue;
				}
			if(soap_flag_building1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:building", &(a->ns6__Address::building), "ns3:String255"))
				{	soap_flag_building1--;
					continue;
				}
			if(soap_flag_room1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:room", &(a->ns6__Address::room), "ns3:String255"))
				{	soap_flag_room1--;
					continue;
				}
			if(soap_flag_postIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:postIndex", &(a->ns6__Address::postIndex), "ns3:String255"))
				{	soap_flag_postIndex1--;
					continue;
				}
			if(soap_flag_postBox1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:postBox", &(a->ns6__Address::postBox), "ns3:String255"))
				{	soap_flag_postBox1--;
					continue;
				}
			if(soap_flag_additionalInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:additionalInfo", &(a->ns6__Address::additionalInfo), "ns3:NText"))
				{	soap_flag_additionalInfo1--;
					continue;
				}
			if(soap_flag_addressView1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:addressView", &(a->ns6__Address::addressView), "ns3:NText"))
				{	soap_flag_addressView1--;
					continue;
				}
			if(soap_flag_enAddressView1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__NText(soap, "ns6:enAddressView", &(a->ns6__Address::enAddressView), "ns3:NText"))
				{	soap_flag_enAddressView1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Address, 0, sizeof(ns6__Address), 0, soap_copy_ns6__Address);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Address);
	return this->soap_out(soap, tag?tag:"ns6:Address", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Address(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Address * SOAP_FMAC4 soap_get_ns6__Address(struct soap *soap, ns6__Address *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Address(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Address * FASTCALL soap_instantiate_ns6__Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Address, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns6:Area")) {
		cp->type = SOAP_TYPE_ns6__Area;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Area);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Area));
			((ns6__Area*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Area[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Area));
			for(int i = 0; i < n; i++)
				((ns6__Area*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Area*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Address);
		ASSIGN_PTR(size, sizeof(ns6__Address));
		((ns6__Address*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Address[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Address));
		for(int i = 0; i < n; i++)
			((ns6__Address*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Address*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Address %p -> %p\n", q, p));
	*(ns6__Address*)p = *(ns6__Address*)q;
}

void ns6__Street::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns6__Street::localityGuid);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_default_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_default_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	this->ns6__AddressObjectView::hasStreets = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Street::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns6__Street::localityGuid);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_serialize_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_serialize_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ns6__AddressObjectView::hasStreets);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Street::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Street(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Street(struct soap *soap, const char *tag, int id, const ns6__Street *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Street), "ns6:Street"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:view", -1, &(a->ns6__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ns6:regionCode", -1, &(a->ns6__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:type", -1, &(a->ns6__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:countryGuid", -1, &(a->ns6__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:hasStreets", -1, &(a->ns6__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:localityGuid", -1, &(a->ns6__Street::localityGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Street::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Street(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Street * FASTCALL soap_in_ns6__Street(struct soap *soap, const char *tag, ns6__Street *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Street *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Street, sizeof(ns6__Street), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Street) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Street *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__AddressObjectView::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__AddressObjectView::englishName), "ns3:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:view", &(a->ns6__AddressObjectView::view), "ns3:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns6:regionCode", &(a->ns6__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:type", &(a->ns6__AddressObjectView::type), "ns3:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:countryGuid", &(a->ns6__AddressObjectView::countryGuid), "ns3:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:hasStreets", &(a->ns6__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:localityGuid", &(a->ns6__Street::localityGuid), "ns3:UUID"))
				{	soap_flag_localityGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Street *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Street, 0, sizeof(ns6__Street), 0, soap_copy_ns6__Street);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Street::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Street);
	return this->soap_out(soap, tag?tag:"ns6:Street", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Street::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Street(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Street * SOAP_FMAC4 soap_get_ns6__Street(struct soap *soap, ns6__Street *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Street * FASTCALL soap_instantiate_ns6__Street(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Street(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Street, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Street);
		ASSIGN_PTR(size, sizeof(ns6__Street));
		((ns6__Street*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Street[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Street));
		for(int i = 0; i < n; i++)
			((ns6__Street*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Street*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Street(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Street %p -> %p\n", q, p));
	*(ns6__Street*)p = *(ns6__Street*)q;
}

void ns6__Locality::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns6__Locality::regionGuid);
	soap_default_ns3__UUID(soap, &this->ns6__Locality::districtGuid);
	soap_default_ns3__UUID(soap, &this->ns6__Locality::cityGuid);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_default_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_default_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	this->ns6__AddressObjectView::hasStreets = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Locality::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns6__Locality::regionGuid);
	soap_serialize_ns3__UUID(soap, &this->ns6__Locality::districtGuid);
	soap_serialize_ns3__UUID(soap, &this->ns6__Locality::cityGuid);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_serialize_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_serialize_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ns6__AddressObjectView::hasStreets);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Locality::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Locality(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Locality(struct soap *soap, const char *tag, int id, const ns6__Locality *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Locality), "ns6:Locality"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:view", -1, &(a->ns6__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ns6:regionCode", -1, &(a->ns6__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:type", -1, &(a->ns6__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:countryGuid", -1, &(a->ns6__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:hasStreets", -1, &(a->ns6__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:regionGuid", -1, &(a->ns6__Locality::regionGuid), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:districtGuid", -1, &(a->ns6__Locality::districtGuid), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:cityGuid", -1, &(a->ns6__Locality::cityGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Locality::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Locality(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Locality * FASTCALL soap_in_ns6__Locality(struct soap *soap, const char *tag, ns6__Locality *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Locality *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Locality, sizeof(ns6__Locality), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Locality) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Locality *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_regionGuid1 = 1;
	size_t soap_flag_districtGuid1 = 1;
	size_t soap_flag_cityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__AddressObjectView::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__AddressObjectView::englishName), "ns3:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:view", &(a->ns6__AddressObjectView::view), "ns3:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns6:regionCode", &(a->ns6__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:type", &(a->ns6__AddressObjectView::type), "ns3:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:countryGuid", &(a->ns6__AddressObjectView::countryGuid), "ns3:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:hasStreets", &(a->ns6__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:regionGuid", &(a->ns6__Locality::regionGuid), "ns3:UUID"))
				{	soap_flag_regionGuid1--;
					continue;
				}
			if(soap_flag_districtGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:districtGuid", &(a->ns6__Locality::districtGuid), "ns3:UUID"))
				{	soap_flag_districtGuid1--;
					continue;
				}
			if(soap_flag_cityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:cityGuid", &(a->ns6__Locality::cityGuid), "ns3:UUID"))
				{	soap_flag_cityGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Locality *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Locality, 0, sizeof(ns6__Locality), 0, soap_copy_ns6__Locality);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Locality::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Locality);
	return this->soap_out(soap, tag?tag:"ns6:Locality", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Locality::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Locality(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Locality * SOAP_FMAC4 soap_get_ns6__Locality(struct soap *soap, ns6__Locality *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Locality * FASTCALL soap_instantiate_ns6__Locality(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Locality(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Locality, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Locality);
		ASSIGN_PTR(size, sizeof(ns6__Locality));
		((ns6__Locality*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Locality[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Locality));
		for(int i = 0; i < n; i++)
			((ns6__Locality*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Locality*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Locality(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Locality %p -> %p\n", q, p));
	*(ns6__Locality*)p = *(ns6__Locality*)q;
}

void ns6__District::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns6__District::regionGuid);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_default_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_default_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	this->ns6__AddressObjectView::hasStreets = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__District::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns6__District::regionGuid);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_serialize_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_serialize_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ns6__AddressObjectView::hasStreets);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__District::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__District(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__District(struct soap *soap, const char *tag, int id, const ns6__District *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__District), "ns6:District"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:view", -1, &(a->ns6__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ns6:regionCode", -1, &(a->ns6__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:type", -1, &(a->ns6__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:countryGuid", -1, &(a->ns6__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:hasStreets", -1, &(a->ns6__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:regionGuid", -1, &(a->ns6__District::regionGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__District::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__District(soap, tag, this, type);
}

SOAP_FMAC3 ns6__District * FASTCALL soap_in_ns6__District(struct soap *soap, const char *tag, ns6__District *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__District *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__District, sizeof(ns6__District), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__District) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__District *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__AddressObjectView::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__AddressObjectView::englishName), "ns3:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:view", &(a->ns6__AddressObjectView::view), "ns3:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns6:regionCode", &(a->ns6__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:type", &(a->ns6__AddressObjectView::type), "ns3:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:countryGuid", &(a->ns6__AddressObjectView::countryGuid), "ns3:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:hasStreets", &(a->ns6__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:regionGuid", &(a->ns6__District::regionGuid), "ns3:UUID"))
				{	soap_flag_regionGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__District *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__District, 0, sizeof(ns6__District), 0, soap_copy_ns6__District);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__District::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__District);
	return this->soap_out(soap, tag?tag:"ns6:District", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__District::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__District(soap, this, tag, type);
}

SOAP_FMAC3 ns6__District * SOAP_FMAC4 soap_get_ns6__District(struct soap *soap, ns6__District *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__District * FASTCALL soap_instantiate_ns6__District(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__District(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__District, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__District);
		ASSIGN_PTR(size, sizeof(ns6__District));
		((ns6__District*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__District[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__District));
		for(int i = 0; i < n; i++)
			((ns6__District*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__District*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__District(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__District %p -> %p\n", q, p));
	*(ns6__District*)p = *(ns6__District*)q;
}

void ns6__Region::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_default_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_default_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	this->ns6__AddressObjectView::hasStreets = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Region::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_serialize_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_serialize_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ns6__AddressObjectView::hasStreets);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Region::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Region(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Region(struct soap *soap, const char *tag, int id, const ns6__Region *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Region), "ns6:Region"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:view", -1, &(a->ns6__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ns6:regionCode", -1, &(a->ns6__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:type", -1, &(a->ns6__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:countryGuid", -1, &(a->ns6__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:hasStreets", -1, &(a->ns6__AddressObjectView::hasStreets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Region::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Region(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Region * FASTCALL soap_in_ns6__Region(struct soap *soap, const char *tag, ns6__Region *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Region *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Region, sizeof(ns6__Region), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Region) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Region *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__AddressObjectView::name), "ns3:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__AddressObjectView::englishName), "ns3:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:view", &(a->ns6__AddressObjectView::view), "ns3:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns6:regionCode", &(a->ns6__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:type", &(a->ns6__AddressObjectView::type), "ns3:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:countryGuid", &(a->ns6__AddressObjectView::countryGuid), "ns3:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:hasStreets", &(a->ns6__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Region *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Region, 0, sizeof(ns6__Region), 0, soap_copy_ns6__Region);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Region::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Region);
	return this->soap_out(soap, tag?tag:"ns6:Region", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Region::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Region(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Region * SOAP_FMAC4 soap_get_ns6__Region(struct soap *soap, ns6__Region *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Region * FASTCALL soap_instantiate_ns6__Region(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Region(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Region, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Region);
		ASSIGN_PTR(size, sizeof(ns6__Region));
		((ns6__Region*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Region[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Region));
		for(int i = 0; i < n; i++)
			((ns6__Region*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Region*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Region(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Region %p -> %p\n", q, p));
	*(ns6__Region*)p = *(ns6__Region*)q;
}

void ns6__AddressObjectView::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_default_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_default_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_default_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	this->ns6__AddressObjectView::hasStreets = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__AddressObjectView::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::name);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::englishName);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::view);
	soap_serialize_string(soap, &this->ns6__AddressObjectView::regionCode);
	soap_serialize_ns3__String255(soap, &this->ns6__AddressObjectView::type);
	soap_serialize_ns3__UUID(soap, &this->ns6__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ns6__AddressObjectView::hasStreets);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__AddressObjectView::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AddressObjectView(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__AddressObjectView(struct soap *soap, const char *tag, int id, const ns6__AddressObjectView *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AddressObjectView), "ns6:AddressObjectView"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:view", -1, &(a->ns6__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ns6:regionCode", -1, &(a->ns6__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:type", -1, &(a->ns6__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:countryGuid", -1, &(a->ns6__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:hasStreets", -1, &(a->ns6__AddressObjectView::hasStreets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__AddressObjectView::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__AddressObjectView(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AddressObjectView * FASTCALL soap_in_ns6__AddressObjectView(struct soap *soap, const char *tag, ns6__AddressObjectView *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AddressObjectView *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AddressObjectView, sizeof(ns6__AddressObjectView), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__AddressObjectView) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AddressObjectView *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_view1 = 1;
	size_t soap_flag_regionCode1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_countryGuid1 = 1;
	size_t soap_flag_hasStreets1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__AddressObjectView::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__AddressObjectView::englishName), "ns3:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:view", &(a->ns6__AddressObjectView::view), "ns3:String255"))
				{	soap_flag_view1--;
					continue;
				}
			if(soap_flag_regionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns6:regionCode", &(a->ns6__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode1--;
					continue;
				}
			if(soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:type", &(a->ns6__AddressObjectView::type), "ns3:String255"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_countryGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:countryGuid", &(a->ns6__AddressObjectView::countryGuid), "ns3:UUID"))
				{	soap_flag_countryGuid1--;
					continue;
				}
			if(soap_flag_hasStreets1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:hasStreets", &(a->ns6__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__AddressObjectView *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AddressObjectView, 0, sizeof(ns6__AddressObjectView), 0, soap_copy_ns6__AddressObjectView);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__AddressObjectView::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AddressObjectView);
	return this->soap_out(soap, tag?tag:"ns6:AddressObjectView", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__AddressObjectView::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AddressObjectView(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AddressObjectView * SOAP_FMAC4 soap_get_ns6__AddressObjectView(struct soap *soap, ns6__AddressObjectView *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__AddressObjectView(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__AddressObjectView * FASTCALL soap_instantiate_ns6__AddressObjectView(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AddressObjectView(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AddressObjectView, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns6:Region")) {
		cp->type = SOAP_TYPE_ns6__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Region));
			((ns6__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Region[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Region));
			for(int i = 0; i < n; i++)
				((ns6__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:District")) {
		cp->type = SOAP_TYPE_ns6__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__District));
			((ns6__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__District[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__District));
			for(int i = 0; i < n; i++)
				((ns6__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Locality")) {
		cp->type = SOAP_TYPE_ns6__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Locality));
			((ns6__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Locality));
			for(int i = 0; i < n; i++)
				((ns6__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Street")) {
		cp->type = SOAP_TYPE_ns6__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Street));
			((ns6__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Street[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Street));
			for(int i = 0; i < n; i++)
				((ns6__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Street*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__AddressObjectView);
		ASSIGN_PTR(size, sizeof(ns6__AddressObjectView));
		((ns6__AddressObjectView*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__AddressObjectView[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__AddressObjectView));
		for(int i = 0; i < n; i++)
			((ns6__AddressObjectView*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AddressObjectView*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AddressObjectView(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AddressObjectView %p -> %p\n", q, p));
	*(ns6__AddressObjectView*)p = *(ns6__AddressObjectView*)q;
}

void ns6__FederalDistrict::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__FederalDistrict::fullName);
	soap_default_ns3__String255(soap, &this->ns6__FederalDistrict::shortName);
	soap_default_ns3__String255(soap, &this->ns6__FederalDistrict::abbreviation);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__FederalDistrict::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__FederalDistrict::fullName);
	soap_serialize_ns3__String255(soap, &this->ns6__FederalDistrict::shortName);
	soap_serialize_ns3__String255(soap, &this->ns6__FederalDistrict::abbreviation);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__FederalDistrict::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__FederalDistrict(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__FederalDistrict(struct soap *soap, const char *tag, int id, const ns6__FederalDistrict *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__FederalDistrict), "ns6:FederalDistrict"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:fullName", -1, &(a->ns6__FederalDistrict::fullName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:shortName", -1, &(a->ns6__FederalDistrict::shortName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:abbreviation", -1, &(a->ns6__FederalDistrict::abbreviation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__FederalDistrict::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__FederalDistrict(soap, tag, this, type);
}

SOAP_FMAC3 ns6__FederalDistrict * FASTCALL soap_in_ns6__FederalDistrict(struct soap *soap, const char *tag, ns6__FederalDistrict *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__FederalDistrict *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__FederalDistrict, sizeof(ns6__FederalDistrict), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__FederalDistrict) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__FederalDistrict *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_abbreviation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:fullName", &(a->ns6__FederalDistrict::fullName), "ns3:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:shortName", &(a->ns6__FederalDistrict::shortName), "ns3:String255"))
				{	soap_flag_shortName1--;
					continue;
				}
			if(soap_flag_abbreviation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:abbreviation", &(a->ns6__FederalDistrict::abbreviation), "ns3:String255"))
				{	soap_flag_abbreviation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__FederalDistrict *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__FederalDistrict, 0, sizeof(ns6__FederalDistrict), 0, soap_copy_ns6__FederalDistrict);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__FederalDistrict::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__FederalDistrict);
	return this->soap_out(soap, tag?tag:"ns6:FederalDistrict", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__FederalDistrict::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__FederalDistrict(soap, this, tag, type);
}

SOAP_FMAC3 ns6__FederalDistrict * SOAP_FMAC4 soap_get_ns6__FederalDistrict(struct soap *soap, ns6__FederalDistrict *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__FederalDistrict(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__FederalDistrict * FASTCALL soap_instantiate_ns6__FederalDistrict(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__FederalDistrict(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__FederalDistrict, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__FederalDistrict);
		ASSIGN_PTR(size, sizeof(ns6__FederalDistrict));
		((ns6__FederalDistrict*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__FederalDistrict[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__FederalDistrict));
		for(int i = 0; i < n; i++)
			((ns6__FederalDistrict*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__FederalDistrict*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__FederalDistrict(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__FederalDistrict %p -> %p\n", q, p));
	*(ns6__FederalDistrict*)p = *(ns6__FederalDistrict*)q;
}

void ns6__Country::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Country::name);
	soap_default_ns3__String255(soap, &this->ns6__Country::fullName);
	soap_default_ns3__String255(soap, &this->ns6__Country::englishName);
	soap_default_ns6__Code(soap, &this->ns6__Country::code);
	soap_default_ns6__Code3(soap, &this->ns6__Country::code3);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Country::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Country::name);
	soap_serialize_ns3__String255(soap, &this->ns6__Country::fullName);
	soap_serialize_ns3__String255(soap, &this->ns6__Country::englishName);
	soap_serialize_ns6__Code(soap, &this->ns6__Country::code);
	soap_serialize_ns6__Code3(soap, &this->ns6__Country::code3);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Country::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Country(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Country(struct soap *soap, const char *tag, int id, const ns6__Country *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Country), "ns6:Country"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Country::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:fullName", -1, &(a->ns6__Country::fullName), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:englishName", -1, &(a->ns6__Country::englishName), ""))
		return soap->error;
	if(soap_out_ns6__Code(soap, "ns6:code", -1, &(a->ns6__Country::code), ""))
		return soap->error;
	if(soap_out_ns6__Code3(soap, "ns6:code3", -1, &(a->ns6__Country::code3), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Country::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Country(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Country * FASTCALL soap_in_ns6__Country(struct soap *soap, const char *tag, ns6__Country *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Country *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Country, sizeof(ns6__Country), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Country) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Country *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_code31 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Country::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:fullName", &(a->ns6__Country::fullName), "ns3:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:englishName", &(a->ns6__Country::englishName), "ns3:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__Code(soap, "ns6:code", &(a->ns6__Country::code), "ns6:Code"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_code31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns6__Code3(soap, "ns6:code3", &(a->ns6__Country::code3), "ns6:Code3"))
				{	soap_flag_code31--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Country *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Country, 0, sizeof(ns6__Country), 0, soap_copy_ns6__Country);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Country::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Country);
	return this->soap_out(soap, tag?tag:"ns6:Country", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Country::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Country(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Country * SOAP_FMAC4 soap_get_ns6__Country(struct soap *soap, ns6__Country *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Country * FASTCALL soap_instantiate_ns6__Country(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Country(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Country, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Country);
		ASSIGN_PTR(size, sizeof(ns6__Country));
		((ns6__Country*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Country[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Country));
		for(int i = 0; i < n; i++)
			((ns6__Country*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Country*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Country(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Country %p -> %p\n", q, p));
	*(ns6__Country*)p = *(ns6__Country*)q;
}

void ns6__UnitList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__UnitList::__sizeunit = 0;
	this->ns6__UnitList::unit = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__UnitList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__UnitList::unit) {
		for(int i = 0; i < this->ns6__UnitList::__sizeunit; i++) {
			soap_serialize_PointerTons6__Unit(soap, this->ns6__UnitList::unit + i);
		}
	}
	/* transient soap skipped */
}

int ns6__UnitList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UnitList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__UnitList(struct soap *soap, const char *tag, int id, const ns6__UnitList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UnitList), "ns6:UnitList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__UnitList::unit) {
		int i;
		for(i = 0; i < a->ns6__UnitList::__sizeunit; i++)
			if(soap_out_PointerTons6__Unit(soap, "ns6:unit", -1, a->ns6__UnitList::unit + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__UnitList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__UnitList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UnitList * FASTCALL soap_in_ns6__UnitList(struct soap *soap, const char *tag, ns6__UnitList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UnitList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UnitList, sizeof(ns6__UnitList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__UnitList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__UnitList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_unit1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:unit", 1, NULL)) {
				if(a->ns6__UnitList::unit == NULL) {
					if(soap_blist_unit1 == NULL)
						soap_blist_unit1 = soap_new_block(soap);
					a->ns6__UnitList::unit = (ns6__Unit **)soap_push_block(soap, soap_blist_unit1, sizeof(ns6__Unit *));
					if(a->ns6__UnitList::unit == NULL)
						return NULL;
					*a->ns6__UnitList::unit = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Unit(soap, "ns6:unit", a->ns6__UnitList::unit, "ns6:Unit"))
				{	a->ns6__UnitList::__sizeunit++;
					a->ns6__UnitList::unit = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__UnitList::unit)
			soap_pop_block(soap, soap_blist_unit1);
		if(a->ns6__UnitList::__sizeunit)
			a->ns6__UnitList::unit = (ns6__Unit **)soap_save_block(soap, soap_blist_unit1, NULL, 1);
		else
		{	a->ns6__UnitList::unit = NULL;
			if(soap_blist_unit1)
				soap_end_block(soap, soap_blist_unit1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__UnitList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UnitList, 0, sizeof(ns6__UnitList), 0, soap_copy_ns6__UnitList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__UnitList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__UnitList);
	return this->soap_out(soap, tag?tag:"ns6:UnitList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__UnitList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UnitList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UnitList * SOAP_FMAC4 soap_get_ns6__UnitList(struct soap *soap, ns6__UnitList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__UnitList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__UnitList * FASTCALL soap_instantiate_ns6__UnitList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__UnitList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__UnitList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__UnitList);
		ASSIGN_PTR(size, sizeof(ns6__UnitList));
		((ns6__UnitList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__UnitList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__UnitList));
		for(int i = 0; i < n; i++)
			((ns6__UnitList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__UnitList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__UnitList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__UnitList %p -> %p\n", q, p));
	*(ns6__UnitList*)p = *(ns6__UnitList*)q;
}

void ns6__PurposeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__PurposeList::__sizepurpose = 0;
	this->ns6__PurposeList::purpose = NULL;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns6__PurposeList::soap_serialize(struct soap *soap) const
{
	if(this->ns6__PurposeList::purpose) {
		for(int i = 0; i < this->ns6__PurposeList::__sizepurpose; i++) {
			soap_serialize_PointerTons6__Purpose(soap, this->ns6__PurposeList::purpose + i);
		}
	}
	/* transient soap skipped */
}

int ns6__PurposeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__PurposeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__PurposeList(struct soap *soap, const char *tag, int id, const ns6__PurposeList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PurposeList), "ns6:PurposeList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns6__PurposeList::purpose) {
		int i;
		for(i = 0; i < a->ns6__PurposeList::__sizepurpose; i++)
			if(soap_out_PointerTons6__Purpose(soap, "ns6:purpose", -1, a->ns6__PurposeList::purpose + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns6__PurposeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__PurposeList(soap, tag, this, type);
}

SOAP_FMAC3 ns6__PurposeList * FASTCALL soap_in_ns6__PurposeList(struct soap *soap, const char *tag, ns6__PurposeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__PurposeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PurposeList, sizeof(ns6__PurposeList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__PurposeList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__PurposeList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_purpose1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:purpose", 1, NULL)) {
				if(a->ns6__PurposeList::purpose == NULL) {
					if(soap_blist_purpose1 == NULL)
						soap_blist_purpose1 = soap_new_block(soap);
					a->ns6__PurposeList::purpose = (ns6__Purpose **)soap_push_block(soap, soap_blist_purpose1, sizeof(ns6__Purpose *));
					if(a->ns6__PurposeList::purpose == NULL)
						return NULL;
					*a->ns6__PurposeList::purpose = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Purpose(soap, "ns6:purpose", a->ns6__PurposeList::purpose, "ns6:Purpose"))
				{	a->ns6__PurposeList::__sizepurpose++;
					a->ns6__PurposeList::purpose = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns6__PurposeList::purpose)
			soap_pop_block(soap, soap_blist_purpose1);
		if(a->ns6__PurposeList::__sizepurpose)
			a->ns6__PurposeList::purpose = (ns6__Purpose **)soap_save_block(soap, soap_blist_purpose1, NULL, 1);
		else
		{	a->ns6__PurposeList::purpose = NULL;
			if(soap_blist_purpose1)
				soap_end_block(soap, soap_blist_purpose1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__PurposeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PurposeList, 0, sizeof(ns6__PurposeList), 0, soap_copy_ns6__PurposeList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__PurposeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__PurposeList);
	return this->soap_out(soap, tag?tag:"ns6:PurposeList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__PurposeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__PurposeList(soap, this, tag, type);
}

SOAP_FMAC3 ns6__PurposeList * SOAP_FMAC4 soap_get_ns6__PurposeList(struct soap *soap, ns6__PurposeList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__PurposeList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__PurposeList * FASTCALL soap_instantiate_ns6__PurposeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__PurposeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__PurposeList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__PurposeList);
		ASSIGN_PTR(size, sizeof(ns6__PurposeList));
		((ns6__PurposeList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__PurposeList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__PurposeList));
		for(int i = 0; i < n; i++)
			((ns6__PurposeList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__PurposeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__PurposeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__PurposeList %p -> %p\n", q, p));
	*(ns6__PurposeList*)p = *(ns6__PurposeList*)q;
}

void ns6__PackingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__PackingType::globalID = NULL;
	soap_default_ns3__String255(soap, &this->ns6__PackingType::name);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__PackingType::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__PackingCodeType(soap, &this->ns6__PackingType::globalID);
	soap_serialize_ns3__String255(soap, &this->ns6__PackingType::name);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__PackingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__PackingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__PackingType(struct soap *soap, const char *tag, int id, const ns6__PackingType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PackingType), "ns6:PackingType"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTons6__PackingCodeType(soap, "ns6:globalID", -1, &(a->ns6__PackingType::globalID), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__PackingType::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__PackingType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__PackingType(soap, tag, this, type);
}

SOAP_FMAC3 ns6__PackingType * FASTCALL soap_in_ns6__PackingType(struct soap *soap, const char *tag, ns6__PackingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__PackingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PackingType, sizeof(ns6__PackingType), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__PackingType) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__PackingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_globalID1 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_globalID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__PackingCodeType(soap, "ns6:globalID", &(a->ns6__PackingType::globalID), "ns6:PackingCodeType"))
				{	soap_flag_globalID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__PackingType::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__PackingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PackingType, 0, sizeof(ns6__PackingType), 0, soap_copy_ns6__PackingType);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__PackingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__PackingType);
	return this->soap_out(soap, tag?tag:"ns6:PackingType", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__PackingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__PackingType(soap, this, tag, type);
}

SOAP_FMAC3 ns6__PackingType * SOAP_FMAC4 soap_get_ns6__PackingType(struct soap *soap, ns6__PackingType *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__PackingType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__PackingType * FASTCALL soap_instantiate_ns6__PackingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__PackingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__PackingType, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__PackingType);
		ASSIGN_PTR(size, sizeof(ns6__PackingType));
		((ns6__PackingType*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__PackingType[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__PackingType));
		for(int i = 0; i < n; i++)
			((ns6__PackingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__PackingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__PackingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__PackingType %p -> %p\n", q, p));
	*(ns6__PackingType*)p = *(ns6__PackingType*)q;
}

void ns6__Unit::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Unit::name);
	soap_default_ns3__String255(soap, &this->ns6__Unit::fullName);
	soap_default_ns3__UUID(soap, &this->ns6__Unit::commonUnitGuid);
	soap_default_xsd__integer(soap, &this->ns6__Unit::factor);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Unit::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Unit::name);
	soap_serialize_ns3__String255(soap, &this->ns6__Unit::fullName);
	soap_serialize_ns3__UUID(soap, &this->ns6__Unit::commonUnitGuid);
	soap_serialize_xsd__integer(soap, &this->ns6__Unit::factor);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Unit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Unit(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Unit(struct soap *soap, const char *tag, int id, const ns6__Unit *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Unit), "ns6:Unit"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Unit::name), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:fullName", -1, &(a->ns6__Unit::fullName), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns6:commonUnitGuid", -1, &(a->ns6__Unit::commonUnitGuid), ""))
		return soap->error;
	if(soap_out_xsd__integer(soap, "ns6:factor", -1, &(a->ns6__Unit::factor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Unit::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Unit(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Unit * FASTCALL soap_in_ns6__Unit(struct soap *soap, const char *tag, ns6__Unit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Unit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Unit, sizeof(ns6__Unit), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Unit) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Unit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_commonUnitGuid1 = 1;
	size_t soap_flag_factor1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Unit::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:fullName", &(a->ns6__Unit::fullName), "ns3:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_commonUnitGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:commonUnitGuid", &(a->ns6__Unit::commonUnitGuid), "ns3:UUID"))
				{	soap_flag_commonUnitGuid1--;
					continue;
				}
			if(soap_flag_factor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "ns6:factor", &(a->ns6__Unit::factor), "xsd:integer"))
				{	soap_flag_factor1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Unit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Unit, 0, sizeof(ns6__Unit), 0, soap_copy_ns6__Unit);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Unit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Unit);
	return this->soap_out(soap, tag?tag:"ns6:Unit", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Unit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Unit(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Unit * SOAP_FMAC4 soap_get_ns6__Unit(struct soap *soap, ns6__Unit *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Unit * FASTCALL soap_instantiate_ns6__Unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Unit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Unit, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Unit);
		ASSIGN_PTR(size, sizeof(ns6__Unit));
		((ns6__Unit*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Unit[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Unit));
		for(int i = 0; i < n; i++)
			((ns6__Unit*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Unit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Unit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Unit %p -> %p\n", q, p));
	*(ns6__Unit*)p = *(ns6__Unit*)q;
}

void ns6__Purpose::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__String255(soap, &this->ns6__Purpose::name);
	this->ns6__Purpose::forSubstandard = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns6__Purpose::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__String255(soap, &this->ns6__Purpose::name);
	soap_serialize_PointerTobool(soap, &this->ns6__Purpose::forSubstandard);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns6__Purpose::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Purpose(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Purpose(struct soap *soap, const char *tag, int id, const ns6__Purpose *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Purpose), "ns6:Purpose"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ns3__String255(soap, "ns6:name", -1, &(a->ns6__Purpose::name), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns6:forSubstandard", -1, &(a->ns6__Purpose::forSubstandard), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__Purpose::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns6__Purpose(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Purpose * FASTCALL soap_in_ns6__Purpose(struct soap *soap, const char *tag, ns6__Purpose *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Purpose *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Purpose, sizeof(ns6__Purpose), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns6__Purpose) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Purpose *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_forSubstandard1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__String255(soap, "ns6:name", &(a->ns6__Purpose::name), "ns3:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_forSubstandard1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns6:forSubstandard", &(a->ns6__Purpose::forSubstandard), "xsd:boolean"))
				{	soap_flag_forSubstandard1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns6__Purpose *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Purpose, 0, sizeof(ns6__Purpose), 0, soap_copy_ns6__Purpose);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__Purpose::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Purpose);
	return this->soap_out(soap, tag?tag:"ns6:Purpose", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns6__Purpose::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Purpose(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Purpose * SOAP_FMAC4 soap_get_ns6__Purpose(struct soap *soap, ns6__Purpose *p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Purpose * FASTCALL soap_instantiate_ns6__Purpose(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Purpose(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Purpose, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns6__Purpose);
		ASSIGN_PTR(size, sizeof(ns6__Purpose));
		((ns6__Purpose*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns6__Purpose[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns6__Purpose));
		for(int i = 0; i < n; i++)
			((ns6__Purpose*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Purpose*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Purpose(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Purpose %p -> %p\n", q, p));
	*(ns6__Purpose*)p = *(ns6__Purpose*)q;
}

void ns5__GetAppliedUserAuthorityListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetAppliedUserAuthorityListResponse::ns7__authorityList = NULL;
	/* transient soap skipped */
}

void ns5__GetAppliedUserAuthorityListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__AuthorityList(soap, &this->ns5__GetAppliedUserAuthorityListResponse::ns7__authorityList);
	/* transient soap skipped */
}

int ns5__GetAppliedUserAuthorityListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetAppliedUserAuthorityListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, int id, const ns5__GetAppliedUserAuthorityListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse), "ns5:GetAppliedUserAuthorityListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__authorityList)
		soap_element_result(soap, "ns7:authorityList");
	if(soap_out_PointerTons7__AuthorityList(soap, "ns7:authorityList", -1, &(a->ns5__GetAppliedUserAuthorityListResponse::ns7__authorityList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetAppliedUserAuthorityListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetAppliedUserAuthorityListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListResponse * FASTCALL soap_in_ns5__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, ns5__GetAppliedUserAuthorityListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetAppliedUserAuthorityListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse, sizeof(ns5__GetAppliedUserAuthorityListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetAppliedUserAuthorityListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__authorityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__authorityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__AuthorityList(soap, "ns7:authorityList", &(a->ns5__GetAppliedUserAuthorityListResponse::ns7__authorityList), "ns7:AuthorityList"))
				{	soap_flag_ns7__authorityList1--;
					continue;
				}
			soap_check_result(soap, "ns7:authorityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetAppliedUserAuthorityListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse, 0, sizeof(ns5__GetAppliedUserAuthorityListResponse), 0, soap_copy_ns5__GetAppliedUserAuthorityListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__GetAppliedUserAuthorityListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetAppliedUserAuthorityListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetAppliedUserAuthorityListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetAppliedUserAuthorityListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListResponse * SOAP_FMAC4 soap_get_ns5__GetAppliedUserAuthorityListResponse(struct soap *soap, ns5__GetAppliedUserAuthorityListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetAppliedUserAuthorityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetAppliedUserAuthorityListResponse * FASTCALL soap_instantiate_ns5__GetAppliedUserAuthorityListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetAppliedUserAuthorityListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetAppliedUserAuthorityListResponse));
		((ns5__GetAppliedUserAuthorityListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetAppliedUserAuthorityListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetAppliedUserAuthorityListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetAppliedUserAuthorityListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetAppliedUserAuthorityListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetAppliedUserAuthorityListResponse %p -> %p\n", q, p));
	*(ns5__GetAppliedUserAuthorityListResponse*)p = *(ns5__GetAppliedUserAuthorityListResponse*)q;
}

void ns5__GetAppliedUserAuthorityListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetAppliedUserAuthorityListRequest::ns3__listOptions = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetAppliedUserAuthorityListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetAppliedUserAuthorityListRequest::ns3__listOptions);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetAppliedUserAuthorityListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetAppliedUserAuthorityListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, int id, const ns5__GetAppliedUserAuthorityListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest), "ns5:GetAppliedUserAuthorityListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetAppliedUserAuthorityListRequest::ns3__listOptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetAppliedUserAuthorityListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetAppliedUserAuthorityListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListRequest * FASTCALL soap_in_ns5__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, ns5__GetAppliedUserAuthorityListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetAppliedUserAuthorityListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest, sizeof(ns5__GetAppliedUserAuthorityListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetAppliedUserAuthorityListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetAppliedUserAuthorityListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetAppliedUserAuthorityListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest, 0, sizeof(ns5__GetAppliedUserAuthorityListRequest), 0, soap_copy_ns5__GetAppliedUserAuthorityListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetAppliedUserAuthorityListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetAppliedUserAuthorityListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetAppliedUserAuthorityListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetAppliedUserAuthorityListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListRequest * SOAP_FMAC4 soap_get_ns5__GetAppliedUserAuthorityListRequest(struct soap *soap, ns5__GetAppliedUserAuthorityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetAppliedUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetAppliedUserAuthorityListRequest * FASTCALL soap_instantiate_ns5__GetAppliedUserAuthorityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetAppliedUserAuthorityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetAppliedUserAuthorityListRequest));
		((ns5__GetAppliedUserAuthorityListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetAppliedUserAuthorityListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetAppliedUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetAppliedUserAuthorityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetAppliedUserAuthorityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetAppliedUserAuthorityListRequest %p -> %p\n", q, p));
	*(ns5__GetAppliedUserAuthorityListRequest*)p = *(ns5__GetAppliedUserAuthorityListRequest*)q;
}

void ns5__UnbindBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UnbindBusinessEntityUserResponse::__sizeuser = 0;
	this->ns5__UnbindBusinessEntityUserResponse::ns7__user = NULL;
	/* transient soap skipped */
}

void ns5__UnbindBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UnbindBusinessEntityUserResponse::ns7__user) {
		for(int i = 0; i < this->ns5__UnbindBusinessEntityUserResponse::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__UnbindBusinessEntityUserResponse::ns7__user + i);
		}
	}
	/* transient soap skipped */
}

int ns5__UnbindBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UnbindBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const ns5__UnbindBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse), "ns5:UnbindBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->ns5__UnbindBusinessEntityUserResponse::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__UnbindBusinessEntityUserResponse::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__UnbindBusinessEntityUserResponse::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UnbindBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UnbindBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserResponse * FASTCALL soap_in_ns5__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, ns5__UnbindBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UnbindBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse, sizeof(ns5__UnbindBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UnbindBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__UnbindBusinessEntityUserResponse::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__UnbindBusinessEntityUserResponse::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__UnbindBusinessEntityUserResponse::ns7__user == NULL)
						return NULL;
					*a->ns5__UnbindBusinessEntityUserResponse::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__UnbindBusinessEntityUserResponse::ns7__user, "ns7:User"))
				{	a->ns5__UnbindBusinessEntityUserResponse::__sizeuser++;
					a->ns5__UnbindBusinessEntityUserResponse::ns7__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UnbindBusinessEntityUserResponse::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__UnbindBusinessEntityUserResponse::__sizeuser)
			a->ns5__UnbindBusinessEntityUserResponse::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__UnbindBusinessEntityUserResponse::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UnbindBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse, 0, sizeof(ns5__UnbindBusinessEntityUserResponse), 0, soap_copy_ns5__UnbindBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__UnbindBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"ns5:UnbindBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UnbindBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UnbindBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserResponse * SOAP_FMAC4 soap_get_ns5__UnbindBusinessEntityUserResponse(struct soap *soap, ns5__UnbindBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UnbindBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UnbindBusinessEntityUserResponse * FASTCALL soap_instantiate_ns5__UnbindBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UnbindBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(ns5__UnbindBusinessEntityUserResponse));
		((ns5__UnbindBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UnbindBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((ns5__UnbindBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UnbindBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UnbindBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UnbindBusinessEntityUserResponse %p -> %p\n", q, p));
	*(ns5__UnbindBusinessEntityUserResponse*)p = *(ns5__UnbindBusinessEntityUserResponse*)q;
}

void ns5__UnbindBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UnbindBusinessEntityUserRequest::__sizeuser = 0;
	this->ns5__UnbindBusinessEntityUserRequest::ns7__user = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__UnbindBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UnbindBusinessEntityUserRequest::ns7__user) {
		for(int i = 0; i < this->ns5__UnbindBusinessEntityUserRequest::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__UnbindBusinessEntityUserRequest::ns7__user + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__UnbindBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UnbindBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const ns5__UnbindBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest), "ns5:UnbindBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__UnbindBusinessEntityUserRequest::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__UnbindBusinessEntityUserRequest::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__UnbindBusinessEntityUserRequest::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UnbindBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UnbindBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserRequest * FASTCALL soap_in_ns5__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, ns5__UnbindBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UnbindBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest, sizeof(ns5__UnbindBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UnbindBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__UnbindBusinessEntityUserRequest::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__UnbindBusinessEntityUserRequest::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__UnbindBusinessEntityUserRequest::ns7__user == NULL)
						return NULL;
					*a->ns5__UnbindBusinessEntityUserRequest::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__UnbindBusinessEntityUserRequest::ns7__user, "ns7:User"))
				{	a->ns5__UnbindBusinessEntityUserRequest::__sizeuser++;
					a->ns5__UnbindBusinessEntityUserRequest::ns7__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UnbindBusinessEntityUserRequest::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__UnbindBusinessEntityUserRequest::__sizeuser)
			a->ns5__UnbindBusinessEntityUserRequest::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__UnbindBusinessEntityUserRequest::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UnbindBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest, 0, sizeof(ns5__UnbindBusinessEntityUserRequest), 0, soap_copy_ns5__UnbindBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->ns5__UnbindBusinessEntityUserRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__UnbindBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"ns5:UnbindBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UnbindBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UnbindBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserRequest * SOAP_FMAC4 soap_get_ns5__UnbindBusinessEntityUserRequest(struct soap *soap, ns5__UnbindBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UnbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UnbindBusinessEntityUserRequest * FASTCALL soap_instantiate_ns5__UnbindBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UnbindBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(ns5__UnbindBusinessEntityUserRequest));
		((ns5__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UnbindBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((ns5__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UnbindBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UnbindBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UnbindBusinessEntityUserRequest %p -> %p\n", q, p));
	*(ns5__UnbindBusinessEntityUserRequest*)p = *(ns5__UnbindBusinessEntityUserRequest*)q;
}

void ns5__UpdateUserWorkingAreasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateUserWorkingAreasResponse::__sizeuser = 0;
	this->ns5__UpdateUserWorkingAreasResponse::ns7__user = NULL;
	/* transient soap skipped */
}

void ns5__UpdateUserWorkingAreasResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UpdateUserWorkingAreasResponse::ns7__user) {
		for(int i = 0; i < this->ns5__UpdateUserWorkingAreasResponse::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__UpdateUserWorkingAreasResponse::ns7__user + i);
		}
	}
	/* transient soap skipped */
}

int ns5__UpdateUserWorkingAreasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateUserWorkingAreasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, int id, const ns5__UpdateUserWorkingAreasResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse), "ns5:UpdateUserWorkingAreasResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->ns5__UpdateUserWorkingAreasResponse::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__UpdateUserWorkingAreasResponse::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__UpdateUserWorkingAreasResponse::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateUserWorkingAreasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateUserWorkingAreasResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasResponse * FASTCALL soap_in_ns5__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, ns5__UpdateUserWorkingAreasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateUserWorkingAreasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse, sizeof(ns5__UpdateUserWorkingAreasResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateUserWorkingAreasResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__UpdateUserWorkingAreasResponse::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__UpdateUserWorkingAreasResponse::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__UpdateUserWorkingAreasResponse::ns7__user == NULL)
						return NULL;
					*a->ns5__UpdateUserWorkingAreasResponse::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__UpdateUserWorkingAreasResponse::ns7__user, "ns7:User"))
				{	a->ns5__UpdateUserWorkingAreasResponse::__sizeuser++;
					a->ns5__UpdateUserWorkingAreasResponse::ns7__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateUserWorkingAreasResponse::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__UpdateUserWorkingAreasResponse::__sizeuser)
			a->ns5__UpdateUserWorkingAreasResponse::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__UpdateUserWorkingAreasResponse::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateUserWorkingAreasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse, 0, sizeof(ns5__UpdateUserWorkingAreasResponse), 0, soap_copy_ns5__UpdateUserWorkingAreasResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__UpdateUserWorkingAreasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse);
	return this->soap_out(soap, tag?tag:"ns5:UpdateUserWorkingAreasResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateUserWorkingAreasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateUserWorkingAreasResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasResponse * SOAP_FMAC4 soap_get_ns5__UpdateUserWorkingAreasResponse(struct soap *soap, ns5__UpdateUserWorkingAreasResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateUserWorkingAreasResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateUserWorkingAreasResponse * FASTCALL soap_instantiate_ns5__UpdateUserWorkingAreasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateUserWorkingAreasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasResponse);
		ASSIGN_PTR(size, sizeof(ns5__UpdateUserWorkingAreasResponse));
		((ns5__UpdateUserWorkingAreasResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserWorkingAreasResponse));
		for(int i = 0; i < n; i++)
			((ns5__UpdateUserWorkingAreasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateUserWorkingAreasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateUserWorkingAreasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateUserWorkingAreasResponse %p -> %p\n", q, p));
	*(ns5__UpdateUserWorkingAreasResponse*)p = *(ns5__UpdateUserWorkingAreasResponse*)q;
}

void ns5__UpdateUserWorkingAreasRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateUserWorkingAreasRequest::__sizeuser = 0;
	this->ns5__UpdateUserWorkingAreasRequest::ns7__user = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__UpdateUserWorkingAreasRequest::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UpdateUserWorkingAreasRequest::ns7__user) {
		for(int i = 0; i < this->ns5__UpdateUserWorkingAreasRequest::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__UpdateUserWorkingAreasRequest::ns7__user + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__UpdateUserWorkingAreasRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateUserWorkingAreasRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, const ns5__UpdateUserWorkingAreasRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest), "ns5:UpdateUserWorkingAreasRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__UpdateUserWorkingAreasRequest::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__UpdateUserWorkingAreasRequest::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__UpdateUserWorkingAreasRequest::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateUserWorkingAreasRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateUserWorkingAreasRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasRequest * FASTCALL soap_in_ns5__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, ns5__UpdateUserWorkingAreasRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateUserWorkingAreasRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest, sizeof(ns5__UpdateUserWorkingAreasRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateUserWorkingAreasRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__UpdateUserWorkingAreasRequest::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__UpdateUserWorkingAreasRequest::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__UpdateUserWorkingAreasRequest::ns7__user == NULL)
						return NULL;
					*a->ns5__UpdateUserWorkingAreasRequest::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__UpdateUserWorkingAreasRequest::ns7__user, "ns7:User"))
				{	a->ns5__UpdateUserWorkingAreasRequest::__sizeuser++;
					a->ns5__UpdateUserWorkingAreasRequest::ns7__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateUserWorkingAreasRequest::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__UpdateUserWorkingAreasRequest::__sizeuser)
			a->ns5__UpdateUserWorkingAreasRequest::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__UpdateUserWorkingAreasRequest::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateUserWorkingAreasRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest, 0, sizeof(ns5__UpdateUserWorkingAreasRequest), 0, soap_copy_ns5__UpdateUserWorkingAreasRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->ns5__UpdateUserWorkingAreasRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__UpdateUserWorkingAreasRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest);
	return this->soap_out(soap, tag?tag:"ns5:UpdateUserWorkingAreasRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateUserWorkingAreasRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateUserWorkingAreasRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasRequest * SOAP_FMAC4 soap_get_ns5__UpdateUserWorkingAreasRequest(struct soap *soap, ns5__UpdateUserWorkingAreasRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateUserWorkingAreasRequest * FASTCALL soap_instantiate_ns5__UpdateUserWorkingAreasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateUserWorkingAreasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasRequest);
		ASSIGN_PTR(size, sizeof(ns5__UpdateUserWorkingAreasRequest));
		((ns5__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserWorkingAreasRequest));
		for(int i = 0; i < n; i++)
			((ns5__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateUserWorkingAreasRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateUserWorkingAreasRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateUserWorkingAreasRequest %p -> %p\n", q, p));
	*(ns5__UpdateUserWorkingAreasRequest*)p = *(ns5__UpdateUserWorkingAreasRequest*)q;
}

void ns5__UpdateUserAuthoritiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateUserAuthoritiesResponse::__sizeuser = 0;
	this->ns5__UpdateUserAuthoritiesResponse::ns7__user = NULL;
	/* transient soap skipped */
}

void ns5__UpdateUserAuthoritiesResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UpdateUserAuthoritiesResponse::ns7__user) {
		for(int i = 0; i < this->ns5__UpdateUserAuthoritiesResponse::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__UpdateUserAuthoritiesResponse::ns7__user + i);
		}
	}
	/* transient soap skipped */
}

int ns5__UpdateUserAuthoritiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateUserAuthoritiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, int id, const ns5__UpdateUserAuthoritiesResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse), "ns5:UpdateUserAuthoritiesResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->ns5__UpdateUserAuthoritiesResponse::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__UpdateUserAuthoritiesResponse::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__UpdateUserAuthoritiesResponse::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateUserAuthoritiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateUserAuthoritiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesResponse * FASTCALL soap_in_ns5__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, ns5__UpdateUserAuthoritiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateUserAuthoritiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse, sizeof(ns5__UpdateUserAuthoritiesResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateUserAuthoritiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__UpdateUserAuthoritiesResponse::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__UpdateUserAuthoritiesResponse::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__UpdateUserAuthoritiesResponse::ns7__user == NULL)
						return NULL;
					*a->ns5__UpdateUserAuthoritiesResponse::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__UpdateUserAuthoritiesResponse::ns7__user, "ns7:User"))
				{	a->ns5__UpdateUserAuthoritiesResponse::__sizeuser++;
					a->ns5__UpdateUserAuthoritiesResponse::ns7__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateUserAuthoritiesResponse::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__UpdateUserAuthoritiesResponse::__sizeuser)
			a->ns5__UpdateUserAuthoritiesResponse::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__UpdateUserAuthoritiesResponse::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateUserAuthoritiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse, 0, sizeof(ns5__UpdateUserAuthoritiesResponse), 0, soap_copy_ns5__UpdateUserAuthoritiesResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__UpdateUserAuthoritiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse);
	return this->soap_out(soap, tag?tag:"ns5:UpdateUserAuthoritiesResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateUserAuthoritiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateUserAuthoritiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesResponse * SOAP_FMAC4 soap_get_ns5__UpdateUserAuthoritiesResponse(struct soap *soap, ns5__UpdateUserAuthoritiesResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateUserAuthoritiesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateUserAuthoritiesResponse * FASTCALL soap_instantiate_ns5__UpdateUserAuthoritiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateUserAuthoritiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesResponse);
		ASSIGN_PTR(size, sizeof(ns5__UpdateUserAuthoritiesResponse));
		((ns5__UpdateUserAuthoritiesResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserAuthoritiesResponse));
		for(int i = 0; i < n; i++)
			((ns5__UpdateUserAuthoritiesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateUserAuthoritiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateUserAuthoritiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateUserAuthoritiesResponse %p -> %p\n", q, p));
	*(ns5__UpdateUserAuthoritiesResponse*)p = *(ns5__UpdateUserAuthoritiesResponse*)q;
}

void ns5__UpdateUserAuthoritiesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateUserAuthoritiesRequest::__sizeuser = 0;
	this->ns5__UpdateUserAuthoritiesRequest::ns7__user = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__UpdateUserAuthoritiesRequest::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UpdateUserAuthoritiesRequest::ns7__user) {
		for(int i = 0; i < this->ns5__UpdateUserAuthoritiesRequest::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__UpdateUserAuthoritiesRequest::ns7__user + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__UpdateUserAuthoritiesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateUserAuthoritiesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, const ns5__UpdateUserAuthoritiesRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest), "ns5:UpdateUserAuthoritiesRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__UpdateUserAuthoritiesRequest::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__UpdateUserAuthoritiesRequest::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__UpdateUserAuthoritiesRequest::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateUserAuthoritiesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateUserAuthoritiesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesRequest * FASTCALL soap_in_ns5__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, ns5__UpdateUserAuthoritiesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateUserAuthoritiesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest, sizeof(ns5__UpdateUserAuthoritiesRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateUserAuthoritiesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__UpdateUserAuthoritiesRequest::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__UpdateUserAuthoritiesRequest::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__UpdateUserAuthoritiesRequest::ns7__user == NULL)
						return NULL;
					*a->ns5__UpdateUserAuthoritiesRequest::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__UpdateUserAuthoritiesRequest::ns7__user, "ns7:User"))
				{	a->ns5__UpdateUserAuthoritiesRequest::__sizeuser++;
					a->ns5__UpdateUserAuthoritiesRequest::ns7__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateUserAuthoritiesRequest::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__UpdateUserAuthoritiesRequest::__sizeuser)
			a->ns5__UpdateUserAuthoritiesRequest::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__UpdateUserAuthoritiesRequest::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateUserAuthoritiesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest, 0, sizeof(ns5__UpdateUserAuthoritiesRequest), 0, soap_copy_ns5__UpdateUserAuthoritiesRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->ns5__UpdateUserAuthoritiesRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__UpdateUserAuthoritiesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest);
	return this->soap_out(soap, tag?tag:"ns5:UpdateUserAuthoritiesRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateUserAuthoritiesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateUserAuthoritiesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesRequest * SOAP_FMAC4 soap_get_ns5__UpdateUserAuthoritiesRequest(struct soap *soap, ns5__UpdateUserAuthoritiesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateUserAuthoritiesRequest * FASTCALL soap_instantiate_ns5__UpdateUserAuthoritiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateUserAuthoritiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesRequest);
		ASSIGN_PTR(size, sizeof(ns5__UpdateUserAuthoritiesRequest));
		((ns5__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserAuthoritiesRequest));
		for(int i = 0; i < n; i++)
			((ns5__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateUserAuthoritiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateUserAuthoritiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateUserAuthoritiesRequest %p -> %p\n", q, p));
	*(ns5__UpdateUserAuthoritiesRequest*)p = *(ns5__UpdateUserAuthoritiesRequest*)q;
}

void ns5__GetBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetBusinessEntityUserResponse::ns7__user = NULL;
	/* transient soap skipped */
}

void ns5__GetBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__User(soap, &this->ns5__GetBusinessEntityUserResponse::ns7__user);
	/* transient soap skipped */
}

int ns5__GetBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const ns5__GetBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetBusinessEntityUserResponse), "ns5:GetBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__user)
		soap_element_result(soap, "ns7:user");
	if(soap_out_PointerTons7__User(soap, "ns7:user", -1, &(a->ns5__GetBusinessEntityUserResponse::ns7__user), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserResponse * FASTCALL soap_in_ns5__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetBusinessEntityUserResponse, sizeof(ns5__GetBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__user1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__user1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns7:user", &(a->ns5__GetBusinessEntityUserResponse::ns7__user), "ns7:User"))
				{	soap_flag_ns7__user1--;
					continue;
				}
			soap_check_result(soap, "ns7:user");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetBusinessEntityUserResponse, 0, sizeof(ns5__GetBusinessEntityUserResponse), 0, soap_copy_ns5__GetBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__GetBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserResponse * SOAP_FMAC4 soap_get_ns5__GetBusinessEntityUserResponse(struct soap *soap, ns5__GetBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetBusinessEntityUserResponse * FASTCALL soap_instantiate_ns5__GetBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserResponse));
		((ns5__GetBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetBusinessEntityUserResponse %p -> %p\n", q, p));
	*(ns5__GetBusinessEntityUserResponse*)p = *(ns5__GetBusinessEntityUserResponse*)q;
}

void ns5__GetBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetBusinessEntityUserRequest::ns7__user = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__User(soap, &this->ns5__GetBusinessEntityUserRequest::ns7__user);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const ns5__GetBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetBusinessEntityUserRequest), "ns5:GetBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__GetBusinessEntityUserRequest::ns7__user) {
		if(soap_out_PointerTons7__User(soap, "ns7:user", -1, &a->ns5__GetBusinessEntityUserRequest::ns7__user, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:user"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserRequest * FASTCALL soap_in_ns5__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetBusinessEntityUserRequest, sizeof(ns5__GetBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns7__user1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns7__user1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns7:user", &(a->ns5__GetBusinessEntityUserRequest::ns7__user), "ns7:User"))
				{	soap_flag_ns7__user1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetBusinessEntityUserRequest, 0, sizeof(ns5__GetBusinessEntityUserRequest), 0, soap_copy_ns5__GetBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns7__user1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserRequest * SOAP_FMAC4 soap_get_ns5__GetBusinessEntityUserRequest(struct soap *soap, ns5__GetBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetBusinessEntityUserRequest * FASTCALL soap_instantiate_ns5__GetBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserRequest));
		((ns5__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetBusinessEntityUserRequest %p -> %p\n", q, p));
	*(ns5__GetBusinessEntityUserRequest*)p = *(ns5__GetBusinessEntityUserRequest*)q;
}

void ns5__GetBusinessEntityUserListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetBusinessEntityUserListResponse::ns7__userList = NULL;
	/* transient soap skipped */
}

void ns5__GetBusinessEntityUserListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__UserList(soap, &this->ns5__GetBusinessEntityUserListResponse::ns7__userList);
	/* transient soap skipped */
}

int ns5__GetBusinessEntityUserListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetBusinessEntityUserListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, int id, const ns5__GetBusinessEntityUserListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse), "ns5:GetBusinessEntityUserListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__userList)
		soap_element_result(soap, "ns7:userList");
	if(soap_out_PointerTons7__UserList(soap, "ns7:userList", -1, &(a->ns5__GetBusinessEntityUserListResponse::ns7__userList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetBusinessEntityUserListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetBusinessEntityUserListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListResponse * FASTCALL soap_in_ns5__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetBusinessEntityUserListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse, sizeof(ns5__GetBusinessEntityUserListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetBusinessEntityUserListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetBusinessEntityUserListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__userList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__userList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__UserList(soap, "ns7:userList", &(a->ns5__GetBusinessEntityUserListResponse::ns7__userList), "ns7:UserList"))
				{	soap_flag_ns7__userList1--;
					continue;
				}
			soap_check_result(soap, "ns7:userList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetBusinessEntityUserListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse, 0, sizeof(ns5__GetBusinessEntityUserListResponse), 0, soap_copy_ns5__GetBusinessEntityUserListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__GetBusinessEntityUserListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetBusinessEntityUserListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetBusinessEntityUserListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetBusinessEntityUserListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListResponse * SOAP_FMAC4 soap_get_ns5__GetBusinessEntityUserListResponse(struct soap *soap, ns5__GetBusinessEntityUserListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetBusinessEntityUserListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetBusinessEntityUserListResponse * FASTCALL soap_instantiate_ns5__GetBusinessEntityUserListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetBusinessEntityUserListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserListResponse));
		((ns5__GetBusinessEntityUserListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetBusinessEntityUserListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetBusinessEntityUserListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetBusinessEntityUserListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetBusinessEntityUserListResponse %p -> %p\n", q, p));
	*(ns5__GetBusinessEntityUserListResponse*)p = *(ns5__GetBusinessEntityUserListResponse*)q;
}

void ns5__GetBusinessEntityUserListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetBusinessEntityUserListRequest::ns3__listOptions = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetBusinessEntityUserListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetBusinessEntityUserListRequest::ns3__listOptions);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetBusinessEntityUserListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetBusinessEntityUserListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, const ns5__GetBusinessEntityUserListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest), "ns5:GetBusinessEntityUserListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetBusinessEntityUserListRequest::ns3__listOptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetBusinessEntityUserListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetBusinessEntityUserListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListRequest * FASTCALL soap_in_ns5__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetBusinessEntityUserListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest, sizeof(ns5__GetBusinessEntityUserListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetBusinessEntityUserListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetBusinessEntityUserListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetBusinessEntityUserListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetBusinessEntityUserListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest, 0, sizeof(ns5__GetBusinessEntityUserListRequest), 0, soap_copy_ns5__GetBusinessEntityUserListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetBusinessEntityUserListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetBusinessEntityUserListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetBusinessEntityUserListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetBusinessEntityUserListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListRequest * SOAP_FMAC4 soap_get_ns5__GetBusinessEntityUserListRequest(struct soap *soap, ns5__GetBusinessEntityUserListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetBusinessEntityUserListRequest * FASTCALL soap_instantiate_ns5__GetBusinessEntityUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetBusinessEntityUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserListRequest));
		((ns5__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetBusinessEntityUserListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetBusinessEntityUserListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetBusinessEntityUserListRequest %p -> %p\n", q, p));
	*(ns5__GetBusinessEntityUserListRequest*)p = *(ns5__GetBusinessEntityUserListRequest*)q;
}

void ns5__AddBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__AddBusinessEntityUserResponse::__sizeuser = 0;
	this->ns5__AddBusinessEntityUserResponse::ns7__user = NULL;
	/* transient soap skipped */
}

void ns5__AddBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__AddBusinessEntityUserResponse::ns7__user) {
		for(int i = 0; i < this->ns5__AddBusinessEntityUserResponse::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__AddBusinessEntityUserResponse::ns7__user + i);
		}
	}
	/* transient soap skipped */
}

int ns5__AddBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__AddBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const ns5__AddBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__AddBusinessEntityUserResponse), "ns5:AddBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->ns5__AddBusinessEntityUserResponse::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__AddBusinessEntityUserResponse::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__AddBusinessEntityUserResponse::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__AddBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__AddBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserResponse * FASTCALL soap_in_ns5__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, ns5__AddBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__AddBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AddBusinessEntityUserResponse, sizeof(ns5__AddBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__AddBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__AddBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__AddBusinessEntityUserResponse::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__AddBusinessEntityUserResponse::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__AddBusinessEntityUserResponse::ns7__user == NULL)
						return NULL;
					*a->ns5__AddBusinessEntityUserResponse::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__AddBusinessEntityUserResponse::ns7__user, "ns7:User"))
				{	a->ns5__AddBusinessEntityUserResponse::__sizeuser++;
					a->ns5__AddBusinessEntityUserResponse::ns7__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__AddBusinessEntityUserResponse::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__AddBusinessEntityUserResponse::__sizeuser)
			a->ns5__AddBusinessEntityUserResponse::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__AddBusinessEntityUserResponse::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__AddBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AddBusinessEntityUserResponse, 0, sizeof(ns5__AddBusinessEntityUserResponse), 0, soap_copy_ns5__AddBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__AddBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__AddBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"ns5:AddBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__AddBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__AddBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserResponse * SOAP_FMAC4 soap_get_ns5__AddBusinessEntityUserResponse(struct soap *soap, ns5__AddBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__AddBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__AddBusinessEntityUserResponse * FASTCALL soap_instantiate_ns5__AddBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__AddBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__AddBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(ns5__AddBusinessEntityUserResponse));
		((ns5__AddBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__AddBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((ns5__AddBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__AddBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__AddBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__AddBusinessEntityUserResponse %p -> %p\n", q, p));
	*(ns5__AddBusinessEntityUserResponse*)p = *(ns5__AddBusinessEntityUserResponse*)q;
}

void ns5__AddBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__AddBusinessEntityUserRequest::__sizeuser = 0;
	this->ns5__AddBusinessEntityUserRequest::ns7__user = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__AddBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	if(this->ns5__AddBusinessEntityUserRequest::ns7__user) {
		for(int i = 0; i < this->ns5__AddBusinessEntityUserRequest::__sizeuser; i++) {
			soap_serialize_PointerTons7__User(soap, this->ns5__AddBusinessEntityUserRequest::ns7__user + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__AddBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__AddBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const ns5__AddBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__AddBusinessEntityUserRequest), "ns5:AddBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__AddBusinessEntityUserRequest::ns7__user) {
		int i;
		for(i = 0; i < a->ns5__AddBusinessEntityUserRequest::__sizeuser; i++)
			if(soap_out_PointerTons7__User(soap, "ns7:user", -1, a->ns5__AddBusinessEntityUserRequest::ns7__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__AddBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__AddBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserRequest * FASTCALL soap_in_ns5__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, ns5__AddBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__AddBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AddBusinessEntityUserRequest, sizeof(ns5__AddBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__AddBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__AddBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_ns7__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:user", 1, NULL)) {
				if(a->ns5__AddBusinessEntityUserRequest::ns7__user == NULL) {
					if(soap_blist_ns7__user1 == NULL)
						soap_blist_ns7__user1 = soap_new_block(soap);
					a->ns5__AddBusinessEntityUserRequest::ns7__user = (ns7__User **)soap_push_block(soap, soap_blist_ns7__user1, sizeof(ns7__User *));
					if(a->ns5__AddBusinessEntityUserRequest::ns7__user == NULL)
						return NULL;
					*a->ns5__AddBusinessEntityUserRequest::ns7__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__User(soap, "ns7:user", a->ns5__AddBusinessEntityUserRequest::ns7__user, "ns7:User"))
				{	a->ns5__AddBusinessEntityUserRequest::__sizeuser++;
					a->ns5__AddBusinessEntityUserRequest::ns7__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__AddBusinessEntityUserRequest::ns7__user)
			soap_pop_block(soap, soap_blist_ns7__user1);
		if(a->ns5__AddBusinessEntityUserRequest::__sizeuser)
			a->ns5__AddBusinessEntityUserRequest::ns7__user = (ns7__User **)soap_save_block(soap, soap_blist_ns7__user1, NULL, 1);
		else
		{	a->ns5__AddBusinessEntityUserRequest::ns7__user = NULL;
			if(soap_blist_ns7__user1)
				soap_end_block(soap, soap_blist_ns7__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__AddBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AddBusinessEntityUserRequest, 0, sizeof(ns5__AddBusinessEntityUserRequest), 0, soap_copy_ns5__AddBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->ns5__AddBusinessEntityUserRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__AddBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__AddBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"ns5:AddBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__AddBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__AddBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserRequest * SOAP_FMAC4 soap_get_ns5__AddBusinessEntityUserRequest(struct soap *soap, ns5__AddBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__AddBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__AddBusinessEntityUserRequest * FASTCALL soap_instantiate_ns5__AddBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__AddBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__AddBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(ns5__AddBusinessEntityUserRequest));
		((ns5__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__AddBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((ns5__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__AddBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__AddBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__AddBusinessEntityUserRequest %p -> %p\n", q, p));
	*(ns5__AddBusinessEntityUserRequest*)p = *(ns5__AddBusinessEntityUserRequest*)q;
}

void ns5__CheckShipmentRegionalizationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__CheckShipmentRegionalizationResponse::__sizer13nRouteSection = 0;
	this->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection = NULL;
	/* transient soap skipped */
}

void ns5__CheckShipmentRegionalizationResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection) {
		for(int i = 0; i < this->ns5__CheckShipmentRegionalizationResponse::__sizer13nRouteSection; i++) {
			soap_serialize_PointerTons7__RouteSectionR13nRules(soap, this->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection + i);
		}
	}
	/* transient soap skipped */
}

int ns5__CheckShipmentRegionalizationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CheckShipmentRegionalizationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, int id, const ns5__CheckShipmentRegionalizationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse), "ns5:CheckShipmentRegionalizationResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizer13nRouteSection");
	if(a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection) {
		int i;
		for(i = 0; i < a->ns5__CheckShipmentRegionalizationResponse::__sizer13nRouteSection; i++)
			if(soap_out_PointerTons7__RouteSectionR13nRules(soap, "ns7:r13nRouteSection", -1, a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__CheckShipmentRegionalizationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__CheckShipmentRegionalizationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationResponse * FASTCALL soap_in_ns5__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, ns5__CheckShipmentRegionalizationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CheckShipmentRegionalizationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse, sizeof(ns5__CheckShipmentRegionalizationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__CheckShipmentRegionalizationResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__r13nRouteSection1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:r13nRouteSection", 1, NULL)) {
				if(a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection == NULL) {
					if(soap_blist_ns7__r13nRouteSection1 == NULL)
						soap_blist_ns7__r13nRouteSection1 = soap_new_block(soap);
					a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection = (ns7__RouteSectionR13nRules **)soap_push_block(soap, soap_blist_ns7__r13nRouteSection1, sizeof(ns7__RouteSectionR13nRules *));
					if(a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection == NULL)
						return NULL;
					*a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__RouteSectionR13nRules(soap, "ns7:r13nRouteSection", a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection, "ns7:RouteSectionR13nRules"))
				{	a->ns5__CheckShipmentRegionalizationResponse::__sizer13nRouteSection++;
					a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizer13nRouteSection");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection)
			soap_pop_block(soap, soap_blist_ns7__r13nRouteSection1);
		if(a->ns5__CheckShipmentRegionalizationResponse::__sizer13nRouteSection)
			a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection = (ns7__RouteSectionR13nRules **)soap_save_block(soap, soap_blist_ns7__r13nRouteSection1, NULL, 1);
		else
		{	a->ns5__CheckShipmentRegionalizationResponse::ns7__r13nRouteSection = NULL;
			if(soap_blist_ns7__r13nRouteSection1)
				soap_end_block(soap, soap_blist_ns7__r13nRouteSection1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__CheckShipmentRegionalizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse, 0, sizeof(ns5__CheckShipmentRegionalizationResponse), 0, soap_copy_ns5__CheckShipmentRegionalizationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__CheckShipmentRegionalizationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse);
	return this->soap_out(soap, tag?tag:"ns5:CheckShipmentRegionalizationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__CheckShipmentRegionalizationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CheckShipmentRegionalizationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationResponse * SOAP_FMAC4 soap_get_ns5__CheckShipmentRegionalizationResponse(struct soap *soap, ns5__CheckShipmentRegionalizationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__CheckShipmentRegionalizationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__CheckShipmentRegionalizationResponse * FASTCALL soap_instantiate_ns5__CheckShipmentRegionalizationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__CheckShipmentRegionalizationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationResponse);
		ASSIGN_PTR(size, sizeof(ns5__CheckShipmentRegionalizationResponse));
		((ns5__CheckShipmentRegionalizationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__CheckShipmentRegionalizationResponse));
		for(int i = 0; i < n; i++)
			((ns5__CheckShipmentRegionalizationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__CheckShipmentRegionalizationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__CheckShipmentRegionalizationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__CheckShipmentRegionalizationResponse %p -> %p\n", q, p));
	*(ns5__CheckShipmentRegionalizationResponse*)p = *(ns5__CheckShipmentRegionalizationResponse*)q;
}

void ns5__CheckShipmentRegionalizationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__CheckShipmentRegionalizationRequest::__sizecargoType = 0;
	this->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType = NULL;
	this->ns5__CheckShipmentRegionalizationRequest::ns7__shipmentRoute = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__CheckShipmentRegionalizationRequest::soap_serialize(struct soap *soap) const
{
	if(this->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType) {
		for(int i = 0; i < this->ns5__CheckShipmentRegionalizationRequest::__sizecargoType; i++) {
			soap_serialize_PointerTons6__SubProduct(soap, this->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType + i);
		}
	}
	soap_serialize_PointerTons7__ShipmentRoute(soap, &this->ns5__CheckShipmentRegionalizationRequest::ns7__shipmentRoute);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__CheckShipmentRegionalizationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__CheckShipmentRegionalizationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, const ns5__CheckShipmentRegionalizationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest), "ns5:CheckShipmentRegionalizationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType) {
		int i;
		for(i = 0; i < a->ns5__CheckShipmentRegionalizationRequest::__sizecargoType; i++)
			if(soap_out_PointerTons6__SubProduct(soap, "ns6:cargoType", -1, a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType + i, ""))
				return soap->error;
	}
	if(a->ns5__CheckShipmentRegionalizationRequest::ns7__shipmentRoute) {
		if(soap_out_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", -1, &a->ns5__CheckShipmentRegionalizationRequest::ns7__shipmentRoute, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:shipmentRoute"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__CheckShipmentRegionalizationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__CheckShipmentRegionalizationRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationRequest * FASTCALL soap_in_ns5__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, ns5__CheckShipmentRegionalizationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__CheckShipmentRegionalizationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest, sizeof(ns5__CheckShipmentRegionalizationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__CheckShipmentRegionalizationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_ns6__cargoType1 = NULL;
	size_t soap_flag_ns7__shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:cargoType", 1, NULL)) {
				if(a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType == NULL) {
					if(soap_blist_ns6__cargoType1 == NULL)
						soap_blist_ns6__cargoType1 = soap_new_block(soap);
					a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType = (ns6__SubProduct **)soap_push_block(soap, soap_blist_ns6__cargoType1, sizeof(ns6__SubProduct *));
					if(a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType == NULL)
						return NULL;
					*a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__SubProduct(soap, "ns6:cargoType", a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType, "ns6:SubProduct"))
				{	a->ns5__CheckShipmentRegionalizationRequest::__sizecargoType++;
					a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType = NULL;
					continue;
				}
			}
			if(soap_flag_ns7__shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", &(a->ns5__CheckShipmentRegionalizationRequest::ns7__shipmentRoute), "ns7:ShipmentRoute"))
				{	soap_flag_ns7__shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType)
			soap_pop_block(soap, soap_blist_ns6__cargoType1);
		if(a->ns5__CheckShipmentRegionalizationRequest::__sizecargoType)
			a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType = (ns6__SubProduct **)soap_save_block(soap, soap_blist_ns6__cargoType1, NULL, 1);
		else
		{	a->ns5__CheckShipmentRegionalizationRequest::ns6__cargoType = NULL;
			if(soap_blist_ns6__cargoType1)
				soap_end_block(soap, soap_blist_ns6__cargoType1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__CheckShipmentRegionalizationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest, 0, sizeof(ns5__CheckShipmentRegionalizationRequest), 0, soap_copy_ns5__CheckShipmentRegionalizationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->ns5__CheckShipmentRegionalizationRequest::__sizecargoType < 1 || soap_flag_ns7__shipmentRoute1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__CheckShipmentRegionalizationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest);
	return this->soap_out(soap, tag?tag:"ns5:CheckShipmentRegionalizationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__CheckShipmentRegionalizationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__CheckShipmentRegionalizationRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationRequest * SOAP_FMAC4 soap_get_ns5__CheckShipmentRegionalizationRequest(struct soap *soap, ns5__CheckShipmentRegionalizationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__CheckShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__CheckShipmentRegionalizationRequest * FASTCALL soap_instantiate_ns5__CheckShipmentRegionalizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__CheckShipmentRegionalizationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationRequest);
		ASSIGN_PTR(size, sizeof(ns5__CheckShipmentRegionalizationRequest));
		((ns5__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__CheckShipmentRegionalizationRequest));
		for(int i = 0; i < n; i++)
			((ns5__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__CheckShipmentRegionalizationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__CheckShipmentRegionalizationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__CheckShipmentRegionalizationRequest %p -> %p\n", q, p));
	*(ns5__CheckShipmentRegionalizationRequest*)p = *(ns5__CheckShipmentRegionalizationRequest*)q;
}

void ns5__UpdateVeterinaryEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateVeterinaryEventsResponse::__sizestockEntry = 0;
	this->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry = NULL;
	/* transient soap skipped */
}

void ns5__UpdateVeterinaryEventsResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry) {
		for(int i = 0; i < this->ns5__UpdateVeterinaryEventsResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int ns5__UpdateVeterinaryEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateVeterinaryEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, int id, const ns5__UpdateVeterinaryEventsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse), "ns5:UpdateVeterinaryEventsResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry) {
		int i;
		for(i = 0; i < a->ns5__UpdateVeterinaryEventsResponse::__sizestockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns7:stockEntry", -1, a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateVeterinaryEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateVeterinaryEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsResponse * FASTCALL soap_in_ns5__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, ns5__UpdateVeterinaryEventsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateVeterinaryEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse, sizeof(ns5__UpdateVeterinaryEventsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateVeterinaryEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:stockEntry", 1, NULL)) {
				if(a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry == NULL) {
					if(soap_blist_ns7__stockEntry1 == NULL)
						soap_blist_ns7__stockEntry1 = soap_new_block(soap);
					a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_ns7__stockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry == NULL)
						return NULL;
					*a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:stockEntry", a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry, "ns7:StockEntry"))
				{	a->ns5__UpdateVeterinaryEventsResponse::__sizestockEntry++;
					a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry)
			soap_pop_block(soap, soap_blist_ns7__stockEntry1);
		if(a->ns5__UpdateVeterinaryEventsResponse::__sizestockEntry)
			a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_ns7__stockEntry1, NULL, 1);
		else
		{	a->ns5__UpdateVeterinaryEventsResponse::ns7__stockEntry = NULL;
			if(soap_blist_ns7__stockEntry1)
				soap_end_block(soap, soap_blist_ns7__stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateVeterinaryEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse, 0, sizeof(ns5__UpdateVeterinaryEventsResponse), 0, soap_copy_ns5__UpdateVeterinaryEventsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__UpdateVeterinaryEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse);
	return this->soap_out(soap, tag?tag:"ns5:UpdateVeterinaryEventsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateVeterinaryEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateVeterinaryEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsResponse * SOAP_FMAC4 soap_get_ns5__UpdateVeterinaryEventsResponse(struct soap *soap, ns5__UpdateVeterinaryEventsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateVeterinaryEventsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateVeterinaryEventsResponse * FASTCALL soap_instantiate_ns5__UpdateVeterinaryEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateVeterinaryEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsResponse);
		ASSIGN_PTR(size, sizeof(ns5__UpdateVeterinaryEventsResponse));
		((ns5__UpdateVeterinaryEventsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateVeterinaryEventsResponse));
		for(int i = 0; i < n; i++)
			((ns5__UpdateVeterinaryEventsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateVeterinaryEventsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateVeterinaryEventsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateVeterinaryEventsResponse %p -> %p\n", q, p));
	*(ns5__UpdateVeterinaryEventsResponse*)p = *(ns5__UpdateVeterinaryEventsResponse*)q;
}

void ns5__UpdateVeterinaryEventsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateVeterinaryEventsRequest::enterprise = NULL;
	this->ns5__UpdateVeterinaryEventsRequest::__sizestockEntry = 0;
	this->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__UpdateVeterinaryEventsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns5__UpdateVeterinaryEventsRequest::enterprise);
	if(this->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry) {
		for(int i = 0; i < this->ns5__UpdateVeterinaryEventsRequest::__sizestockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__UpdateVeterinaryEventsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateVeterinaryEventsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, const ns5__UpdateVeterinaryEventsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest), "ns5:UpdateVeterinaryEventsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__UpdateVeterinaryEventsRequest::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns5:enterprise", -1, &a->ns5__UpdateVeterinaryEventsRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:enterprise"))
		return soap->error;
	if(a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry) {
		int i;
		for(i = 0; i < a->ns5__UpdateVeterinaryEventsRequest::__sizestockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns7:stockEntry", -1, a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateVeterinaryEventsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateVeterinaryEventsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsRequest * FASTCALL soap_in_ns5__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, ns5__UpdateVeterinaryEventsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateVeterinaryEventsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest, sizeof(ns5__UpdateVeterinaryEventsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateVeterinaryEventsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	struct soap_blist *soap_blist_ns7__stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns5:enterprise", &(a->ns5__UpdateVeterinaryEventsRequest::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:stockEntry", 1, NULL)) {
				if(a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry == NULL) {
					if(soap_blist_ns7__stockEntry1 == NULL)
						soap_blist_ns7__stockEntry1 = soap_new_block(soap);
					a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_ns7__stockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry == NULL)
						return NULL;
					*a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:stockEntry", a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry, "ns7:StockEntry"))
				{	a->ns5__UpdateVeterinaryEventsRequest::__sizestockEntry++;
					a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry)
			soap_pop_block(soap, soap_blist_ns7__stockEntry1);
		if(a->ns5__UpdateVeterinaryEventsRequest::__sizestockEntry)
			a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_ns7__stockEntry1, NULL, 1);
		else
		{	a->ns5__UpdateVeterinaryEventsRequest::ns7__stockEntry = NULL;
			if(soap_blist_ns7__stockEntry1)
				soap_end_block(soap, soap_blist_ns7__stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateVeterinaryEventsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest, 0, sizeof(ns5__UpdateVeterinaryEventsRequest), 0, soap_copy_ns5__UpdateVeterinaryEventsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || a->ns5__UpdateVeterinaryEventsRequest::__sizestockEntry < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__UpdateVeterinaryEventsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest);
	return this->soap_out(soap, tag?tag:"ns5:UpdateVeterinaryEventsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateVeterinaryEventsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateVeterinaryEventsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsRequest * SOAP_FMAC4 soap_get_ns5__UpdateVeterinaryEventsRequest(struct soap *soap, ns5__UpdateVeterinaryEventsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateVeterinaryEventsRequest * FASTCALL soap_instantiate_ns5__UpdateVeterinaryEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateVeterinaryEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsRequest);
		ASSIGN_PTR(size, sizeof(ns5__UpdateVeterinaryEventsRequest));
		((ns5__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateVeterinaryEventsRequest));
		for(int i = 0; i < n; i++)
			((ns5__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateVeterinaryEventsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateVeterinaryEventsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateVeterinaryEventsRequest %p -> %p\n", q, p));
	*(ns5__UpdateVeterinaryEventsRequest*)p = *(ns5__UpdateVeterinaryEventsRequest*)q;
}

void ns5__UpdateTransportMovementDetailsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateTransportMovementDetailsResponse::__sizevetDocument = 0;
	this->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument = NULL;
	/* transient soap skipped */
}

void ns5__UpdateTransportMovementDetailsResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument) {
		for(int i = 0; i < this->ns5__UpdateTransportMovementDetailsResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int ns5__UpdateTransportMovementDetailsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateTransportMovementDetailsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, int id, const ns5__UpdateTransportMovementDetailsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse), "ns5:UpdateTransportMovementDetailsResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizevetDocument");
	if(a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument) {
		int i;
		for(i = 0; i < a->ns5__UpdateTransportMovementDetailsResponse::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns7:vetDocument", -1, a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateTransportMovementDetailsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateTransportMovementDetailsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsResponse * FASTCALL soap_in_ns5__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, ns5__UpdateTransportMovementDetailsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateTransportMovementDetailsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse, sizeof(ns5__UpdateTransportMovementDetailsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateTransportMovementDetailsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ns7__vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:vetDocument", 1, NULL)) {
				if(a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument == NULL) {
					if(soap_blist_ns7__vetDocument1 == NULL)
						soap_blist_ns7__vetDocument1 = soap_new_block(soap);
					a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_ns7__vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument == NULL)
						return NULL;
					*a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns7:vetDocument", a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument, "ns7:VetDocument"))
				{	a->ns5__UpdateTransportMovementDetailsResponse::__sizevetDocument++;
					a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizevetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument)
			soap_pop_block(soap, soap_blist_ns7__vetDocument1);
		if(a->ns5__UpdateTransportMovementDetailsResponse::__sizevetDocument)
			a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_ns7__vetDocument1, NULL, 1);
		else
		{	a->ns5__UpdateTransportMovementDetailsResponse::ns7__vetDocument = NULL;
			if(soap_blist_ns7__vetDocument1)
				soap_end_block(soap, soap_blist_ns7__vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateTransportMovementDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse, 0, sizeof(ns5__UpdateTransportMovementDetailsResponse), 0, soap_copy_ns5__UpdateTransportMovementDetailsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__UpdateTransportMovementDetailsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse);
	return this->soap_out(soap, tag?tag:"ns5:UpdateTransportMovementDetailsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateTransportMovementDetailsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateTransportMovementDetailsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsResponse * SOAP_FMAC4 soap_get_ns5__UpdateTransportMovementDetailsResponse(struct soap *soap, ns5__UpdateTransportMovementDetailsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateTransportMovementDetailsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateTransportMovementDetailsResponse * FASTCALL soap_instantiate_ns5__UpdateTransportMovementDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateTransportMovementDetailsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsResponse);
		ASSIGN_PTR(size, sizeof(ns5__UpdateTransportMovementDetailsResponse));
		((ns5__UpdateTransportMovementDetailsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateTransportMovementDetailsResponse));
		for(int i = 0; i < n; i++)
			((ns5__UpdateTransportMovementDetailsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateTransportMovementDetailsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateTransportMovementDetailsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateTransportMovementDetailsResponse %p -> %p\n", q, p));
	*(ns5__UpdateTransportMovementDetailsResponse*)p = *(ns5__UpdateTransportMovementDetailsResponse*)q;
}

void ns5__UpdateTransportMovementDetailsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__UpdateTransportMovementDetailsRequest::ns7__deliveryParticipant = NULL;
	this->ns5__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid = 0;
	this->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid = NULL;
	this->ns5__UpdateTransportMovementDetailsRequest::ns7__shipmentRoute = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__UpdateTransportMovementDetailsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessMember(soap, &this->ns5__UpdateTransportMovementDetailsRequest::ns7__deliveryParticipant);
	if(this->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid) {
		for(int i = 0; i < this->ns5__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid; i++) {
			soap_serialize_ns3__UUID(soap, this->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid + i);
		}
	}
	soap_serialize_PointerTons7__ShipmentRoute(soap, &this->ns5__UpdateTransportMovementDetailsRequest::ns7__shipmentRoute);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__UpdateTransportMovementDetailsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UpdateTransportMovementDetailsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, const ns5__UpdateTransportMovementDetailsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest), "ns5:UpdateTransportMovementDetailsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__UpdateTransportMovementDetailsRequest::ns7__deliveryParticipant) {
		if(soap_out_PointerTons6__BusinessMember(soap, "ns7:deliveryParticipant", -1, &a->ns5__UpdateTransportMovementDetailsRequest::ns7__deliveryParticipant, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:deliveryParticipant"))
		return soap->error;
	if(a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid) {
		int i;
		for(i = 0; i < a->ns5__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid; i++)
			if(soap_out_ns3__UUID(soap, "ns7:vetDocumentUuid", -1, a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid + i, ""))
				return soap->error;
	}
	if(a->ns5__UpdateTransportMovementDetailsRequest::ns7__shipmentRoute) {
		if(soap_out_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", -1, &a->ns5__UpdateTransportMovementDetailsRequest::ns7__shipmentRoute, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:shipmentRoute"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__UpdateTransportMovementDetailsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__UpdateTransportMovementDetailsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsRequest * FASTCALL soap_in_ns5__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, ns5__UpdateTransportMovementDetailsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UpdateTransportMovementDetailsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest, sizeof(ns5__UpdateTransportMovementDetailsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UpdateTransportMovementDetailsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns7__deliveryParticipant1 = 1;
	struct soap_blist *soap_blist_ns7__vetDocumentUuid1 = NULL;
	size_t soap_flag_ns7__shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns7__deliveryParticipant1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessMember(soap, "ns7:deliveryParticipant", &(a->ns5__UpdateTransportMovementDetailsRequest::ns7__deliveryParticipant), "ns6:BusinessMember"))
				{	soap_flag_ns7__deliveryParticipant1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:vetDocumentUuid", 1, NULL)) {
				if(a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid == NULL) {
					if(soap_blist_ns7__vetDocumentUuid1 == NULL)
						soap_blist_ns7__vetDocumentUuid1 = soap_new_block(soap);
					a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid = (char **)soap_push_block(soap, soap_blist_ns7__vetDocumentUuid1, sizeof(char *));
					if(a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid == NULL)
						return NULL;
					*a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid = NULL;
				}
				soap_revert(soap);
				if(soap_in_ns3__UUID(soap, "ns7:vetDocumentUuid", a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid, "ns3:UUID"))
				{	a->ns5__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid++;
					a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid = NULL;
					continue;
				}
			}
			if(soap_flag_ns7__shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ShipmentRoute(soap, "ns7:shipmentRoute", &(a->ns5__UpdateTransportMovementDetailsRequest::ns7__shipmentRoute), "ns7:ShipmentRoute"))
				{	soap_flag_ns7__shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid)
			soap_pop_block(soap, soap_blist_ns7__vetDocumentUuid1);
		if(a->ns5__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid)
			a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid = (char **)soap_save_block(soap, soap_blist_ns7__vetDocumentUuid1, NULL, 1);
		else
		{	a->ns5__UpdateTransportMovementDetailsRequest::ns7__vetDocumentUuid = NULL;
			if(soap_blist_ns7__vetDocumentUuid1)
				soap_end_block(soap, soap_blist_ns7__vetDocumentUuid1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__UpdateTransportMovementDetailsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest, 0, sizeof(ns5__UpdateTransportMovementDetailsRequest), 0, soap_copy_ns5__UpdateTransportMovementDetailsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns7__deliveryParticipant1 > 0 || a->ns5__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid < 1 || soap_flag_ns7__shipmentRoute1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__UpdateTransportMovementDetailsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest);
	return this->soap_out(soap, tag?tag:"ns5:UpdateTransportMovementDetailsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__UpdateTransportMovementDetailsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UpdateTransportMovementDetailsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsRequest * SOAP_FMAC4 soap_get_ns5__UpdateTransportMovementDetailsRequest(struct soap *soap, ns5__UpdateTransportMovementDetailsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__UpdateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UpdateTransportMovementDetailsRequest * FASTCALL soap_instantiate_ns5__UpdateTransportMovementDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UpdateTransportMovementDetailsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsRequest);
		ASSIGN_PTR(size, sizeof(ns5__UpdateTransportMovementDetailsRequest));
		((ns5__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__UpdateTransportMovementDetailsRequest));
		for(int i = 0; i < n; i++)
			((ns5__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UpdateTransportMovementDetailsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UpdateTransportMovementDetailsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UpdateTransportMovementDetailsRequest %p -> %p\n", q, p));
	*(ns5__UpdateTransportMovementDetailsRequest*)p = *(ns5__UpdateTransportMovementDetailsRequest*)q;
}

void ns5__GetStockEntryVersionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryVersionListResponse::ns7__stockEntryList = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryVersionListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns5__GetStockEntryVersionListResponse::ns7__stockEntryList);
	/* transient soap skipped */
}

int ns5__GetStockEntryVersionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryVersionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryVersionListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryVersionListResponse), "ns5:GetStockEntryVersionListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__stockEntryList)
		soap_element_result(soap, "ns7:stockEntryList");
	if(a->ns5__GetStockEntryVersionListResponse::ns7__stockEntryList) {
		if(soap_out_PointerTons7__StockEntryList(soap, "ns7:stockEntryList", -1, &a->ns5__GetStockEntryVersionListResponse::ns7__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryVersionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryVersionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListResponse * FASTCALL soap_in_ns5__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, ns5__GetStockEntryVersionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryVersionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryVersionListResponse, sizeof(ns5__GetStockEntryVersionListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryVersionListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryVersionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns7:stockEntryList", &(a->ns5__GetStockEntryVersionListResponse::ns7__stockEntryList), "ns7:StockEntryList"))
				{	soap_flag_ns7__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "ns7:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryVersionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryVersionListResponse, 0, sizeof(ns5__GetStockEntryVersionListResponse), 0, soap_copy_ns5__GetStockEntryVersionListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryVersionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryVersionListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryVersionListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryVersionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryVersionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListResponse * SOAP_FMAC4 soap_get_ns5__GetStockEntryVersionListResponse(struct soap *soap, ns5__GetStockEntryVersionListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryVersionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryVersionListResponse * FASTCALL soap_instantiate_ns5__GetStockEntryVersionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryVersionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryVersionListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryVersionListResponse));
		((ns5__GetStockEntryVersionListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryVersionListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryVersionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryVersionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryVersionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryVersionListResponse %p -> %p\n", q, p));
	*(ns5__GetStockEntryVersionListResponse*)p = *(ns5__GetStockEntryVersionListResponse*)q;
}

void ns5__GetStockEntryVersionListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryVersionListRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryVersionListRequest::ns3__guid);
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryVersionListRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryVersionListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetStockEntryVersionListRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryVersionListRequest::ns3__guid);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryVersionListRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetStockEntryVersionListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryVersionListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryVersionListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryVersionListRequest), "ns5:GetStockEntryVersionListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetStockEntryVersionListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->ns5__GetStockEntryVersionListRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->ns5__GetStockEntryVersionListRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	if(a->ns5__GetStockEntryVersionListRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetStockEntryVersionListRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryVersionListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryVersionListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListRequest * FASTCALL soap_in_ns5__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, ns5__GetStockEntryVersionListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryVersionListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryVersionListRequest, sizeof(ns5__GetStockEntryVersionListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryVersionListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryVersionListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__guid1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetStockEntryVersionListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns5__GetStockEntryVersionListRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetStockEntryVersionListRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryVersionListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryVersionListRequest, 0, sizeof(ns5__GetStockEntryVersionListRequest), 0, soap_copy_ns5__GetStockEntryVersionListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns3__guid1 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryVersionListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryVersionListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryVersionListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryVersionListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryVersionListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListRequest * SOAP_FMAC4 soap_get_ns5__GetStockEntryVersionListRequest(struct soap *soap, ns5__GetStockEntryVersionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryVersionListRequest * FASTCALL soap_instantiate_ns5__GetStockEntryVersionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryVersionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryVersionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryVersionListRequest));
		((ns5__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryVersionListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryVersionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryVersionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryVersionListRequest %p -> %p\n", q, p));
	*(ns5__GetStockEntryVersionListRequest*)p = *(ns5__GetStockEntryVersionListRequest*)q;
}

void ns5__GetStockEntryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryListResponse::ns7__stockEntryList = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns5__GetStockEntryListResponse::ns7__stockEntryList);
	/* transient soap skipped */
}

int ns5__GetStockEntryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryListResponse(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryListResponse), "ns5:GetStockEntryListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__stockEntryList)
		soap_element_result(soap, "ns7:stockEntryList");
	if(a->ns5__GetStockEntryListResponse::ns7__stockEntryList) {
		if(soap_out_PointerTons7__StockEntryList(soap, "ns7:stockEntryList", -1, &a->ns5__GetStockEntryListResponse::ns7__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryListResponse * FASTCALL soap_in_ns5__GetStockEntryListResponse(struct soap *soap, const char *tag, ns5__GetStockEntryListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryListResponse, sizeof(ns5__GetStockEntryListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns7:stockEntryList", &(a->ns5__GetStockEntryListResponse::ns7__stockEntryList), "ns7:StockEntryList"))
				{	soap_flag_ns7__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "ns7:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryListResponse, 0, sizeof(ns5__GetStockEntryListResponse), 0, soap_copy_ns5__GetStockEntryListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryListResponse * SOAP_FMAC4 soap_get_ns5__GetStockEntryListResponse(struct soap *soap, ns5__GetStockEntryListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryListResponse * FASTCALL soap_instantiate_ns5__GetStockEntryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryListResponse));
		((ns5__GetStockEntryListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryListResponse %p -> %p\n", q, p));
	*(ns5__GetStockEntryListResponse*)p = *(ns5__GetStockEntryListResponse*)q;
}

void ns5__GetStockEntryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryListRequest::ns3__listOptions = NULL;
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryListRequest::ns6__enterpriseGuid);
	this->ns5__GetStockEntryListRequest::searchPattern = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetStockEntryListRequest::ns3__listOptions);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryListRequest::ns6__enterpriseGuid);
	soap_serialize_PointerTons7__StockEntrySearchPattern(soap, &this->ns5__GetStockEntryListRequest::searchPattern);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetStockEntryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryListRequest(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryListRequest), "ns5:GetStockEntryListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetStockEntryListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->ns5__GetStockEntryListRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetStockEntryListRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	if(soap_out_PointerTons7__StockEntrySearchPattern(soap, "ns5:searchPattern", -1, &(a->ns5__GetStockEntryListRequest::searchPattern), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryListRequest * FASTCALL soap_in_ns5__GetStockEntryListRequest(struct soap *soap, const char *tag, ns5__GetStockEntryListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryListRequest, sizeof(ns5__GetStockEntryListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	size_t soap_flag_searchPattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetStockEntryListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetStockEntryListRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap_flag_searchPattern1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntrySearchPattern(soap, "ns5:searchPattern", &(a->ns5__GetStockEntryListRequest::searchPattern), "ns7:StockEntrySearchPattern"))
				{	soap_flag_searchPattern1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryListRequest, 0, sizeof(ns5__GetStockEntryListRequest), 0, soap_copy_ns5__GetStockEntryListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryListRequest * SOAP_FMAC4 soap_get_ns5__GetStockEntryListRequest(struct soap *soap, ns5__GetStockEntryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryListRequest * FASTCALL soap_instantiate_ns5__GetStockEntryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryListRequest));
		((ns5__GetStockEntryListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryListRequest %p -> %p\n", q, p));
	*(ns5__GetStockEntryListRequest*)p = *(ns5__GetStockEntryListRequest*)q;
}

void ns5__GetStockEntryChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryChangesListResponse::ns7__stockEntryList = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns5__GetStockEntryChangesListResponse::ns7__stockEntryList);
	/* transient soap skipped */
}

int ns5__GetStockEntryChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryChangesListResponse), "ns5:GetStockEntryChangesListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__stockEntryList)
		soap_element_result(soap, "ns7:stockEntryList");
	if(a->ns5__GetStockEntryChangesListResponse::ns7__stockEntryList) {
		if(soap_out_PointerTons7__StockEntryList(soap, "ns7:stockEntryList", -1, &a->ns5__GetStockEntryChangesListResponse::ns7__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListResponse * FASTCALL soap_in_ns5__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, ns5__GetStockEntryChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryChangesListResponse, sizeof(ns5__GetStockEntryChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns7:stockEntryList", &(a->ns5__GetStockEntryChangesListResponse::ns7__stockEntryList), "ns7:StockEntryList"))
				{	soap_flag_ns7__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "ns7:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryChangesListResponse, 0, sizeof(ns5__GetStockEntryChangesListResponse), 0, soap_copy_ns5__GetStockEntryChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListResponse * SOAP_FMAC4 soap_get_ns5__GetStockEntryChangesListResponse(struct soap *soap, ns5__GetStockEntryChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryChangesListResponse * FASTCALL soap_instantiate_ns5__GetStockEntryChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryChangesListResponse));
		((ns5__GetStockEntryChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryChangesListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryChangesListResponse %p -> %p\n", q, p));
	*(ns5__GetStockEntryChangesListResponse*)p = *(ns5__GetStockEntryChangesListResponse*)q;
}

void ns5__GetStockEntryChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryChangesListRequest::ns3__listOptions = NULL;
	this->ns5__GetStockEntryChangesListRequest::ns3__updateDateInterval = NULL;
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryChangesListRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetStockEntryChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->ns5__GetStockEntryChangesListRequest::ns3__updateDateInterval);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryChangesListRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetStockEntryChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryChangesListRequest), "ns5:GetStockEntryChangesListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetStockEntryChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->ns5__GetStockEntryChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->ns5__GetStockEntryChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	if(a->ns5__GetStockEntryChangesListRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetStockEntryChangesListRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListRequest * FASTCALL soap_in_ns5__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, ns5__GetStockEntryChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryChangesListRequest, sizeof(ns5__GetStockEntryChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetStockEntryChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->ns5__GetStockEntryChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetStockEntryChangesListRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryChangesListRequest, 0, sizeof(ns5__GetStockEntryChangesListRequest), 0, soap_copy_ns5__GetStockEntryChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns3__updateDateInterval1 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListRequest * SOAP_FMAC4 soap_get_ns5__GetStockEntryChangesListRequest(struct soap *soap, ns5__GetStockEntryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryChangesListRequest * FASTCALL soap_instantiate_ns5__GetStockEntryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryChangesListRequest));
		((ns5__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryChangesListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryChangesListRequest %p -> %p\n", q, p));
	*(ns5__GetStockEntryChangesListRequest*)p = *(ns5__GetStockEntryChangesListRequest*)q;
}

void ns5__GetStockEntryByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryByUuidResponse::ns7__stockEntry = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntry(soap, &this->ns5__GetStockEntryByUuidResponse::ns7__stockEntry);
	/* transient soap skipped */
}

int ns5__GetStockEntryByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryByUuidResponse), "ns5:GetStockEntryByUuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__stockEntry)
		soap_element_result(soap, "ns7:stockEntry");
	if(a->ns5__GetStockEntryByUuidResponse::ns7__stockEntry) {
		if(soap_out_PointerTons7__StockEntry(soap, "ns7:stockEntry", -1, &a->ns5__GetStockEntryByUuidResponse::ns7__stockEntry, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:stockEntry"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidResponse * FASTCALL soap_in_ns5__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, ns5__GetStockEntryByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryByUuidResponse, sizeof(ns5__GetStockEntryByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__stockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__stockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:stockEntry", &(a->ns5__GetStockEntryByUuidResponse::ns7__stockEntry), "ns7:StockEntry"))
				{	soap_flag_ns7__stockEntry1--;
					continue;
				}
			soap_check_result(soap, "ns7:stockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryByUuidResponse, 0, sizeof(ns5__GetStockEntryByUuidResponse), 0, soap_copy_ns5__GetStockEntryByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__stockEntry1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidResponse * SOAP_FMAC4 soap_get_ns5__GetStockEntryByUuidResponse(struct soap *soap, ns5__GetStockEntryByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryByUuidResponse * FASTCALL soap_instantiate_ns5__GetStockEntryByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByUuidResponse));
		((ns5__GetStockEntryByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByUuidResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryByUuidResponse %p -> %p\n", q, p));
	*(ns5__GetStockEntryByUuidResponse*)p = *(ns5__GetStockEntryByUuidResponse*)q;
}

void ns5__GetStockEntryByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryByUuidRequest::ns3__uuid);
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryByUuidRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryByUuidRequest::ns3__uuid);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryByUuidRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetStockEntryByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryByUuidRequest), "ns5:GetStockEntryByUuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__GetStockEntryByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->ns5__GetStockEntryByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	if(a->ns5__GetStockEntryByUuidRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetStockEntryByUuidRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidRequest * FASTCALL soap_in_ns5__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, ns5__GetStockEntryByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryByUuidRequest, sizeof(ns5__GetStockEntryByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__uuid1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns5__GetStockEntryByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetStockEntryByUuidRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryByUuidRequest, 0, sizeof(ns5__GetStockEntryByUuidRequest), 0, soap_copy_ns5__GetStockEntryByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns3__uuid1 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidRequest * SOAP_FMAC4 soap_get_ns5__GetStockEntryByUuidRequest(struct soap *soap, ns5__GetStockEntryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryByUuidRequest * FASTCALL soap_instantiate_ns5__GetStockEntryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByUuidRequest));
		((ns5__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByUuidRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryByUuidRequest %p -> %p\n", q, p));
	*(ns5__GetStockEntryByUuidRequest*)p = *(ns5__GetStockEntryByUuidRequest*)q;
}

void ns5__GetStockEntryByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetStockEntryByGuidResponse::ns7__stockEntry = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntry(soap, &this->ns5__GetStockEntryByGuidResponse::ns7__stockEntry);
	/* transient soap skipped */
}

int ns5__GetStockEntryByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryByGuidResponse), "ns5:GetStockEntryByGuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__stockEntry)
		soap_element_result(soap, "ns7:stockEntry");
	if(a->ns5__GetStockEntryByGuidResponse::ns7__stockEntry) {
		if(soap_out_PointerTons7__StockEntry(soap, "ns7:stockEntry", -1, &a->ns5__GetStockEntryByGuidResponse::ns7__stockEntry, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:stockEntry"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidResponse * FASTCALL soap_in_ns5__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, ns5__GetStockEntryByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryByGuidResponse, sizeof(ns5__GetStockEntryByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__stockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__stockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntry(soap, "ns7:stockEntry", &(a->ns5__GetStockEntryByGuidResponse::ns7__stockEntry), "ns7:StockEntry"))
				{	soap_flag_ns7__stockEntry1--;
					continue;
				}
			soap_check_result(soap, "ns7:stockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryByGuidResponse, 0, sizeof(ns5__GetStockEntryByGuidResponse), 0, soap_copy_ns5__GetStockEntryByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__stockEntry1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidResponse * SOAP_FMAC4 soap_get_ns5__GetStockEntryByGuidResponse(struct soap *soap, ns5__GetStockEntryByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryByGuidResponse * FASTCALL soap_instantiate_ns5__GetStockEntryByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByGuidResponse));
		((ns5__GetStockEntryByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByGuidResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryByGuidResponse %p -> %p\n", q, p));
	*(ns5__GetStockEntryByGuidResponse*)p = *(ns5__GetStockEntryByGuidResponse*)q;
}

void ns5__GetStockEntryByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryByGuidRequest::ns3__guid);
	soap_default_ns3__UUID(soap, &this->ns5__GetStockEntryByGuidRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetStockEntryByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryByGuidRequest::ns3__guid);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetStockEntryByGuidRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetStockEntryByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetStockEntryByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, const ns5__GetStockEntryByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetStockEntryByGuidRequest), "ns5:GetStockEntryByGuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__GetStockEntryByGuidRequest::ns3__guid) {
		if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &a->ns5__GetStockEntryByGuidRequest::ns3__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:guid"))
		return soap->error;
	if(a->ns5__GetStockEntryByGuidRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetStockEntryByGuidRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetStockEntryByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetStockEntryByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidRequest * FASTCALL soap_in_ns5__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, ns5__GetStockEntryByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetStockEntryByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetStockEntryByGuidRequest, sizeof(ns5__GetStockEntryByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetStockEntryByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetStockEntryByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__guid1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns5__GetStockEntryByGuidRequest::ns3__guid), "ns3:UUID"))
				{	soap_flag_ns3__guid1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetStockEntryByGuidRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetStockEntryByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetStockEntryByGuidRequest, 0, sizeof(ns5__GetStockEntryByGuidRequest), 0, soap_copy_ns5__GetStockEntryByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns3__guid1 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetStockEntryByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetStockEntryByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetStockEntryByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetStockEntryByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetStockEntryByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidRequest * SOAP_FMAC4 soap_get_ns5__GetStockEntryByGuidRequest(struct soap *soap, ns5__GetStockEntryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetStockEntryByGuidRequest * FASTCALL soap_instantiate_ns5__GetStockEntryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetStockEntryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetStockEntryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByGuidRequest));
		((ns5__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByGuidRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetStockEntryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetStockEntryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetStockEntryByGuidRequest %p -> %p\n", q, p));
	*(ns5__GetStockEntryByGuidRequest*)p = *(ns5__GetStockEntryByGuidRequest*)q;
}

void ns5__GetVetDocumentChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetVetDocumentChangesListResponse::ns7__vetDocumentList = NULL;
	/* transient soap skipped */
}

void ns5__GetVetDocumentChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__VetDocumentList(soap, &this->ns5__GetVetDocumentChangesListResponse::ns7__vetDocumentList);
	/* transient soap skipped */
}

int ns5__GetVetDocumentChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetVetDocumentChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, int id, const ns5__GetVetDocumentChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse), "ns5:GetVetDocumentChangesListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__vetDocumentList)
		soap_element_result(soap, "ns7:vetDocumentList");
	if(a->ns5__GetVetDocumentChangesListResponse::ns7__vetDocumentList) {
		if(soap_out_PointerTons7__VetDocumentList(soap, "ns7:vetDocumentList", -1, &a->ns5__GetVetDocumentChangesListResponse::ns7__vetDocumentList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:vetDocumentList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetVetDocumentChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetVetDocumentChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListResponse * FASTCALL soap_in_ns5__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, ns5__GetVetDocumentChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetVetDocumentChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse, sizeof(ns5__GetVetDocumentChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetVetDocumentChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetVetDocumentChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__vetDocumentList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__vetDocumentList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentList(soap, "ns7:vetDocumentList", &(a->ns5__GetVetDocumentChangesListResponse::ns7__vetDocumentList), "ns7:VetDocumentList"))
				{	soap_flag_ns7__vetDocumentList1--;
					continue;
				}
			soap_check_result(soap, "ns7:vetDocumentList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetVetDocumentChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse, 0, sizeof(ns5__GetVetDocumentChangesListResponse), 0, soap_copy_ns5__GetVetDocumentChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__vetDocumentList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetVetDocumentChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetVetDocumentChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetVetDocumentChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetVetDocumentChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListResponse * SOAP_FMAC4 soap_get_ns5__GetVetDocumentChangesListResponse(struct soap *soap, ns5__GetVetDocumentChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetVetDocumentChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetVetDocumentChangesListResponse * FASTCALL soap_instantiate_ns5__GetVetDocumentChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetVetDocumentChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentChangesListResponse));
		((ns5__GetVetDocumentChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentChangesListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetVetDocumentChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetVetDocumentChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetVetDocumentChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetVetDocumentChangesListResponse %p -> %p\n", q, p));
	*(ns5__GetVetDocumentChangesListResponse*)p = *(ns5__GetVetDocumentChangesListResponse*)q;
}

void ns5__GetVetDocumentChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetVetDocumentChangesListRequest::ns3__listOptions = NULL;
	this->ns5__GetVetDocumentChangesListRequest::ns3__updateDateInterval = NULL;
	soap_default_ns3__UUID(soap, &this->ns5__GetVetDocumentChangesListRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetVetDocumentChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetVetDocumentChangesListRequest::ns3__listOptions);
	soap_serialize_PointerTons3__DateInterval(soap, &this->ns5__GetVetDocumentChangesListRequest::ns3__updateDateInterval);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetVetDocumentChangesListRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetVetDocumentChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetVetDocumentChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, const ns5__GetVetDocumentChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest), "ns5:GetVetDocumentChangesListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetVetDocumentChangesListRequest::ns3__listOptions), ""))
		return soap->error;
	if(a->ns5__GetVetDocumentChangesListRequest::ns3__updateDateInterval) {
		if(soap_out_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", -1, &a->ns5__GetVetDocumentChangesListRequest::ns3__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:updateDateInterval"))
		return soap->error;
	if(a->ns5__GetVetDocumentChangesListRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetVetDocumentChangesListRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetVetDocumentChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetVetDocumentChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListRequest * FASTCALL soap_in_ns5__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, ns5__GetVetDocumentChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetVetDocumentChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest, sizeof(ns5__GetVetDocumentChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetVetDocumentChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetVetDocumentChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns3__updateDateInterval1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetVetDocumentChangesListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns3__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__DateInterval(soap, "ns3:updateDateInterval", &(a->ns5__GetVetDocumentChangesListRequest::ns3__updateDateInterval), "ns3:DateInterval"))
				{	soap_flag_ns3__updateDateInterval1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetVetDocumentChangesListRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetVetDocumentChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest, 0, sizeof(ns5__GetVetDocumentChangesListRequest), 0, soap_copy_ns5__GetVetDocumentChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns3__updateDateInterval1 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetVetDocumentChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetVetDocumentChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetVetDocumentChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetVetDocumentChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListRequest * SOAP_FMAC4 soap_get_ns5__GetVetDocumentChangesListRequest(struct soap *soap, ns5__GetVetDocumentChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetVetDocumentChangesListRequest * FASTCALL soap_instantiate_ns5__GetVetDocumentChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetVetDocumentChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentChangesListRequest));
		((ns5__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentChangesListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetVetDocumentChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetVetDocumentChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetVetDocumentChangesListRequest %p -> %p\n", q, p));
	*(ns5__GetVetDocumentChangesListRequest*)p = *(ns5__GetVetDocumentChangesListRequest*)q;
}

void ns5__GetVetDocumentListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetVetDocumentListResponse::ns7__vetDocumentList = NULL;
	/* transient soap skipped */
}

void ns5__GetVetDocumentListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__VetDocumentList(soap, &this->ns5__GetVetDocumentListResponse::ns7__vetDocumentList);
	/* transient soap skipped */
}

int ns5__GetVetDocumentListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetVetDocumentListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetVetDocumentListResponse(struct soap *soap, const char *tag, int id, const ns5__GetVetDocumentListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetVetDocumentListResponse), "ns5:GetVetDocumentListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__vetDocumentList)
		soap_element_result(soap, "ns7:vetDocumentList");
	if(a->ns5__GetVetDocumentListResponse::ns7__vetDocumentList) {
		if(soap_out_PointerTons7__VetDocumentList(soap, "ns7:vetDocumentList", -1, &a->ns5__GetVetDocumentListResponse::ns7__vetDocumentList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:vetDocumentList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetVetDocumentListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetVetDocumentListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetVetDocumentListResponse * FASTCALL soap_in_ns5__GetVetDocumentListResponse(struct soap *soap, const char *tag, ns5__GetVetDocumentListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetVetDocumentListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetVetDocumentListResponse, sizeof(ns5__GetVetDocumentListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetVetDocumentListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetVetDocumentListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__vetDocumentList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__vetDocumentList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentList(soap, "ns7:vetDocumentList", &(a->ns5__GetVetDocumentListResponse::ns7__vetDocumentList), "ns7:VetDocumentList"))
				{	soap_flag_ns7__vetDocumentList1--;
					continue;
				}
			soap_check_result(soap, "ns7:vetDocumentList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetVetDocumentListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetVetDocumentListResponse, 0, sizeof(ns5__GetVetDocumentListResponse), 0, soap_copy_ns5__GetVetDocumentListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__vetDocumentList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetVetDocumentListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetVetDocumentListResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetVetDocumentListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetVetDocumentListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetVetDocumentListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetVetDocumentListResponse * SOAP_FMAC4 soap_get_ns5__GetVetDocumentListResponse(struct soap *soap, ns5__GetVetDocumentListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetVetDocumentListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetVetDocumentListResponse * FASTCALL soap_instantiate_ns5__GetVetDocumentListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetVetDocumentListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetVetDocumentListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentListResponse));
		((ns5__GetVetDocumentListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentListResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetVetDocumentListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetVetDocumentListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetVetDocumentListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetVetDocumentListResponse %p -> %p\n", q, p));
	*(ns5__GetVetDocumentListResponse*)p = *(ns5__GetVetDocumentListResponse*)q;
}

void ns5__GetVetDocumentListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetVetDocumentListRequest::ns3__listOptions = NULL;
	this->ns5__GetVetDocumentListRequest::ns7__vetDocumentType = NULL;
	this->ns5__GetVetDocumentListRequest::ns7__vetDocumentStatus = NULL;
	soap_default_ns3__UUID(soap, &this->ns5__GetVetDocumentListRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetVetDocumentListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons3__ListOptions(soap, &this->ns5__GetVetDocumentListRequest::ns3__listOptions);
	soap_serialize_PointerTons7__VetDocumentType(soap, &this->ns5__GetVetDocumentListRequest::ns7__vetDocumentType);
	soap_serialize_PointerTons7__VetDocumentStatus(soap, &this->ns5__GetVetDocumentListRequest::ns7__vetDocumentStatus);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetVetDocumentListRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetVetDocumentListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetVetDocumentListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetVetDocumentListRequest(struct soap *soap, const char *tag, int id, const ns5__GetVetDocumentListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetVetDocumentListRequest), "ns5:GetVetDocumentListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTons3__ListOptions(soap, "ns3:listOptions", -1, &(a->ns5__GetVetDocumentListRequest::ns3__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTons7__VetDocumentType(soap, "ns7:vetDocumentType", -1, &(a->ns5__GetVetDocumentListRequest::ns7__vetDocumentType), ""))
		return soap->error;
	if(soap_out_PointerTons7__VetDocumentStatus(soap, "ns7:vetDocumentStatus", -1, &(a->ns5__GetVetDocumentListRequest::ns7__vetDocumentStatus), ""))
		return soap->error;
	if(a->ns5__GetVetDocumentListRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetVetDocumentListRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetVetDocumentListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetVetDocumentListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetVetDocumentListRequest * FASTCALL soap_in_ns5__GetVetDocumentListRequest(struct soap *soap, const char *tag, ns5__GetVetDocumentListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetVetDocumentListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetVetDocumentListRequest, sizeof(ns5__GetVetDocumentListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetVetDocumentListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetVetDocumentListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__listOptions1 = 1;
	size_t soap_flag_ns7__vetDocumentType1 = 1;
	size_t soap_flag_ns7__vetDocumentStatus1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__ListOptions(soap, "ns3:listOptions", &(a->ns5__GetVetDocumentListRequest::ns3__listOptions), "ns3:ListOptions"))
				{	soap_flag_ns3__listOptions1--;
					continue;
				}
			if(soap_flag_ns7__vetDocumentType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentType(soap, "ns7:vetDocumentType", &(a->ns5__GetVetDocumentListRequest::ns7__vetDocumentType), "ns7:VetDocumentType"))
				{	soap_flag_ns7__vetDocumentType1--;
					continue;
				}
			if(soap_flag_ns7__vetDocumentStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocumentStatus(soap, "ns7:vetDocumentStatus", &(a->ns5__GetVetDocumentListRequest::ns7__vetDocumentStatus), "ns7:VetDocumentStatus"))
				{	soap_flag_ns7__vetDocumentStatus1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetVetDocumentListRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetVetDocumentListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetVetDocumentListRequest, 0, sizeof(ns5__GetVetDocumentListRequest), 0, soap_copy_ns5__GetVetDocumentListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetVetDocumentListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetVetDocumentListRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetVetDocumentListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetVetDocumentListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetVetDocumentListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetVetDocumentListRequest * SOAP_FMAC4 soap_get_ns5__GetVetDocumentListRequest(struct soap *soap, ns5__GetVetDocumentListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetVetDocumentListRequest * FASTCALL soap_instantiate_ns5__GetVetDocumentListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetVetDocumentListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetVetDocumentListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentListRequest));
		((ns5__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentListRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetVetDocumentListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetVetDocumentListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetVetDocumentListRequest %p -> %p\n", q, p));
	*(ns5__GetVetDocumentListRequest*)p = *(ns5__GetVetDocumentListRequest*)q;
}

void ns5__GetVetDocumentByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__GetVetDocumentByUuidResponse::ns7__vetDocument = NULL;
	/* transient soap skipped */
}

void ns5__GetVetDocumentByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__VetDocument(soap, &this->ns5__GetVetDocumentByUuidResponse::ns7__vetDocument);
	/* transient soap skipped */
}

int ns5__GetVetDocumentByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetVetDocumentByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, int id, const ns5__GetVetDocumentByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse), "ns5:GetVetDocumentByUuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns7__vetDocument)
		soap_element_result(soap, "ns7:vetDocument");
	if(a->ns5__GetVetDocumentByUuidResponse::ns7__vetDocument) {
		if(soap_out_PointerTons7__VetDocument(soap, "ns7:vetDocument", -1, &a->ns5__GetVetDocumentByUuidResponse::ns7__vetDocument, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns7:vetDocument"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetVetDocumentByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetVetDocumentByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidResponse * FASTCALL soap_in_ns5__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, ns5__GetVetDocumentByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetVetDocumentByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse, sizeof(ns5__GetVetDocumentByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetVetDocumentByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetVetDocumentByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns7__vetDocument1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_ns7__vetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocument(soap, "ns7:vetDocument", &(a->ns5__GetVetDocumentByUuidResponse::ns7__vetDocument), "ns7:VetDocument"))
				{	soap_flag_ns7__vetDocument1--;
					continue;
				}
			soap_check_result(soap, "ns7:vetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetVetDocumentByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse, 0, sizeof(ns5__GetVetDocumentByUuidResponse), 0, soap_copy_ns5__GetVetDocumentByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns7__vetDocument1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetVetDocumentByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns5:GetVetDocumentByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetVetDocumentByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetVetDocumentByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidResponse * SOAP_FMAC4 soap_get_ns5__GetVetDocumentByUuidResponse(struct soap *soap, ns5__GetVetDocumentByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetVetDocumentByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetVetDocumentByUuidResponse * FASTCALL soap_instantiate_ns5__GetVetDocumentByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetVetDocumentByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidResponse);
		ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentByUuidResponse));
		((ns5__GetVetDocumentByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentByUuidResponse));
		for(int i = 0; i < n; i++)
			((ns5__GetVetDocumentByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetVetDocumentByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetVetDocumentByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetVetDocumentByUuidResponse %p -> %p\n", q, p));
	*(ns5__GetVetDocumentByUuidResponse*)p = *(ns5__GetVetDocumentByUuidResponse*)q;
}

void ns5__GetVetDocumentByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns5__GetVetDocumentByUuidRequest::ns3__uuid);
	soap_default_ns3__UUID(soap, &this->ns5__GetVetDocumentByUuidRequest::ns6__enterpriseGuid);
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__GetVetDocumentByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns5__GetVetDocumentByUuidRequest::ns3__uuid);
	soap_serialize_ns3__UUID(soap, &this->ns5__GetVetDocumentByUuidRequest::ns6__enterpriseGuid);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__GetVetDocumentByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__GetVetDocumentByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, const ns5__GetVetDocumentByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest), "ns5:GetVetDocumentByUuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__GetVetDocumentByUuidRequest::ns3__uuid) {
		if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &a->ns5__GetVetDocumentByUuidRequest::ns3__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:uuid"))
		return soap->error;
	if(a->ns5__GetVetDocumentByUuidRequest::ns6__enterpriseGuid) {
		if(soap_out_ns3__UUID(soap, "ns6:enterpriseGuid", -1, &a->ns5__GetVetDocumentByUuidRequest::ns6__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns6:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__GetVetDocumentByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__GetVetDocumentByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidRequest * FASTCALL soap_in_ns5__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, ns5__GetVetDocumentByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__GetVetDocumentByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest, sizeof(ns5__GetVetDocumentByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__GetVetDocumentByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__GetVetDocumentByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_ns3__uuid1 = 1;
	size_t soap_flag_ns6__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_ns3__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns5__GetVetDocumentByUuidRequest::ns3__uuid), "ns3:UUID"))
				{	soap_flag_ns3__uuid1--;
					continue;
				}
			if(soap_flag_ns6__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns6:enterpriseGuid", &(a->ns5__GetVetDocumentByUuidRequest::ns6__enterpriseGuid), "ns3:UUID"))
				{	soap_flag_ns6__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__GetVetDocumentByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest, 0, sizeof(ns5__GetVetDocumentByUuidRequest), 0, soap_copy_ns5__GetVetDocumentByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ns3__uuid1 > 0 || soap_flag_ns6__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__GetVetDocumentByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns5:GetVetDocumentByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__GetVetDocumentByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__GetVetDocumentByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidRequest * SOAP_FMAC4 soap_get_ns5__GetVetDocumentByUuidRequest(struct soap *soap, ns5__GetVetDocumentByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__GetVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__GetVetDocumentByUuidRequest * FASTCALL soap_instantiate_ns5__GetVetDocumentByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__GetVetDocumentByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidRequest);
		ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentByUuidRequest));
		((ns5__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentByUuidRequest));
		for(int i = 0; i < n; i++)
			((ns5__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__GetVetDocumentByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__GetVetDocumentByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__GetVetDocumentByUuidRequest %p -> %p\n", q, p));
	*(ns5__GetVetDocumentByUuidRequest*)p = *(ns5__GetVetDocumentByUuidRequest*)q;
}

void ns5__ModifyProducerStockListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyProducerStockListResponse::productItemList = NULL;
	/* transient soap skipped */
}

void ns5__ModifyProducerStockListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__ProductItemList(soap, &this->ns5__ModifyProducerStockListResponse::productItemList);
	/* transient soap skipped */
}

int ns5__ModifyProducerStockListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyProducerStockListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyProducerStockListResponse(struct soap *soap, const char *tag, int id, const ns5__ModifyProducerStockListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyProducerStockListResponse), "ns5:ModifyProducerStockListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->productItemList)
		soap_element_result(soap, "ns5:productItemList");
	if(a->ns5__ModifyProducerStockListResponse::productItemList) {
		if(soap_out_PointerTons6__ProductItemList(soap, "ns5:productItemList", -1, &a->ns5__ModifyProducerStockListResponse::productItemList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:productItemList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyProducerStockListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyProducerStockListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyProducerStockListResponse * FASTCALL soap_in_ns5__ModifyProducerStockListResponse(struct soap *soap, const char *tag, ns5__ModifyProducerStockListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyProducerStockListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyProducerStockListResponse, sizeof(ns5__ModifyProducerStockListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyProducerStockListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyProducerStockListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__ProductItemList(soap, "ns5:productItemList", &(a->ns5__ModifyProducerStockListResponse::productItemList), "ns6:ProductItemList"))
				{	soap_flag_productItemList1--;
					continue;
				}
			soap_check_result(soap, "ns5:productItemList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyProducerStockListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyProducerStockListResponse, 0, sizeof(ns5__ModifyProducerStockListResponse), 0, soap_copy_ns5__ModifyProducerStockListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_productItemList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ModifyProducerStockListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyProducerStockListResponse);
	return this->soap_out(soap, tag?tag:"ns5:ModifyProducerStockListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyProducerStockListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyProducerStockListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyProducerStockListResponse * SOAP_FMAC4 soap_get_ns5__ModifyProducerStockListResponse(struct soap *soap, ns5__ModifyProducerStockListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyProducerStockListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyProducerStockListResponse * FASTCALL soap_instantiate_ns5__ModifyProducerStockListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyProducerStockListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyProducerStockListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListResponse);
		ASSIGN_PTR(size, sizeof(ns5__ModifyProducerStockListResponse));
		((ns5__ModifyProducerStockListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyProducerStockListResponse));
		for(int i = 0; i < n; i++)
			((ns5__ModifyProducerStockListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyProducerStockListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyProducerStockListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyProducerStockListResponse %p -> %p\n", q, p));
	*(ns5__ModifyProducerStockListResponse*)p = *(ns5__ModifyProducerStockListResponse*)q;
}

void ns5__ModifyProducerStockListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyProducerStockListRequest::modificationOperation = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__ModifyProducerStockListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__PSLModificationOperation(soap, &this->ns5__ModifyProducerStockListRequest::modificationOperation);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__ModifyProducerStockListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyProducerStockListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyProducerStockListRequest(struct soap *soap, const char *tag, int id, const ns5__ModifyProducerStockListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyProducerStockListRequest), "ns5:ModifyProducerStockListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__ModifyProducerStockListRequest::modificationOperation) {
		if(soap_out_PointerTons7__PSLModificationOperation(soap, "ns5:modificationOperation", -1, &a->ns5__ModifyProducerStockListRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyProducerStockListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyProducerStockListRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyProducerStockListRequest * FASTCALL soap_in_ns5__ModifyProducerStockListRequest(struct soap *soap, const char *tag, ns5__ModifyProducerStockListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyProducerStockListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyProducerStockListRequest, sizeof(ns5__ModifyProducerStockListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyProducerStockListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyProducerStockListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__PSLModificationOperation(soap, "ns5:modificationOperation", &(a->ns5__ModifyProducerStockListRequest::modificationOperation), "ns7:PSLModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyProducerStockListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyProducerStockListRequest, 0, sizeof(ns5__ModifyProducerStockListRequest), 0, soap_copy_ns5__ModifyProducerStockListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ModifyProducerStockListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyProducerStockListRequest);
	return this->soap_out(soap, tag?tag:"ns5:ModifyProducerStockListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyProducerStockListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyProducerStockListRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyProducerStockListRequest * SOAP_FMAC4 soap_get_ns5__ModifyProducerStockListRequest(struct soap *soap, ns5__ModifyProducerStockListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyProducerStockListRequest * FASTCALL soap_instantiate_ns5__ModifyProducerStockListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyProducerStockListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyProducerStockListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListRequest);
		ASSIGN_PTR(size, sizeof(ns5__ModifyProducerStockListRequest));
		((ns5__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyProducerStockListRequest));
		for(int i = 0; i < n; i++)
			((ns5__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyProducerStockListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyProducerStockListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyProducerStockListRequest %p -> %p\n", q, p));
	*(ns5__ModifyProducerStockListRequest*)p = *(ns5__ModifyProducerStockListRequest*)q;
}

void ns5__ResolveDiscrepancyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ResolveDiscrepancyResponse::stockEntryList = NULL;
	/* transient soap skipped */
}

void ns5__ResolveDiscrepancyResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns5__ResolveDiscrepancyResponse::stockEntryList);
	/* transient soap skipped */
}

int ns5__ResolveDiscrepancyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ResolveDiscrepancyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, int id, const ns5__ResolveDiscrepancyResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ResolveDiscrepancyResponse), "ns5:ResolveDiscrepancyResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "ns5:stockEntryList");
	if(a->ns5__ResolveDiscrepancyResponse::stockEntryList) {
		if(soap_out_PointerTons7__StockEntryList(soap, "ns5:stockEntryList", -1, &a->ns5__ResolveDiscrepancyResponse::stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ResolveDiscrepancyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ResolveDiscrepancyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyResponse * FASTCALL soap_in_ns5__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, ns5__ResolveDiscrepancyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ResolveDiscrepancyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ResolveDiscrepancyResponse, sizeof(ns5__ResolveDiscrepancyResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ResolveDiscrepancyResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ResolveDiscrepancyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns5:stockEntryList", &(a->ns5__ResolveDiscrepancyResponse::stockEntryList), "ns7:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "ns5:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ResolveDiscrepancyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ResolveDiscrepancyResponse, 0, sizeof(ns5__ResolveDiscrepancyResponse), 0, soap_copy_ns5__ResolveDiscrepancyResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ResolveDiscrepancyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ResolveDiscrepancyResponse);
	return this->soap_out(soap, tag?tag:"ns5:ResolveDiscrepancyResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ResolveDiscrepancyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ResolveDiscrepancyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyResponse * SOAP_FMAC4 soap_get_ns5__ResolveDiscrepancyResponse(struct soap *soap, ns5__ResolveDiscrepancyResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ResolveDiscrepancyResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ResolveDiscrepancyResponse * FASTCALL soap_instantiate_ns5__ResolveDiscrepancyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ResolveDiscrepancyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ResolveDiscrepancyResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyResponse);
		ASSIGN_PTR(size, sizeof(ns5__ResolveDiscrepancyResponse));
		((ns5__ResolveDiscrepancyResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ResolveDiscrepancyResponse));
		for(int i = 0; i < n; i++)
			((ns5__ResolveDiscrepancyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ResolveDiscrepancyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ResolveDiscrepancyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ResolveDiscrepancyResponse %p -> %p\n", q, p));
	*(ns5__ResolveDiscrepancyResponse*)p = *(ns5__ResolveDiscrepancyResponse*)q;
}

void ns5__ResolveDiscrepancyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ResolveDiscrepancyRequest::enterprise = NULL;
	soap_default_time(soap, &this->ns5__ResolveDiscrepancyRequest::inventoryDate);
	this->ns5__ResolveDiscrepancyRequest::responsible = NULL;
	this->ns5__ResolveDiscrepancyRequest::__sizestockDiscrepancy = 0;
	this->ns5__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
	this->ns5__ResolveDiscrepancyRequest::__sizediscrepancyReport = 0;
	this->ns5__ResolveDiscrepancyRequest::discrepancyReport = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__ResolveDiscrepancyRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns5__ResolveDiscrepancyRequest::enterprise);
	soap_embedded(soap, &this->ns5__ResolveDiscrepancyRequest::inventoryDate, SOAP_TYPE_time);
	soap_serialize_PointerTons7__User(soap, &this->ns5__ResolveDiscrepancyRequest::responsible);
	if(this->ns5__ResolveDiscrepancyRequest::stockDiscrepancy) {
		for(int i = 0; i < this->ns5__ResolveDiscrepancyRequest::__sizestockDiscrepancy; i++) {
			soap_serialize_PointerTons7__StockDiscrepancy(soap, this->ns5__ResolveDiscrepancyRequest::stockDiscrepancy + i);
		}
	}
	if(this->ns5__ResolveDiscrepancyRequest::discrepancyReport) {
		for(int i = 0; i < this->ns5__ResolveDiscrepancyRequest::__sizediscrepancyReport; i++) {
			soap_serialize_PointerTons7__DiscrepancyReport(soap, this->ns5__ResolveDiscrepancyRequest::discrepancyReport + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__ResolveDiscrepancyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ResolveDiscrepancyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, const ns5__ResolveDiscrepancyRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ResolveDiscrepancyRequest), "ns5:ResolveDiscrepancyRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__ResolveDiscrepancyRequest::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns5:enterprise", -1, &a->ns5__ResolveDiscrepancyRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:enterprise"))
		return soap->error;
	if(soap_out_time(soap, "ns5:inventoryDate", -1, &(a->ns5__ResolveDiscrepancyRequest::inventoryDate), ""))
		return soap->error;
	if(a->ns5__ResolveDiscrepancyRequest::responsible) {
		if(soap_out_PointerTons7__User(soap, "ns5:responsible", -1, &a->ns5__ResolveDiscrepancyRequest::responsible, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:responsible"))
		return soap->error;
	if(a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy) {
		int i;
		for(i = 0; i < a->ns5__ResolveDiscrepancyRequest::__sizestockDiscrepancy; i++)
			if(soap_out_PointerTons7__StockDiscrepancy(soap, "ns5:stockDiscrepancy", -1, a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy + i, ""))
				return soap->error;
	}
	if(a->ns5__ResolveDiscrepancyRequest::discrepancyReport) {
		int i;
		for(i = 0; i < a->ns5__ResolveDiscrepancyRequest::__sizediscrepancyReport; i++)
			if(soap_out_PointerTons7__DiscrepancyReport(soap, "ns5:discrepancyReport", -1, a->ns5__ResolveDiscrepancyRequest::discrepancyReport + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__ResolveDiscrepancyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ResolveDiscrepancyRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyRequest * FASTCALL soap_in_ns5__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, ns5__ResolveDiscrepancyRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ResolveDiscrepancyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ResolveDiscrepancyRequest, sizeof(ns5__ResolveDiscrepancyRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ResolveDiscrepancyRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ResolveDiscrepancyRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_inventoryDate1 = 1;
	size_t soap_flag_responsible1 = 1;
	struct soap_blist *soap_blist_stockDiscrepancy1 = NULL;
	struct soap_blist *soap_blist_discrepancyReport1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns5:enterprise", &(a->ns5__ResolveDiscrepancyRequest::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_inventoryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "ns5:inventoryDate", &(a->ns5__ResolveDiscrepancyRequest::inventoryDate), "xsd:dateTime"))
				{	soap_flag_inventoryDate1--;
					continue;
				}
			if(soap_flag_responsible1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:responsible", &(a->ns5__ResolveDiscrepancyRequest::responsible), "ns7:User"))
				{	soap_flag_responsible1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:stockDiscrepancy", 1, NULL)) {
				if(a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy == NULL) {
					if(soap_blist_stockDiscrepancy1 == NULL)
						soap_blist_stockDiscrepancy1 = soap_new_block(soap);
					a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy = (ns7__StockDiscrepancy **)soap_push_block(soap, soap_blist_stockDiscrepancy1, sizeof(ns7__StockDiscrepancy *));
					if(a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy == NULL)
						return NULL;
					*a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockDiscrepancy(soap, "ns5:stockDiscrepancy", a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy, "ns7:StockDiscrepancy"))
				{	a->ns5__ResolveDiscrepancyRequest::__sizestockDiscrepancy++;
					a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:discrepancyReport", 1, NULL)) {
				if(a->ns5__ResolveDiscrepancyRequest::discrepancyReport == NULL) {
					if(soap_blist_discrepancyReport1 == NULL)
						soap_blist_discrepancyReport1 = soap_new_block(soap);
					a->ns5__ResolveDiscrepancyRequest::discrepancyReport = (ns7__DiscrepancyReport **)soap_push_block(soap, soap_blist_discrepancyReport1, sizeof(ns7__DiscrepancyReport *));
					if(a->ns5__ResolveDiscrepancyRequest::discrepancyReport == NULL)
						return NULL;
					*a->ns5__ResolveDiscrepancyRequest::discrepancyReport = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__DiscrepancyReport(soap, "ns5:discrepancyReport", a->ns5__ResolveDiscrepancyRequest::discrepancyReport, "ns7:DiscrepancyReport"))
				{	a->ns5__ResolveDiscrepancyRequest::__sizediscrepancyReport++;
					a->ns5__ResolveDiscrepancyRequest::discrepancyReport = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy)
			soap_pop_block(soap, soap_blist_stockDiscrepancy1);
		if(a->ns5__ResolveDiscrepancyRequest::__sizestockDiscrepancy)
			a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy = (ns7__StockDiscrepancy **)soap_save_block(soap, soap_blist_stockDiscrepancy1, NULL, 1);
		else
		{	a->ns5__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
			if(soap_blist_stockDiscrepancy1)
				soap_end_block(soap, soap_blist_stockDiscrepancy1);
		}
		if(a->ns5__ResolveDiscrepancyRequest::discrepancyReport)
			soap_pop_block(soap, soap_blist_discrepancyReport1);
		if(a->ns5__ResolveDiscrepancyRequest::__sizediscrepancyReport)
			a->ns5__ResolveDiscrepancyRequest::discrepancyReport = (ns7__DiscrepancyReport **)soap_save_block(soap, soap_blist_discrepancyReport1, NULL, 1);
		else
		{	a->ns5__ResolveDiscrepancyRequest::discrepancyReport = NULL;
			if(soap_blist_discrepancyReport1)
				soap_end_block(soap, soap_blist_discrepancyReport1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ResolveDiscrepancyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ResolveDiscrepancyRequest, 0, sizeof(ns5__ResolveDiscrepancyRequest), 0, soap_copy_ns5__ResolveDiscrepancyRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_inventoryDate1 > 0 || soap_flag_responsible1 > 0 || a->ns5__ResolveDiscrepancyRequest::__sizestockDiscrepancy < 1 || a->ns5__ResolveDiscrepancyRequest::__sizediscrepancyReport < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ResolveDiscrepancyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ResolveDiscrepancyRequest);
	return this->soap_out(soap, tag?tag:"ns5:ResolveDiscrepancyRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ResolveDiscrepancyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ResolveDiscrepancyRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyRequest * SOAP_FMAC4 soap_get_ns5__ResolveDiscrepancyRequest(struct soap *soap, ns5__ResolveDiscrepancyRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ResolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ResolveDiscrepancyRequest * FASTCALL soap_instantiate_ns5__ResolveDiscrepancyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ResolveDiscrepancyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ResolveDiscrepancyRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyRequest);
		ASSIGN_PTR(size, sizeof(ns5__ResolveDiscrepancyRequest));
		((ns5__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ResolveDiscrepancyRequest));
		for(int i = 0; i < n; i++)
			((ns5__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ResolveDiscrepancyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ResolveDiscrepancyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ResolveDiscrepancyRequest %p -> %p\n", q, p));
	*(ns5__ResolveDiscrepancyRequest*)p = *(ns5__ResolveDiscrepancyRequest*)q;
}

void ns5__ModifyActivityLocationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyActivityLocationsResponse::businessEntity = NULL;
	/* transient soap skipped */
}

void ns5__ModifyActivityLocationsResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__BusinessEntity(soap, &this->ns5__ModifyActivityLocationsResponse::businessEntity);
	/* transient soap skipped */
}

int ns5__ModifyActivityLocationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyActivityLocationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, int id, const ns5__ModifyActivityLocationsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyActivityLocationsResponse), "ns5:ModifyActivityLocationsResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->businessEntity)
		soap_element_result(soap, "ns5:businessEntity");
	if(soap_out_PointerTons6__BusinessEntity(soap, "ns5:businessEntity", -1, &(a->ns5__ModifyActivityLocationsResponse::businessEntity), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyActivityLocationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyActivityLocationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsResponse * FASTCALL soap_in_ns5__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, ns5__ModifyActivityLocationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyActivityLocationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyActivityLocationsResponse, sizeof(ns5__ModifyActivityLocationsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyActivityLocationsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyActivityLocationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns5:businessEntity", &(a->ns5__ModifyActivityLocationsResponse::businessEntity), "ns6:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			soap_check_result(soap, "ns5:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyActivityLocationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyActivityLocationsResponse, 0, sizeof(ns5__ModifyActivityLocationsResponse), 0, soap_copy_ns5__ModifyActivityLocationsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ModifyActivityLocationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyActivityLocationsResponse);
	return this->soap_out(soap, tag?tag:"ns5:ModifyActivityLocationsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyActivityLocationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyActivityLocationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsResponse * SOAP_FMAC4 soap_get_ns5__ModifyActivityLocationsResponse(struct soap *soap, ns5__ModifyActivityLocationsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyActivityLocationsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyActivityLocationsResponse * FASTCALL soap_instantiate_ns5__ModifyActivityLocationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyActivityLocationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyActivityLocationsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsResponse);
		ASSIGN_PTR(size, sizeof(ns5__ModifyActivityLocationsResponse));
		((ns5__ModifyActivityLocationsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyActivityLocationsResponse));
		for(int i = 0; i < n; i++)
			((ns5__ModifyActivityLocationsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyActivityLocationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyActivityLocationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyActivityLocationsResponse %p -> %p\n", q, p));
	*(ns5__ModifyActivityLocationsResponse*)p = *(ns5__ModifyActivityLocationsResponse*)q;
}

void ns5__ModifyActivityLocationsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyActivityLocationsRequest::modificationOperation = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__ModifyActivityLocationsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__BEActivityLocationsModificationOperation(soap, &this->ns5__ModifyActivityLocationsRequest::modificationOperation);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__ModifyActivityLocationsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyActivityLocationsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, const ns5__ModifyActivityLocationsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyActivityLocationsRequest), "ns5:ModifyActivityLocationsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__ModifyActivityLocationsRequest::modificationOperation) {
		if(soap_out_PointerTons7__BEActivityLocationsModificationOperation(soap, "ns5:modificationOperation", -1, &a->ns5__ModifyActivityLocationsRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyActivityLocationsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyActivityLocationsRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsRequest * FASTCALL soap_in_ns5__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, ns5__ModifyActivityLocationsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyActivityLocationsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyActivityLocationsRequest, sizeof(ns5__ModifyActivityLocationsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyActivityLocationsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyActivityLocationsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__BEActivityLocationsModificationOperation(soap, "ns5:modificationOperation", &(a->ns5__ModifyActivityLocationsRequest::modificationOperation), "ns7:BEActivityLocationsModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyActivityLocationsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyActivityLocationsRequest, 0, sizeof(ns5__ModifyActivityLocationsRequest), 0, soap_copy_ns5__ModifyActivityLocationsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ModifyActivityLocationsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyActivityLocationsRequest);
	return this->soap_out(soap, tag?tag:"ns5:ModifyActivityLocationsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyActivityLocationsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyActivityLocationsRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsRequest * SOAP_FMAC4 soap_get_ns5__ModifyActivityLocationsRequest(struct soap *soap, ns5__ModifyActivityLocationsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyActivityLocationsRequest * FASTCALL soap_instantiate_ns5__ModifyActivityLocationsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyActivityLocationsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyActivityLocationsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsRequest);
		ASSIGN_PTR(size, sizeof(ns5__ModifyActivityLocationsRequest));
		((ns5__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyActivityLocationsRequest));
		for(int i = 0; i < n; i++)
			((ns5__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyActivityLocationsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyActivityLocationsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyActivityLocationsRequest %p -> %p\n", q, p));
	*(ns5__ModifyActivityLocationsRequest*)p = *(ns5__ModifyActivityLocationsRequest*)q;
}

void ns5__ModifyEnterpriseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyEnterpriseResponse::__sizeenterprise = 0;
	this->ns5__ModifyEnterpriseResponse::enterprise = NULL;
	/* transient soap skipped */
}

void ns5__ModifyEnterpriseResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__ModifyEnterpriseResponse::enterprise) {
		for(int i = 0; i < this->ns5__ModifyEnterpriseResponse::__sizeenterprise; i++) {
			soap_serialize_PointerTons6__Enterprise(soap, this->ns5__ModifyEnterpriseResponse::enterprise + i);
		}
	}
	/* transient soap skipped */
}

int ns5__ModifyEnterpriseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyEnterpriseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyEnterpriseResponse(struct soap *soap, const char *tag, int id, const ns5__ModifyEnterpriseResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyEnterpriseResponse), "ns5:ModifyEnterpriseResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeenterprise");
	if(a->ns5__ModifyEnterpriseResponse::enterprise) {
		int i;
		for(i = 0; i < a->ns5__ModifyEnterpriseResponse::__sizeenterprise; i++)
			if(soap_out_PointerTons6__Enterprise(soap, "ns5:enterprise", -1, a->ns5__ModifyEnterpriseResponse::enterprise + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyEnterpriseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyEnterpriseResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyEnterpriseResponse * FASTCALL soap_in_ns5__ModifyEnterpriseResponse(struct soap *soap, const char *tag, ns5__ModifyEnterpriseResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyEnterpriseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyEnterpriseResponse, sizeof(ns5__ModifyEnterpriseResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyEnterpriseResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyEnterpriseResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_enterprise1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:enterprise", 1, NULL)) {
				if(a->ns5__ModifyEnterpriseResponse::enterprise == NULL) {
					if(soap_blist_enterprise1 == NULL)
						soap_blist_enterprise1 = soap_new_block(soap);
					a->ns5__ModifyEnterpriseResponse::enterprise = (ns6__Enterprise **)soap_push_block(soap, soap_blist_enterprise1, sizeof(ns6__Enterprise *));
					if(a->ns5__ModifyEnterpriseResponse::enterprise == NULL)
						return NULL;
					*a->ns5__ModifyEnterpriseResponse::enterprise = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__Enterprise(soap, "ns5:enterprise", a->ns5__ModifyEnterpriseResponse::enterprise, "ns6:Enterprise"))
				{	a->ns5__ModifyEnterpriseResponse::__sizeenterprise++;
					a->ns5__ModifyEnterpriseResponse::enterprise = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeenterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__ModifyEnterpriseResponse::enterprise)
			soap_pop_block(soap, soap_blist_enterprise1);
		if(a->ns5__ModifyEnterpriseResponse::__sizeenterprise)
			a->ns5__ModifyEnterpriseResponse::enterprise = (ns6__Enterprise **)soap_save_block(soap, soap_blist_enterprise1, NULL, 1);
		else
		{	a->ns5__ModifyEnterpriseResponse::enterprise = NULL;
			if(soap_blist_enterprise1)
				soap_end_block(soap, soap_blist_enterprise1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyEnterpriseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyEnterpriseResponse, 0, sizeof(ns5__ModifyEnterpriseResponse), 0, soap_copy_ns5__ModifyEnterpriseResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ModifyEnterpriseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyEnterpriseResponse);
	return this->soap_out(soap, tag?tag:"ns5:ModifyEnterpriseResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyEnterpriseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyEnterpriseResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyEnterpriseResponse * SOAP_FMAC4 soap_get_ns5__ModifyEnterpriseResponse(struct soap *soap, ns5__ModifyEnterpriseResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyEnterpriseResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyEnterpriseResponse * FASTCALL soap_instantiate_ns5__ModifyEnterpriseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyEnterpriseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyEnterpriseResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseResponse);
		ASSIGN_PTR(size, sizeof(ns5__ModifyEnterpriseResponse));
		((ns5__ModifyEnterpriseResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyEnterpriseResponse));
		for(int i = 0; i < n; i++)
			((ns5__ModifyEnterpriseResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyEnterpriseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyEnterpriseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyEnterpriseResponse %p -> %p\n", q, p));
	*(ns5__ModifyEnterpriseResponse*)p = *(ns5__ModifyEnterpriseResponse*)q;
}

void ns5__ModifyEnterpriseRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyEnterpriseRequest::modificationOperation = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__ModifyEnterpriseRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__ENTModificationOperation(soap, &this->ns5__ModifyEnterpriseRequest::modificationOperation);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__ModifyEnterpriseRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyEnterpriseRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyEnterpriseRequest(struct soap *soap, const char *tag, int id, const ns5__ModifyEnterpriseRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyEnterpriseRequest), "ns5:ModifyEnterpriseRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__ModifyEnterpriseRequest::modificationOperation) {
		if(soap_out_PointerTons7__ENTModificationOperation(soap, "ns5:modificationOperation", -1, &a->ns5__ModifyEnterpriseRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyEnterpriseRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyEnterpriseRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyEnterpriseRequest * FASTCALL soap_in_ns5__ModifyEnterpriseRequest(struct soap *soap, const char *tag, ns5__ModifyEnterpriseRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyEnterpriseRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyEnterpriseRequest, sizeof(ns5__ModifyEnterpriseRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyEnterpriseRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyEnterpriseRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ENTModificationOperation(soap, "ns5:modificationOperation", &(a->ns5__ModifyEnterpriseRequest::modificationOperation), "ns7:ENTModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyEnterpriseRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyEnterpriseRequest, 0, sizeof(ns5__ModifyEnterpriseRequest), 0, soap_copy_ns5__ModifyEnterpriseRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ModifyEnterpriseRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyEnterpriseRequest);
	return this->soap_out(soap, tag?tag:"ns5:ModifyEnterpriseRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyEnterpriseRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyEnterpriseRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyEnterpriseRequest * SOAP_FMAC4 soap_get_ns5__ModifyEnterpriseRequest(struct soap *soap, ns5__ModifyEnterpriseRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyEnterpriseRequest * FASTCALL soap_instantiate_ns5__ModifyEnterpriseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyEnterpriseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyEnterpriseRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseRequest);
		ASSIGN_PTR(size, sizeof(ns5__ModifyEnterpriseRequest));
		((ns5__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyEnterpriseRequest));
		for(int i = 0; i < n; i++)
			((ns5__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyEnterpriseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyEnterpriseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyEnterpriseRequest %p -> %p\n", q, p));
	*(ns5__ModifyEnterpriseRequest*)p = *(ns5__ModifyEnterpriseRequest*)q;
}

void ns5__ModifyBusinessEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyBusinessEntityResponse::__sizebusinessEntity = 0;
	this->ns5__ModifyBusinessEntityResponse::businessEntity = NULL;
	/* transient soap skipped */
}

void ns5__ModifyBusinessEntityResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__ModifyBusinessEntityResponse::businessEntity) {
		for(int i = 0; i < this->ns5__ModifyBusinessEntityResponse::__sizebusinessEntity; i++) {
			soap_serialize_PointerTons6__BusinessEntity(soap, this->ns5__ModifyBusinessEntityResponse::businessEntity + i);
		}
	}
	/* transient soap skipped */
}

int ns5__ModifyBusinessEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyBusinessEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, int id, const ns5__ModifyBusinessEntityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyBusinessEntityResponse), "ns5:ModifyBusinessEntityResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizebusinessEntity");
	if(a->ns5__ModifyBusinessEntityResponse::businessEntity) {
		int i;
		for(i = 0; i < a->ns5__ModifyBusinessEntityResponse::__sizebusinessEntity; i++)
			if(soap_out_PointerTons6__BusinessEntity(soap, "ns5:businessEntity", -1, a->ns5__ModifyBusinessEntityResponse::businessEntity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyBusinessEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyBusinessEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityResponse * FASTCALL soap_in_ns5__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, ns5__ModifyBusinessEntityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyBusinessEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyBusinessEntityResponse, sizeof(ns5__ModifyBusinessEntityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyBusinessEntityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyBusinessEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_businessEntity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:businessEntity", 1, NULL)) {
				if(a->ns5__ModifyBusinessEntityResponse::businessEntity == NULL) {
					if(soap_blist_businessEntity1 == NULL)
						soap_blist_businessEntity1 = soap_new_block(soap);
					a->ns5__ModifyBusinessEntityResponse::businessEntity = (ns6__BusinessEntity **)soap_push_block(soap, soap_blist_businessEntity1, sizeof(ns6__BusinessEntity *));
					if(a->ns5__ModifyBusinessEntityResponse::businessEntity == NULL)
						return NULL;
					*a->ns5__ModifyBusinessEntityResponse::businessEntity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons6__BusinessEntity(soap, "ns5:businessEntity", a->ns5__ModifyBusinessEntityResponse::businessEntity, "ns6:BusinessEntity"))
				{	a->ns5__ModifyBusinessEntityResponse::__sizebusinessEntity++;
					a->ns5__ModifyBusinessEntityResponse::businessEntity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizebusinessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__ModifyBusinessEntityResponse::businessEntity)
			soap_pop_block(soap, soap_blist_businessEntity1);
		if(a->ns5__ModifyBusinessEntityResponse::__sizebusinessEntity)
			a->ns5__ModifyBusinessEntityResponse::businessEntity = (ns6__BusinessEntity **)soap_save_block(soap, soap_blist_businessEntity1, NULL, 1);
		else
		{	a->ns5__ModifyBusinessEntityResponse::businessEntity = NULL;
			if(soap_blist_businessEntity1)
				soap_end_block(soap, soap_blist_businessEntity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyBusinessEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyBusinessEntityResponse, 0, sizeof(ns5__ModifyBusinessEntityResponse), 0, soap_copy_ns5__ModifyBusinessEntityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ModifyBusinessEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyBusinessEntityResponse);
	return this->soap_out(soap, tag?tag:"ns5:ModifyBusinessEntityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyBusinessEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyBusinessEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityResponse * SOAP_FMAC4 soap_get_ns5__ModifyBusinessEntityResponse(struct soap *soap, ns5__ModifyBusinessEntityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyBusinessEntityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyBusinessEntityResponse * FASTCALL soap_instantiate_ns5__ModifyBusinessEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyBusinessEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyBusinessEntityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityResponse);
		ASSIGN_PTR(size, sizeof(ns5__ModifyBusinessEntityResponse));
		((ns5__ModifyBusinessEntityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyBusinessEntityResponse));
		for(int i = 0; i < n; i++)
			((ns5__ModifyBusinessEntityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyBusinessEntityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyBusinessEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyBusinessEntityResponse %p -> %p\n", q, p));
	*(ns5__ModifyBusinessEntityResponse*)p = *(ns5__ModifyBusinessEntityResponse*)q;
}

void ns5__ModifyBusinessEntityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ModifyBusinessEntityRequest::modificationOperation = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__ModifyBusinessEntityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__BEModificationOperation(soap, &this->ns5__ModifyBusinessEntityRequest::modificationOperation);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__ModifyBusinessEntityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ModifyBusinessEntityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, const ns5__ModifyBusinessEntityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ModifyBusinessEntityRequest), "ns5:ModifyBusinessEntityRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__ModifyBusinessEntityRequest::modificationOperation) {
		if(soap_out_PointerTons7__BEModificationOperation(soap, "ns5:modificationOperation", -1, &a->ns5__ModifyBusinessEntityRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ModifyBusinessEntityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ModifyBusinessEntityRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityRequest * FASTCALL soap_in_ns5__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, ns5__ModifyBusinessEntityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ModifyBusinessEntityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ModifyBusinessEntityRequest, sizeof(ns5__ModifyBusinessEntityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ModifyBusinessEntityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ModifyBusinessEntityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__BEModificationOperation(soap, "ns5:modificationOperation", &(a->ns5__ModifyBusinessEntityRequest::modificationOperation), "ns7:BEModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ModifyBusinessEntityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ModifyBusinessEntityRequest, 0, sizeof(ns5__ModifyBusinessEntityRequest), 0, soap_copy_ns5__ModifyBusinessEntityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ModifyBusinessEntityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ModifyBusinessEntityRequest);
	return this->soap_out(soap, tag?tag:"ns5:ModifyBusinessEntityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ModifyBusinessEntityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ModifyBusinessEntityRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityRequest * SOAP_FMAC4 soap_get_ns5__ModifyBusinessEntityRequest(struct soap *soap, ns5__ModifyBusinessEntityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ModifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ModifyBusinessEntityRequest * FASTCALL soap_instantiate_ns5__ModifyBusinessEntityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ModifyBusinessEntityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ModifyBusinessEntityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityRequest);
		ASSIGN_PTR(size, sizeof(ns5__ModifyBusinessEntityRequest));
		((ns5__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ModifyBusinessEntityRequest));
		for(int i = 0; i < n; i++)
			((ns5__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ModifyBusinessEntityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ModifyBusinessEntityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ModifyBusinessEntityRequest %p -> %p\n", q, p));
	*(ns5__ModifyBusinessEntityRequest*)p = *(ns5__ModifyBusinessEntityRequest*)q;
}

void ns5__WithdrawVetDocumentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__WithdrawVetDocumentResponse::vetDocument = NULL;
	this->ns5__WithdrawVetDocumentResponse::__sizestockEntry = 0;
	this->ns5__WithdrawVetDocumentResponse::stockEntry = NULL;
	/* transient soap skipped */
}

void ns5__WithdrawVetDocumentResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__VetDocument(soap, &this->ns5__WithdrawVetDocumentResponse::vetDocument);
	if(this->ns5__WithdrawVetDocumentResponse::stockEntry) {
		for(int i = 0; i < this->ns5__WithdrawVetDocumentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns5__WithdrawVetDocumentResponse::stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int ns5__WithdrawVetDocumentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__WithdrawVetDocumentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, int id, const ns5__WithdrawVetDocumentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__WithdrawVetDocumentResponse), "ns5:WithdrawVetDocumentResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vetDocument)
		soap_element_result(soap, "ns5:vetDocument");
	if(soap_out_PointerTons7__VetDocument(soap, "ns5:vetDocument", -1, &(a->ns5__WithdrawVetDocumentResponse::vetDocument), ""))
		return soap->error;
	if(a->ns5__WithdrawVetDocumentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->ns5__WithdrawVetDocumentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns5:stockEntry", -1, a->ns5__WithdrawVetDocumentResponse::stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__WithdrawVetDocumentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__WithdrawVetDocumentResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentResponse * FASTCALL soap_in_ns5__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, ns5__WithdrawVetDocumentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__WithdrawVetDocumentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__WithdrawVetDocumentResponse, sizeof(ns5__WithdrawVetDocumentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__WithdrawVetDocumentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__WithdrawVetDocumentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vetDocument1 = 1;
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__VetDocument(soap, "ns5:vetDocument", &(a->ns5__WithdrawVetDocumentResponse::vetDocument), "ns7:VetDocument"))
				{	soap_flag_vetDocument1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:stockEntry", 1, NULL)) {
				if(a->ns5__WithdrawVetDocumentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->ns5__WithdrawVetDocumentResponse::stockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns5__WithdrawVetDocumentResponse::stockEntry == NULL)
						return NULL;
					*a->ns5__WithdrawVetDocumentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns5:stockEntry", a->ns5__WithdrawVetDocumentResponse::stockEntry, "ns7:StockEntry"))
				{	a->ns5__WithdrawVetDocumentResponse::__sizestockEntry++;
					a->ns5__WithdrawVetDocumentResponse::stockEntry = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns5:vetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__WithdrawVetDocumentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->ns5__WithdrawVetDocumentResponse::__sizestockEntry)
			a->ns5__WithdrawVetDocumentResponse::stockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->ns5__WithdrawVetDocumentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__WithdrawVetDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__WithdrawVetDocumentResponse, 0, sizeof(ns5__WithdrawVetDocumentResponse), 0, soap_copy_ns5__WithdrawVetDocumentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__WithdrawVetDocumentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__WithdrawVetDocumentResponse);
	return this->soap_out(soap, tag?tag:"ns5:WithdrawVetDocumentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__WithdrawVetDocumentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__WithdrawVetDocumentResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentResponse * SOAP_FMAC4 soap_get_ns5__WithdrawVetDocumentResponse(struct soap *soap, ns5__WithdrawVetDocumentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__WithdrawVetDocumentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__WithdrawVetDocumentResponse * FASTCALL soap_instantiate_ns5__WithdrawVetDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__WithdrawVetDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__WithdrawVetDocumentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentResponse);
		ASSIGN_PTR(size, sizeof(ns5__WithdrawVetDocumentResponse));
		((ns5__WithdrawVetDocumentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__WithdrawVetDocumentResponse));
		for(int i = 0; i < n; i++)
			((ns5__WithdrawVetDocumentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__WithdrawVetDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__WithdrawVetDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__WithdrawVetDocumentResponse %p -> %p\n", q, p));
	*(ns5__WithdrawVetDocumentResponse*)p = *(ns5__WithdrawVetDocumentResponse*)q;
}

void ns5__WithdrawVetDocumentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns5__WithdrawVetDocumentRequest::vetDocumentId);
	soap_default_ns7__VetDocumentStatusChangeReason(soap, &this->ns5__WithdrawVetDocumentRequest::withdrawReason);
	soap_default_time(soap, &this->ns5__WithdrawVetDocumentRequest::withdrawDate);
	this->ns5__WithdrawVetDocumentRequest::specifiedPerson = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__WithdrawVetDocumentRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns5__WithdrawVetDocumentRequest::vetDocumentId);
	soap_serialize_ns7__VetDocumentStatusChangeReason(soap, &this->ns5__WithdrawVetDocumentRequest::withdrawReason);
	soap_embedded(soap, &this->ns5__WithdrawVetDocumentRequest::withdrawDate, SOAP_TYPE_time);
	soap_serialize_PointerTons7__User(soap, &this->ns5__WithdrawVetDocumentRequest::specifiedPerson);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__WithdrawVetDocumentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__WithdrawVetDocumentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, const ns5__WithdrawVetDocumentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__WithdrawVetDocumentRequest), "ns5:WithdrawVetDocumentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__WithdrawVetDocumentRequest::vetDocumentId) {
		if(soap_out_ns3__UUID(soap, "ns5:vetDocumentId", -1, &a->ns5__WithdrawVetDocumentRequest::vetDocumentId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:vetDocumentId"))
		return soap->error;
	if(a->ns5__WithdrawVetDocumentRequest::withdrawReason) {
		if(soap_out_ns7__VetDocumentStatusChangeReason(soap, "ns5:withdrawReason", -1, &a->ns5__WithdrawVetDocumentRequest::withdrawReason, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:withdrawReason"))
		return soap->error;
	if(soap_out_time(soap, "ns5:withdrawDate", -1, &(a->ns5__WithdrawVetDocumentRequest::withdrawDate), ""))
		return soap->error;
	if(soap_out_PointerTons7__User(soap, "ns5:specifiedPerson", -1, &(a->ns5__WithdrawVetDocumentRequest::specifiedPerson), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__WithdrawVetDocumentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__WithdrawVetDocumentRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentRequest * FASTCALL soap_in_ns5__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, ns5__WithdrawVetDocumentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__WithdrawVetDocumentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__WithdrawVetDocumentRequest, sizeof(ns5__WithdrawVetDocumentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__WithdrawVetDocumentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__WithdrawVetDocumentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vetDocumentId1 = 1;
	size_t soap_flag_withdrawReason1 = 1;
	size_t soap_flag_withdrawDate1 = 1;
	size_t soap_flag_specifiedPerson1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vetDocumentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns5:vetDocumentId", &(a->ns5__WithdrawVetDocumentRequest::vetDocumentId), "ns3:UUID"))
				{	soap_flag_vetDocumentId1--;
					continue;
				}
			if(soap_flag_withdrawReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns7__VetDocumentStatusChangeReason(soap, "ns5:withdrawReason", &(a->ns5__WithdrawVetDocumentRequest::withdrawReason), "ns7:VetDocumentStatusChangeReason"))
				{	soap_flag_withdrawReason1--;
					continue;
				}
			if(soap_flag_withdrawDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "ns5:withdrawDate", &(a->ns5__WithdrawVetDocumentRequest::withdrawDate), "xsd:dateTime"))
				{	soap_flag_withdrawDate1--;
					continue;
				}
			if(soap_flag_specifiedPerson1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:specifiedPerson", &(a->ns5__WithdrawVetDocumentRequest::specifiedPerson), "ns7:User"))
				{	soap_flag_specifiedPerson1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__WithdrawVetDocumentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__WithdrawVetDocumentRequest, 0, sizeof(ns5__WithdrawVetDocumentRequest), 0, soap_copy_ns5__WithdrawVetDocumentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vetDocumentId1 > 0 || soap_flag_withdrawReason1 > 0 || soap_flag_withdrawDate1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__WithdrawVetDocumentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__WithdrawVetDocumentRequest);
	return this->soap_out(soap, tag?tag:"ns5:WithdrawVetDocumentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__WithdrawVetDocumentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__WithdrawVetDocumentRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentRequest * SOAP_FMAC4 soap_get_ns5__WithdrawVetDocumentRequest(struct soap *soap, ns5__WithdrawVetDocumentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__WithdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__WithdrawVetDocumentRequest * FASTCALL soap_instantiate_ns5__WithdrawVetDocumentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__WithdrawVetDocumentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__WithdrawVetDocumentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentRequest);
		ASSIGN_PTR(size, sizeof(ns5__WithdrawVetDocumentRequest));
		((ns5__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__WithdrawVetDocumentRequest));
		for(int i = 0; i < n; i++)
			((ns5__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__WithdrawVetDocumentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__WithdrawVetDocumentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__WithdrawVetDocumentRequest %p -> %p\n", q, p));
	*(ns5__WithdrawVetDocumentRequest*)p = *(ns5__WithdrawVetDocumentRequest*)q;
}

void ns5__MergeStockEntriesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__MergeStockEntriesResponse::stockEntryList = NULL;
	/* transient soap skipped */
}

void ns5__MergeStockEntriesResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns5__MergeStockEntriesResponse::stockEntryList);
	/* transient soap skipped */
}

int ns5__MergeStockEntriesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MergeStockEntriesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__MergeStockEntriesResponse(struct soap *soap, const char *tag, int id, const ns5__MergeStockEntriesResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__MergeStockEntriesResponse), "ns5:MergeStockEntriesResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "ns5:stockEntryList");
	if(a->ns5__MergeStockEntriesResponse::stockEntryList) {
		if(soap_out_PointerTons7__StockEntryList(soap, "ns5:stockEntryList", -1, &a->ns5__MergeStockEntriesResponse::stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__MergeStockEntriesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__MergeStockEntriesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MergeStockEntriesResponse * FASTCALL soap_in_ns5__MergeStockEntriesResponse(struct soap *soap, const char *tag, ns5__MergeStockEntriesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MergeStockEntriesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__MergeStockEntriesResponse, sizeof(ns5__MergeStockEntriesResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__MergeStockEntriesResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MergeStockEntriesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns5:stockEntryList", &(a->ns5__MergeStockEntriesResponse::stockEntryList), "ns7:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "ns5:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__MergeStockEntriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__MergeStockEntriesResponse, 0, sizeof(ns5__MergeStockEntriesResponse), 0, soap_copy_ns5__MergeStockEntriesResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__MergeStockEntriesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__MergeStockEntriesResponse);
	return this->soap_out(soap, tag?tag:"ns5:MergeStockEntriesResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__MergeStockEntriesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MergeStockEntriesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MergeStockEntriesResponse * SOAP_FMAC4 soap_get_ns5__MergeStockEntriesResponse(struct soap *soap, ns5__MergeStockEntriesResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__MergeStockEntriesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MergeStockEntriesResponse * FASTCALL soap_instantiate_ns5__MergeStockEntriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MergeStockEntriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__MergeStockEntriesResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesResponse);
		ASSIGN_PTR(size, sizeof(ns5__MergeStockEntriesResponse));
		((ns5__MergeStockEntriesResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__MergeStockEntriesResponse));
		for(int i = 0; i < n; i++)
			((ns5__MergeStockEntriesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__MergeStockEntriesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MergeStockEntriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MergeStockEntriesResponse %p -> %p\n", q, p));
	*(ns5__MergeStockEntriesResponse*)p = *(ns5__MergeStockEntriesResponse*)q;
}

void ns5__MergeStockEntriesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__MergeStockEntriesRequest::enterprise = NULL;
	this->ns5__MergeStockEntriesRequest::mergeOperation = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__MergeStockEntriesRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns5__MergeStockEntriesRequest::enterprise);
	soap_serialize_PointerTons7__MergeStockEntriesOperation(soap, &this->ns5__MergeStockEntriesRequest::mergeOperation);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__MergeStockEntriesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MergeStockEntriesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__MergeStockEntriesRequest(struct soap *soap, const char *tag, int id, const ns5__MergeStockEntriesRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__MergeStockEntriesRequest), "ns5:MergeStockEntriesRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__MergeStockEntriesRequest::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns5:enterprise", -1, &a->ns5__MergeStockEntriesRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:enterprise"))
		return soap->error;
	if(a->ns5__MergeStockEntriesRequest::mergeOperation) {
		if(soap_out_PointerTons7__MergeStockEntriesOperation(soap, "ns5:mergeOperation", -1, &a->ns5__MergeStockEntriesRequest::mergeOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:mergeOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__MergeStockEntriesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__MergeStockEntriesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MergeStockEntriesRequest * FASTCALL soap_in_ns5__MergeStockEntriesRequest(struct soap *soap, const char *tag, ns5__MergeStockEntriesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MergeStockEntriesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__MergeStockEntriesRequest, sizeof(ns5__MergeStockEntriesRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__MergeStockEntriesRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MergeStockEntriesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_mergeOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns5:enterprise", &(a->ns5__MergeStockEntriesRequest::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_mergeOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__MergeStockEntriesOperation(soap, "ns5:mergeOperation", &(a->ns5__MergeStockEntriesRequest::mergeOperation), "ns7:MergeStockEntriesOperation"))
				{	soap_flag_mergeOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__MergeStockEntriesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__MergeStockEntriesRequest, 0, sizeof(ns5__MergeStockEntriesRequest), 0, soap_copy_ns5__MergeStockEntriesRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_mergeOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__MergeStockEntriesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__MergeStockEntriesRequest);
	return this->soap_out(soap, tag?tag:"ns5:MergeStockEntriesRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__MergeStockEntriesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MergeStockEntriesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MergeStockEntriesRequest * SOAP_FMAC4 soap_get_ns5__MergeStockEntriesRequest(struct soap *soap, ns5__MergeStockEntriesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__MergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MergeStockEntriesRequest * FASTCALL soap_instantiate_ns5__MergeStockEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MergeStockEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__MergeStockEntriesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesRequest);
		ASSIGN_PTR(size, sizeof(ns5__MergeStockEntriesRequest));
		((ns5__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__MergeStockEntriesRequest));
		for(int i = 0; i < n; i++)
			((ns5__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__MergeStockEntriesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MergeStockEntriesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MergeStockEntriesRequest %p -> %p\n", q, p));
	*(ns5__MergeStockEntriesRequest*)p = *(ns5__MergeStockEntriesRequest*)q;
}

void ns5__RegisterProductionOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__RegisterProductionOperationResponse::stockEntryList = NULL;
	this->ns5__RegisterProductionOperationResponse::__sizevetDocument = 0;
	this->ns5__RegisterProductionOperationResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void ns5__RegisterProductionOperationResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__StockEntryList(soap, &this->ns5__RegisterProductionOperationResponse::stockEntryList);
	if(this->ns5__RegisterProductionOperationResponse::vetDocument) {
		for(int i = 0; i < this->ns5__RegisterProductionOperationResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns5__RegisterProductionOperationResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int ns5__RegisterProductionOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RegisterProductionOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__RegisterProductionOperationResponse(struct soap *soap, const char *tag, int id, const ns5__RegisterProductionOperationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__RegisterProductionOperationResponse), "ns5:RegisterProductionOperationResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "ns5:stockEntryList");
	if(soap_out_PointerTons7__StockEntryList(soap, "ns5:stockEntryList", -1, &(a->ns5__RegisterProductionOperationResponse::stockEntryList), ""))
		return soap->error;
	if(a->ns5__RegisterProductionOperationResponse::vetDocument) {
		int i;
		for(i = 0; i < a->ns5__RegisterProductionOperationResponse::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns5:vetDocument", -1, a->ns5__RegisterProductionOperationResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__RegisterProductionOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__RegisterProductionOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RegisterProductionOperationResponse * FASTCALL soap_in_ns5__RegisterProductionOperationResponse(struct soap *soap, const char *tag, ns5__RegisterProductionOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RegisterProductionOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__RegisterProductionOperationResponse, sizeof(ns5__RegisterProductionOperationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__RegisterProductionOperationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RegisterProductionOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__StockEntryList(soap, "ns5:stockEntryList", &(a->ns5__RegisterProductionOperationResponse::stockEntryList), "ns7:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:vetDocument", 1, NULL)) {
				if(a->ns5__RegisterProductionOperationResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->ns5__RegisterProductionOperationResponse::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns5__RegisterProductionOperationResponse::vetDocument == NULL)
						return NULL;
					*a->ns5__RegisterProductionOperationResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns5:vetDocument", a->ns5__RegisterProductionOperationResponse::vetDocument, "ns7:VetDocument"))
				{	a->ns5__RegisterProductionOperationResponse::__sizevetDocument++;
					a->ns5__RegisterProductionOperationResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns5:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__RegisterProductionOperationResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->ns5__RegisterProductionOperationResponse::__sizevetDocument)
			a->ns5__RegisterProductionOperationResponse::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->ns5__RegisterProductionOperationResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__RegisterProductionOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__RegisterProductionOperationResponse, 0, sizeof(ns5__RegisterProductionOperationResponse), 0, soap_copy_ns5__RegisterProductionOperationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__RegisterProductionOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__RegisterProductionOperationResponse);
	return this->soap_out(soap, tag?tag:"ns5:RegisterProductionOperationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__RegisterProductionOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RegisterProductionOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RegisterProductionOperationResponse * SOAP_FMAC4 soap_get_ns5__RegisterProductionOperationResponse(struct soap *soap, ns5__RegisterProductionOperationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__RegisterProductionOperationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RegisterProductionOperationResponse * FASTCALL soap_instantiate_ns5__RegisterProductionOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RegisterProductionOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__RegisterProductionOperationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationResponse);
		ASSIGN_PTR(size, sizeof(ns5__RegisterProductionOperationResponse));
		((ns5__RegisterProductionOperationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__RegisterProductionOperationResponse));
		for(int i = 0; i < n; i++)
			((ns5__RegisterProductionOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__RegisterProductionOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RegisterProductionOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RegisterProductionOperationResponse %p -> %p\n", q, p));
	*(ns5__RegisterProductionOperationResponse*)p = *(ns5__RegisterProductionOperationResponse*)q;
}

void ns5__RegisterProductionOperationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__RegisterProductionOperationRequest::enterprise = NULL;
	this->ns5__RegisterProductionOperationRequest::productionOperation = NULL;
	this->ns5__RegisterProductionOperationRequest::__sizevetDocument = 0;
	this->ns5__RegisterProductionOperationRequest::vetDocument = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__RegisterProductionOperationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons6__Enterprise(soap, &this->ns5__RegisterProductionOperationRequest::enterprise);
	soap_serialize_PointerTons7__ProductionOperation(soap, &this->ns5__RegisterProductionOperationRequest::productionOperation);
	if(this->ns5__RegisterProductionOperationRequest::vetDocument) {
		for(int i = 0; i < this->ns5__RegisterProductionOperationRequest::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns5__RegisterProductionOperationRequest::vetDocument + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__RegisterProductionOperationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__RegisterProductionOperationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__RegisterProductionOperationRequest(struct soap *soap, const char *tag, int id, const ns5__RegisterProductionOperationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__RegisterProductionOperationRequest), "ns5:RegisterProductionOperationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__RegisterProductionOperationRequest::enterprise) {
		if(soap_out_PointerTons6__Enterprise(soap, "ns5:enterprise", -1, &a->ns5__RegisterProductionOperationRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:enterprise"))
		return soap->error;
	if(a->ns5__RegisterProductionOperationRequest::productionOperation) {
		if(soap_out_PointerTons7__ProductionOperation(soap, "ns5:productionOperation", -1, &a->ns5__RegisterProductionOperationRequest::productionOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:productionOperation"))
		return soap->error;
	if(a->ns5__RegisterProductionOperationRequest::vetDocument) {
		int i;
		for(i = 0; i < a->ns5__RegisterProductionOperationRequest::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns5:vetDocument", -1, a->ns5__RegisterProductionOperationRequest::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__RegisterProductionOperationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__RegisterProductionOperationRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__RegisterProductionOperationRequest * FASTCALL soap_in_ns5__RegisterProductionOperationRequest(struct soap *soap, const char *tag, ns5__RegisterProductionOperationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__RegisterProductionOperationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__RegisterProductionOperationRequest, sizeof(ns5__RegisterProductionOperationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__RegisterProductionOperationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__RegisterProductionOperationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_productionOperation1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__Enterprise(soap, "ns5:enterprise", &(a->ns5__RegisterProductionOperationRequest::enterprise), "ns6:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_productionOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__ProductionOperation(soap, "ns5:productionOperation", &(a->ns5__RegisterProductionOperationRequest::productionOperation), "ns7:ProductionOperation"))
				{	soap_flag_productionOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:vetDocument", 1, NULL)) {
				if(a->ns5__RegisterProductionOperationRequest::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->ns5__RegisterProductionOperationRequest::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns5__RegisterProductionOperationRequest::vetDocument == NULL)
						return NULL;
					*a->ns5__RegisterProductionOperationRequest::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns5:vetDocument", a->ns5__RegisterProductionOperationRequest::vetDocument, "ns7:VetDocument"))
				{	a->ns5__RegisterProductionOperationRequest::__sizevetDocument++;
					a->ns5__RegisterProductionOperationRequest::vetDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__RegisterProductionOperationRequest::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->ns5__RegisterProductionOperationRequest::__sizevetDocument)
			a->ns5__RegisterProductionOperationRequest::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->ns5__RegisterProductionOperationRequest::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__RegisterProductionOperationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__RegisterProductionOperationRequest, 0, sizeof(ns5__RegisterProductionOperationRequest), 0, soap_copy_ns5__RegisterProductionOperationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_productionOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__RegisterProductionOperationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__RegisterProductionOperationRequest);
	return this->soap_out(soap, tag?tag:"ns5:RegisterProductionOperationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__RegisterProductionOperationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__RegisterProductionOperationRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__RegisterProductionOperationRequest * SOAP_FMAC4 soap_get_ns5__RegisterProductionOperationRequest(struct soap *soap, ns5__RegisterProductionOperationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__RegisterProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__RegisterProductionOperationRequest * FASTCALL soap_instantiate_ns5__RegisterProductionOperationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__RegisterProductionOperationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__RegisterProductionOperationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationRequest);
		ASSIGN_PTR(size, sizeof(ns5__RegisterProductionOperationRequest));
		((ns5__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__RegisterProductionOperationRequest));
		for(int i = 0; i < n; i++)
			((ns5__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__RegisterProductionOperationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__RegisterProductionOperationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__RegisterProductionOperationRequest %p -> %p\n", q, p));
	*(ns5__RegisterProductionOperationRequest*)p = *(ns5__RegisterProductionOperationRequest*)q;
}

void ns5__PrepareOutgoingConsignmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__PrepareOutgoingConsignmentResponse::__sizestockEntry = 0;
	this->ns5__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
	this->ns5__PrepareOutgoingConsignmentResponse::__sizevetDocument = 0;
	this->ns5__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void ns5__PrepareOutgoingConsignmentResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__PrepareOutgoingConsignmentResponse::stockEntry) {
		for(int i = 0; i < this->ns5__PrepareOutgoingConsignmentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns5__PrepareOutgoingConsignmentResponse::stockEntry + i);
		}
	}
	if(this->ns5__PrepareOutgoingConsignmentResponse::vetDocument) {
		for(int i = 0; i < this->ns5__PrepareOutgoingConsignmentResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns5__PrepareOutgoingConsignmentResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int ns5__PrepareOutgoingConsignmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__PrepareOutgoingConsignmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, int id, const ns5__PrepareOutgoingConsignmentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse), "ns5:PrepareOutgoingConsignmentResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->ns5__PrepareOutgoingConsignmentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->ns5__PrepareOutgoingConsignmentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns5:stockEntry", -1, a->ns5__PrepareOutgoingConsignmentResponse::stockEntry + i, ""))
				return soap->error;
	}
	if(a->ns5__PrepareOutgoingConsignmentResponse::vetDocument) {
		int i;
		for(i = 0; i < a->ns5__PrepareOutgoingConsignmentResponse::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns5:vetDocument", -1, a->ns5__PrepareOutgoingConsignmentResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__PrepareOutgoingConsignmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__PrepareOutgoingConsignmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentResponse * FASTCALL soap_in_ns5__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, ns5__PrepareOutgoingConsignmentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__PrepareOutgoingConsignmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse, sizeof(ns5__PrepareOutgoingConsignmentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__PrepareOutgoingConsignmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:stockEntry", 1, NULL)) {
				if(a->ns5__PrepareOutgoingConsignmentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->ns5__PrepareOutgoingConsignmentResponse::stockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns5__PrepareOutgoingConsignmentResponse::stockEntry == NULL)
						return NULL;
					*a->ns5__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns5:stockEntry", a->ns5__PrepareOutgoingConsignmentResponse::stockEntry, "ns7:StockEntry"))
				{	a->ns5__PrepareOutgoingConsignmentResponse::__sizestockEntry++;
					a->ns5__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:vetDocument", 1, NULL)) {
				if(a->ns5__PrepareOutgoingConsignmentResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->ns5__PrepareOutgoingConsignmentResponse::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns5__PrepareOutgoingConsignmentResponse::vetDocument == NULL)
						return NULL;
					*a->ns5__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns5:vetDocument", a->ns5__PrepareOutgoingConsignmentResponse::vetDocument, "ns7:VetDocument"))
				{	a->ns5__PrepareOutgoingConsignmentResponse::__sizevetDocument++;
					a->ns5__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__PrepareOutgoingConsignmentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->ns5__PrepareOutgoingConsignmentResponse::__sizestockEntry)
			a->ns5__PrepareOutgoingConsignmentResponse::stockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->ns5__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(a->ns5__PrepareOutgoingConsignmentResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->ns5__PrepareOutgoingConsignmentResponse::__sizevetDocument)
			a->ns5__PrepareOutgoingConsignmentResponse::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->ns5__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__PrepareOutgoingConsignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse, 0, sizeof(ns5__PrepareOutgoingConsignmentResponse), 0, soap_copy_ns5__PrepareOutgoingConsignmentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__PrepareOutgoingConsignmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse);
	return this->soap_out(soap, tag?tag:"ns5:PrepareOutgoingConsignmentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__PrepareOutgoingConsignmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__PrepareOutgoingConsignmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentResponse * SOAP_FMAC4 soap_get_ns5__PrepareOutgoingConsignmentResponse(struct soap *soap, ns5__PrepareOutgoingConsignmentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__PrepareOutgoingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__PrepareOutgoingConsignmentResponse * FASTCALL soap_instantiate_ns5__PrepareOutgoingConsignmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__PrepareOutgoingConsignmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentResponse);
		ASSIGN_PTR(size, sizeof(ns5__PrepareOutgoingConsignmentResponse));
		((ns5__PrepareOutgoingConsignmentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__PrepareOutgoingConsignmentResponse));
		for(int i = 0; i < n; i++)
			((ns5__PrepareOutgoingConsignmentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__PrepareOutgoingConsignmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__PrepareOutgoingConsignmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__PrepareOutgoingConsignmentResponse %p -> %p\n", q, p));
	*(ns5__PrepareOutgoingConsignmentResponse*)p = *(ns5__PrepareOutgoingConsignmentResponse*)q;
}

void ns5__PrepareOutgoingConsignmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__PrepareOutgoingConsignmentRequest::__sizedelivery = 0;
	this->ns5__PrepareOutgoingConsignmentRequest::delivery = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__PrepareOutgoingConsignmentRequest::soap_serialize(struct soap *soap) const
{
	if(this->ns5__PrepareOutgoingConsignmentRequest::delivery) {
		for(int i = 0; i < this->ns5__PrepareOutgoingConsignmentRequest::__sizedelivery; i++) {
			soap_serialize_PointerTons7__Delivery(soap, this->ns5__PrepareOutgoingConsignmentRequest::delivery + i);
		}
	}
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__PrepareOutgoingConsignmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__PrepareOutgoingConsignmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, const ns5__PrepareOutgoingConsignmentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest), "ns5:PrepareOutgoingConsignmentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__PrepareOutgoingConsignmentRequest::delivery) {
		int i;
		for(i = 0; i < a->ns5__PrepareOutgoingConsignmentRequest::__sizedelivery; i++)
			if(soap_out_PointerTons7__Delivery(soap, "ns5:delivery", -1, a->ns5__PrepareOutgoingConsignmentRequest::delivery + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__PrepareOutgoingConsignmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__PrepareOutgoingConsignmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentRequest * FASTCALL soap_in_ns5__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, ns5__PrepareOutgoingConsignmentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__PrepareOutgoingConsignmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest, sizeof(ns5__PrepareOutgoingConsignmentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__PrepareOutgoingConsignmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_delivery1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:delivery", 1, NULL)) {
				if(a->ns5__PrepareOutgoingConsignmentRequest::delivery == NULL) {
					if(soap_blist_delivery1 == NULL)
						soap_blist_delivery1 = soap_new_block(soap);
					a->ns5__PrepareOutgoingConsignmentRequest::delivery = (ns7__Delivery **)soap_push_block(soap, soap_blist_delivery1, sizeof(ns7__Delivery *));
					if(a->ns5__PrepareOutgoingConsignmentRequest::delivery == NULL)
						return NULL;
					*a->ns5__PrepareOutgoingConsignmentRequest::delivery = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__Delivery(soap, "ns5:delivery", a->ns5__PrepareOutgoingConsignmentRequest::delivery, "ns7:Delivery"))
				{	a->ns5__PrepareOutgoingConsignmentRequest::__sizedelivery++;
					a->ns5__PrepareOutgoingConsignmentRequest::delivery = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__PrepareOutgoingConsignmentRequest::delivery)
			soap_pop_block(soap, soap_blist_delivery1);
		if(a->ns5__PrepareOutgoingConsignmentRequest::__sizedelivery)
			a->ns5__PrepareOutgoingConsignmentRequest::delivery = (ns7__Delivery **)soap_save_block(soap, soap_blist_delivery1, NULL, 1);
		else
		{	a->ns5__PrepareOutgoingConsignmentRequest::delivery = NULL;
			if(soap_blist_delivery1)
				soap_end_block(soap, soap_blist_delivery1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__PrepareOutgoingConsignmentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest, 0, sizeof(ns5__PrepareOutgoingConsignmentRequest), 0, soap_copy_ns5__PrepareOutgoingConsignmentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->ns5__PrepareOutgoingConsignmentRequest::__sizedelivery < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__PrepareOutgoingConsignmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest);
	return this->soap_out(soap, tag?tag:"ns5:PrepareOutgoingConsignmentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__PrepareOutgoingConsignmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__PrepareOutgoingConsignmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentRequest * SOAP_FMAC4 soap_get_ns5__PrepareOutgoingConsignmentRequest(struct soap *soap, ns5__PrepareOutgoingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__PrepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__PrepareOutgoingConsignmentRequest * FASTCALL soap_instantiate_ns5__PrepareOutgoingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__PrepareOutgoingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(ns5__PrepareOutgoingConsignmentRequest));
		((ns5__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__PrepareOutgoingConsignmentRequest));
		for(int i = 0; i < n; i++)
			((ns5__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__PrepareOutgoingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__PrepareOutgoingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__PrepareOutgoingConsignmentRequest %p -> %p\n", q, p));
	*(ns5__PrepareOutgoingConsignmentRequest*)p = *(ns5__PrepareOutgoingConsignmentRequest*)q;
}

void ns5__ProcessIncomingConsignmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ProcessIncomingConsignmentResponse::__sizestockEntry = 0;
	this->ns5__ProcessIncomingConsignmentResponse::stockEntry = NULL;
	this->ns5__ProcessIncomingConsignmentResponse::__sizevetDocument = 0;
	this->ns5__ProcessIncomingConsignmentResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void ns5__ProcessIncomingConsignmentResponse::soap_serialize(struct soap *soap) const
{
	if(this->ns5__ProcessIncomingConsignmentResponse::stockEntry) {
		for(int i = 0; i < this->ns5__ProcessIncomingConsignmentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTons7__StockEntry(soap, this->ns5__ProcessIncomingConsignmentResponse::stockEntry + i);
		}
	}
	if(this->ns5__ProcessIncomingConsignmentResponse::vetDocument) {
		for(int i = 0; i < this->ns5__ProcessIncomingConsignmentResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTons7__VetDocument(soap, this->ns5__ProcessIncomingConsignmentResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int ns5__ProcessIncomingConsignmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ProcessIncomingConsignmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, int id, const ns5__ProcessIncomingConsignmentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse), "ns5:ProcessIncomingConsignmentResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->ns5__ProcessIncomingConsignmentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->ns5__ProcessIncomingConsignmentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTons7__StockEntry(soap, "ns5:stockEntry", -1, a->ns5__ProcessIncomingConsignmentResponse::stockEntry + i, ""))
				return soap->error;
	}
	if(a->ns5__ProcessIncomingConsignmentResponse::vetDocument) {
		int i;
		for(i = 0; i < a->ns5__ProcessIncomingConsignmentResponse::__sizevetDocument; i++)
			if(soap_out_PointerTons7__VetDocument(soap, "ns5:vetDocument", -1, a->ns5__ProcessIncomingConsignmentResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns5__ProcessIncomingConsignmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ProcessIncomingConsignmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentResponse * FASTCALL soap_in_ns5__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, ns5__ProcessIncomingConsignmentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ProcessIncomingConsignmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse, sizeof(ns5__ProcessIncomingConsignmentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ProcessIncomingConsignmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:stockEntry", 1, NULL)) {
				if(a->ns5__ProcessIncomingConsignmentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->ns5__ProcessIncomingConsignmentResponse::stockEntry = (ns7__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(ns7__StockEntry *));
					if(a->ns5__ProcessIncomingConsignmentResponse::stockEntry == NULL)
						return NULL;
					*a->ns5__ProcessIncomingConsignmentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__StockEntry(soap, "ns5:stockEntry", a->ns5__ProcessIncomingConsignmentResponse::stockEntry, "ns7:StockEntry"))
				{	a->ns5__ProcessIncomingConsignmentResponse::__sizestockEntry++;
					a->ns5__ProcessIncomingConsignmentResponse::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:vetDocument", 1, NULL)) {
				if(a->ns5__ProcessIncomingConsignmentResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->ns5__ProcessIncomingConsignmentResponse::vetDocument = (ns7__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(ns7__VetDocument *));
					if(a->ns5__ProcessIncomingConsignmentResponse::vetDocument == NULL)
						return NULL;
					*a->ns5__ProcessIncomingConsignmentResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__VetDocument(soap, "ns5:vetDocument", a->ns5__ProcessIncomingConsignmentResponse::vetDocument, "ns7:VetDocument"))
				{	a->ns5__ProcessIncomingConsignmentResponse::__sizevetDocument++;
					a->ns5__ProcessIncomingConsignmentResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__ProcessIncomingConsignmentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->ns5__ProcessIncomingConsignmentResponse::__sizestockEntry)
			a->ns5__ProcessIncomingConsignmentResponse::stockEntry = (ns7__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->ns5__ProcessIncomingConsignmentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(a->ns5__ProcessIncomingConsignmentResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->ns5__ProcessIncomingConsignmentResponse::__sizevetDocument)
			a->ns5__ProcessIncomingConsignmentResponse::vetDocument = (ns7__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->ns5__ProcessIncomingConsignmentResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ProcessIncomingConsignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse, 0, sizeof(ns5__ProcessIncomingConsignmentResponse), 0, soap_copy_ns5__ProcessIncomingConsignmentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ProcessIncomingConsignmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse);
	return this->soap_out(soap, tag?tag:"ns5:ProcessIncomingConsignmentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ProcessIncomingConsignmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ProcessIncomingConsignmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentResponse * SOAP_FMAC4 soap_get_ns5__ProcessIncomingConsignmentResponse(struct soap *soap, ns5__ProcessIncomingConsignmentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ProcessIncomingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ProcessIncomingConsignmentResponse * FASTCALL soap_instantiate_ns5__ProcessIncomingConsignmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ProcessIncomingConsignmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentResponse);
		ASSIGN_PTR(size, sizeof(ns5__ProcessIncomingConsignmentResponse));
		((ns5__ProcessIncomingConsignmentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ProcessIncomingConsignmentResponse));
		for(int i = 0; i < n; i++)
			((ns5__ProcessIncomingConsignmentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ProcessIncomingConsignmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ProcessIncomingConsignmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ProcessIncomingConsignmentResponse %p -> %p\n", q, p));
	*(ns5__ProcessIncomingConsignmentResponse*)p = *(ns5__ProcessIncomingConsignmentResponse*)q;
}

void ns5__ProcessIncomingConsignmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__ProcessIncomingConsignmentRequest::delivery = NULL;
	this->ns5__ProcessIncomingConsignmentRequest::deliveryFacts = NULL;
	this->ns5__ProcessIncomingConsignmentRequest::__sizediscrepancyReport = 0;
	this->ns5__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
	this->ns5__ProcessIncomingConsignmentRequest::returnedDelivery = NULL;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__ProcessIncomingConsignmentRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons7__Delivery(soap, &this->ns5__ProcessIncomingConsignmentRequest::delivery);
	soap_serialize_PointerTons7__DeliveryFactList(soap, &this->ns5__ProcessIncomingConsignmentRequest::deliveryFacts);
	if(this->ns5__ProcessIncomingConsignmentRequest::discrepancyReport) {
		for(int i = 0; i < this->ns5__ProcessIncomingConsignmentRequest::__sizediscrepancyReport; i++) {
			soap_serialize_PointerTons7__DiscrepancyReport(soap, this->ns5__ProcessIncomingConsignmentRequest::discrepancyReport + i);
		}
	}
	soap_serialize_PointerTons7__Delivery(soap, &this->ns5__ProcessIncomingConsignmentRequest::returnedDelivery);
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__ProcessIncomingConsignmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ProcessIncomingConsignmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, const ns5__ProcessIncomingConsignmentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest), "ns5:ProcessIncomingConsignmentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->ns5__ProcessIncomingConsignmentRequest::delivery) {
		if(soap_out_PointerTons7__Delivery(soap, "ns5:delivery", -1, &a->ns5__ProcessIncomingConsignmentRequest::delivery, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:delivery"))
		return soap->error;
	if(a->ns5__ProcessIncomingConsignmentRequest::deliveryFacts) {
		if(soap_out_PointerTons7__DeliveryFactList(soap, "ns5:deliveryFacts", -1, &a->ns5__ProcessIncomingConsignmentRequest::deliveryFacts, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:deliveryFacts"))
		return soap->error;
	if(a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport) {
		int i;
		for(i = 0; i < a->ns5__ProcessIncomingConsignmentRequest::__sizediscrepancyReport; i++)
			if(soap_out_PointerTons7__DiscrepancyReport(soap, "ns5:discrepancyReport", -1, a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTons7__Delivery(soap, "ns5:returnedDelivery", -1, &(a->ns5__ProcessIncomingConsignmentRequest::returnedDelivery), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ProcessIncomingConsignmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__ProcessIncomingConsignmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentRequest * FASTCALL soap_in_ns5__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, ns5__ProcessIncomingConsignmentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ProcessIncomingConsignmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest, sizeof(ns5__ProcessIncomingConsignmentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ProcessIncomingConsignmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_delivery1 = 1;
	size_t soap_flag_deliveryFacts1 = 1;
	struct soap_blist *soap_blist_discrepancyReport1 = NULL;
	size_t soap_flag_returnedDelivery1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_delivery1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Delivery(soap, "ns5:delivery", &(a->ns5__ProcessIncomingConsignmentRequest::delivery), "ns7:Delivery"))
				{	soap_flag_delivery1--;
					continue;
				}
			if(soap_flag_deliveryFacts1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__DeliveryFactList(soap, "ns5:deliveryFacts", &(a->ns5__ProcessIncomingConsignmentRequest::deliveryFacts), "ns7:DeliveryFactList"))
				{	soap_flag_deliveryFacts1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:discrepancyReport", 1, NULL)) {
				if(a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport == NULL) {
					if(soap_blist_discrepancyReport1 == NULL)
						soap_blist_discrepancyReport1 = soap_new_block(soap);
					a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport = (ns7__DiscrepancyReport **)soap_push_block(soap, soap_blist_discrepancyReport1, sizeof(ns7__DiscrepancyReport *));
					if(a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport == NULL)
						return NULL;
					*a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons7__DiscrepancyReport(soap, "ns5:discrepancyReport", a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport, "ns7:DiscrepancyReport"))
				{	a->ns5__ProcessIncomingConsignmentRequest::__sizediscrepancyReport++;
					a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
					continue;
				}
			}
			if(soap_flag_returnedDelivery1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__Delivery(soap, "ns5:returnedDelivery", &(a->ns5__ProcessIncomingConsignmentRequest::returnedDelivery), "ns7:Delivery"))
				{	soap_flag_returnedDelivery1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport)
			soap_pop_block(soap, soap_blist_discrepancyReport1);
		if(a->ns5__ProcessIncomingConsignmentRequest::__sizediscrepancyReport)
			a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport = (ns7__DiscrepancyReport **)soap_save_block(soap, soap_blist_discrepancyReport1, NULL, 1);
		else
		{	a->ns5__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
			if(soap_blist_discrepancyReport1)
				soap_end_block(soap, soap_blist_discrepancyReport1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__ProcessIncomingConsignmentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest, 0, sizeof(ns5__ProcessIncomingConsignmentRequest), 0, soap_copy_ns5__ProcessIncomingConsignmentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_delivery1 > 0 || soap_flag_deliveryFacts1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ProcessIncomingConsignmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest);
	return this->soap_out(soap, tag?tag:"ns5:ProcessIncomingConsignmentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__ProcessIncomingConsignmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ProcessIncomingConsignmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentRequest * SOAP_FMAC4 soap_get_ns5__ProcessIncomingConsignmentRequest(struct soap *soap, ns5__ProcessIncomingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__ProcessIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ProcessIncomingConsignmentRequest * FASTCALL soap_instantiate_ns5__ProcessIncomingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ProcessIncomingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(ns5__ProcessIncomingConsignmentRequest));
		((ns5__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__ProcessIncomingConsignmentRequest));
		for(int i = 0; i < n; i++)
			((ns5__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ProcessIncomingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ProcessIncomingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ProcessIncomingConsignmentRequest %p -> %p\n", q, p));
	*(ns5__ProcessIncomingConsignmentRequest*)p = *(ns5__ProcessIncomingConsignmentRequest*)q;
}

void ns5__MercuryApplicationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	this->ns5__MercuryApplicationRequest::initiator = NULL;
	this->ns5__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void ns5__MercuryApplicationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__Identifier(soap, &this->ns5__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTons7__User(soap, &this->ns5__MercuryApplicationRequest::initiator);
	soap_serialize_PointerTons6__OTPToken(soap, &this->ns5__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int ns5__MercuryApplicationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__MercuryApplicationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns5__MercuryApplicationRequest(struct soap *soap, const char *tag, int id, const ns5__MercuryApplicationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__MercuryApplicationRequest), "ns5:MercuryApplicationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->ns5__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_ns3__Identifier(soap, "ns5:localTransactionId", -1, &a->ns5__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:localTransactionId"))
		return soap->error;
	if(a->ns5__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTons7__User(soap, "ns5:initiator", -1, &a->ns5__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns5:initiator"))
		return soap->error;
	if(soap_out_PointerTons6__OTPToken(soap, "ns5:sessionToken", -1, &(a->ns5__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__MercuryApplicationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns5__MercuryApplicationRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns5__MercuryApplicationRequest * FASTCALL soap_in_ns5__MercuryApplicationRequest(struct soap *soap, const char *tag, ns5__MercuryApplicationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__MercuryApplicationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__MercuryApplicationRequest, sizeof(ns5__MercuryApplicationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns5__MercuryApplicationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns5__MercuryApplicationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId1 = 1;
	size_t soap_flag_initiator1 = 1;
	size_t soap_flag_sessionToken1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__Identifier(soap, "ns5:localTransactionId", &(a->ns5__MercuryApplicationRequest::localTransactionId), "ns3:Identifier"))
				{	soap_flag_localTransactionId1--;
					continue;
				}
			if(soap_flag_initiator1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons7__User(soap, "ns5:initiator", &(a->ns5__MercuryApplicationRequest::initiator), "ns7:User"))
				{	soap_flag_initiator1--;
					continue;
				}
			if(soap_flag_sessionToken1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons6__OTPToken(soap, "ns5:sessionToken", &(a->ns5__MercuryApplicationRequest::sessionToken), "ns6:OTPToken"))
				{	soap_flag_sessionToken1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns5__MercuryApplicationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__MercuryApplicationRequest, 0, sizeof(ns5__MercuryApplicationRequest), 0, soap_copy_ns5__MercuryApplicationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId1 > 0 || soap_flag_initiator1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__MercuryApplicationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__MercuryApplicationRequest);
	return this->soap_out(soap, tag?tag:"ns5:MercuryApplicationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns5__MercuryApplicationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__MercuryApplicationRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns5__MercuryApplicationRequest * SOAP_FMAC4 soap_get_ns5__MercuryApplicationRequest(struct soap *soap, ns5__MercuryApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_ns5__MercuryApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__MercuryApplicationRequest * FASTCALL soap_instantiate_ns5__MercuryApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__MercuryApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__MercuryApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns5:ProcessIncomingConsignmentRequest")) {
		cp->type = SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ProcessIncomingConsignmentRequest));
			((ns5__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ProcessIncomingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((ns5__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ProcessIncomingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:PrepareOutgoingConsignmentRequest")) {
		cp->type = SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__PrepareOutgoingConsignmentRequest));
			((ns5__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__PrepareOutgoingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((ns5__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__PrepareOutgoingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:RegisterProductionOperationRequest")) {
		cp->type = SOAP_TYPE_ns5__RegisterProductionOperationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__RegisterProductionOperationRequest));
			((ns5__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__RegisterProductionOperationRequest));
			for(int i = 0; i < n; i++)
				((ns5__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__RegisterProductionOperationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:MergeStockEntriesRequest")) {
		cp->type = SOAP_TYPE_ns5__MergeStockEntriesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__MergeStockEntriesRequest));
			((ns5__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__MergeStockEntriesRequest));
			for(int i = 0; i < n; i++)
				((ns5__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__MergeStockEntriesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:WithdrawVetDocumentRequest")) {
		cp->type = SOAP_TYPE_ns5__WithdrawVetDocumentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__WithdrawVetDocumentRequest));
			((ns5__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__WithdrawVetDocumentRequest));
			for(int i = 0; i < n; i++)
				((ns5__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__WithdrawVetDocumentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyBusinessEntityRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyBusinessEntityRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyBusinessEntityRequest));
			((ns5__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyBusinessEntityRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyBusinessEntityRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyEnterpriseRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyEnterpriseRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyEnterpriseRequest));
			((ns5__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyEnterpriseRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyEnterpriseRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyActivityLocationsRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyActivityLocationsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyActivityLocationsRequest));
			((ns5__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyActivityLocationsRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyActivityLocationsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ResolveDiscrepancyRequest")) {
		cp->type = SOAP_TYPE_ns5__ResolveDiscrepancyRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ResolveDiscrepancyRequest));
			((ns5__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ResolveDiscrepancyRequest));
			for(int i = 0; i < n; i++)
				((ns5__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ResolveDiscrepancyRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyProducerStockListRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyProducerStockListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyProducerStockListRequest));
			((ns5__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyProducerStockListRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyProducerStockListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentByUuidRequest")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentByUuidRequest));
			((ns5__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentByUuidRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentListRequest));
			((ns5__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentChangesListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentChangesListRequest));
			((ns5__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentChangesListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryByGuidRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryByGuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByGuidRequest));
			((ns5__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByGuidRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryByGuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryByUuidRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByUuidRequest));
			((ns5__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByUuidRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryChangesListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryChangesListRequest));
			((ns5__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryChangesListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryListRequest));
			((ns5__GetStockEntryListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryVersionListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryVersionListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryVersionListRequest));
			((ns5__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryVersionListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryVersionListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateTransportMovementDetailsRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateTransportMovementDetailsRequest));
			((ns5__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateTransportMovementDetailsRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateTransportMovementDetailsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateVeterinaryEventsRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateVeterinaryEventsRequest));
			((ns5__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateVeterinaryEventsRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateVeterinaryEventsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:CheckShipmentRegionalizationRequest")) {
		cp->type = SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__CheckShipmentRegionalizationRequest));
			((ns5__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__CheckShipmentRegionalizationRequest));
			for(int i = 0; i < n; i++)
				((ns5__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__CheckShipmentRegionalizationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:AddBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_ns5__AddBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__AddBusinessEntityUserRequest));
			((ns5__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__AddBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((ns5__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__AddBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetBusinessEntityUserListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetBusinessEntityUserListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserListRequest));
			((ns5__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetBusinessEntityUserListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_ns5__GetBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserRequest));
			((ns5__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateUserAuthoritiesRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateUserAuthoritiesRequest));
			((ns5__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserAuthoritiesRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateUserAuthoritiesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateUserWorkingAreasRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateUserWorkingAreasRequest));
			((ns5__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserWorkingAreasRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateUserWorkingAreasRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UnbindBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UnbindBusinessEntityUserRequest));
			((ns5__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UnbindBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((ns5__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UnbindBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetAppliedUserAuthorityListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetAppliedUserAuthorityListRequest));
			((ns5__GetAppliedUserAuthorityListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetAppliedUserAuthorityListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetAppliedUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetAppliedUserAuthorityListRequest*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns5__MercuryApplicationRequest);
		ASSIGN_PTR(size, sizeof(ns5__MercuryApplicationRequest));
		((ns5__MercuryApplicationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns5__MercuryApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns5__MercuryApplicationRequest));
		for(int i = 0; i < n; i++)
			((ns5__MercuryApplicationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__MercuryApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__MercuryApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__MercuryApplicationRequest %p -> %p\n", q, p));
	*(ns5__MercuryApplicationRequest*)p = *(ns5__MercuryApplicationRequest*)q;
}

void ns4__BusinessError::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns3__Error::__item);
	soap_default_xsd__NCName(soap, &this->ns3__Error::code);
	this->ns3__Error::qualifier = NULL;
	/* transient soap skipped */
}

void ns4__BusinessError::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->ns3__Error::__item);
	/* transient soap skipped */
}

int ns4__BusinessError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__BusinessError(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__BusinessError(struct soap *soap, const char *tag, int id, const ns4__BusinessError *a, const char *type)
{
	if(((ns3__Error*)a)->code)
		soap_set_attr(soap, "code", ((ns3__Error*)a)->code, 1);
	if(((ns3__Error*)a)->qualifier)
		if(*((ns3__Error*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns3__Error*)a)->qualifier, 1);
	return soap_out_string(soap, tag, id, &(a->ns3__Error::__item), "ns4:BusinessError");
}

void *ns4__BusinessError::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__BusinessError(soap, tag, this, type);
}

SOAP_FMAC3 ns4__BusinessError * FASTCALL soap_in_ns4__BusinessError(struct soap *soap, const char *tag, ns4__BusinessError *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (ns4__BusinessError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__BusinessError, sizeof(ns4__BusinessError), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__BusinessError)
			return (ns4__BusinessError *)a->soap_in(soap, tag, type);
	}
	if(soap_s2string(soap, soap_attr_value(soap, "code", 1), &((ns3__Error*)a)->code, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns3__Error*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns3__Error*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(!soap_in_string(soap, tag, &(a->ns3__Error::__item), "ns4:BusinessError"))
		return NULL;
	return a;
}

int ns4__BusinessError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__BusinessError);
	return this->soap_out(soap, tag?tag:"ns4:BusinessError", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__BusinessError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__BusinessError(soap, this, tag, type);
}

SOAP_FMAC3 ns4__BusinessError * SOAP_FMAC4 soap_get_ns4__BusinessError(struct soap *soap, ns4__BusinessError *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__BusinessError * FASTCALL soap_instantiate_ns4__BusinessError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__BusinessError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__BusinessError, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__BusinessError);
		ASSIGN_PTR(size, sizeof(ns4__BusinessError));
		((ns4__BusinessError*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__BusinessError[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__BusinessError));
		for(int i = 0; i < n; i++)
			((ns4__BusinessError*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__BusinessError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__BusinessError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__BusinessError %p -> %p\n", q, p));
	*(ns4__BusinessError*)p = *(ns4__BusinessError*)q;
}

void ns4__BusinessErrorList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__BusinessErrorList::__sizeerror = 0;
	this->ns4__BusinessErrorList::error = NULL;
	/* transient soap skipped */
}

void ns4__BusinessErrorList::soap_serialize(struct soap *soap) const
{
	if(this->ns4__BusinessErrorList::error) {
		for(int i = 0; i < this->ns4__BusinessErrorList::__sizeerror; i++) {
			soap_serialize_PointerTons4__BusinessError(soap, this->ns4__BusinessErrorList::error + i);
		}
	}
	/* transient soap skipped */
}

int ns4__BusinessErrorList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__BusinessErrorList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__BusinessErrorList(struct soap *soap, const char *tag, int id, const ns4__BusinessErrorList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__BusinessErrorList), type))
		return soap->error;
	if(a->ns4__BusinessErrorList::error) {
		int i;
		for(i = 0; i < a->ns4__BusinessErrorList::__sizeerror; i++)
			if(soap_out_PointerTons4__BusinessError(soap, "ns4:error", -1, a->ns4__BusinessErrorList::error + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__BusinessErrorList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__BusinessErrorList(soap, tag, this, type);
}

SOAP_FMAC3 ns4__BusinessErrorList * FASTCALL soap_in_ns4__BusinessErrorList(struct soap *soap, const char *tag, ns4__BusinessErrorList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__BusinessErrorList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__BusinessErrorList, sizeof(ns4__BusinessErrorList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__BusinessErrorList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns4__BusinessErrorList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_error1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:error", 1, NULL)) {
				if(a->ns4__BusinessErrorList::error == NULL) {
					if(soap_blist_error1 == NULL)
						soap_blist_error1 = soap_new_block(soap);
					a->ns4__BusinessErrorList::error = (ns4__BusinessError **)soap_push_block(soap, soap_blist_error1, sizeof(ns4__BusinessError *));
					if(a->ns4__BusinessErrorList::error == NULL)
						return NULL;
					*a->ns4__BusinessErrorList::error = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons4__BusinessError(soap, "ns4:error", a->ns4__BusinessErrorList::error, "ns4:BusinessError"))
				{	a->ns4__BusinessErrorList::__sizeerror++;
					a->ns4__BusinessErrorList::error = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns4__BusinessErrorList::error)
			soap_pop_block(soap, soap_blist_error1);
		if(a->ns4__BusinessErrorList::__sizeerror)
			a->ns4__BusinessErrorList::error = (ns4__BusinessError **)soap_save_block(soap, soap_blist_error1, NULL, 1);
		else
		{	a->ns4__BusinessErrorList::error = NULL;
			if(soap_blist_error1)
				soap_end_block(soap, soap_blist_error1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns4__BusinessErrorList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__BusinessErrorList, 0, sizeof(ns4__BusinessErrorList), 0, soap_copy_ns4__BusinessErrorList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__BusinessErrorList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__BusinessErrorList);
	return this->soap_out(soap, tag?tag:"ns4:BusinessErrorList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__BusinessErrorList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__BusinessErrorList(soap, this, tag, type);
}

SOAP_FMAC3 ns4__BusinessErrorList * SOAP_FMAC4 soap_get_ns4__BusinessErrorList(struct soap *soap, ns4__BusinessErrorList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__BusinessErrorList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__BusinessErrorList * FASTCALL soap_instantiate_ns4__BusinessErrorList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__BusinessErrorList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__BusinessErrorList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__BusinessErrorList);
		ASSIGN_PTR(size, sizeof(ns4__BusinessErrorList));
		((ns4__BusinessErrorList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__BusinessErrorList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__BusinessErrorList));
		for(int i = 0; i < n; i++)
			((ns4__BusinessErrorList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__BusinessErrorList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__BusinessErrorList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__BusinessErrorList %p -> %p\n", q, p));
	*(ns4__BusinessErrorList*)p = *(ns4__BusinessErrorList*)q;
}

void ns4__ApplicationResultData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns4__ApplicationResultData::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int ns4__ApplicationResultData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ApplicationResultData(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__ApplicationResultData(struct soap *soap, const char *tag, int id, const ns4__ApplicationResultData *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ApplicationResultData), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ApplicationResultData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ApplicationResultData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ApplicationResultData * FASTCALL soap_in_ns4__ApplicationResultData(struct soap *soap, const char *tag, ns4__ApplicationResultData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ApplicationResultData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ApplicationResultData, sizeof(ns4__ApplicationResultData), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__ApplicationResultData) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ApplicationResultData *)a->soap_in(soap, tag, type);
		}
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns4__ApplicationResultData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ApplicationResultData, 0, sizeof(ns4__ApplicationResultData), 0, soap_copy_ns4__ApplicationResultData);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ApplicationResultData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ApplicationResultData);
	return this->soap_out(soap, tag?tag:"ns4:ApplicationResultData", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__ApplicationResultData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ApplicationResultData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ApplicationResultData * SOAP_FMAC4 soap_get_ns4__ApplicationResultData(struct soap *soap, ns4__ApplicationResultData *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__ApplicationResultData(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ApplicationResultData * FASTCALL soap_instantiate_ns4__ApplicationResultData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ApplicationResultData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ApplicationResultData, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns5:ProcessIncomingConsignmentResponse")) {
		cp->type = SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ProcessIncomingConsignmentResponse));
			((ns5__ProcessIncomingConsignmentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ProcessIncomingConsignmentResponse));
			for(int i = 0; i < n; i++)
				((ns5__ProcessIncomingConsignmentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ProcessIncomingConsignmentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:PrepareOutgoingConsignmentResponse")) {
		cp->type = SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__PrepareOutgoingConsignmentResponse));
			((ns5__PrepareOutgoingConsignmentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__PrepareOutgoingConsignmentResponse));
			for(int i = 0; i < n; i++)
				((ns5__PrepareOutgoingConsignmentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__PrepareOutgoingConsignmentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:RegisterProductionOperationResponse")) {
		cp->type = SOAP_TYPE_ns5__RegisterProductionOperationResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__RegisterProductionOperationResponse));
			((ns5__RegisterProductionOperationResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__RegisterProductionOperationResponse));
			for(int i = 0; i < n; i++)
				((ns5__RegisterProductionOperationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__RegisterProductionOperationResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:MergeStockEntriesResponse")) {
		cp->type = SOAP_TYPE_ns5__MergeStockEntriesResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__MergeStockEntriesResponse));
			((ns5__MergeStockEntriesResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__MergeStockEntriesResponse));
			for(int i = 0; i < n; i++)
				((ns5__MergeStockEntriesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__MergeStockEntriesResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:WithdrawVetDocumentResponse")) {
		cp->type = SOAP_TYPE_ns5__WithdrawVetDocumentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__WithdrawVetDocumentResponse));
			((ns5__WithdrawVetDocumentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__WithdrawVetDocumentResponse));
			for(int i = 0; i < n; i++)
				((ns5__WithdrawVetDocumentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__WithdrawVetDocumentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyBusinessEntityResponse")) {
		cp->type = SOAP_TYPE_ns5__ModifyBusinessEntityResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyBusinessEntityResponse));
			((ns5__ModifyBusinessEntityResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyBusinessEntityResponse));
			for(int i = 0; i < n; i++)
				((ns5__ModifyBusinessEntityResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyBusinessEntityResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyEnterpriseResponse")) {
		cp->type = SOAP_TYPE_ns5__ModifyEnterpriseResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyEnterpriseResponse));
			((ns5__ModifyEnterpriseResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyEnterpriseResponse));
			for(int i = 0; i < n; i++)
				((ns5__ModifyEnterpriseResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyEnterpriseResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyActivityLocationsResponse")) {
		cp->type = SOAP_TYPE_ns5__ModifyActivityLocationsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyActivityLocationsResponse));
			((ns5__ModifyActivityLocationsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyActivityLocationsResponse));
			for(int i = 0; i < n; i++)
				((ns5__ModifyActivityLocationsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyActivityLocationsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ResolveDiscrepancyResponse")) {
		cp->type = SOAP_TYPE_ns5__ResolveDiscrepancyResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ResolveDiscrepancyResponse));
			((ns5__ResolveDiscrepancyResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ResolveDiscrepancyResponse));
			for(int i = 0; i < n; i++)
				((ns5__ResolveDiscrepancyResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ResolveDiscrepancyResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyProducerStockListResponse")) {
		cp->type = SOAP_TYPE_ns5__ModifyProducerStockListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyProducerStockListResponse));
			((ns5__ModifyProducerStockListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyProducerStockListResponse));
			for(int i = 0; i < n; i++)
				((ns5__ModifyProducerStockListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyProducerStockListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentByUuidResponse")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentByUuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentByUuidResponse));
			((ns5__GetVetDocumentByUuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentByUuidResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentByUuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentByUuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentListResponse));
			((ns5__GetVetDocumentListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentChangesListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentChangesListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentChangesListResponse));
			((ns5__GetVetDocumentChangesListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentChangesListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentChangesListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentChangesListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryByGuidResponse")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryByGuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByGuidResponse));
			((ns5__GetStockEntryByGuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByGuidResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryByGuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryByGuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryByUuidResponse")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryByUuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByUuidResponse));
			((ns5__GetStockEntryByUuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByUuidResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryByUuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryByUuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryChangesListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryChangesListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryChangesListResponse));
			((ns5__GetStockEntryChangesListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryChangesListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryChangesListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryChangesListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryListResponse));
			((ns5__GetStockEntryListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryVersionListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryVersionListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryVersionListResponse));
			((ns5__GetStockEntryVersionListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryVersionListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryVersionListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryVersionListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateTransportMovementDetailsResponse")) {
		cp->type = SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateTransportMovementDetailsResponse));
			((ns5__UpdateTransportMovementDetailsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateTransportMovementDetailsResponse));
			for(int i = 0; i < n; i++)
				((ns5__UpdateTransportMovementDetailsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateTransportMovementDetailsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateVeterinaryEventsResponse")) {
		cp->type = SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateVeterinaryEventsResponse));
			((ns5__UpdateVeterinaryEventsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateVeterinaryEventsResponse));
			for(int i = 0; i < n; i++)
				((ns5__UpdateVeterinaryEventsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateVeterinaryEventsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:CheckShipmentRegionalizationResponse")) {
		cp->type = SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__CheckShipmentRegionalizationResponse));
			((ns5__CheckShipmentRegionalizationResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__CheckShipmentRegionalizationResponse));
			for(int i = 0; i < n; i++)
				((ns5__CheckShipmentRegionalizationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__CheckShipmentRegionalizationResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:AddBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_ns5__AddBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__AddBusinessEntityUserResponse));
			((ns5__AddBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__AddBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((ns5__AddBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__AddBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetBusinessEntityUserListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetBusinessEntityUserListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserListResponse));
			((ns5__GetBusinessEntityUserListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetBusinessEntityUserListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetBusinessEntityUserListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_ns5__GetBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserResponse));
			((ns5__GetBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateUserAuthoritiesResponse")) {
		cp->type = SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateUserAuthoritiesResponse));
			((ns5__UpdateUserAuthoritiesResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserAuthoritiesResponse));
			for(int i = 0; i < n; i++)
				((ns5__UpdateUserAuthoritiesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateUserAuthoritiesResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateUserWorkingAreasResponse")) {
		cp->type = SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateUserWorkingAreasResponse));
			((ns5__UpdateUserWorkingAreasResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserWorkingAreasResponse));
			for(int i = 0; i < n; i++)
				((ns5__UpdateUserWorkingAreasResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateUserWorkingAreasResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UnbindBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UnbindBusinessEntityUserResponse));
			((ns5__UnbindBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UnbindBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((ns5__UnbindBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UnbindBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetAppliedUserAuthorityListResponse")) {
		cp->type = SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetAppliedUserAuthorityListResponse));
			((ns5__GetAppliedUserAuthorityListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetAppliedUserAuthorityListResponse));
			for(int i = 0; i < n; i++)
				((ns5__GetAppliedUserAuthorityListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetAppliedUserAuthorityListResponse*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationResultData);
		ASSIGN_PTR(size, sizeof(ns4__ApplicationResultData));
		((ns4__ApplicationResultData*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationResultData[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__ApplicationResultData));
		for(int i = 0; i < n; i++)
			((ns4__ApplicationResultData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ApplicationResultData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ApplicationResultData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ApplicationResultData %p -> %p\n", q, p));
	*(ns4__ApplicationResultData*)p = *(ns4__ApplicationResultData*)q;
}

void ns4__ApplicationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns4__ApplicationData::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int ns4__ApplicationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ApplicationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__ApplicationData(struct soap *soap, const char *tag, int id, const ns4__ApplicationData *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ApplicationData), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ApplicationData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ApplicationData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ApplicationData * FASTCALL soap_in_ns4__ApplicationData(struct soap *soap, const char *tag, ns4__ApplicationData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ApplicationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ApplicationData, sizeof(ns4__ApplicationData), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__ApplicationData) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ApplicationData *)a->soap_in(soap, tag, type);
		}
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns4__ApplicationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ApplicationData, 0, sizeof(ns4__ApplicationData), 0, soap_copy_ns4__ApplicationData);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ApplicationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ApplicationData);
	return this->soap_out(soap, tag?tag:"ns4:ApplicationData", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__ApplicationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ApplicationData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ApplicationData * SOAP_FMAC4 soap_get_ns4__ApplicationData(struct soap *soap, ns4__ApplicationData *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__ApplicationData(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ApplicationData * FASTCALL soap_instantiate_ns4__ApplicationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ApplicationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ApplicationData, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns5:MercuryApplicationRequest")) {
		cp->type = SOAP_TYPE_ns5__MercuryApplicationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__MercuryApplicationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__MercuryApplicationRequest));
			((ns5__MercuryApplicationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__MercuryApplicationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__MercuryApplicationRequest));
			for(int i = 0; i < n; i++)
				((ns5__MercuryApplicationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__MercuryApplicationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ProcessIncomingConsignmentRequest")) {
		cp->type = SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ProcessIncomingConsignmentRequest));
			((ns5__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ProcessIncomingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ProcessIncomingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((ns5__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ProcessIncomingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:PrepareOutgoingConsignmentRequest")) {
		cp->type = SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__PrepareOutgoingConsignmentRequest));
			((ns5__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__PrepareOutgoingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__PrepareOutgoingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((ns5__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__PrepareOutgoingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:RegisterProductionOperationRequest")) {
		cp->type = SOAP_TYPE_ns5__RegisterProductionOperationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__RegisterProductionOperationRequest));
			((ns5__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__RegisterProductionOperationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__RegisterProductionOperationRequest));
			for(int i = 0; i < n; i++)
				((ns5__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__RegisterProductionOperationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:MergeStockEntriesRequest")) {
		cp->type = SOAP_TYPE_ns5__MergeStockEntriesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__MergeStockEntriesRequest));
			((ns5__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__MergeStockEntriesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__MergeStockEntriesRequest));
			for(int i = 0; i < n; i++)
				((ns5__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__MergeStockEntriesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:WithdrawVetDocumentRequest")) {
		cp->type = SOAP_TYPE_ns5__WithdrawVetDocumentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__WithdrawVetDocumentRequest));
			((ns5__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__WithdrawVetDocumentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__WithdrawVetDocumentRequest));
			for(int i = 0; i < n; i++)
				((ns5__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__WithdrawVetDocumentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyBusinessEntityRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyBusinessEntityRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyBusinessEntityRequest));
			((ns5__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyBusinessEntityRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyBusinessEntityRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyBusinessEntityRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyEnterpriseRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyEnterpriseRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyEnterpriseRequest));
			((ns5__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyEnterpriseRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyEnterpriseRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyEnterpriseRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyActivityLocationsRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyActivityLocationsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyActivityLocationsRequest));
			((ns5__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyActivityLocationsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyActivityLocationsRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyActivityLocationsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ResolveDiscrepancyRequest")) {
		cp->type = SOAP_TYPE_ns5__ResolveDiscrepancyRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ResolveDiscrepancyRequest));
			((ns5__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ResolveDiscrepancyRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ResolveDiscrepancyRequest));
			for(int i = 0; i < n; i++)
				((ns5__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ResolveDiscrepancyRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:ModifyProducerStockListRequest")) {
		cp->type = SOAP_TYPE_ns5__ModifyProducerStockListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__ModifyProducerStockListRequest));
			((ns5__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__ModifyProducerStockListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__ModifyProducerStockListRequest));
			for(int i = 0; i < n; i++)
				((ns5__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__ModifyProducerStockListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentByUuidRequest")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentByUuidRequest));
			((ns5__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentByUuidRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentListRequest));
			((ns5__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetVetDocumentChangesListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetVetDocumentChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetVetDocumentChangesListRequest));
			((ns5__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetVetDocumentChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetVetDocumentChangesListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetVetDocumentChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryByGuidRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryByGuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByGuidRequest));
			((ns5__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByGuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByGuidRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryByGuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryByUuidRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryByUuidRequest));
			((ns5__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryByUuidRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryChangesListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryChangesListRequest));
			((ns5__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryChangesListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryListRequest));
			((ns5__GetStockEntryListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetStockEntryVersionListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetStockEntryVersionListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetStockEntryVersionListRequest));
			((ns5__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetStockEntryVersionListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetStockEntryVersionListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetStockEntryVersionListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateTransportMovementDetailsRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateTransportMovementDetailsRequest));
			((ns5__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateTransportMovementDetailsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateTransportMovementDetailsRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateTransportMovementDetailsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateVeterinaryEventsRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateVeterinaryEventsRequest));
			((ns5__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateVeterinaryEventsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateVeterinaryEventsRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateVeterinaryEventsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:CheckShipmentRegionalizationRequest")) {
		cp->type = SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__CheckShipmentRegionalizationRequest));
			((ns5__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__CheckShipmentRegionalizationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__CheckShipmentRegionalizationRequest));
			for(int i = 0; i < n; i++)
				((ns5__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__CheckShipmentRegionalizationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:AddBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_ns5__AddBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__AddBusinessEntityUserRequest));
			((ns5__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__AddBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__AddBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((ns5__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__AddBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetBusinessEntityUserListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetBusinessEntityUserListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserListRequest));
			((ns5__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetBusinessEntityUserListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_ns5__GetBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetBusinessEntityUserRequest));
			((ns5__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateUserAuthoritiesRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateUserAuthoritiesRequest));
			((ns5__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserAuthoritiesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserAuthoritiesRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateUserAuthoritiesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UpdateUserWorkingAreasRequest")) {
		cp->type = SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UpdateUserWorkingAreasRequest));
			((ns5__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UpdateUserWorkingAreasRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UpdateUserWorkingAreasRequest));
			for(int i = 0; i < n; i++)
				((ns5__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UpdateUserWorkingAreasRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:UnbindBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__UnbindBusinessEntityUserRequest));
			((ns5__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__UnbindBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__UnbindBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((ns5__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__UnbindBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns5:GetAppliedUserAuthorityListRequest")) {
		cp->type = SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns5__GetAppliedUserAuthorityListRequest));
			((ns5__GetAppliedUserAuthorityListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns5__GetAppliedUserAuthorityListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(ns5__GetAppliedUserAuthorityListRequest));
			for(int i = 0; i < n; i++)
				((ns5__GetAppliedUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__GetAppliedUserAuthorityListRequest*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationData);
		ASSIGN_PTR(size, sizeof(ns4__ApplicationData));
		((ns4__ApplicationData*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationData[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__ApplicationData));
		for(int i = 0; i < n; i++)
			((ns4__ApplicationData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ApplicationData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ApplicationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ApplicationData %p -> %p\n", q, p));
	*(ns4__ApplicationData*)p = *(ns4__ApplicationData*)q;
}

void ns4__ApplicationResultWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ApplicationResultWrapper::__any = NULL;
	this->ns4__ApplicationResultWrapper::encoding = NULL;
	/* transient soap skipped */
}

void ns4__ApplicationResultWrapper::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int ns4__ApplicationResultWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ApplicationResultWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__ApplicationResultWrapper(struct soap *soap, const char *tag, int id, const ns4__ApplicationResultWrapper *a, const char *type)
{
	if(((ns4__ApplicationResultWrapper*)a)->encoding)
		soap_set_attr(soap, "encoding", soap_ns4__ContentEncoding2s(soap, *((ns4__ApplicationResultWrapper*)a)->encoding), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ApplicationResultWrapper), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->ns4__ApplicationResultWrapper::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ApplicationResultWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ApplicationResultWrapper(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ApplicationResultWrapper * FASTCALL soap_in_ns4__ApplicationResultWrapper(struct soap *soap, const char *tag, ns4__ApplicationResultWrapper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ApplicationResultWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ApplicationResultWrapper, sizeof(ns4__ApplicationResultWrapper), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__ApplicationResultWrapper) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ApplicationResultWrapper *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "encoding", 0);
		if(t)
		{
			if(!(((ns4__ApplicationResultWrapper*)a)->encoding = (enum ns4__ContentEncoding *)soap_malloc(soap, sizeof(enum ns4__ContentEncoding))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2ns4__ContentEncoding(soap, t, ((ns4__ApplicationResultWrapper*)a)->encoding))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &(a->ns4__ApplicationResultWrapper::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns4__ApplicationResultWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ApplicationResultWrapper, 0, sizeof(ns4__ApplicationResultWrapper), 0, soap_copy_ns4__ApplicationResultWrapper);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ApplicationResultWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ApplicationResultWrapper);
	return this->soap_out(soap, tag?tag:"ns4:ApplicationResultWrapper", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__ApplicationResultWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ApplicationResultWrapper(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ApplicationResultWrapper * SOAP_FMAC4 soap_get_ns4__ApplicationResultWrapper(struct soap *soap, ns4__ApplicationResultWrapper *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__ApplicationResultWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ApplicationResultWrapper * FASTCALL soap_instantiate_ns4__ApplicationResultWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ApplicationResultWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ApplicationResultWrapper, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationResultWrapper);
		ASSIGN_PTR(size, sizeof(ns4__ApplicationResultWrapper));
		((ns4__ApplicationResultWrapper*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationResultWrapper[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__ApplicationResultWrapper));
		for(int i = 0; i < n; i++)
			((ns4__ApplicationResultWrapper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ApplicationResultWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ApplicationResultWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ApplicationResultWrapper %p -> %p\n", q, p));
	*(ns4__ApplicationResultWrapper*)p = *(ns4__ApplicationResultWrapper*)q;
}

void ns4__ApplicationDataWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__ApplicationDataWrapper::__any = NULL;
	this->ns4__ApplicationDataWrapper::encoding = NULL;
	/* transient soap skipped */
}

void ns4__ApplicationDataWrapper::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int ns4__ApplicationDataWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ApplicationDataWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__ApplicationDataWrapper(struct soap *soap, const char *tag, int id, const ns4__ApplicationDataWrapper *a, const char *type)
{
	if(((ns4__ApplicationDataWrapper*)a)->encoding)
		soap_set_attr(soap, "encoding", soap_ns4__ContentEncoding2s(soap, *((ns4__ApplicationDataWrapper*)a)->encoding), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ApplicationDataWrapper), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->ns4__ApplicationDataWrapper::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__ApplicationDataWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__ApplicationDataWrapper(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ApplicationDataWrapper * FASTCALL soap_in_ns4__ApplicationDataWrapper(struct soap *soap, const char *tag, ns4__ApplicationDataWrapper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ApplicationDataWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ApplicationDataWrapper, sizeof(ns4__ApplicationDataWrapper), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__ApplicationDataWrapper) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ApplicationDataWrapper *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "encoding", 0);
		if(t)
		{
			if(!(((ns4__ApplicationDataWrapper*)a)->encoding = (enum ns4__ContentEncoding *)soap_malloc(soap, sizeof(enum ns4__ContentEncoding))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2ns4__ContentEncoding(soap, t, ((ns4__ApplicationDataWrapper*)a)->encoding))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &(a->ns4__ApplicationDataWrapper::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns4__ApplicationDataWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ApplicationDataWrapper, 0, sizeof(ns4__ApplicationDataWrapper), 0, soap_copy_ns4__ApplicationDataWrapper);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ApplicationDataWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ApplicationDataWrapper);
	return this->soap_out(soap, tag?tag:"ns4:ApplicationDataWrapper", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__ApplicationDataWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ApplicationDataWrapper(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ApplicationDataWrapper * SOAP_FMAC4 soap_get_ns4__ApplicationDataWrapper(struct soap *soap, ns4__ApplicationDataWrapper *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__ApplicationDataWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ApplicationDataWrapper * FASTCALL soap_instantiate_ns4__ApplicationDataWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ApplicationDataWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ApplicationDataWrapper, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationDataWrapper);
		ASSIGN_PTR(size, sizeof(ns4__ApplicationDataWrapper));
		((ns4__ApplicationDataWrapper*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__ApplicationDataWrapper[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__ApplicationDataWrapper));
		for(int i = 0; i < n; i++)
			((ns4__ApplicationDataWrapper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ApplicationDataWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ApplicationDataWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ApplicationDataWrapper %p -> %p\n", q, p));
	*(ns4__ApplicationDataWrapper*)p = *(ns4__ApplicationDataWrapper*)q;
}

void ns4__Application::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns4__Application::applicationId);
	this->ns4__Application::status = NULL;
	soap_default_xsd__Name(soap, &this->ns4__Application::serviceId);
	soap_default_ns3__UUID(soap, &this->ns4__Application::issuerId);
	this->ns4__Application::issueDate = NULL;
	this->ns4__Application::rcvDate = NULL;
	this->ns4__Application::prdcRsltDate = NULL;
	this->ns4__Application::data = NULL;
	this->ns4__Application::result = NULL;
	this->ns4__Application::errors = NULL;
	/* transient soap skipped */
}

void ns4__Application::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns4__Application::applicationId);
	soap_serialize_PointerTons4__ApplicationStatus(soap, &this->ns4__Application::status);
	soap_serialize_xsd__Name(soap, &this->ns4__Application::serviceId);
	soap_serialize_ns3__UUID(soap, &this->ns4__Application::issuerId);
	soap_serialize_PointerTotime(soap, &this->ns4__Application::issueDate);
	soap_serialize_PointerTotime(soap, &this->ns4__Application::rcvDate);
	soap_serialize_PointerTotime(soap, &this->ns4__Application::prdcRsltDate);
	soap_serialize_PointerTons4__ApplicationDataWrapper(soap, &this->ns4__Application::data);
	soap_serialize_PointerTons4__ApplicationResultWrapper(soap, &this->ns4__Application::result);
	soap_serialize_PointerTons4__BusinessErrorList(soap, &this->ns4__Application::errors);
	/* transient soap skipped */
}

int ns4__Application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__Application(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__Application(struct soap *soap, const char *tag, int id, const ns4__Application *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Application), type))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns4:applicationId", -1, &(a->ns4__Application::applicationId), ""))
		return soap->error;
	if(soap_out_PointerTons4__ApplicationStatus(soap, "ns4:status", -1, &(a->ns4__Application::status), ""))
		return soap->error;
	if(soap_out_xsd__Name(soap, "ns4:serviceId", -1, &(a->ns4__Application::serviceId), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns4:issuerId", -1, &(a->ns4__Application::issuerId), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns4:issueDate", -1, &(a->ns4__Application::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns4:rcvDate", -1, &(a->ns4__Application::rcvDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns4:prdcRsltDate", -1, &(a->ns4__Application::prdcRsltDate), ""))
		return soap->error;
	if(soap_out_PointerTons4__ApplicationDataWrapper(soap, "ns4:data", -1, &(a->ns4__Application::data), ""))
		return soap->error;
	if(soap_out_PointerTons4__ApplicationResultWrapper(soap, "ns4:result", -1, &(a->ns4__Application::result), ""))
		return soap->error;
	if(soap_out_PointerTons4__BusinessErrorList(soap, "ns4:errors", -1, &(a->ns4__Application::errors), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__Application::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns4__Application(soap, tag, this, type);
}

SOAP_FMAC3 ns4__Application * FASTCALL soap_in_ns4__Application(struct soap *soap, const char *tag, ns4__Application *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__Application *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Application, sizeof(ns4__Application), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns4__Application) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns4__Application *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_serviceId1 = 1;
	size_t soap_flag_issuerId1 = 1;
	size_t soap_flag_issueDate1 = 1;
	size_t soap_flag_rcvDate1 = 1;
	size_t soap_flag_prdcRsltDate1 = 1;
	size_t soap_flag_data1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_errors1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns4:applicationId", &(a->ns4__Application::applicationId), "ns3:UUID"))
				{	soap_flag_applicationId1--;
					continue;
				}
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__ApplicationStatus(soap, "ns4:status", &(a->ns4__Application::status), "ns4:ApplicationStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_serviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__Name(soap, "ns4:serviceId", &(a->ns4__Application::serviceId), "xsd:Name"))
				{	soap_flag_serviceId1--;
					continue;
				}
			if(soap_flag_issuerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns4:issuerId", &(a->ns4__Application::issuerId), "ns3:UUID"))
				{	soap_flag_issuerId1--;
					continue;
				}
			if(soap_flag_issueDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns4:issueDate", &(a->ns4__Application::issueDate), "xsd:dateTime"))
				{	soap_flag_issueDate1--;
					continue;
				}
			if(soap_flag_rcvDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns4:rcvDate", &(a->ns4__Application::rcvDate), "xsd:dateTime"))
				{	soap_flag_rcvDate1--;
					continue;
				}
			if(soap_flag_prdcRsltDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns4:prdcRsltDate", &(a->ns4__Application::prdcRsltDate), "xsd:dateTime"))
				{	soap_flag_prdcRsltDate1--;
					continue;
				}
			if(soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__ApplicationDataWrapper(soap, "ns4:data", &(a->ns4__Application::data), "ns4:ApplicationDataWrapper"))
				{	soap_flag_data1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__ApplicationResultWrapper(soap, "ns4:result", &(a->ns4__Application::result), "ns4:ApplicationResultWrapper"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_errors1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__BusinessErrorList(soap, "ns4:errors", &(a->ns4__Application::errors), "ns4:BusinessErrorList"))
				{	soap_flag_errors1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns4__Application *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Application, 0, sizeof(ns4__Application), 0, soap_copy_ns4__Application);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__Application::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__Application);
	return this->soap_out(soap, tag?tag:"ns4:Application", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns4__Application::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__Application(soap, this, tag, type);
}

SOAP_FMAC3 ns4__Application * SOAP_FMAC4 soap_get_ns4__Application(struct soap *soap, ns4__Application *p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__Application(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__Application * FASTCALL soap_instantiate_ns4__Application(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__Application(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__Application, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns4__Application);
		ASSIGN_PTR(size, sizeof(ns4__Application));
		((ns4__Application*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns4__Application[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns4__Application));
		for(int i = 0; i < n; i++)
			((ns4__Application*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__Application*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__Application(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__Application %p -> %p\n", q, p));
	*(ns4__Application*)p = *(ns4__Application*)q;
}

void ns3__Error::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns3__Error::__item);
	soap_default_xsd__NCName(soap, &this->ns3__Error::code);
	this->ns3__Error::qualifier = NULL;
	/* transient soap skipped */
}

void ns3__Error::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->ns3__Error::__item);
	/* transient soap skipped */
}

int ns3__Error::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Error(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__Error(struct soap *soap, const char *tag, int id, const ns3__Error *a, const char *type)
{
	if(((ns3__Error*)a)->code)
		soap_set_attr(soap, "code", ((ns3__Error*)a)->code, 1);
	if(((ns3__Error*)a)->qualifier)
		if(*((ns3__Error*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((ns3__Error*)a)->qualifier, 1);
	return soap_out_string(soap, tag, id, &a->ns3__Error::__item, "");
}

void *ns3__Error::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Error(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Error * FASTCALL soap_in_ns3__Error(struct soap *soap, const char *tag, ns3__Error *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (ns3__Error *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__Error, sizeof(ns3__Error), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__Error)
			return (ns3__Error *)a->soap_in(soap, tag, type);
	}
	if(soap_s2string(soap, soap_attr_value(soap, "code", 1), &((ns3__Error*)a)->code, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((ns3__Error*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((ns3__Error*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(!soap_in_string(soap, tag, &(a->ns3__Error::__item), "ns3:Error"))
		return NULL;
	return a;
}

int ns3__Error::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__Error);
	return this->soap_out(soap, tag?tag:"ns3:Error", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__Error::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Error(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Error * SOAP_FMAC4 soap_get_ns3__Error(struct soap *soap, ns3__Error *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__Error * FASTCALL soap_instantiate_ns3__Error(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Error(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__Error, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns4:BusinessError")) {
		cp->type = SOAP_TYPE_ns4__BusinessError;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns4__BusinessError);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns4__BusinessError));
			((ns4__BusinessError*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns4__BusinessError[n]);
			ASSIGN_PTR(size, n * sizeof(ns4__BusinessError));
			for(int i = 0; i < n; i++)
				((ns4__BusinessError*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns4__BusinessError*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__Error);
		ASSIGN_PTR(size, sizeof(ns3__Error));
		((ns3__Error*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__Error[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__Error));
		for(int i = 0; i < n; i++)
			((ns3__Error*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__Error*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__Error(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__Error %p -> %p\n", q, p));
	*(ns3__Error*)p = *(ns3__Error*)q;
}

void ns3__FaultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns3__FaultInfo::message);
	this->ns3__FaultInfo::__sizeerror = 0;
	this->ns3__FaultInfo::error = NULL;
	/* transient soap skipped */
}

void ns3__FaultInfo::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->ns3__FaultInfo::message);
	if(this->ns3__FaultInfo::error) {
		for(int i = 0; i < this->ns3__FaultInfo::__sizeerror; i++) {
			soap_serialize_PointerTons3__Error(soap, this->ns3__FaultInfo::error + i);
		}
	}
	/* transient soap skipped */
}

int ns3__FaultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FaultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__FaultInfo(struct soap *soap, const char *tag, int id, const ns3__FaultInfo *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__FaultInfo), type))
		return soap->error;
	if(a->ns3__FaultInfo::message) {
		if(soap_out_string(soap, "ns3:message", -1, &a->ns3__FaultInfo::message, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns3:message"))
		return soap->error;
	if(a->ns3__FaultInfo::error) {
		int i;
		for(i = 0; i < a->ns3__FaultInfo::__sizeerror; i++)
			if(soap_out_PointerTons3__Error(soap, "ns3:error", -1, a->ns3__FaultInfo::error + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__FaultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FaultInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FaultInfo * FASTCALL soap_in_ns3__FaultInfo(struct soap *soap, const char *tag, ns3__FaultInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FaultInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__FaultInfo, sizeof(ns3__FaultInfo), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__FaultInfo) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns3__FaultInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	struct soap_blist *soap_blist_error1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns3:message", &(a->ns3__FaultInfo::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:error", 1, NULL)) {
				if(a->ns3__FaultInfo::error == NULL) {
					if(soap_blist_error1 == NULL)
						soap_blist_error1 = soap_new_block(soap);
					a->ns3__FaultInfo::error = (ns3__Error **)soap_push_block(soap, soap_blist_error1, sizeof(ns3__Error *));
					if(a->ns3__FaultInfo::error == NULL)
						return NULL;
					*a->ns3__FaultInfo::error = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTons3__Error(soap, "ns3:error", a->ns3__FaultInfo::error, "ns3:Error"))
				{	a->ns3__FaultInfo::__sizeerror++;
					a->ns3__FaultInfo::error = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ns3__FaultInfo::error)
			soap_pop_block(soap, soap_blist_error1);
		if(a->ns3__FaultInfo::__sizeerror)
			a->ns3__FaultInfo::error = (ns3__Error **)soap_save_block(soap, soap_blist_error1, NULL, 1);
		else
		{	a->ns3__FaultInfo::error = NULL;
			if(soap_blist_error1)
				soap_end_block(soap, soap_blist_error1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns3__FaultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__FaultInfo, 0, sizeof(ns3__FaultInfo), 0, soap_copy_ns3__FaultInfo);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_message1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__FaultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__FaultInfo);
	return this->soap_out(soap, tag?tag:"ns3:FaultInfo", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__FaultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FaultInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FaultInfo * SOAP_FMAC4 soap_get_ns3__FaultInfo(struct soap *soap, ns3__FaultInfo *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__FaultInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__FaultInfo * FASTCALL soap_instantiate_ns3__FaultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FaultInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__FaultInfo, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__FaultInfo);
		ASSIGN_PTR(size, sizeof(ns3__FaultInfo));
		((ns3__FaultInfo*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__FaultInfo[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__FaultInfo));
		for(int i = 0; i < n; i++)
			((ns3__FaultInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__FaultInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__FaultInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__FaultInfo %p -> %p\n", q, p));
	*(ns3__FaultInfo*)p = *(ns3__FaultInfo*)q;
}

void ns3__EntityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__EntityList::count = NULL;
	this->ns3__EntityList::total = NULL;
	this->ns3__EntityList::offset = NULL;
	this->ns3__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ns3__EntityList::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int ns3__EntityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__EntityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__EntityList(struct soap *soap, const char *tag, int id, const ns3__EntityList *a, const char *type)
{
	if(((ns3__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((ns3__EntityList*)a)->count), 1);
	if(((ns3__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((ns3__EntityList*)a)->total), 1);
	if(((ns3__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((ns3__EntityList*)a)->offset), 1);
	if(((ns3__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((ns3__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__EntityList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__EntityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__EntityList(soap, tag, this, type);
}

SOAP_FMAC3 ns3__EntityList * FASTCALL soap_in_ns3__EntityList(struct soap *soap, const char *tag, ns3__EntityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__EntityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__EntityList, sizeof(ns3__EntityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__EntityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns3__EntityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((ns3__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((ns3__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((ns3__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((ns3__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns3__EntityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__EntityList, 0, sizeof(ns3__EntityList), 0, soap_copy_ns3__EntityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__EntityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__EntityList);
	return this->soap_out(soap, tag?tag:"ns3:EntityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__EntityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__EntityList(soap, this, tag, type);
}

SOAP_FMAC3 ns3__EntityList * SOAP_FMAC4 soap_get_ns3__EntityList(struct soap *soap, ns3__EntityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__EntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__EntityList * FASTCALL soap_instantiate_ns3__EntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__EntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__EntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns6:PurposeList")) {
		cp->type = SOAP_TYPE_ns6__PurposeList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__PurposeList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__PurposeList));
			((ns6__PurposeList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__PurposeList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__PurposeList));
			for(int i = 0; i < n; i++)
				((ns6__PurposeList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__PurposeList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:UnitList")) {
		cp->type = SOAP_TYPE_ns6__UnitList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__UnitList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__UnitList));
			((ns6__UnitList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__UnitList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__UnitList));
			for(int i = 0; i < n; i++)
				((ns6__UnitList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__UnitList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:CountryList")) {
		cp->type = SOAP_TYPE_ns6__CountryList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__CountryList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__CountryList));
			((ns6__CountryList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__CountryList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__CountryList));
			for(int i = 0; i < n; i++)
				((ns6__CountryList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__CountryList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionList")) {
		cp->type = SOAP_TYPE_ns6__RegionList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionList));
			((ns6__RegionList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionList));
			for(int i = 0; i < n; i++)
				((ns6__RegionList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:DistrictList")) {
		cp->type = SOAP_TYPE_ns6__DistrictList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__DistrictList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__DistrictList));
			((ns6__DistrictList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__DistrictList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__DistrictList));
			for(int i = 0; i < n; i++)
				((ns6__DistrictList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__DistrictList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:LocalityList")) {
		cp->type = SOAP_TYPE_ns6__LocalityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__LocalityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__LocalityList));
			((ns6__LocalityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__LocalityList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__LocalityList));
			for(int i = 0; i < n; i++)
				((ns6__LocalityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__LocalityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:StreetList")) {
		cp->type = SOAP_TYPE_ns6__StreetList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__StreetList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__StreetList));
			((ns6__StreetList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__StreetList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__StreetList));
			for(int i = 0; i < n; i++)
				((ns6__StreetList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__StreetList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:EnterpriseActivityList")) {
		cp->type = SOAP_TYPE_ns6__EnterpriseActivityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__EnterpriseActivityList));
			((ns6__EnterpriseActivityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivityList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseActivityList));
			for(int i = 0; i < n; i++)
				((ns6__EnterpriseActivityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__EnterpriseActivityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:EnterpriseList")) {
		cp->type = SOAP_TYPE_ns6__EnterpriseList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__EnterpriseList));
			((ns6__EnterpriseList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseList));
			for(int i = 0; i < n; i++)
				((ns6__EnterpriseList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__EnterpriseList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:BusinessEntityList")) {
		cp->type = SOAP_TYPE_ns6__BusinessEntityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__BusinessEntityList));
			((ns6__BusinessEntityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntityList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__BusinessEntityList));
			for(int i = 0; i < n; i++)
				((ns6__BusinessEntityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__BusinessEntityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ProductList")) {
		cp->type = SOAP_TYPE_ns6__ProductList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ProductList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ProductList));
			((ns6__ProductList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ProductList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ProductList));
			for(int i = 0; i < n; i++)
				((ns6__ProductList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ProductList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:SubProductList")) {
		cp->type = SOAP_TYPE_ns6__SubProductList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__SubProductList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__SubProductList));
			((ns6__SubProductList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__SubProductList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__SubProductList));
			for(int i = 0; i < n; i++)
				((ns6__SubProductList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SubProductList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ProductItemList")) {
		cp->type = SOAP_TYPE_ns6__ProductItemList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ProductItemList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ProductItemList));
			((ns6__ProductItemList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ProductItemList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ProductItemList));
			for(int i = 0; i < n; i++)
				((ns6__ProductItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ProductItemList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationConditionList")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationConditionList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationConditionList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationConditionList));
			((ns6__RegionalizationConditionList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationConditionList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationConditionList));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationConditionList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationConditionList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationRegionStatusList")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationRegionStatusList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatusList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationRegionStatusList));
			((ns6__RegionalizationRegionStatusList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatusList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationRegionStatusList));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationRegionStatusList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationRegionStatusList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationShippingRuleList")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationShippingRuleList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRuleList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationShippingRuleList));
			((ns6__RegionalizationShippingRuleList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRuleList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationShippingRuleList));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationShippingRuleList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationShippingRuleList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:AnimalDiseaseList")) {
		cp->type = SOAP_TYPE_ns6__AnimalDiseaseList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__AnimalDiseaseList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__AnimalDiseaseList));
			((ns6__AnimalDiseaseList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__AnimalDiseaseList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__AnimalDiseaseList));
			for(int i = 0; i < n; i++)
				((ns6__AnimalDiseaseList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__AnimalDiseaseList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ResearchMethodList")) {
		cp->type = SOAP_TYPE_ns6__ResearchMethodList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethodList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ResearchMethodList));
			((ns6__ResearchMethodList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethodList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ResearchMethodList));
			for(int i = 0; i < n; i++)
				((ns6__ResearchMethodList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ResearchMethodList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ActivityLocationList")) {
		cp->type = SOAP_TYPE_ns6__ActivityLocationList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ActivityLocationList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ActivityLocationList));
			((ns6__ActivityLocationList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ActivityLocationList[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ActivityLocationList));
			for(int i = 0; i < n; i++)
				((ns6__ActivityLocationList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ActivityLocationList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:VetDocumentList")) {
		cp->type = SOAP_TYPE_ns7__VetDocumentList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__VetDocumentList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__VetDocumentList));
			((ns7__VetDocumentList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__VetDocumentList[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__VetDocumentList));
			for(int i = 0; i < n; i++)
				((ns7__VetDocumentList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__VetDocumentList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:StockEntryList")) {
		cp->type = SOAP_TYPE_ns7__StockEntryList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__StockEntryList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__StockEntryList));
			((ns7__StockEntryList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__StockEntryList[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__StockEntryList));
			for(int i = 0; i < n; i++)
				((ns7__StockEntryList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__StockEntryList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:UserList")) {
		cp->type = SOAP_TYPE_ns7__UserList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__UserList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__UserList));
			((ns7__UserList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__UserList[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__UserList));
			for(int i = 0; i < n; i++)
				((ns7__UserList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__UserList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:WorkingAreaList")) {
		cp->type = SOAP_TYPE_ns7__WorkingAreaList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__WorkingAreaList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__WorkingAreaList));
			((ns7__WorkingAreaList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__WorkingAreaList[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__WorkingAreaList));
			for(int i = 0; i < n; i++)
				((ns7__WorkingAreaList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__WorkingAreaList*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__EntityList);
		ASSIGN_PTR(size, sizeof(ns3__EntityList));
		((ns3__EntityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__EntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__EntityList));
		for(int i = 0; i < n; i++)
			((ns3__EntityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__EntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__EntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__EntityList %p -> %p\n", q, p));
	*(ns3__EntityList*)p = *(ns3__EntityList*)q;
}

void ns3__DateInterval::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__DateInterval::beginDate = NULL;
	this->ns3__DateInterval::endDate = NULL;
	/* transient soap skipped */
}

void ns3__DateInterval::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->ns3__DateInterval::beginDate);
	soap_serialize_PointerTotime(soap, &this->ns3__DateInterval::endDate);
	/* transient soap skipped */
}

int ns3__DateInterval::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DateInterval(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__DateInterval(struct soap *soap, const char *tag, int id, const ns3__DateInterval *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__DateInterval), type))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:beginDate", -1, &(a->ns3__DateInterval::beginDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:endDate", -1, &(a->ns3__DateInterval::endDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__DateInterval::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__DateInterval(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DateInterval * FASTCALL soap_in_ns3__DateInterval(struct soap *soap, const char *tag, ns3__DateInterval *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DateInterval *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DateInterval, sizeof(ns3__DateInterval), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__DateInterval) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DateInterval *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_beginDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_beginDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:beginDate", &(a->ns3__DateInterval::beginDate), "xsd:dateTime"))
				{	soap_flag_beginDate1--;
					continue;
				}
			if(soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:endDate", &(a->ns3__DateInterval::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns3__DateInterval *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DateInterval, 0, sizeof(ns3__DateInterval), 0, soap_copy_ns3__DateInterval);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__DateInterval::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__DateInterval);
	return this->soap_out(soap, tag?tag:"ns3:DateInterval", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__DateInterval::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DateInterval(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DateInterval * SOAP_FMAC4 soap_get_ns3__DateInterval(struct soap *soap, ns3__DateInterval *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__DateInterval(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__DateInterval * FASTCALL soap_instantiate_ns3__DateInterval(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DateInterval(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__DateInterval, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__DateInterval);
		ASSIGN_PTR(size, sizeof(ns3__DateInterval));
		((ns3__DateInterval*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__DateInterval[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__DateInterval));
		for(int i = 0; i < n; i++)
			((ns3__DateInterval*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__DateInterval*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DateInterval(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DateInterval %p -> %p\n", q, p));
	*(ns3__DateInterval*)p = *(ns3__DateInterval*)q;
}

void ns3__ListOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->ns3__ListOptions::count);
	soap_default_xsd__nonNegativeInteger(soap, &this->ns3__ListOptions::offset);
	/* transient soap skipped */
}

void ns3__ListOptions::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__nonNegativeInteger(soap, &this->ns3__ListOptions::count);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->ns3__ListOptions::offset);
	/* transient soap skipped */
}

int ns3__ListOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ListOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__ListOptions(struct soap *soap, const char *tag, int id, const ns3__ListOptions *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ListOptions), type))
		return soap->error;
	if(soap_out_xsd__nonNegativeInteger(soap, "ns3:count", -1, &(a->ns3__ListOptions::count), ""))
		return soap->error;
	if(soap_out_xsd__nonNegativeInteger(soap, "ns3:offset", -1, &(a->ns3__ListOptions::offset), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ListOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ListOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ListOptions * FASTCALL soap_in_ns3__ListOptions(struct soap *soap, const char *tag, ns3__ListOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ListOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ListOptions, sizeof(ns3__ListOptions), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__ListOptions) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ListOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_count1 = 1;
	size_t soap_flag_offset1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__nonNegativeInteger(soap, "ns3:count", &(a->ns3__ListOptions::count), "xsd:nonNegativeInteger"))
				{	soap_flag_count1--;
					continue;
				}
			if(soap_flag_offset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__nonNegativeInteger(soap, "ns3:offset", &(a->ns3__ListOptions::offset), "xsd:nonNegativeInteger"))
				{	soap_flag_offset1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns3__ListOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ListOptions, 0, sizeof(ns3__ListOptions), 0, soap_copy_ns3__ListOptions);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__ListOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ListOptions);
	return this->soap_out(soap, tag?tag:"ns3:ListOptions", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__ListOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ListOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ListOptions * SOAP_FMAC4 soap_get_ns3__ListOptions(struct soap *soap, ns3__ListOptions *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__ListOptions(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__ListOptions * FASTCALL soap_instantiate_ns3__ListOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ListOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ListOptions, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__ListOptions);
		ASSIGN_PTR(size, sizeof(ns3__ListOptions));
		((ns3__ListOptions*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__ListOptions[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__ListOptions));
		for(int i = 0; i < n; i++)
			((ns3__ListOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ListOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ListOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ListOptions %p -> %p\n", q, p));
	*(ns3__ListOptions*)p = *(ns3__ListOptions*)q;
}

void ns3__GenericVersioningEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	this->ns3__GenericVersioningEntity::active = NULL;
	this->ns3__GenericVersioningEntity::last = NULL;
	this->ns3__GenericVersioningEntity::status = NULL;
	this->ns3__GenericVersioningEntity::createDate = NULL;
	this->ns3__GenericVersioningEntity::updateDate = NULL;
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_default_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns3__GenericVersioningEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->ns3__GenericVersioningEntity::last);
	soap_serialize_PointerTons3__VersionStatus(soap, &this->ns3__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->ns3__GenericVersioningEntity::updateDate);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::previous);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericVersioningEntity::next);
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns3__GenericVersioningEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__GenericVersioningEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__GenericVersioningEntity(struct soap *soap, const char *tag, int id, const ns3__GenericVersioningEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__GenericVersioningEntity), "ns3:GenericVersioningEntity"))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_ns3__UUID(soap, "ns3:guid", -1, &(a->ns3__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:active", -1, &(a->ns3__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ns3:last", -1, &(a->ns3__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTons3__VersionStatus(soap, "ns3:status", -1, &(a->ns3__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:createDate", -1, &(a->ns3__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "ns3:updateDate", -1, &(a->ns3__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:previous", -1, &(a->ns3__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:next", -1, &(a->ns3__GenericVersioningEntity::next), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__GenericVersioningEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__GenericVersioningEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns3__GenericVersioningEntity * FASTCALL soap_in_ns3__GenericVersioningEntity(struct soap *soap, const char *tag, ns3__GenericVersioningEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__GenericVersioningEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__GenericVersioningEntity, sizeof(ns3__GenericVersioningEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__GenericVersioningEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns3__GenericVersioningEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_guid1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_last1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_createDate1 = 1;
	size_t soap_flag_updateDate1 = 1;
	size_t soap_flag_previous1 = 1;
	size_t soap_flag_next1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:guid", &(a->ns3__GenericVersioningEntity::guid), "ns3:UUID"))
				{	soap_flag_guid1--;
					continue;
				}
			if(soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:active", &(a->ns3__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if(soap_flag_last1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ns3:last", &(a->ns3__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last1--;
					continue;
				}
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__VersionStatus(soap, "ns3:status", &(a->ns3__GenericVersioningEntity::status), "ns3:VersionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:createDate", &(a->ns3__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if(soap_flag_updateDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "ns3:updateDate", &(a->ns3__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate1--;
					continue;
				}
			if(soap_flag_previous1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:previous", &(a->ns3__GenericVersioningEntity::previous), "ns3:UUID"))
				{	soap_flag_previous1--;
					continue;
				}
			if(soap_flag_next1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:next", &(a->ns3__GenericVersioningEntity::next), "ns3:UUID"))
				{	soap_flag_next1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns3__GenericVersioningEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__GenericVersioningEntity, 0, sizeof(ns3__GenericVersioningEntity), 0, soap_copy_ns3__GenericVersioningEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__GenericVersioningEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__GenericVersioningEntity);
	return this->soap_out(soap, tag?tag:"ns3:GenericVersioningEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__GenericVersioningEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__GenericVersioningEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns3__GenericVersioningEntity * SOAP_FMAC4 soap_get_ns3__GenericVersioningEntity(struct soap *soap, ns3__GenericVersioningEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__GenericVersioningEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__GenericVersioningEntity * FASTCALL soap_instantiate_ns3__GenericVersioningEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__GenericVersioningEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__GenericVersioningEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns6:Purpose")) {
		cp->type = SOAP_TYPE_ns6__Purpose;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Purpose);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Purpose));
			((ns6__Purpose*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Purpose[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Purpose));
			for(int i = 0; i < n; i++)
				((ns6__Purpose*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Purpose*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Unit")) {
		cp->type = SOAP_TYPE_ns6__Unit;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Unit);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Unit));
			((ns6__Unit*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Unit[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Unit));
			for(int i = 0; i < n; i++)
				((ns6__Unit*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Unit*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:PackingType")) {
		cp->type = SOAP_TYPE_ns6__PackingType;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__PackingType);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__PackingType));
			((ns6__PackingType*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__PackingType[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__PackingType));
			for(int i = 0; i < n; i++)
				((ns6__PackingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__PackingType*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Country")) {
		cp->type = SOAP_TYPE_ns6__Country;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Country);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Country));
			((ns6__Country*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Country[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Country));
			for(int i = 0; i < n; i++)
				((ns6__Country*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Country*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:FederalDistrict")) {
		cp->type = SOAP_TYPE_ns6__FederalDistrict;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__FederalDistrict);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__FederalDistrict));
			((ns6__FederalDistrict*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__FederalDistrict[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__FederalDistrict));
			for(int i = 0; i < n; i++)
				((ns6__FederalDistrict*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__FederalDistrict*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:AddressObjectView")) {
		cp->type = SOAP_TYPE_ns6__AddressObjectView;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__AddressObjectView);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__AddressObjectView));
			((ns6__AddressObjectView*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__AddressObjectView[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__AddressObjectView));
			for(int i = 0; i < n; i++)
				((ns6__AddressObjectView*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__AddressObjectView*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Enterprise")) {
		cp->type = SOAP_TYPE_ns6__Enterprise;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Enterprise);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Enterprise));
			((ns6__Enterprise*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Enterprise[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Enterprise));
			for(int i = 0; i < n; i++)
				((ns6__Enterprise*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Enterprise*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:BusinessEntity")) {
		cp->type = SOAP_TYPE_ns6__BusinessEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__BusinessEntity));
			((ns6__BusinessEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntity[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__BusinessEntity));
			for(int i = 0; i < n; i++)
				((ns6__BusinessEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__BusinessEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ProductItem")) {
		cp->type = SOAP_TYPE_ns6__ProductItem;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ProductItem);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ProductItem));
			((ns6__ProductItem*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ProductItem[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ProductItem));
			for(int i = 0; i < n; i++)
				((ns6__ProductItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ProductItem*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Product")) {
		cp->type = SOAP_TYPE_ns6__Product;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Product);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Product));
			((ns6__Product*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Product[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Product));
			for(int i = 0; i < n; i++)
				((ns6__Product*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Product*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:SubProduct")) {
		cp->type = SOAP_TYPE_ns6__SubProduct;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__SubProduct);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__SubProduct));
			((ns6__SubProduct*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__SubProduct[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__SubProduct));
			for(int i = 0; i < n; i++)
				((ns6__SubProduct*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SubProduct*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Indicator")) {
		cp->type = SOAP_TYPE_ns6__Indicator;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Indicator);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Indicator));
			((ns6__Indicator*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Indicator[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Indicator));
			for(int i = 0; i < n; i++)
				((ns6__Indicator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Indicator*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:AnimalDisease")) {
		cp->type = SOAP_TYPE_ns6__AnimalDisease;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__AnimalDisease);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__AnimalDisease));
			((ns6__AnimalDisease*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__AnimalDisease[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__AnimalDisease));
			for(int i = 0; i < n; i++)
				((ns6__AnimalDisease*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__AnimalDisease*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ResearchMethod")) {
		cp->type = SOAP_TYPE_ns6__ResearchMethod;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethod);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ResearchMethod));
			((ns6__ResearchMethod*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethod[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ResearchMethod));
			for(int i = 0; i < n; i++)
				((ns6__ResearchMethod*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ResearchMethod*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationCondition")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationCondition;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationCondition);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationCondition));
			((ns6__RegionalizationCondition*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationCondition[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationCondition));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationCondition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationCondition*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationShippingRule")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationShippingRule;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRule);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationShippingRule));
			((ns6__RegionalizationShippingRule*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRule[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationShippingRule));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationShippingRule*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationRegionStatus")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationRegionStatus;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatus);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationRegionStatus));
			((ns6__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatus[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationRegionStatus));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationRegionStatus*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:StockEntry")) {
		cp->type = SOAP_TYPE_ns7__StockEntry;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__StockEntry);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__StockEntry));
			((ns7__StockEntry*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__StockEntry[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__StockEntry));
			for(int i = 0; i < n; i++)
				((ns7__StockEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__StockEntry*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Region")) {
		cp->type = SOAP_TYPE_ns6__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Region));
			((ns6__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Region[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Region));
			for(int i = 0; i < n; i++)
				((ns6__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:District")) {
		cp->type = SOAP_TYPE_ns6__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__District));
			((ns6__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__District[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__District));
			for(int i = 0; i < n; i++)
				((ns6__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Locality")) {
		cp->type = SOAP_TYPE_ns6__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Locality));
			((ns6__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Locality));
			for(int i = 0; i < n; i++)
				((ns6__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Street")) {
		cp->type = SOAP_TYPE_ns6__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Street));
			((ns6__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Street[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Street));
			for(int i = 0; i < n; i++)
				((ns6__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Street*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_ns7__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__StockEntrySearchPattern));
			((ns7__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((ns7__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__GenericVersioningEntity);
		ASSIGN_PTR(size, sizeof(ns3__GenericVersioningEntity));
		((ns3__GenericVersioningEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__GenericVersioningEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__GenericVersioningEntity));
		for(int i = 0; i < n; i++)
			((ns3__GenericVersioningEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__GenericVersioningEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__GenericVersioningEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__GenericVersioningEntity %p -> %p\n", q, p));
	*(ns3__GenericVersioningEntity*)p = *(ns3__GenericVersioningEntity*)q;
}

void ns3__GenericEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

void ns3__GenericEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns3__UUID(soap, &this->ns3__GenericEntity::uuid);
	/* transient soap skipped */
}

int ns3__GenericEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__GenericEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__GenericEntity(struct soap *soap, const char *tag, int id, const ns3__GenericEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__GenericEntity), type))
		return soap->error;
	if(soap_out_ns3__UUID(soap, "ns3:uuid", -1, &(a->ns3__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__GenericEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__GenericEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns3__GenericEntity * FASTCALL soap_in_ns3__GenericEntity(struct soap *soap, const char *tag, ns3__GenericEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__GenericEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__GenericEntity, sizeof(ns3__GenericEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ns3__GenericEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ns3__GenericEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns3:uuid", &(a->ns3__GenericEntity::uuid), "ns3:UUID"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ns3__GenericEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__GenericEntity, 0, sizeof(ns3__GenericEntity), 0, soap_copy_ns3__GenericEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__GenericEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__GenericEntity);
	return this->soap_out(soap, tag?tag:"ns3:GenericEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *ns3__GenericEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__GenericEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns3__GenericEntity * SOAP_FMAC4 soap_get_ns3__GenericEntity(struct soap *soap, ns3__GenericEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__GenericEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__GenericEntity * FASTCALL soap_instantiate_ns3__GenericEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__GenericEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__GenericEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ns3:GenericVersioningEntity")) {
		cp->type = SOAP_TYPE_ns3__GenericVersioningEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns3__GenericVersioningEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns3__GenericVersioningEntity));
			((ns3__GenericVersioningEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns3__GenericVersioningEntity[n]);
			ASSIGN_PTR(size, n * sizeof(ns3__GenericVersioningEntity));
			for(int i = 0; i < n; i++)
				((ns3__GenericVersioningEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__GenericVersioningEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:EnterpriseActivity")) {
		cp->type = SOAP_TYPE_ns6__EnterpriseActivity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__EnterpriseActivity));
			((ns6__EnterpriseActivity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__EnterpriseActivity[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__EnterpriseActivity));
			for(int i = 0; i < n; i++)
				((ns6__EnterpriseActivity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__EnterpriseActivity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:IncorporationForm")) {
		cp->type = SOAP_TYPE_ns6__IncorporationForm;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__IncorporationForm);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__IncorporationForm));
			((ns6__IncorporationForm*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__IncorporationForm[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__IncorporationForm));
			for(int i = 0; i < n; i++)
				((ns6__IncorporationForm*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__IncorporationForm*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:Delivery")) {
		cp->type = SOAP_TYPE_ns7__Delivery;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__Delivery);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__Delivery));
			((ns7__Delivery*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__Delivery[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__Delivery));
			for(int i = 0; i < n; i++)
				((ns7__Delivery*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__Delivery*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:DiscrepancyReason")) {
		cp->type = SOAP_TYPE_ns7__DiscrepancyReason;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReason);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__DiscrepancyReason));
			((ns7__DiscrepancyReason*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReason[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__DiscrepancyReason));
			for(int i = 0; i < n; i++)
				((ns7__DiscrepancyReason*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__DiscrepancyReason*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:Document")) {
		cp->type = SOAP_TYPE_ns7__Document;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__Document);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__Document));
			((ns7__Document*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__Document[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__Document));
			for(int i = 0; i < n; i++)
				((ns7__Document*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__Document*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:ShipmentRoutePoint")) {
		cp->type = SOAP_TYPE_ns7__ShipmentRoutePoint;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__ShipmentRoutePoint);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__ShipmentRoutePoint));
			((ns7__ShipmentRoutePoint*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__ShipmentRoutePoint[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__ShipmentRoutePoint));
			for(int i = 0; i < n; i++)
				((ns7__ShipmentRoutePoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ShipmentRoutePoint*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:User")) {
		cp->type = SOAP_TYPE_ns7__User;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__User);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__User));
			((ns7__User*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__User[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__User));
			for(int i = 0; i < n; i++)
				((ns7__User*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__User*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Purpose")) {
		cp->type = SOAP_TYPE_ns6__Purpose;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Purpose);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Purpose));
			((ns6__Purpose*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Purpose[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Purpose));
			for(int i = 0; i < n; i++)
				((ns6__Purpose*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Purpose*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Unit")) {
		cp->type = SOAP_TYPE_ns6__Unit;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Unit);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Unit));
			((ns6__Unit*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Unit[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Unit));
			for(int i = 0; i < n; i++)
				((ns6__Unit*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Unit*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:PackingType")) {
		cp->type = SOAP_TYPE_ns6__PackingType;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__PackingType);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__PackingType));
			((ns6__PackingType*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__PackingType[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__PackingType));
			for(int i = 0; i < n; i++)
				((ns6__PackingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__PackingType*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Country")) {
		cp->type = SOAP_TYPE_ns6__Country;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Country);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Country));
			((ns6__Country*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Country[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Country));
			for(int i = 0; i < n; i++)
				((ns6__Country*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Country*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:FederalDistrict")) {
		cp->type = SOAP_TYPE_ns6__FederalDistrict;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__FederalDistrict);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__FederalDistrict));
			((ns6__FederalDistrict*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__FederalDistrict[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__FederalDistrict));
			for(int i = 0; i < n; i++)
				((ns6__FederalDistrict*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__FederalDistrict*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:AddressObjectView")) {
		cp->type = SOAP_TYPE_ns6__AddressObjectView;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__AddressObjectView);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__AddressObjectView));
			((ns6__AddressObjectView*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__AddressObjectView[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__AddressObjectView));
			for(int i = 0; i < n; i++)
				((ns6__AddressObjectView*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__AddressObjectView*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Enterprise")) {
		cp->type = SOAP_TYPE_ns6__Enterprise;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Enterprise);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Enterprise));
			((ns6__Enterprise*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Enterprise[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Enterprise));
			for(int i = 0; i < n; i++)
				((ns6__Enterprise*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Enterprise*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:BusinessEntity")) {
		cp->type = SOAP_TYPE_ns6__BusinessEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__BusinessEntity));
			((ns6__BusinessEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__BusinessEntity[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__BusinessEntity));
			for(int i = 0; i < n; i++)
				((ns6__BusinessEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__BusinessEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ProductItem")) {
		cp->type = SOAP_TYPE_ns6__ProductItem;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ProductItem);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ProductItem));
			((ns6__ProductItem*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ProductItem[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ProductItem));
			for(int i = 0; i < n; i++)
				((ns6__ProductItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ProductItem*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Product")) {
		cp->type = SOAP_TYPE_ns6__Product;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Product);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Product));
			((ns6__Product*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Product[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Product));
			for(int i = 0; i < n; i++)
				((ns6__Product*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Product*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:SubProduct")) {
		cp->type = SOAP_TYPE_ns6__SubProduct;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__SubProduct);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__SubProduct));
			((ns6__SubProduct*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__SubProduct[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__SubProduct));
			for(int i = 0; i < n; i++)
				((ns6__SubProduct*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__SubProduct*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Indicator")) {
		cp->type = SOAP_TYPE_ns6__Indicator;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Indicator);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Indicator));
			((ns6__Indicator*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Indicator[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Indicator));
			for(int i = 0; i < n; i++)
				((ns6__Indicator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Indicator*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:AnimalDisease")) {
		cp->type = SOAP_TYPE_ns6__AnimalDisease;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__AnimalDisease);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__AnimalDisease));
			((ns6__AnimalDisease*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__AnimalDisease[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__AnimalDisease));
			for(int i = 0; i < n; i++)
				((ns6__AnimalDisease*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__AnimalDisease*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:ResearchMethod")) {
		cp->type = SOAP_TYPE_ns6__ResearchMethod;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethod);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__ResearchMethod));
			((ns6__ResearchMethod*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__ResearchMethod[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__ResearchMethod));
			for(int i = 0; i < n; i++)
				((ns6__ResearchMethod*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ResearchMethod*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationCondition")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationCondition;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationCondition);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationCondition));
			((ns6__RegionalizationCondition*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationCondition[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationCondition));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationCondition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationCondition*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationShippingRule")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationShippingRule;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRule);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationShippingRule));
			((ns6__RegionalizationShippingRule*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationShippingRule[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationShippingRule));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationShippingRule*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:RegionalizationRegionStatus")) {
		cp->type = SOAP_TYPE_ns6__RegionalizationRegionStatus;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatus);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__RegionalizationRegionStatus));
			((ns6__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__RegionalizationRegionStatus[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__RegionalizationRegionStatus));
			for(int i = 0; i < n; i++)
				((ns6__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RegionalizationRegionStatus*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:VetDocument")) {
		cp->type = SOAP_TYPE_ns7__VetDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__VetDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__VetDocument));
			((ns7__VetDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__VetDocument[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__VetDocument));
			for(int i = 0; i < n; i++)
				((ns7__VetDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__VetDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:DiscrepancyReport")) {
		cp->type = SOAP_TYPE_ns7__DiscrepancyReport;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReport);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__DiscrepancyReport));
			((ns7__DiscrepancyReport*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__DiscrepancyReport[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__DiscrepancyReport));
			for(int i = 0; i < n; i++)
				((ns7__DiscrepancyReport*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__DiscrepancyReport*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:StockEntry")) {
		cp->type = SOAP_TYPE_ns7__StockEntry;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__StockEntry);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__StockEntry));
			((ns7__StockEntry*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__StockEntry[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__StockEntry));
			for(int i = 0; i < n; i++)
				((ns7__StockEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__StockEntry*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:Waybill")) {
		cp->type = SOAP_TYPE_ns7__Waybill;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__Waybill);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__Waybill));
			((ns7__Waybill*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__Waybill[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__Waybill));
			for(int i = 0; i < n; i++)
				((ns7__Waybill*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__Waybill*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:ReferencedDocument")) {
		cp->type = SOAP_TYPE_ns7__ReferencedDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__ReferencedDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__ReferencedDocument));
			((ns7__ReferencedDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__ReferencedDocument[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__ReferencedDocument));
			for(int i = 0; i < n; i++)
				((ns7__ReferencedDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__ReferencedDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Region")) {
		cp->type = SOAP_TYPE_ns6__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Region));
			((ns6__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Region[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Region));
			for(int i = 0; i < n; i++)
				((ns6__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:District")) {
		cp->type = SOAP_TYPE_ns6__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__District));
			((ns6__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__District[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__District));
			for(int i = 0; i < n; i++)
				((ns6__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Locality")) {
		cp->type = SOAP_TYPE_ns6__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Locality));
			((ns6__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Locality));
			for(int i = 0; i < n; i++)
				((ns6__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns6:Street")) {
		cp->type = SOAP_TYPE_ns6__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns6__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns6__Street));
			((ns6__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns6__Street[n]);
			ASSIGN_PTR(size, n * sizeof(ns6__Street));
			for(int i = 0; i < n; i++)
				((ns6__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__Street*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ns7:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_ns7__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ns7__StockEntrySearchPattern));
			((ns7__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ns7__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(ns7__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((ns7__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ns3__GenericEntity);
		ASSIGN_PTR(size, sizeof(ns3__GenericEntity));
		((ns3__GenericEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ns3__GenericEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ns3__GenericEntity));
		for(int i = 0; i < n; i++)
			((ns3__GenericEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__GenericEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__GenericEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__GenericEntity %p -> %p\n", q, p));
	*(ns3__GenericEntity*)p = *(ns3__GenericEntity*)q;
}

void _ns1__receiveApplicationResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__receiveApplicationResultResponse::ns4__application = NULL;
	/* transient soap skipped */
}

void _ns1__receiveApplicationResultResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons4__Application(soap, &this->_ns1__receiveApplicationResultResponse::ns4__application);
	/* transient soap skipped */
}

int _ns1__receiveApplicationResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__receiveApplicationResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns1__receiveApplicationResultResponse(struct soap *soap, const char *tag, int id, const _ns1__receiveApplicationResultResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__receiveApplicationResultResponse), type))
		return soap->error;
	if(a->ns4__application)
		soap_element_result(soap, "ns4:application");
	if(a->_ns1__receiveApplicationResultResponse::ns4__application) {
		if(soap_out_PointerTons4__Application(soap, "ns4:application", -1, &a->_ns1__receiveApplicationResultResponse::ns4__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns4:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__receiveApplicationResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__receiveApplicationResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__receiveApplicationResultResponse * FASTCALL soap_in__ns1__receiveApplicationResultResponse(struct soap *soap, const char *tag, _ns1__receiveApplicationResultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__receiveApplicationResultResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__receiveApplicationResultResponse, sizeof(_ns1__receiveApplicationResultResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns1__receiveApplicationResultResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__receiveApplicationResultResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns4__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns4__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__Application(soap, "ns4:application", &(a->_ns1__receiveApplicationResultResponse::ns4__application), "ns4:Application"))
				{	soap_flag_ns4__application1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns4:application");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns1__receiveApplicationResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__receiveApplicationResultResponse, 0, sizeof(_ns1__receiveApplicationResultResponse), 0, soap_copy__ns1__receiveApplicationResultResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns4__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__receiveApplicationResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__receiveApplicationResultResponse);
	return this->soap_out(soap, tag?tag:"ns1:receiveApplicationResultResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns1__receiveApplicationResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__receiveApplicationResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__receiveApplicationResultResponse * SOAP_FMAC4 soap_get__ns1__receiveApplicationResultResponse(struct soap *soap, _ns1__receiveApplicationResultResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns1__receiveApplicationResultResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__receiveApplicationResultResponse * FASTCALL soap_instantiate__ns1__receiveApplicationResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__receiveApplicationResultResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__receiveApplicationResultResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns1__receiveApplicationResultResponse);
		ASSIGN_PTR(size, sizeof(_ns1__receiveApplicationResultResponse));
		((_ns1__receiveApplicationResultResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns1__receiveApplicationResultResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns1__receiveApplicationResultResponse));
		for(int i = 0; i < n; i++)
			((_ns1__receiveApplicationResultResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__receiveApplicationResultResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__receiveApplicationResultResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__receiveApplicationResultResponse %p -> %p\n", q, p));
	*(_ns1__receiveApplicationResultResponse*)p = *(_ns1__receiveApplicationResultResponse*)q;
}

void _ns1__receiveApplicationResultRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__APIKey(soap, &this->_ns1__receiveApplicationResultRequest::apiKey);
	soap_default_ns3__UUID(soap, &this->_ns1__receiveApplicationResultRequest::issuerId);
	soap_default_ns3__UUID(soap, &this->_ns1__receiveApplicationResultRequest::applicationId);
	/* transient soap skipped */
}

void _ns1__receiveApplicationResultRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns4__APIKey(soap, &this->_ns1__receiveApplicationResultRequest::apiKey);
	soap_serialize_ns3__UUID(soap, &this->_ns1__receiveApplicationResultRequest::issuerId);
	soap_serialize_ns3__UUID(soap, &this->_ns1__receiveApplicationResultRequest::applicationId);
	/* transient soap skipped */
}

int _ns1__receiveApplicationResultRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__receiveApplicationResultRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns1__receiveApplicationResultRequest(struct soap *soap, const char *tag, int id, const _ns1__receiveApplicationResultRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__receiveApplicationResultRequest), type))
		return soap->error;
	if(a->_ns1__receiveApplicationResultRequest::apiKey) {
		if(soap_out_ns4__APIKey(soap, "ns1:apiKey", -1, &a->_ns1__receiveApplicationResultRequest::apiKey, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns1:apiKey"))
		return soap->error;
	if(a->_ns1__receiveApplicationResultRequest::issuerId) {
		if(soap_out_ns3__UUID(soap, "ns1:issuerId", -1, &a->_ns1__receiveApplicationResultRequest::issuerId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns1:issuerId"))
		return soap->error;
	if(a->_ns1__receiveApplicationResultRequest::applicationId) {
		if(soap_out_ns3__UUID(soap, "ns1:applicationId", -1, &a->_ns1__receiveApplicationResultRequest::applicationId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns1:applicationId"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__receiveApplicationResultRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__receiveApplicationResultRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__receiveApplicationResultRequest * FASTCALL soap_in__ns1__receiveApplicationResultRequest(struct soap *soap, const char *tag, _ns1__receiveApplicationResultRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__receiveApplicationResultRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__receiveApplicationResultRequest, sizeof(_ns1__receiveApplicationResultRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns1__receiveApplicationResultRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__receiveApplicationResultRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_apiKey1 = 1;
	size_t soap_flag_issuerId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_apiKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns4__APIKey(soap, "ns1:apiKey", &(a->_ns1__receiveApplicationResultRequest::apiKey), "ns4:APIKey"))
				{	soap_flag_apiKey1--;
					continue;
				}
			if(soap_flag_issuerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns1:issuerId", &(a->_ns1__receiveApplicationResultRequest::issuerId), "ns3:UUID"))
				{	soap_flag_issuerId1--;
					continue;
				}
			if(soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns3__UUID(soap, "ns1:applicationId", &(a->_ns1__receiveApplicationResultRequest::applicationId), "ns3:UUID"))
				{	soap_flag_applicationId1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns1__receiveApplicationResultRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__receiveApplicationResultRequest, 0, sizeof(_ns1__receiveApplicationResultRequest), 0, soap_copy__ns1__receiveApplicationResultRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiKey1 > 0 || soap_flag_issuerId1 > 0 || soap_flag_applicationId1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__receiveApplicationResultRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__receiveApplicationResultRequest);
	return this->soap_out(soap, tag?tag:"ns1:receiveApplicationResultRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns1__receiveApplicationResultRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__receiveApplicationResultRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__receiveApplicationResultRequest * SOAP_FMAC4 soap_get__ns1__receiveApplicationResultRequest(struct soap *soap, _ns1__receiveApplicationResultRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns1__receiveApplicationResultRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__receiveApplicationResultRequest * FASTCALL soap_instantiate__ns1__receiveApplicationResultRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__receiveApplicationResultRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__receiveApplicationResultRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns1__receiveApplicationResultRequest);
		ASSIGN_PTR(size, sizeof(_ns1__receiveApplicationResultRequest));
		((_ns1__receiveApplicationResultRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns1__receiveApplicationResultRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns1__receiveApplicationResultRequest));
		for(int i = 0; i < n; i++)
			((_ns1__receiveApplicationResultRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__receiveApplicationResultRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__receiveApplicationResultRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__receiveApplicationResultRequest %p -> %p\n", q, p));
	*(_ns1__receiveApplicationResultRequest*)p = *(_ns1__receiveApplicationResultRequest*)q;
}

void _ns1__submitApplicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__submitApplicationResponse::ns4__application = NULL;
	/* transient soap skipped */
}

void _ns1__submitApplicationResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTons4__Application(soap, &this->_ns1__submitApplicationResponse::ns4__application);
	/* transient soap skipped */
}

int _ns1__submitApplicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__submitApplicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns1__submitApplicationResponse(struct soap *soap, const char *tag, int id, const _ns1__submitApplicationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__submitApplicationResponse), type))
		return soap->error;
	if(a->ns4__application)
		soap_element_result(soap, "ns4:application");
	if(a->_ns1__submitApplicationResponse::ns4__application) {
		if(soap_out_PointerTons4__Application(soap, "ns4:application", -1, &a->_ns1__submitApplicationResponse::ns4__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns4:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__submitApplicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__submitApplicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__submitApplicationResponse * FASTCALL soap_in__ns1__submitApplicationResponse(struct soap *soap, const char *tag, _ns1__submitApplicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__submitApplicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__submitApplicationResponse, sizeof(_ns1__submitApplicationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns1__submitApplicationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__submitApplicationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns4__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns4__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__Application(soap, "ns4:application", &(a->_ns1__submitApplicationResponse::ns4__application), "ns4:Application"))
				{	soap_flag_ns4__application1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns4:application");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns1__submitApplicationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__submitApplicationResponse, 0, sizeof(_ns1__submitApplicationResponse), 0, soap_copy__ns1__submitApplicationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns4__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__submitApplicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__submitApplicationResponse);
	return this->soap_out(soap, tag?tag:"ns1:submitApplicationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns1__submitApplicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__submitApplicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__submitApplicationResponse * SOAP_FMAC4 soap_get__ns1__submitApplicationResponse(struct soap *soap, _ns1__submitApplicationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns1__submitApplicationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__submitApplicationResponse * FASTCALL soap_instantiate__ns1__submitApplicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__submitApplicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__submitApplicationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns1__submitApplicationResponse);
		ASSIGN_PTR(size, sizeof(_ns1__submitApplicationResponse));
		((_ns1__submitApplicationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns1__submitApplicationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns1__submitApplicationResponse));
		for(int i = 0; i < n; i++)
			((_ns1__submitApplicationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__submitApplicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__submitApplicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__submitApplicationResponse %p -> %p\n", q, p));
	*(_ns1__submitApplicationResponse*)p = *(_ns1__submitApplicationResponse*)q;
}

void _ns1__submitApplicationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns4__APIKey(soap, &this->_ns1__submitApplicationRequest::apiKey);
	this->_ns1__submitApplicationRequest::ns4__application = NULL;
	/* transient soap skipped */
}

void _ns1__submitApplicationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ns4__APIKey(soap, &this->_ns1__submitApplicationRequest::apiKey);
	soap_serialize_PointerTons4__Application(soap, &this->_ns1__submitApplicationRequest::ns4__application);
	/* transient soap skipped */
}

int _ns1__submitApplicationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__submitApplicationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns1__submitApplicationRequest(struct soap *soap, const char *tag, int id, const _ns1__submitApplicationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__submitApplicationRequest), type))
		return soap->error;
	if(a->_ns1__submitApplicationRequest::apiKey) {
		if(soap_out_ns4__APIKey(soap, "ns1:apiKey", -1, &a->_ns1__submitApplicationRequest::apiKey, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns1:apiKey"))
		return soap->error;
	if(a->_ns1__submitApplicationRequest::ns4__application) {
		if(soap_out_PointerTons4__Application(soap, "ns4:application", -1, &a->_ns1__submitApplicationRequest::ns4__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns4:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__submitApplicationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__submitApplicationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__submitApplicationRequest * FASTCALL soap_in__ns1__submitApplicationRequest(struct soap *soap, const char *tag, _ns1__submitApplicationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__submitApplicationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__submitApplicationRequest, sizeof(_ns1__submitApplicationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns1__submitApplicationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__submitApplicationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_apiKey1 = 1;
	size_t soap_flag_ns4__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_apiKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ns4__APIKey(soap, "ns1:apiKey", &(a->_ns1__submitApplicationRequest::apiKey), "ns4:APIKey"))
				{	soap_flag_apiKey1--;
					continue;
				}
			if(soap_flag_ns4__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons4__Application(soap, "ns4:application", &(a->_ns1__submitApplicationRequest::ns4__application), "ns4:Application"))
				{	soap_flag_ns4__application1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns1__submitApplicationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__submitApplicationRequest, 0, sizeof(_ns1__submitApplicationRequest), 0, soap_copy__ns1__submitApplicationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiKey1 > 0 || soap_flag_ns4__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__submitApplicationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__submitApplicationRequest);
	return this->soap_out(soap, tag?tag:"ns1:submitApplicationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns1__submitApplicationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__submitApplicationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__submitApplicationRequest * SOAP_FMAC4 soap_get__ns1__submitApplicationRequest(struct soap *soap, _ns1__submitApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns1__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__submitApplicationRequest * FASTCALL soap_instantiate__ns1__submitApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__submitApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__submitApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns1__submitApplicationRequest);
		ASSIGN_PTR(size, sizeof(_ns1__submitApplicationRequest));
		((_ns1__submitApplicationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns1__submitApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns1__submitApplicationRequest));
		for(int i = 0; i < n; i++)
			((_ns1__submitApplicationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__submitApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__submitApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__submitApplicationRequest %p -> %p\n", q, p));
	*(_ns1__submitApplicationRequest*)p = *(_ns1__submitApplicationRequest*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if(this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if(this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if(id < 0)
		return soap->error;
	if(soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if(soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * FASTCALL soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced)
		a->soap_default(soap);
	if(soap->body && !*soap->href) {	
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if(soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		
#ifndef WITH_LEANER
		if(*soap->href != '#')
		{	if(soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	return this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type) ? soap->error : soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * FASTCALL soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		ASSIGN_PTR(size, sizeof(xsd__base64Binary));
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(xsd__base64Binary[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(xsd__base64Binary));
		for(int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if(soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if(soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if(soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if(soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if(soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * FASTCALL soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if(soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if(soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if(soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	return soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * FASTCALL soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Fault));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Fault));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if(soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if(soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * FASTCALL soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	return soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * FASTCALL soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Reason));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Reason));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if(soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * FASTCALL soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	return soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * FASTCALL soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Code));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Code));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * FASTCALL soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	return soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * FASTCALL soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Header));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Header));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetActivityLocationList(struct soap *soap, struct __ns9__GetActivityLocationList *a)
{
	a->ns8__getActivityLocationListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetActivityLocationList(struct soap *soap, const struct __ns9__GetActivityLocationList *a)
{
	soap_serialize_PointerTo_ns8__getActivityLocationListRequest(soap, &a->ns8__getActivityLocationListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetActivityLocationList(struct soap *soap, const char *tag, int id, const struct __ns9__GetActivityLocationList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getActivityLocationListRequest(soap, "ns8:getActivityLocationListRequest", -1, &a->ns8__getActivityLocationListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetActivityLocationList * FASTCALL soap_in___ns9__GetActivityLocationList(struct soap *soap, const char *tag, struct __ns9__GetActivityLocationList *a, const char *type)
{
	size_t soap_flag_ns8__getActivityLocationListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetActivityLocationList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetActivityLocationList, sizeof(struct __ns9__GetActivityLocationList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetActivityLocationList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getActivityLocationListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getActivityLocationListRequest(soap, "ns8:getActivityLocationListRequest", &a->ns8__getActivityLocationListRequest, ""))
				{	soap_flag_ns8__getActivityLocationListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetActivityLocationList(struct soap *soap, const struct __ns9__GetActivityLocationList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetActivityLocationList(soap, tag?tag:"-ns9:GetActivityLocationList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetActivityLocationList * SOAP_FMAC4 soap_get___ns9__GetActivityLocationList(struct soap *soap, struct __ns9__GetActivityLocationList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetActivityLocationList * FASTCALL soap_instantiate___ns9__GetActivityLocationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetActivityLocationList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetActivityLocationList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetActivityLocationList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetActivityLocationList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetActivityLocationList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetActivityLocationList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetActivityLocationList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetActivityLocationList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetActivityLocationList %p -> %p\n", q, p));
	*(struct __ns9__GetActivityLocationList*)p = *(struct __ns9__GetActivityLocationList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetBusinessMemberByGLN(struct soap *soap, struct __ns9__GetBusinessMemberByGLN *a)
{
	a->ns8__getBusinessMemberByGLNRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetBusinessMemberByGLN(struct soap *soap, const struct __ns9__GetBusinessMemberByGLN *a)
{
	soap_serialize_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, &a->ns8__getBusinessMemberByGLNRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetBusinessMemberByGLN(struct soap *soap, const char *tag, int id, const struct __ns9__GetBusinessMemberByGLN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, "ns8:getBusinessMemberByGLNRequest", -1, &a->ns8__getBusinessMemberByGLNRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessMemberByGLN * FASTCALL soap_in___ns9__GetBusinessMemberByGLN(struct soap *soap, const char *tag, struct __ns9__GetBusinessMemberByGLN *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessMemberByGLNRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetBusinessMemberByGLN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetBusinessMemberByGLN, sizeof(struct __ns9__GetBusinessMemberByGLN), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetBusinessMemberByGLN(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessMemberByGLNRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, "ns8:getBusinessMemberByGLNRequest", &a->ns8__getBusinessMemberByGLNRequest, ""))
				{	soap_flag_ns8__getBusinessMemberByGLNRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetBusinessMemberByGLN(struct soap *soap, const struct __ns9__GetBusinessMemberByGLN *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetBusinessMemberByGLN(soap, tag?tag:"-ns9:GetBusinessMemberByGLN", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessMemberByGLN * SOAP_FMAC4 soap_get___ns9__GetBusinessMemberByGLN(struct soap *soap, struct __ns9__GetBusinessMemberByGLN *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetBusinessMemberByGLN(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetBusinessMemberByGLN * FASTCALL soap_instantiate___ns9__GetBusinessMemberByGLN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetBusinessMemberByGLN(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetBusinessMemberByGLN, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessMemberByGLN);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetBusinessMemberByGLN));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessMemberByGLN[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetBusinessMemberByGLN));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetBusinessMemberByGLN*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetBusinessMemberByGLN(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetBusinessMemberByGLN %p -> %p\n", q, p));
	*(struct __ns9__GetBusinessMemberByGLN*)p = *(struct __ns9__GetBusinessMemberByGLN*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetRussianEnterpriseChangesList(struct soap *soap, struct __ns9__GetRussianEnterpriseChangesList *a)
{
	a->ns8__getRussianEnterpriseChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetRussianEnterpriseChangesList(struct soap *soap, const struct __ns9__GetRussianEnterpriseChangesList *a)
{
	soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, &a->ns8__getRussianEnterpriseChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetRussianEnterpriseChangesList(struct soap *soap, const char *tag, int id, const struct __ns9__GetRussianEnterpriseChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, "ns8:getRussianEnterpriseChangesListRequest", -1, &a->ns8__getRussianEnterpriseChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetRussianEnterpriseChangesList * FASTCALL soap_in___ns9__GetRussianEnterpriseChangesList(struct soap *soap, const char *tag, struct __ns9__GetRussianEnterpriseChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getRussianEnterpriseChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetRussianEnterpriseChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetRussianEnterpriseChangesList, sizeof(struct __ns9__GetRussianEnterpriseChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetRussianEnterpriseChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getRussianEnterpriseChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, "ns8:getRussianEnterpriseChangesListRequest", &a->ns8__getRussianEnterpriseChangesListRequest, ""))
				{	soap_flag_ns8__getRussianEnterpriseChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetRussianEnterpriseChangesList(struct soap *soap, const struct __ns9__GetRussianEnterpriseChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetRussianEnterpriseChangesList(soap, tag?tag:"-ns9:GetRussianEnterpriseChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetRussianEnterpriseChangesList * SOAP_FMAC4 soap_get___ns9__GetRussianEnterpriseChangesList(struct soap *soap, struct __ns9__GetRussianEnterpriseChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetRussianEnterpriseChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetRussianEnterpriseChangesList * FASTCALL soap_instantiate___ns9__GetRussianEnterpriseChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetRussianEnterpriseChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetRussianEnterpriseChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetRussianEnterpriseChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetRussianEnterpriseChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetRussianEnterpriseChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetRussianEnterpriseChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetRussianEnterpriseChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetRussianEnterpriseChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetRussianEnterpriseChangesList %p -> %p\n", q, p));
	*(struct __ns9__GetRussianEnterpriseChangesList*)p = *(struct __ns9__GetRussianEnterpriseChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetForeignEnterpriseChangesList(struct soap *soap, struct __ns9__GetForeignEnterpriseChangesList *a)
{
	a->ns8__getForeignEnterpriseChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetForeignEnterpriseChangesList(struct soap *soap, const struct __ns9__GetForeignEnterpriseChangesList *a)
{
	soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, &a->ns8__getForeignEnterpriseChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetForeignEnterpriseChangesList(struct soap *soap, const char *tag, int id, const struct __ns9__GetForeignEnterpriseChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, "ns8:getForeignEnterpriseChangesListRequest", -1, &a->ns8__getForeignEnterpriseChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetForeignEnterpriseChangesList * FASTCALL soap_in___ns9__GetForeignEnterpriseChangesList(struct soap *soap, const char *tag, struct __ns9__GetForeignEnterpriseChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getForeignEnterpriseChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetForeignEnterpriseChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetForeignEnterpriseChangesList, sizeof(struct __ns9__GetForeignEnterpriseChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetForeignEnterpriseChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getForeignEnterpriseChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, "ns8:getForeignEnterpriseChangesListRequest", &a->ns8__getForeignEnterpriseChangesListRequest, ""))
				{	soap_flag_ns8__getForeignEnterpriseChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetForeignEnterpriseChangesList(struct soap *soap, const struct __ns9__GetForeignEnterpriseChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetForeignEnterpriseChangesList(soap, tag?tag:"-ns9:GetForeignEnterpriseChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetForeignEnterpriseChangesList * SOAP_FMAC4 soap_get___ns9__GetForeignEnterpriseChangesList(struct soap *soap, struct __ns9__GetForeignEnterpriseChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetForeignEnterpriseChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetForeignEnterpriseChangesList * FASTCALL soap_instantiate___ns9__GetForeignEnterpriseChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetForeignEnterpriseChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetForeignEnterpriseChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetForeignEnterpriseChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetForeignEnterpriseChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetForeignEnterpriseChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetForeignEnterpriseChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetForeignEnterpriseChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetForeignEnterpriseChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetForeignEnterpriseChangesList %p -> %p\n", q, p));
	*(struct __ns9__GetForeignEnterpriseChangesList*)p = *(struct __ns9__GetForeignEnterpriseChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetRussianEnterpriseList(struct soap *soap, struct __ns9__GetRussianEnterpriseList *a)
{
	a->ns8__getRussianEnterpriseListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetRussianEnterpriseList(struct soap *soap, const struct __ns9__GetRussianEnterpriseList *a)
{
	soap_serialize_PointerTo_ns8__getRussianEnterpriseListRequest(soap, &a->ns8__getRussianEnterpriseListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetRussianEnterpriseList(struct soap *soap, const char *tag, int id, const struct __ns9__GetRussianEnterpriseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(soap, "ns8:getRussianEnterpriseListRequest", -1, &a->ns8__getRussianEnterpriseListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetRussianEnterpriseList * FASTCALL soap_in___ns9__GetRussianEnterpriseList(struct soap *soap, const char *tag, struct __ns9__GetRussianEnterpriseList *a, const char *type)
{
	size_t soap_flag_ns8__getRussianEnterpriseListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetRussianEnterpriseList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetRussianEnterpriseList, sizeof(struct __ns9__GetRussianEnterpriseList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetRussianEnterpriseList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getRussianEnterpriseListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(soap, "ns8:getRussianEnterpriseListRequest", &a->ns8__getRussianEnterpriseListRequest, ""))
				{	soap_flag_ns8__getRussianEnterpriseListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetRussianEnterpriseList(struct soap *soap, const struct __ns9__GetRussianEnterpriseList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetRussianEnterpriseList(soap, tag?tag:"-ns9:GetRussianEnterpriseList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetRussianEnterpriseList * SOAP_FMAC4 soap_get___ns9__GetRussianEnterpriseList(struct soap *soap, struct __ns9__GetRussianEnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetRussianEnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetRussianEnterpriseList * FASTCALL soap_instantiate___ns9__GetRussianEnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetRussianEnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetRussianEnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetRussianEnterpriseList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetRussianEnterpriseList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetRussianEnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetRussianEnterpriseList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetRussianEnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetRussianEnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetRussianEnterpriseList %p -> %p\n", q, p));
	*(struct __ns9__GetRussianEnterpriseList*)p = *(struct __ns9__GetRussianEnterpriseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetForeignEnterpriseList(struct soap *soap, struct __ns9__GetForeignEnterpriseList *a)
{
	a->ns8__getForeignEnterpriseListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetForeignEnterpriseList(struct soap *soap, const struct __ns9__GetForeignEnterpriseList *a)
{
	soap_serialize_PointerTo_ns8__getForeignEnterpriseListRequest(soap, &a->ns8__getForeignEnterpriseListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetForeignEnterpriseList(struct soap *soap, const char *tag, int id, const struct __ns9__GetForeignEnterpriseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(soap, "ns8:getForeignEnterpriseListRequest", -1, &a->ns8__getForeignEnterpriseListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetForeignEnterpriseList * FASTCALL soap_in___ns9__GetForeignEnterpriseList(struct soap *soap, const char *tag, struct __ns9__GetForeignEnterpriseList *a, const char *type)
{
	size_t soap_flag_ns8__getForeignEnterpriseListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetForeignEnterpriseList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetForeignEnterpriseList, sizeof(struct __ns9__GetForeignEnterpriseList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetForeignEnterpriseList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getForeignEnterpriseListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(soap, "ns8:getForeignEnterpriseListRequest", &a->ns8__getForeignEnterpriseListRequest, ""))
				{	soap_flag_ns8__getForeignEnterpriseListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetForeignEnterpriseList(struct soap *soap, const struct __ns9__GetForeignEnterpriseList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetForeignEnterpriseList(soap, tag?tag:"-ns9:GetForeignEnterpriseList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetForeignEnterpriseList * SOAP_FMAC4 soap_get___ns9__GetForeignEnterpriseList(struct soap *soap, struct __ns9__GetForeignEnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetForeignEnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetForeignEnterpriseList * FASTCALL soap_instantiate___ns9__GetForeignEnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetForeignEnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetForeignEnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetForeignEnterpriseList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetForeignEnterpriseList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetForeignEnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetForeignEnterpriseList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetForeignEnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetForeignEnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetForeignEnterpriseList %p -> %p\n", q, p));
	*(struct __ns9__GetForeignEnterpriseList*)p = *(struct __ns9__GetForeignEnterpriseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetEnterpriseByUuid(struct soap *soap, struct __ns9__GetEnterpriseByUuid *a)
{
	a->ns8__getEnterpriseByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetEnterpriseByUuid(struct soap *soap, const struct __ns9__GetEnterpriseByUuid *a)
{
	soap_serialize_PointerTo_ns8__getEnterpriseByUuidRequest(soap, &a->ns8__getEnterpriseByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetEnterpriseByUuid(struct soap *soap, const char *tag, int id, const struct __ns9__GetEnterpriseByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(soap, "ns8:getEnterpriseByUuidRequest", -1, &a->ns8__getEnterpriseByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetEnterpriseByUuid * FASTCALL soap_in___ns9__GetEnterpriseByUuid(struct soap *soap, const char *tag, struct __ns9__GetEnterpriseByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getEnterpriseByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetEnterpriseByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetEnterpriseByUuid, sizeof(struct __ns9__GetEnterpriseByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetEnterpriseByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getEnterpriseByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(soap, "ns8:getEnterpriseByUuidRequest", &a->ns8__getEnterpriseByUuidRequest, ""))
				{	soap_flag_ns8__getEnterpriseByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetEnterpriseByUuid(struct soap *soap, const struct __ns9__GetEnterpriseByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetEnterpriseByUuid(soap, tag?tag:"-ns9:GetEnterpriseByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetEnterpriseByUuid * SOAP_FMAC4 soap_get___ns9__GetEnterpriseByUuid(struct soap *soap, struct __ns9__GetEnterpriseByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetEnterpriseByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetEnterpriseByUuid * FASTCALL soap_instantiate___ns9__GetEnterpriseByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetEnterpriseByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetEnterpriseByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetEnterpriseByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetEnterpriseByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetEnterpriseByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetEnterpriseByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetEnterpriseByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetEnterpriseByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetEnterpriseByUuid %p -> %p\n", q, p));
	*(struct __ns9__GetEnterpriseByUuid*)p = *(struct __ns9__GetEnterpriseByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetEnterpriseByGuid(struct soap *soap, struct __ns9__GetEnterpriseByGuid *a)
{
	a->ns8__getEnterpriseByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetEnterpriseByGuid(struct soap *soap, const struct __ns9__GetEnterpriseByGuid *a)
{
	soap_serialize_PointerTo_ns8__getEnterpriseByGuidRequest(soap, &a->ns8__getEnterpriseByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetEnterpriseByGuid(struct soap *soap, const char *tag, int id, const struct __ns9__GetEnterpriseByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(soap, "ns8:getEnterpriseByGuidRequest", -1, &a->ns8__getEnterpriseByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetEnterpriseByGuid * FASTCALL soap_in___ns9__GetEnterpriseByGuid(struct soap *soap, const char *tag, struct __ns9__GetEnterpriseByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getEnterpriseByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetEnterpriseByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetEnterpriseByGuid, sizeof(struct __ns9__GetEnterpriseByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetEnterpriseByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getEnterpriseByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(soap, "ns8:getEnterpriseByGuidRequest", &a->ns8__getEnterpriseByGuidRequest, ""))
				{	soap_flag_ns8__getEnterpriseByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetEnterpriseByGuid(struct soap *soap, const struct __ns9__GetEnterpriseByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetEnterpriseByGuid(soap, tag?tag:"-ns9:GetEnterpriseByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetEnterpriseByGuid * SOAP_FMAC4 soap_get___ns9__GetEnterpriseByGuid(struct soap *soap, struct __ns9__GetEnterpriseByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetEnterpriseByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetEnterpriseByGuid * FASTCALL soap_instantiate___ns9__GetEnterpriseByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetEnterpriseByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetEnterpriseByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetEnterpriseByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetEnterpriseByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetEnterpriseByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetEnterpriseByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetEnterpriseByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetEnterpriseByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetEnterpriseByGuid %p -> %p\n", q, p));
	*(struct __ns9__GetEnterpriseByGuid*)p = *(struct __ns9__GetEnterpriseByGuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetBusinessEntityChangesList(struct soap *soap, struct __ns9__GetBusinessEntityChangesList *a)
{
	a->ns8__getBusinessEntityChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetBusinessEntityChangesList(struct soap *soap, const struct __ns9__GetBusinessEntityChangesList *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, &a->ns8__getBusinessEntityChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetBusinessEntityChangesList(struct soap *soap, const char *tag, int id, const struct __ns9__GetBusinessEntityChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, "ns8:getBusinessEntityChangesListRequest", -1, &a->ns8__getBusinessEntityChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityChangesList * FASTCALL soap_in___ns9__GetBusinessEntityChangesList(struct soap *soap, const char *tag, struct __ns9__GetBusinessEntityChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetBusinessEntityChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetBusinessEntityChangesList, sizeof(struct __ns9__GetBusinessEntityChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetBusinessEntityChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, "ns8:getBusinessEntityChangesListRequest", &a->ns8__getBusinessEntityChangesListRequest, ""))
				{	soap_flag_ns8__getBusinessEntityChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetBusinessEntityChangesList(struct soap *soap, const struct __ns9__GetBusinessEntityChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetBusinessEntityChangesList(soap, tag?tag:"-ns9:GetBusinessEntityChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityChangesList * SOAP_FMAC4 soap_get___ns9__GetBusinessEntityChangesList(struct soap *soap, struct __ns9__GetBusinessEntityChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetBusinessEntityChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetBusinessEntityChangesList * FASTCALL soap_instantiate___ns9__GetBusinessEntityChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetBusinessEntityChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetBusinessEntityChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetBusinessEntityChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetBusinessEntityChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetBusinessEntityChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetBusinessEntityChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetBusinessEntityChangesList %p -> %p\n", q, p));
	*(struct __ns9__GetBusinessEntityChangesList*)p = *(struct __ns9__GetBusinessEntityChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetBusinessEntityList(struct soap *soap, struct __ns9__GetBusinessEntityList *a)
{
	a->ns8__getBusinessEntityListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetBusinessEntityList(struct soap *soap, const struct __ns9__GetBusinessEntityList *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityListRequest(soap, &a->ns8__getBusinessEntityListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetBusinessEntityList(struct soap *soap, const char *tag, int id, const struct __ns9__GetBusinessEntityList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityListRequest(soap, "ns8:getBusinessEntityListRequest", -1, &a->ns8__getBusinessEntityListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityList * FASTCALL soap_in___ns9__GetBusinessEntityList(struct soap *soap, const char *tag, struct __ns9__GetBusinessEntityList *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityListRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetBusinessEntityList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetBusinessEntityList, sizeof(struct __ns9__GetBusinessEntityList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetBusinessEntityList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityListRequest(soap, "ns8:getBusinessEntityListRequest", &a->ns8__getBusinessEntityListRequest, ""))
				{	soap_flag_ns8__getBusinessEntityListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetBusinessEntityList(struct soap *soap, const struct __ns9__GetBusinessEntityList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetBusinessEntityList(soap, tag?tag:"-ns9:GetBusinessEntityList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityList * SOAP_FMAC4 soap_get___ns9__GetBusinessEntityList(struct soap *soap, struct __ns9__GetBusinessEntityList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetBusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetBusinessEntityList * FASTCALL soap_instantiate___ns9__GetBusinessEntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetBusinessEntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetBusinessEntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityList);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetBusinessEntityList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetBusinessEntityList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetBusinessEntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetBusinessEntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetBusinessEntityList %p -> %p\n", q, p));
	*(struct __ns9__GetBusinessEntityList*)p = *(struct __ns9__GetBusinessEntityList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetBusinessEntityByUuid(struct soap *soap, struct __ns9__GetBusinessEntityByUuid *a)
{
	a->ns8__getBusinessEntityByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetBusinessEntityByUuid(struct soap *soap, const struct __ns9__GetBusinessEntityByUuid *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, &a->ns8__getBusinessEntityByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetBusinessEntityByUuid(struct soap *soap, const char *tag, int id, const struct __ns9__GetBusinessEntityByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, "ns8:getBusinessEntityByUuidRequest", -1, &a->ns8__getBusinessEntityByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityByUuid * FASTCALL soap_in___ns9__GetBusinessEntityByUuid(struct soap *soap, const char *tag, struct __ns9__GetBusinessEntityByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetBusinessEntityByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetBusinessEntityByUuid, sizeof(struct __ns9__GetBusinessEntityByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetBusinessEntityByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, "ns8:getBusinessEntityByUuidRequest", &a->ns8__getBusinessEntityByUuidRequest, ""))
				{	soap_flag_ns8__getBusinessEntityByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetBusinessEntityByUuid(struct soap *soap, const struct __ns9__GetBusinessEntityByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetBusinessEntityByUuid(soap, tag?tag:"-ns9:GetBusinessEntityByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityByUuid * SOAP_FMAC4 soap_get___ns9__GetBusinessEntityByUuid(struct soap *soap, struct __ns9__GetBusinessEntityByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetBusinessEntityByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetBusinessEntityByUuid * FASTCALL soap_instantiate___ns9__GetBusinessEntityByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetBusinessEntityByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetBusinessEntityByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetBusinessEntityByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetBusinessEntityByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetBusinessEntityByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetBusinessEntityByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetBusinessEntityByUuid %p -> %p\n", q, p));
	*(struct __ns9__GetBusinessEntityByUuid*)p = *(struct __ns9__GetBusinessEntityByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns9__GetBusinessEntityByGuid(struct soap *soap, struct __ns9__GetBusinessEntityByGuid *a)
{
	a->ns8__getBusinessEntityByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns9__GetBusinessEntityByGuid(struct soap *soap, const struct __ns9__GetBusinessEntityByGuid *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, &a->ns8__getBusinessEntityByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns9__GetBusinessEntityByGuid(struct soap *soap, const char *tag, int id, const struct __ns9__GetBusinessEntityByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, "ns8:getBusinessEntityByGuidRequest", -1, &a->ns8__getBusinessEntityByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityByGuid * FASTCALL soap_in___ns9__GetBusinessEntityByGuid(struct soap *soap, const char *tag, struct __ns9__GetBusinessEntityByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns9__GetBusinessEntityByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns9__GetBusinessEntityByGuid, sizeof(struct __ns9__GetBusinessEntityByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns9__GetBusinessEntityByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, "ns8:getBusinessEntityByGuidRequest", &a->ns8__getBusinessEntityByGuidRequest, ""))
				{	soap_flag_ns8__getBusinessEntityByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns9__GetBusinessEntityByGuid(struct soap *soap, const struct __ns9__GetBusinessEntityByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns9__GetBusinessEntityByGuid(soap, tag?tag:"-ns9:GetBusinessEntityByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns9__GetBusinessEntityByGuid * SOAP_FMAC4 soap_get___ns9__GetBusinessEntityByGuid(struct soap *soap, struct __ns9__GetBusinessEntityByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns9__GetBusinessEntityByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns9__GetBusinessEntityByGuid * FASTCALL soap_instantiate___ns9__GetBusinessEntityByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns9__GetBusinessEntityByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns9__GetBusinessEntityByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns9__GetBusinessEntityByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns9__GetBusinessEntityByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns9__GetBusinessEntityByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns9__GetBusinessEntityByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns9__GetBusinessEntityByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns9__GetBusinessEntityByGuid %p -> %p\n", q, p));
	*(struct __ns9__GetBusinessEntityByGuid*)p = *(struct __ns9__GetBusinessEntityByGuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, struct __ns11__getAppliedUserAuthorityListRequest *a)
{
	a->ns5__getAppliedUserAuthorityListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, const struct __ns11__getAppliedUserAuthorityListRequest *a)
{
	soap_serialize_PointerTons5__GetAppliedUserAuthorityListRequest(soap, &a->ns5__getAppliedUserAuthorityListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getAppliedUserAuthorityListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetAppliedUserAuthorityListRequest(soap, "ns5:getAppliedUserAuthorityListRequest", -1, &a->ns5__getAppliedUserAuthorityListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getAppliedUserAuthorityListRequest * FASTCALL soap_in___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, struct __ns11__getAppliedUserAuthorityListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getAppliedUserAuthorityListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getAppliedUserAuthorityListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getAppliedUserAuthorityListRequest, sizeof(struct __ns11__getAppliedUserAuthorityListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getAppliedUserAuthorityListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getAppliedUserAuthorityListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetAppliedUserAuthorityListRequest(soap, "ns5:getAppliedUserAuthorityListRequest", &a->ns5__getAppliedUserAuthorityListRequest, "ns5:GetAppliedUserAuthorityListRequest"))
				{	soap_flag_ns5__getAppliedUserAuthorityListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, const struct __ns11__getAppliedUserAuthorityListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getAppliedUserAuthorityListRequest(soap, tag?tag:"-ns11:getAppliedUserAuthorityListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getAppliedUserAuthorityListRequest * SOAP_FMAC4 soap_get___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, struct __ns11__getAppliedUserAuthorityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getAppliedUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getAppliedUserAuthorityListRequest * FASTCALL soap_instantiate___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getAppliedUserAuthorityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getAppliedUserAuthorityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getAppliedUserAuthorityListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getAppliedUserAuthorityListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getAppliedUserAuthorityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getAppliedUserAuthorityListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getAppliedUserAuthorityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getAppliedUserAuthorityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getAppliedUserAuthorityListRequest %p -> %p\n", q, p));
	*(struct __ns11__getAppliedUserAuthorityListRequest*)p = *(struct __ns11__getAppliedUserAuthorityListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__unbindBusinessEntityUserRequest(struct soap *soap, struct __ns11__unbindBusinessEntityUserRequest *a)
{
	a->ns5__unbindBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__unbindBusinessEntityUserRequest(struct soap *soap, const struct __ns11__unbindBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTons5__UnbindBusinessEntityUserRequest(soap, &a->ns5__unbindBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__unbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __ns11__unbindBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__UnbindBusinessEntityUserRequest(soap, "ns5:unbindBusinessEntityUserRequest", -1, &a->ns5__unbindBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__unbindBusinessEntityUserRequest * FASTCALL soap_in___ns11__unbindBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __ns11__unbindBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_ns5__unbindBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __ns11__unbindBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__unbindBusinessEntityUserRequest, sizeof(struct __ns11__unbindBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__unbindBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__unbindBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__UnbindBusinessEntityUserRequest(soap, "ns5:unbindBusinessEntityUserRequest", &a->ns5__unbindBusinessEntityUserRequest, "ns5:UnbindBusinessEntityUserRequest"))
				{	soap_flag_ns5__unbindBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__unbindBusinessEntityUserRequest(struct soap *soap, const struct __ns11__unbindBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__unbindBusinessEntityUserRequest(soap, tag?tag:"-ns11:unbindBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__unbindBusinessEntityUserRequest * SOAP_FMAC4 soap_get___ns11__unbindBusinessEntityUserRequest(struct soap *soap, struct __ns11__unbindBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__unbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__unbindBusinessEntityUserRequest * FASTCALL soap_instantiate___ns11__unbindBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__unbindBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__unbindBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__unbindBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__unbindBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__unbindBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__unbindBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__unbindBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__unbindBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__unbindBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __ns11__unbindBusinessEntityUserRequest*)p = *(struct __ns11__unbindBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__updateUserWorkingAreasRequest(struct soap *soap, struct __ns11__updateUserWorkingAreasRequest *a)
{
	a->ns5__updateUserWorkingAreasRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__updateUserWorkingAreasRequest(struct soap *soap, const struct __ns11__updateUserWorkingAreasRequest *a)
{
	soap_serialize_PointerTons5__UpdateUserWorkingAreasRequest(soap, &a->ns5__updateUserWorkingAreasRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__updateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, const struct __ns11__updateUserWorkingAreasRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__UpdateUserWorkingAreasRequest(soap, "ns5:updateUserWorkingAreasRequest", -1, &a->ns5__updateUserWorkingAreasRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateUserWorkingAreasRequest * FASTCALL soap_in___ns11__updateUserWorkingAreasRequest(struct soap *soap, const char *tag, struct __ns11__updateUserWorkingAreasRequest *a, const char *type)
{
	size_t soap_flag_ns5__updateUserWorkingAreasRequest = 1;
	short soap_flag;
	a = (struct __ns11__updateUserWorkingAreasRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__updateUserWorkingAreasRequest, sizeof(struct __ns11__updateUserWorkingAreasRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__updateUserWorkingAreasRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__updateUserWorkingAreasRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__UpdateUserWorkingAreasRequest(soap, "ns5:updateUserWorkingAreasRequest", &a->ns5__updateUserWorkingAreasRequest, "ns5:UpdateUserWorkingAreasRequest"))
				{	soap_flag_ns5__updateUserWorkingAreasRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__updateUserWorkingAreasRequest(struct soap *soap, const struct __ns11__updateUserWorkingAreasRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__updateUserWorkingAreasRequest(soap, tag?tag:"-ns11:updateUserWorkingAreasRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateUserWorkingAreasRequest * SOAP_FMAC4 soap_get___ns11__updateUserWorkingAreasRequest(struct soap *soap, struct __ns11__updateUserWorkingAreasRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__updateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__updateUserWorkingAreasRequest * FASTCALL soap_instantiate___ns11__updateUserWorkingAreasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__updateUserWorkingAreasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__updateUserWorkingAreasRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateUserWorkingAreasRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__updateUserWorkingAreasRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateUserWorkingAreasRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__updateUserWorkingAreasRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__updateUserWorkingAreasRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__updateUserWorkingAreasRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__updateUserWorkingAreasRequest %p -> %p\n", q, p));
	*(struct __ns11__updateUserWorkingAreasRequest*)p = *(struct __ns11__updateUserWorkingAreasRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__updateUserAuthoritiesRequest(struct soap *soap, struct __ns11__updateUserAuthoritiesRequest *a)
{
	a->ns5__updateUserAuthoritiesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__updateUserAuthoritiesRequest(struct soap *soap, const struct __ns11__updateUserAuthoritiesRequest *a)
{
	soap_serialize_PointerTons5__UpdateUserAuthoritiesRequest(soap, &a->ns5__updateUserAuthoritiesRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__updateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, const struct __ns11__updateUserAuthoritiesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__UpdateUserAuthoritiesRequest(soap, "ns5:updateUserAuthoritiesRequest", -1, &a->ns5__updateUserAuthoritiesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateUserAuthoritiesRequest * FASTCALL soap_in___ns11__updateUserAuthoritiesRequest(struct soap *soap, const char *tag, struct __ns11__updateUserAuthoritiesRequest *a, const char *type)
{
	size_t soap_flag_ns5__updateUserAuthoritiesRequest = 1;
	short soap_flag;
	a = (struct __ns11__updateUserAuthoritiesRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__updateUserAuthoritiesRequest, sizeof(struct __ns11__updateUserAuthoritiesRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__updateUserAuthoritiesRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__updateUserAuthoritiesRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__UpdateUserAuthoritiesRequest(soap, "ns5:updateUserAuthoritiesRequest", &a->ns5__updateUserAuthoritiesRequest, "ns5:UpdateUserAuthoritiesRequest"))
				{	soap_flag_ns5__updateUserAuthoritiesRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__updateUserAuthoritiesRequest(struct soap *soap, const struct __ns11__updateUserAuthoritiesRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__updateUserAuthoritiesRequest(soap, tag?tag:"-ns11:updateUserAuthoritiesRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateUserAuthoritiesRequest * SOAP_FMAC4 soap_get___ns11__updateUserAuthoritiesRequest(struct soap *soap, struct __ns11__updateUserAuthoritiesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__updateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__updateUserAuthoritiesRequest * FASTCALL soap_instantiate___ns11__updateUserAuthoritiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__updateUserAuthoritiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__updateUserAuthoritiesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateUserAuthoritiesRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__updateUserAuthoritiesRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateUserAuthoritiesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__updateUserAuthoritiesRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__updateUserAuthoritiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__updateUserAuthoritiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__updateUserAuthoritiesRequest %p -> %p\n", q, p));
	*(struct __ns11__updateUserAuthoritiesRequest*)p = *(struct __ns11__updateUserAuthoritiesRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getBusinessEntityUserRequest(struct soap *soap, struct __ns11__getBusinessEntityUserRequest *a)
{
	a->ns5__getBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getBusinessEntityUserRequest(struct soap *soap, const struct __ns11__getBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTons5__GetBusinessEntityUserRequest(soap, &a->ns5__getBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetBusinessEntityUserRequest(soap, "ns5:getBusinessEntityUserRequest", -1, &a->ns5__getBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getBusinessEntityUserRequest * FASTCALL soap_in___ns11__getBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __ns11__getBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_ns5__getBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __ns11__getBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getBusinessEntityUserRequest, sizeof(struct __ns11__getBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetBusinessEntityUserRequest(soap, "ns5:getBusinessEntityUserRequest", &a->ns5__getBusinessEntityUserRequest, "ns5:GetBusinessEntityUserRequest"))
				{	soap_flag_ns5__getBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getBusinessEntityUserRequest(struct soap *soap, const struct __ns11__getBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getBusinessEntityUserRequest(soap, tag?tag:"-ns11:getBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getBusinessEntityUserRequest * SOAP_FMAC4 soap_get___ns11__getBusinessEntityUserRequest(struct soap *soap, struct __ns11__getBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getBusinessEntityUserRequest * FASTCALL soap_instantiate___ns11__getBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __ns11__getBusinessEntityUserRequest*)p = *(struct __ns11__getBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getBusinessEntityUserListRequest(struct soap *soap, struct __ns11__getBusinessEntityUserListRequest *a)
{
	a->ns5__getBusinessEntityUserListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getBusinessEntityUserListRequest(struct soap *soap, const struct __ns11__getBusinessEntityUserListRequest *a)
{
	soap_serialize_PointerTons5__GetBusinessEntityUserListRequest(soap, &a->ns5__getBusinessEntityUserListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getBusinessEntityUserListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetBusinessEntityUserListRequest(soap, "ns5:getBusinessEntityUserListRequest", -1, &a->ns5__getBusinessEntityUserListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getBusinessEntityUserListRequest * FASTCALL soap_in___ns11__getBusinessEntityUserListRequest(struct soap *soap, const char *tag, struct __ns11__getBusinessEntityUserListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getBusinessEntityUserListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getBusinessEntityUserListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getBusinessEntityUserListRequest, sizeof(struct __ns11__getBusinessEntityUserListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getBusinessEntityUserListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getBusinessEntityUserListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetBusinessEntityUserListRequest(soap, "ns5:getBusinessEntityUserListRequest", &a->ns5__getBusinessEntityUserListRequest, "ns5:GetBusinessEntityUserListRequest"))
				{	soap_flag_ns5__getBusinessEntityUserListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getBusinessEntityUserListRequest(struct soap *soap, const struct __ns11__getBusinessEntityUserListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getBusinessEntityUserListRequest(soap, tag?tag:"-ns11:getBusinessEntityUserListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getBusinessEntityUserListRequest * SOAP_FMAC4 soap_get___ns11__getBusinessEntityUserListRequest(struct soap *soap, struct __ns11__getBusinessEntityUserListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getBusinessEntityUserListRequest * FASTCALL soap_instantiate___ns11__getBusinessEntityUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getBusinessEntityUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getBusinessEntityUserListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getBusinessEntityUserListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getBusinessEntityUserListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getBusinessEntityUserListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getBusinessEntityUserListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getBusinessEntityUserListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getBusinessEntityUserListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getBusinessEntityUserListRequest %p -> %p\n", q, p));
	*(struct __ns11__getBusinessEntityUserListRequest*)p = *(struct __ns11__getBusinessEntityUserListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__addBusinessEntityUserRequest(struct soap *soap, struct __ns11__addBusinessEntityUserRequest *a)
{
	a->ns5__addBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__addBusinessEntityUserRequest(struct soap *soap, const struct __ns11__addBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTons5__AddBusinessEntityUserRequest(soap, &a->ns5__addBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__addBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __ns11__addBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__AddBusinessEntityUserRequest(soap, "ns5:addBusinessEntityUserRequest", -1, &a->ns5__addBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__addBusinessEntityUserRequest * FASTCALL soap_in___ns11__addBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __ns11__addBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_ns5__addBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __ns11__addBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__addBusinessEntityUserRequest, sizeof(struct __ns11__addBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__addBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__addBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__AddBusinessEntityUserRequest(soap, "ns5:addBusinessEntityUserRequest", &a->ns5__addBusinessEntityUserRequest, "ns5:AddBusinessEntityUserRequest"))
				{	soap_flag_ns5__addBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__addBusinessEntityUserRequest(struct soap *soap, const struct __ns11__addBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__addBusinessEntityUserRequest(soap, tag?tag:"-ns11:addBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__addBusinessEntityUserRequest * SOAP_FMAC4 soap_get___ns11__addBusinessEntityUserRequest(struct soap *soap, struct __ns11__addBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__addBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__addBusinessEntityUserRequest * FASTCALL soap_instantiate___ns11__addBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__addBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__addBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__addBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__addBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__addBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__addBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__addBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__addBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__addBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __ns11__addBusinessEntityUserRequest*)p = *(struct __ns11__addBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__checkShipmentRegionalizationRequest(struct soap *soap, struct __ns11__checkShipmentRegionalizationRequest *a)
{
	a->ns5__checkShipmentRegionalizationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__checkShipmentRegionalizationRequest(struct soap *soap, const struct __ns11__checkShipmentRegionalizationRequest *a)
{
	soap_serialize_PointerTons5__CheckShipmentRegionalizationRequest(soap, &a->ns5__checkShipmentRegionalizationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__checkShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, const struct __ns11__checkShipmentRegionalizationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__CheckShipmentRegionalizationRequest(soap, "ns5:checkShipmentRegionalizationRequest", -1, &a->ns5__checkShipmentRegionalizationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__checkShipmentRegionalizationRequest * FASTCALL soap_in___ns11__checkShipmentRegionalizationRequest(struct soap *soap, const char *tag, struct __ns11__checkShipmentRegionalizationRequest *a, const char *type)
{
	size_t soap_flag_ns5__checkShipmentRegionalizationRequest = 1;
	short soap_flag;
	a = (struct __ns11__checkShipmentRegionalizationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__checkShipmentRegionalizationRequest, sizeof(struct __ns11__checkShipmentRegionalizationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__checkShipmentRegionalizationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__checkShipmentRegionalizationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__CheckShipmentRegionalizationRequest(soap, "ns5:checkShipmentRegionalizationRequest", &a->ns5__checkShipmentRegionalizationRequest, "ns5:CheckShipmentRegionalizationRequest"))
				{	soap_flag_ns5__checkShipmentRegionalizationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__checkShipmentRegionalizationRequest(struct soap *soap, const struct __ns11__checkShipmentRegionalizationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__checkShipmentRegionalizationRequest(soap, tag?tag:"-ns11:checkShipmentRegionalizationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__checkShipmentRegionalizationRequest * SOAP_FMAC4 soap_get___ns11__checkShipmentRegionalizationRequest(struct soap *soap, struct __ns11__checkShipmentRegionalizationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__checkShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__checkShipmentRegionalizationRequest * FASTCALL soap_instantiate___ns11__checkShipmentRegionalizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__checkShipmentRegionalizationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__checkShipmentRegionalizationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__checkShipmentRegionalizationRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__checkShipmentRegionalizationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__checkShipmentRegionalizationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__checkShipmentRegionalizationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__checkShipmentRegionalizationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__checkShipmentRegionalizationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__checkShipmentRegionalizationRequest %p -> %p\n", q, p));
	*(struct __ns11__checkShipmentRegionalizationRequest*)p = *(struct __ns11__checkShipmentRegionalizationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__updateVeterinaryEventsRequest(struct soap *soap, struct __ns11__updateVeterinaryEventsRequest *a)
{
	a->ns5__updateVeterinaryEventsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__updateVeterinaryEventsRequest(struct soap *soap, const struct __ns11__updateVeterinaryEventsRequest *a)
{
	soap_serialize_PointerTons5__UpdateVeterinaryEventsRequest(soap, &a->ns5__updateVeterinaryEventsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__updateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, const struct __ns11__updateVeterinaryEventsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__UpdateVeterinaryEventsRequest(soap, "ns5:updateVeterinaryEventsRequest", -1, &a->ns5__updateVeterinaryEventsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateVeterinaryEventsRequest * FASTCALL soap_in___ns11__updateVeterinaryEventsRequest(struct soap *soap, const char *tag, struct __ns11__updateVeterinaryEventsRequest *a, const char *type)
{
	size_t soap_flag_ns5__updateVeterinaryEventsRequest = 1;
	short soap_flag;
	a = (struct __ns11__updateVeterinaryEventsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__updateVeterinaryEventsRequest, sizeof(struct __ns11__updateVeterinaryEventsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__updateVeterinaryEventsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__updateVeterinaryEventsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__UpdateVeterinaryEventsRequest(soap, "ns5:updateVeterinaryEventsRequest", &a->ns5__updateVeterinaryEventsRequest, "ns5:UpdateVeterinaryEventsRequest"))
				{	soap_flag_ns5__updateVeterinaryEventsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__updateVeterinaryEventsRequest(struct soap *soap, const struct __ns11__updateVeterinaryEventsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__updateVeterinaryEventsRequest(soap, tag?tag:"-ns11:updateVeterinaryEventsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateVeterinaryEventsRequest * SOAP_FMAC4 soap_get___ns11__updateVeterinaryEventsRequest(struct soap *soap, struct __ns11__updateVeterinaryEventsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__updateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__updateVeterinaryEventsRequest * FASTCALL soap_instantiate___ns11__updateVeterinaryEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__updateVeterinaryEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__updateVeterinaryEventsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateVeterinaryEventsRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__updateVeterinaryEventsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateVeterinaryEventsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__updateVeterinaryEventsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__updateVeterinaryEventsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__updateVeterinaryEventsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__updateVeterinaryEventsRequest %p -> %p\n", q, p));
	*(struct __ns11__updateVeterinaryEventsRequest*)p = *(struct __ns11__updateVeterinaryEventsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__updateTransportMovementDetailsRequest(struct soap *soap, struct __ns11__updateTransportMovementDetailsRequest *a)
{
	a->ns5__updateTransportMovementDetailsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__updateTransportMovementDetailsRequest(struct soap *soap, const struct __ns11__updateTransportMovementDetailsRequest *a)
{
	soap_serialize_PointerTons5__UpdateTransportMovementDetailsRequest(soap, &a->ns5__updateTransportMovementDetailsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__updateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, const struct __ns11__updateTransportMovementDetailsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__UpdateTransportMovementDetailsRequest(soap, "ns5:updateTransportMovementDetailsRequest", -1, &a->ns5__updateTransportMovementDetailsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateTransportMovementDetailsRequest * FASTCALL soap_in___ns11__updateTransportMovementDetailsRequest(struct soap *soap, const char *tag, struct __ns11__updateTransportMovementDetailsRequest *a, const char *type)
{
	size_t soap_flag_ns5__updateTransportMovementDetailsRequest = 1;
	short soap_flag;
	a = (struct __ns11__updateTransportMovementDetailsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__updateTransportMovementDetailsRequest, sizeof(struct __ns11__updateTransportMovementDetailsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__updateTransportMovementDetailsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__updateTransportMovementDetailsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__UpdateTransportMovementDetailsRequest(soap, "ns5:updateTransportMovementDetailsRequest", &a->ns5__updateTransportMovementDetailsRequest, "ns5:UpdateTransportMovementDetailsRequest"))
				{	soap_flag_ns5__updateTransportMovementDetailsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__updateTransportMovementDetailsRequest(struct soap *soap, const struct __ns11__updateTransportMovementDetailsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__updateTransportMovementDetailsRequest(soap, tag?tag:"-ns11:updateTransportMovementDetailsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__updateTransportMovementDetailsRequest * SOAP_FMAC4 soap_get___ns11__updateTransportMovementDetailsRequest(struct soap *soap, struct __ns11__updateTransportMovementDetailsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__updateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__updateTransportMovementDetailsRequest * FASTCALL soap_instantiate___ns11__updateTransportMovementDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__updateTransportMovementDetailsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__updateTransportMovementDetailsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateTransportMovementDetailsRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__updateTransportMovementDetailsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__updateTransportMovementDetailsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__updateTransportMovementDetailsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__updateTransportMovementDetailsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__updateTransportMovementDetailsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__updateTransportMovementDetailsRequest %p -> %p\n", q, p));
	*(struct __ns11__updateTransportMovementDetailsRequest*)p = *(struct __ns11__updateTransportMovementDetailsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getStockEntryVersionListRequest(struct soap *soap, struct __ns11__getStockEntryVersionListRequest *a)
{
	a->ns5__getStockEntryVersionListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getStockEntryVersionListRequest(struct soap *soap, const struct __ns11__getStockEntryVersionListRequest *a)
{
	soap_serialize_PointerTons5__GetStockEntryVersionListRequest(soap, &a->ns5__getStockEntryVersionListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getStockEntryVersionListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetStockEntryVersionListRequest(soap, "ns5:getStockEntryVersionListRequest", -1, &a->ns5__getStockEntryVersionListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryVersionListRequest * FASTCALL soap_in___ns11__getStockEntryVersionListRequest(struct soap *soap, const char *tag, struct __ns11__getStockEntryVersionListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getStockEntryVersionListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getStockEntryVersionListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getStockEntryVersionListRequest, sizeof(struct __ns11__getStockEntryVersionListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getStockEntryVersionListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getStockEntryVersionListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetStockEntryVersionListRequest(soap, "ns5:getStockEntryVersionListRequest", &a->ns5__getStockEntryVersionListRequest, "ns5:GetStockEntryVersionListRequest"))
				{	soap_flag_ns5__getStockEntryVersionListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getStockEntryVersionListRequest(struct soap *soap, const struct __ns11__getStockEntryVersionListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getStockEntryVersionListRequest(soap, tag?tag:"-ns11:getStockEntryVersionListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryVersionListRequest * SOAP_FMAC4 soap_get___ns11__getStockEntryVersionListRequest(struct soap *soap, struct __ns11__getStockEntryVersionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getStockEntryVersionListRequest * FASTCALL soap_instantiate___ns11__getStockEntryVersionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getStockEntryVersionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getStockEntryVersionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryVersionListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getStockEntryVersionListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryVersionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getStockEntryVersionListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getStockEntryVersionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getStockEntryVersionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getStockEntryVersionListRequest %p -> %p\n", q, p));
	*(struct __ns11__getStockEntryVersionListRequest*)p = *(struct __ns11__getStockEntryVersionListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getStockEntryChangesListRequest(struct soap *soap, struct __ns11__getStockEntryChangesListRequest *a)
{
	a->ns5__getStockEntryChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getStockEntryChangesListRequest(struct soap *soap, const struct __ns11__getStockEntryChangesListRequest *a)
{
	soap_serialize_PointerTons5__GetStockEntryChangesListRequest(soap, &a->ns5__getStockEntryChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getStockEntryChangesListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetStockEntryChangesListRequest(soap, "ns5:getStockEntryChangesListRequest", -1, &a->ns5__getStockEntryChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryChangesListRequest * FASTCALL soap_in___ns11__getStockEntryChangesListRequest(struct soap *soap, const char *tag, struct __ns11__getStockEntryChangesListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getStockEntryChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getStockEntryChangesListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getStockEntryChangesListRequest, sizeof(struct __ns11__getStockEntryChangesListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getStockEntryChangesListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getStockEntryChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetStockEntryChangesListRequest(soap, "ns5:getStockEntryChangesListRequest", &a->ns5__getStockEntryChangesListRequest, "ns5:GetStockEntryChangesListRequest"))
				{	soap_flag_ns5__getStockEntryChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getStockEntryChangesListRequest(struct soap *soap, const struct __ns11__getStockEntryChangesListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getStockEntryChangesListRequest(soap, tag?tag:"-ns11:getStockEntryChangesListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryChangesListRequest * SOAP_FMAC4 soap_get___ns11__getStockEntryChangesListRequest(struct soap *soap, struct __ns11__getStockEntryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getStockEntryChangesListRequest * FASTCALL soap_instantiate___ns11__getStockEntryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getStockEntryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getStockEntryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryChangesListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getStockEntryChangesListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getStockEntryChangesListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getStockEntryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getStockEntryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getStockEntryChangesListRequest %p -> %p\n", q, p));
	*(struct __ns11__getStockEntryChangesListRequest*)p = *(struct __ns11__getStockEntryChangesListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getStockEntryListRequest(struct soap *soap, struct __ns11__getStockEntryListRequest *a)
{
	a->ns5__getStockEntryListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getStockEntryListRequest(struct soap *soap, const struct __ns11__getStockEntryListRequest *a)
{
	soap_serialize_PointerTons5__GetStockEntryListRequest(soap, &a->ns5__getStockEntryListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getStockEntryListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getStockEntryListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetStockEntryListRequest(soap, "ns5:getStockEntryListRequest", -1, &a->ns5__getStockEntryListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryListRequest * FASTCALL soap_in___ns11__getStockEntryListRequest(struct soap *soap, const char *tag, struct __ns11__getStockEntryListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getStockEntryListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getStockEntryListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getStockEntryListRequest, sizeof(struct __ns11__getStockEntryListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getStockEntryListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getStockEntryListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetStockEntryListRequest(soap, "ns5:getStockEntryListRequest", &a->ns5__getStockEntryListRequest, "ns5:GetStockEntryListRequest"))
				{	soap_flag_ns5__getStockEntryListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getStockEntryListRequest(struct soap *soap, const struct __ns11__getStockEntryListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getStockEntryListRequest(soap, tag?tag:"-ns11:getStockEntryListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryListRequest * SOAP_FMAC4 soap_get___ns11__getStockEntryListRequest(struct soap *soap, struct __ns11__getStockEntryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getStockEntryListRequest * FASTCALL soap_instantiate___ns11__getStockEntryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getStockEntryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getStockEntryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getStockEntryListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getStockEntryListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getStockEntryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getStockEntryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getStockEntryListRequest %p -> %p\n", q, p));
	*(struct __ns11__getStockEntryListRequest*)p = *(struct __ns11__getStockEntryListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getStockEntryByUuidRequest(struct soap *soap, struct __ns11__getStockEntryByUuidRequest *a)
{
	a->ns5__getStockEntryByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getStockEntryByUuidRequest(struct soap *soap, const struct __ns11__getStockEntryByUuidRequest *a)
{
	soap_serialize_PointerTons5__GetStockEntryByUuidRequest(soap, &a->ns5__getStockEntryByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getStockEntryByUuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetStockEntryByUuidRequest(soap, "ns5:getStockEntryByUuidRequest", -1, &a->ns5__getStockEntryByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryByUuidRequest * FASTCALL soap_in___ns11__getStockEntryByUuidRequest(struct soap *soap, const char *tag, struct __ns11__getStockEntryByUuidRequest *a, const char *type)
{
	size_t soap_flag_ns5__getStockEntryByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns11__getStockEntryByUuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getStockEntryByUuidRequest, sizeof(struct __ns11__getStockEntryByUuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getStockEntryByUuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getStockEntryByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetStockEntryByUuidRequest(soap, "ns5:getStockEntryByUuidRequest", &a->ns5__getStockEntryByUuidRequest, "ns5:GetStockEntryByUuidRequest"))
				{	soap_flag_ns5__getStockEntryByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getStockEntryByUuidRequest(struct soap *soap, const struct __ns11__getStockEntryByUuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getStockEntryByUuidRequest(soap, tag?tag:"-ns11:getStockEntryByUuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryByUuidRequest * SOAP_FMAC4 soap_get___ns11__getStockEntryByUuidRequest(struct soap *soap, struct __ns11__getStockEntryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getStockEntryByUuidRequest * FASTCALL soap_instantiate___ns11__getStockEntryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getStockEntryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getStockEntryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryByUuidRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getStockEntryByUuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getStockEntryByUuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getStockEntryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getStockEntryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getStockEntryByUuidRequest %p -> %p\n", q, p));
	*(struct __ns11__getStockEntryByUuidRequest*)p = *(struct __ns11__getStockEntryByUuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getStockEntryByGuidRequest(struct soap *soap, struct __ns11__getStockEntryByGuidRequest *a)
{
	a->ns5__getStockEntryByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getStockEntryByGuidRequest(struct soap *soap, const struct __ns11__getStockEntryByGuidRequest *a)
{
	soap_serialize_PointerTons5__GetStockEntryByGuidRequest(soap, &a->ns5__getStockEntryByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getStockEntryByGuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetStockEntryByGuidRequest(soap, "ns5:getStockEntryByGuidRequest", -1, &a->ns5__getStockEntryByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryByGuidRequest * FASTCALL soap_in___ns11__getStockEntryByGuidRequest(struct soap *soap, const char *tag, struct __ns11__getStockEntryByGuidRequest *a, const char *type)
{
	size_t soap_flag_ns5__getStockEntryByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns11__getStockEntryByGuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getStockEntryByGuidRequest, sizeof(struct __ns11__getStockEntryByGuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getStockEntryByGuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getStockEntryByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetStockEntryByGuidRequest(soap, "ns5:getStockEntryByGuidRequest", &a->ns5__getStockEntryByGuidRequest, "ns5:GetStockEntryByGuidRequest"))
				{	soap_flag_ns5__getStockEntryByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getStockEntryByGuidRequest(struct soap *soap, const struct __ns11__getStockEntryByGuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getStockEntryByGuidRequest(soap, tag?tag:"-ns11:getStockEntryByGuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getStockEntryByGuidRequest * SOAP_FMAC4 soap_get___ns11__getStockEntryByGuidRequest(struct soap *soap, struct __ns11__getStockEntryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getStockEntryByGuidRequest * FASTCALL soap_instantiate___ns11__getStockEntryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getStockEntryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getStockEntryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryByGuidRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getStockEntryByGuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getStockEntryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getStockEntryByGuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getStockEntryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getStockEntryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getStockEntryByGuidRequest %p -> %p\n", q, p));
	*(struct __ns11__getStockEntryByGuidRequest*)p = *(struct __ns11__getStockEntryByGuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getVetDocumentChangesListRequest(struct soap *soap, struct __ns11__getVetDocumentChangesListRequest *a)
{
	a->ns5__getVetDocumentChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getVetDocumentChangesListRequest(struct soap *soap, const struct __ns11__getVetDocumentChangesListRequest *a)
{
	soap_serialize_PointerTons5__GetVetDocumentChangesListRequest(soap, &a->ns5__getVetDocumentChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getVetDocumentChangesListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetVetDocumentChangesListRequest(soap, "ns5:getVetDocumentChangesListRequest", -1, &a->ns5__getVetDocumentChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getVetDocumentChangesListRequest * FASTCALL soap_in___ns11__getVetDocumentChangesListRequest(struct soap *soap, const char *tag, struct __ns11__getVetDocumentChangesListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getVetDocumentChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getVetDocumentChangesListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getVetDocumentChangesListRequest, sizeof(struct __ns11__getVetDocumentChangesListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getVetDocumentChangesListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getVetDocumentChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetVetDocumentChangesListRequest(soap, "ns5:getVetDocumentChangesListRequest", &a->ns5__getVetDocumentChangesListRequest, "ns5:GetVetDocumentChangesListRequest"))
				{	soap_flag_ns5__getVetDocumentChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getVetDocumentChangesListRequest(struct soap *soap, const struct __ns11__getVetDocumentChangesListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getVetDocumentChangesListRequest(soap, tag?tag:"-ns11:getVetDocumentChangesListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getVetDocumentChangesListRequest * SOAP_FMAC4 soap_get___ns11__getVetDocumentChangesListRequest(struct soap *soap, struct __ns11__getVetDocumentChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getVetDocumentChangesListRequest * FASTCALL soap_instantiate___ns11__getVetDocumentChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getVetDocumentChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getVetDocumentChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getVetDocumentChangesListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getVetDocumentChangesListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getVetDocumentChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getVetDocumentChangesListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getVetDocumentChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getVetDocumentChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getVetDocumentChangesListRequest %p -> %p\n", q, p));
	*(struct __ns11__getVetDocumentChangesListRequest*)p = *(struct __ns11__getVetDocumentChangesListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getVetDocumentListRequest(struct soap *soap, struct __ns11__getVetDocumentListRequest *a)
{
	a->ns5__getVetDocumentListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getVetDocumentListRequest(struct soap *soap, const struct __ns11__getVetDocumentListRequest *a)
{
	soap_serialize_PointerTons5__GetVetDocumentListRequest(soap, &a->ns5__getVetDocumentListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getVetDocumentListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getVetDocumentListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetVetDocumentListRequest(soap, "ns5:getVetDocumentListRequest", -1, &a->ns5__getVetDocumentListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getVetDocumentListRequest * FASTCALL soap_in___ns11__getVetDocumentListRequest(struct soap *soap, const char *tag, struct __ns11__getVetDocumentListRequest *a, const char *type)
{
	size_t soap_flag_ns5__getVetDocumentListRequest = 1;
	short soap_flag;
	a = (struct __ns11__getVetDocumentListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getVetDocumentListRequest, sizeof(struct __ns11__getVetDocumentListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getVetDocumentListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getVetDocumentListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetVetDocumentListRequest(soap, "ns5:getVetDocumentListRequest", &a->ns5__getVetDocumentListRequest, "ns5:GetVetDocumentListRequest"))
				{	soap_flag_ns5__getVetDocumentListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getVetDocumentListRequest(struct soap *soap, const struct __ns11__getVetDocumentListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getVetDocumentListRequest(soap, tag?tag:"-ns11:getVetDocumentListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getVetDocumentListRequest * SOAP_FMAC4 soap_get___ns11__getVetDocumentListRequest(struct soap *soap, struct __ns11__getVetDocumentListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getVetDocumentListRequest * FASTCALL soap_instantiate___ns11__getVetDocumentListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getVetDocumentListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getVetDocumentListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getVetDocumentListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getVetDocumentListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getVetDocumentListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getVetDocumentListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getVetDocumentListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getVetDocumentListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getVetDocumentListRequest %p -> %p\n", q, p));
	*(struct __ns11__getVetDocumentListRequest*)p = *(struct __ns11__getVetDocumentListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__getVetDocumentByUuidRequest(struct soap *soap, struct __ns11__getVetDocumentByUuidRequest *a)
{
	a->ns5__getVetDocumentByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__getVetDocumentByUuidRequest(struct soap *soap, const struct __ns11__getVetDocumentByUuidRequest *a)
{
	soap_serialize_PointerTons5__GetVetDocumentByUuidRequest(soap, &a->ns5__getVetDocumentByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__getVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, const struct __ns11__getVetDocumentByUuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__GetVetDocumentByUuidRequest(soap, "ns5:getVetDocumentByUuidRequest", -1, &a->ns5__getVetDocumentByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getVetDocumentByUuidRequest * FASTCALL soap_in___ns11__getVetDocumentByUuidRequest(struct soap *soap, const char *tag, struct __ns11__getVetDocumentByUuidRequest *a, const char *type)
{
	size_t soap_flag_ns5__getVetDocumentByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns11__getVetDocumentByUuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__getVetDocumentByUuidRequest, sizeof(struct __ns11__getVetDocumentByUuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__getVetDocumentByUuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__getVetDocumentByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__GetVetDocumentByUuidRequest(soap, "ns5:getVetDocumentByUuidRequest", &a->ns5__getVetDocumentByUuidRequest, "ns5:GetVetDocumentByUuidRequest"))
				{	soap_flag_ns5__getVetDocumentByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__getVetDocumentByUuidRequest(struct soap *soap, const struct __ns11__getVetDocumentByUuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__getVetDocumentByUuidRequest(soap, tag?tag:"-ns11:getVetDocumentByUuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__getVetDocumentByUuidRequest * SOAP_FMAC4 soap_get___ns11__getVetDocumentByUuidRequest(struct soap *soap, struct __ns11__getVetDocumentByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__getVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__getVetDocumentByUuidRequest * FASTCALL soap_instantiate___ns11__getVetDocumentByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__getVetDocumentByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__getVetDocumentByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getVetDocumentByUuidRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__getVetDocumentByUuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__getVetDocumentByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__getVetDocumentByUuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__getVetDocumentByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__getVetDocumentByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__getVetDocumentByUuidRequest %p -> %p\n", q, p));
	*(struct __ns11__getVetDocumentByUuidRequest*)p = *(struct __ns11__getVetDocumentByUuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__modifyProducerStockListRequest(struct soap *soap, struct __ns11__modifyProducerStockListRequest *a)
{
	a->ns5__modifyProducerStockListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__modifyProducerStockListRequest(struct soap *soap, const struct __ns11__modifyProducerStockListRequest *a)
{
	soap_serialize_PointerTons5__ModifyProducerStockListRequest(soap, &a->ns5__modifyProducerStockListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__modifyProducerStockListRequest(struct soap *soap, const char *tag, int id, const struct __ns11__modifyProducerStockListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__ModifyProducerStockListRequest(soap, "ns5:modifyProducerStockListRequest", -1, &a->ns5__modifyProducerStockListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyProducerStockListRequest * FASTCALL soap_in___ns11__modifyProducerStockListRequest(struct soap *soap, const char *tag, struct __ns11__modifyProducerStockListRequest *a, const char *type)
{
	size_t soap_flag_ns5__modifyProducerStockListRequest = 1;
	short soap_flag;
	a = (struct __ns11__modifyProducerStockListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__modifyProducerStockListRequest, sizeof(struct __ns11__modifyProducerStockListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__modifyProducerStockListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__modifyProducerStockListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__ModifyProducerStockListRequest(soap, "ns5:modifyProducerStockListRequest", &a->ns5__modifyProducerStockListRequest, "ns5:ModifyProducerStockListRequest"))
				{	soap_flag_ns5__modifyProducerStockListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__modifyProducerStockListRequest(struct soap *soap, const struct __ns11__modifyProducerStockListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__modifyProducerStockListRequest(soap, tag?tag:"-ns11:modifyProducerStockListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyProducerStockListRequest * SOAP_FMAC4 soap_get___ns11__modifyProducerStockListRequest(struct soap *soap, struct __ns11__modifyProducerStockListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__modifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__modifyProducerStockListRequest * FASTCALL soap_instantiate___ns11__modifyProducerStockListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__modifyProducerStockListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__modifyProducerStockListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyProducerStockListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__modifyProducerStockListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyProducerStockListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__modifyProducerStockListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__modifyProducerStockListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__modifyProducerStockListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__modifyProducerStockListRequest %p -> %p\n", q, p));
	*(struct __ns11__modifyProducerStockListRequest*)p = *(struct __ns11__modifyProducerStockListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__resolveDiscrepancyRequest(struct soap *soap, struct __ns11__resolveDiscrepancyRequest *a)
{
	a->ns5__resolveDiscrepancyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__resolveDiscrepancyRequest(struct soap *soap, const struct __ns11__resolveDiscrepancyRequest *a)
{
	soap_serialize_PointerTons5__ResolveDiscrepancyRequest(soap, &a->ns5__resolveDiscrepancyRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__resolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, const struct __ns11__resolveDiscrepancyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__ResolveDiscrepancyRequest(soap, "ns5:resolveDiscrepancyRequest", -1, &a->ns5__resolveDiscrepancyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__resolveDiscrepancyRequest * FASTCALL soap_in___ns11__resolveDiscrepancyRequest(struct soap *soap, const char *tag, struct __ns11__resolveDiscrepancyRequest *a, const char *type)
{
	size_t soap_flag_ns5__resolveDiscrepancyRequest = 1;
	short soap_flag;
	a = (struct __ns11__resolveDiscrepancyRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__resolveDiscrepancyRequest, sizeof(struct __ns11__resolveDiscrepancyRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__resolveDiscrepancyRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__resolveDiscrepancyRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__ResolveDiscrepancyRequest(soap, "ns5:resolveDiscrepancyRequest", &a->ns5__resolveDiscrepancyRequest, "ns5:ResolveDiscrepancyRequest"))
				{	soap_flag_ns5__resolveDiscrepancyRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__resolveDiscrepancyRequest(struct soap *soap, const struct __ns11__resolveDiscrepancyRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__resolveDiscrepancyRequest(soap, tag?tag:"-ns11:resolveDiscrepancyRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__resolveDiscrepancyRequest * SOAP_FMAC4 soap_get___ns11__resolveDiscrepancyRequest(struct soap *soap, struct __ns11__resolveDiscrepancyRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__resolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__resolveDiscrepancyRequest * FASTCALL soap_instantiate___ns11__resolveDiscrepancyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__resolveDiscrepancyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__resolveDiscrepancyRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__resolveDiscrepancyRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__resolveDiscrepancyRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__resolveDiscrepancyRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__resolveDiscrepancyRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__resolveDiscrepancyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__resolveDiscrepancyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__resolveDiscrepancyRequest %p -> %p\n", q, p));
	*(struct __ns11__resolveDiscrepancyRequest*)p = *(struct __ns11__resolveDiscrepancyRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__modifyActivityLocationsRequest(struct soap *soap, struct __ns11__modifyActivityLocationsRequest *a)
{
	a->ns5__modifyActivityLocationsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__modifyActivityLocationsRequest(struct soap *soap, const struct __ns11__modifyActivityLocationsRequest *a)
{
	soap_serialize_PointerTons5__ModifyActivityLocationsRequest(soap, &a->ns5__modifyActivityLocationsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__modifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, const struct __ns11__modifyActivityLocationsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__ModifyActivityLocationsRequest(soap, "ns5:modifyActivityLocationsRequest", -1, &a->ns5__modifyActivityLocationsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyActivityLocationsRequest * FASTCALL soap_in___ns11__modifyActivityLocationsRequest(struct soap *soap, const char *tag, struct __ns11__modifyActivityLocationsRequest *a, const char *type)
{
	size_t soap_flag_ns5__modifyActivityLocationsRequest = 1;
	short soap_flag;
	a = (struct __ns11__modifyActivityLocationsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__modifyActivityLocationsRequest, sizeof(struct __ns11__modifyActivityLocationsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__modifyActivityLocationsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__modifyActivityLocationsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__ModifyActivityLocationsRequest(soap, "ns5:modifyActivityLocationsRequest", &a->ns5__modifyActivityLocationsRequest, "ns5:ModifyActivityLocationsRequest"))
				{	soap_flag_ns5__modifyActivityLocationsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__modifyActivityLocationsRequest(struct soap *soap, const struct __ns11__modifyActivityLocationsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__modifyActivityLocationsRequest(soap, tag?tag:"-ns11:modifyActivityLocationsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyActivityLocationsRequest * SOAP_FMAC4 soap_get___ns11__modifyActivityLocationsRequest(struct soap *soap, struct __ns11__modifyActivityLocationsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__modifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__modifyActivityLocationsRequest * FASTCALL soap_instantiate___ns11__modifyActivityLocationsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__modifyActivityLocationsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__modifyActivityLocationsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyActivityLocationsRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__modifyActivityLocationsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyActivityLocationsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__modifyActivityLocationsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__modifyActivityLocationsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__modifyActivityLocationsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__modifyActivityLocationsRequest %p -> %p\n", q, p));
	*(struct __ns11__modifyActivityLocationsRequest*)p = *(struct __ns11__modifyActivityLocationsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__modifyEnterpriseRequest(struct soap *soap, struct __ns11__modifyEnterpriseRequest *a)
{
	a->ns5__modifyEnterpriseRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__modifyEnterpriseRequest(struct soap *soap, const struct __ns11__modifyEnterpriseRequest *a)
{
	soap_serialize_PointerTons5__ModifyEnterpriseRequest(soap, &a->ns5__modifyEnterpriseRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__modifyEnterpriseRequest(struct soap *soap, const char *tag, int id, const struct __ns11__modifyEnterpriseRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__ModifyEnterpriseRequest(soap, "ns5:modifyEnterpriseRequest", -1, &a->ns5__modifyEnterpriseRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyEnterpriseRequest * FASTCALL soap_in___ns11__modifyEnterpriseRequest(struct soap *soap, const char *tag, struct __ns11__modifyEnterpriseRequest *a, const char *type)
{
	size_t soap_flag_ns5__modifyEnterpriseRequest = 1;
	short soap_flag;
	a = (struct __ns11__modifyEnterpriseRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__modifyEnterpriseRequest, sizeof(struct __ns11__modifyEnterpriseRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__modifyEnterpriseRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__modifyEnterpriseRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__ModifyEnterpriseRequest(soap, "ns5:modifyEnterpriseRequest", &a->ns5__modifyEnterpriseRequest, "ns5:ModifyEnterpriseRequest"))
				{	soap_flag_ns5__modifyEnterpriseRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__modifyEnterpriseRequest(struct soap *soap, const struct __ns11__modifyEnterpriseRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__modifyEnterpriseRequest(soap, tag?tag:"-ns11:modifyEnterpriseRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyEnterpriseRequest * SOAP_FMAC4 soap_get___ns11__modifyEnterpriseRequest(struct soap *soap, struct __ns11__modifyEnterpriseRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__modifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__modifyEnterpriseRequest * FASTCALL soap_instantiate___ns11__modifyEnterpriseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__modifyEnterpriseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__modifyEnterpriseRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyEnterpriseRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__modifyEnterpriseRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyEnterpriseRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__modifyEnterpriseRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__modifyEnterpriseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__modifyEnterpriseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__modifyEnterpriseRequest %p -> %p\n", q, p));
	*(struct __ns11__modifyEnterpriseRequest*)p = *(struct __ns11__modifyEnterpriseRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__modifyBusinessEntityRequest(struct soap *soap, struct __ns11__modifyBusinessEntityRequest *a)
{
	a->ns5__modifyBusinessEntityRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__modifyBusinessEntityRequest(struct soap *soap, const struct __ns11__modifyBusinessEntityRequest *a)
{
	soap_serialize_PointerTons5__ModifyBusinessEntityRequest(soap, &a->ns5__modifyBusinessEntityRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__modifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, const struct __ns11__modifyBusinessEntityRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__ModifyBusinessEntityRequest(soap, "ns5:modifyBusinessEntityRequest", -1, &a->ns5__modifyBusinessEntityRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyBusinessEntityRequest * FASTCALL soap_in___ns11__modifyBusinessEntityRequest(struct soap *soap, const char *tag, struct __ns11__modifyBusinessEntityRequest *a, const char *type)
{
	size_t soap_flag_ns5__modifyBusinessEntityRequest = 1;
	short soap_flag;
	a = (struct __ns11__modifyBusinessEntityRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__modifyBusinessEntityRequest, sizeof(struct __ns11__modifyBusinessEntityRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__modifyBusinessEntityRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__modifyBusinessEntityRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__ModifyBusinessEntityRequest(soap, "ns5:modifyBusinessEntityRequest", &a->ns5__modifyBusinessEntityRequest, "ns5:ModifyBusinessEntityRequest"))
				{	soap_flag_ns5__modifyBusinessEntityRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__modifyBusinessEntityRequest(struct soap *soap, const struct __ns11__modifyBusinessEntityRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__modifyBusinessEntityRequest(soap, tag?tag:"-ns11:modifyBusinessEntityRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__modifyBusinessEntityRequest * SOAP_FMAC4 soap_get___ns11__modifyBusinessEntityRequest(struct soap *soap, struct __ns11__modifyBusinessEntityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__modifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__modifyBusinessEntityRequest * FASTCALL soap_instantiate___ns11__modifyBusinessEntityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__modifyBusinessEntityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__modifyBusinessEntityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyBusinessEntityRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__modifyBusinessEntityRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__modifyBusinessEntityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__modifyBusinessEntityRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__modifyBusinessEntityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__modifyBusinessEntityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__modifyBusinessEntityRequest %p -> %p\n", q, p));
	*(struct __ns11__modifyBusinessEntityRequest*)p = *(struct __ns11__modifyBusinessEntityRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__withdrawVetDocumentRequest(struct soap *soap, struct __ns11__withdrawVetDocumentRequest *a)
{
	a->ns5__withdrawVetDocumentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__withdrawVetDocumentRequest(struct soap *soap, const struct __ns11__withdrawVetDocumentRequest *a)
{
	soap_serialize_PointerTons5__WithdrawVetDocumentRequest(soap, &a->ns5__withdrawVetDocumentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__withdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, const struct __ns11__withdrawVetDocumentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__WithdrawVetDocumentRequest(soap, "ns5:withdrawVetDocumentRequest", -1, &a->ns5__withdrawVetDocumentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__withdrawVetDocumentRequest * FASTCALL soap_in___ns11__withdrawVetDocumentRequest(struct soap *soap, const char *tag, struct __ns11__withdrawVetDocumentRequest *a, const char *type)
{
	size_t soap_flag_ns5__withdrawVetDocumentRequest = 1;
	short soap_flag;
	a = (struct __ns11__withdrawVetDocumentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__withdrawVetDocumentRequest, sizeof(struct __ns11__withdrawVetDocumentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__withdrawVetDocumentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__withdrawVetDocumentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__WithdrawVetDocumentRequest(soap, "ns5:withdrawVetDocumentRequest", &a->ns5__withdrawVetDocumentRequest, "ns5:WithdrawVetDocumentRequest"))
				{	soap_flag_ns5__withdrawVetDocumentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__withdrawVetDocumentRequest(struct soap *soap, const struct __ns11__withdrawVetDocumentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__withdrawVetDocumentRequest(soap, tag?tag:"-ns11:withdrawVetDocumentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__withdrawVetDocumentRequest * SOAP_FMAC4 soap_get___ns11__withdrawVetDocumentRequest(struct soap *soap, struct __ns11__withdrawVetDocumentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__withdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__withdrawVetDocumentRequest * FASTCALL soap_instantiate___ns11__withdrawVetDocumentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__withdrawVetDocumentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__withdrawVetDocumentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__withdrawVetDocumentRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__withdrawVetDocumentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__withdrawVetDocumentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__withdrawVetDocumentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__withdrawVetDocumentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__withdrawVetDocumentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__withdrawVetDocumentRequest %p -> %p\n", q, p));
	*(struct __ns11__withdrawVetDocumentRequest*)p = *(struct __ns11__withdrawVetDocumentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__mergeStockEntriesRequest(struct soap *soap, struct __ns11__mergeStockEntriesRequest *a)
{
	a->ns5__mergeStockEntriesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__mergeStockEntriesRequest(struct soap *soap, const struct __ns11__mergeStockEntriesRequest *a)
{
	soap_serialize_PointerTons5__MergeStockEntriesRequest(soap, &a->ns5__mergeStockEntriesRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__mergeStockEntriesRequest(struct soap *soap, const char *tag, int id, const struct __ns11__mergeStockEntriesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__MergeStockEntriesRequest(soap, "ns5:mergeStockEntriesRequest", -1, &a->ns5__mergeStockEntriesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__mergeStockEntriesRequest * FASTCALL soap_in___ns11__mergeStockEntriesRequest(struct soap *soap, const char *tag, struct __ns11__mergeStockEntriesRequest *a, const char *type)
{
	size_t soap_flag_ns5__mergeStockEntriesRequest = 1;
	short soap_flag;
	a = (struct __ns11__mergeStockEntriesRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__mergeStockEntriesRequest, sizeof(struct __ns11__mergeStockEntriesRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__mergeStockEntriesRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__mergeStockEntriesRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__MergeStockEntriesRequest(soap, "ns5:mergeStockEntriesRequest", &a->ns5__mergeStockEntriesRequest, "ns5:MergeStockEntriesRequest"))
				{	soap_flag_ns5__mergeStockEntriesRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__mergeStockEntriesRequest(struct soap *soap, const struct __ns11__mergeStockEntriesRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__mergeStockEntriesRequest(soap, tag?tag:"-ns11:mergeStockEntriesRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__mergeStockEntriesRequest * SOAP_FMAC4 soap_get___ns11__mergeStockEntriesRequest(struct soap *soap, struct __ns11__mergeStockEntriesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__mergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__mergeStockEntriesRequest * FASTCALL soap_instantiate___ns11__mergeStockEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__mergeStockEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__mergeStockEntriesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__mergeStockEntriesRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__mergeStockEntriesRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__mergeStockEntriesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__mergeStockEntriesRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__mergeStockEntriesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__mergeStockEntriesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__mergeStockEntriesRequest %p -> %p\n", q, p));
	*(struct __ns11__mergeStockEntriesRequest*)p = *(struct __ns11__mergeStockEntriesRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__registerProductionOperationRequest(struct soap *soap, struct __ns11__registerProductionOperationRequest *a)
{
	a->ns5__registerProductionOperationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__registerProductionOperationRequest(struct soap *soap, const struct __ns11__registerProductionOperationRequest *a)
{
	soap_serialize_PointerTons5__RegisterProductionOperationRequest(soap, &a->ns5__registerProductionOperationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__registerProductionOperationRequest(struct soap *soap, const char *tag, int id, const struct __ns11__registerProductionOperationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__RegisterProductionOperationRequest(soap, "ns5:registerProductionOperationRequest", -1, &a->ns5__registerProductionOperationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__registerProductionOperationRequest * FASTCALL soap_in___ns11__registerProductionOperationRequest(struct soap *soap, const char *tag, struct __ns11__registerProductionOperationRequest *a, const char *type)
{
	size_t soap_flag_ns5__registerProductionOperationRequest = 1;
	short soap_flag;
	a = (struct __ns11__registerProductionOperationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__registerProductionOperationRequest, sizeof(struct __ns11__registerProductionOperationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__registerProductionOperationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__registerProductionOperationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__RegisterProductionOperationRequest(soap, "ns5:registerProductionOperationRequest", &a->ns5__registerProductionOperationRequest, "ns5:RegisterProductionOperationRequest"))
				{	soap_flag_ns5__registerProductionOperationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__registerProductionOperationRequest(struct soap *soap, const struct __ns11__registerProductionOperationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__registerProductionOperationRequest(soap, tag?tag:"-ns11:registerProductionOperationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__registerProductionOperationRequest * SOAP_FMAC4 soap_get___ns11__registerProductionOperationRequest(struct soap *soap, struct __ns11__registerProductionOperationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__registerProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__registerProductionOperationRequest * FASTCALL soap_instantiate___ns11__registerProductionOperationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__registerProductionOperationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__registerProductionOperationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__registerProductionOperationRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__registerProductionOperationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__registerProductionOperationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__registerProductionOperationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__registerProductionOperationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__registerProductionOperationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__registerProductionOperationRequest %p -> %p\n", q, p));
	*(struct __ns11__registerProductionOperationRequest*)p = *(struct __ns11__registerProductionOperationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, struct __ns11__prepareOutgoingConsignmentRequest *a)
{
	a->ns5__prepareOutgoingConsignmentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, const struct __ns11__prepareOutgoingConsignmentRequest *a)
{
	soap_serialize_PointerTons5__PrepareOutgoingConsignmentRequest(soap, &a->ns5__prepareOutgoingConsignmentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, const struct __ns11__prepareOutgoingConsignmentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__PrepareOutgoingConsignmentRequest(soap, "ns5:prepareOutgoingConsignmentRequest", -1, &a->ns5__prepareOutgoingConsignmentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__prepareOutgoingConsignmentRequest * FASTCALL soap_in___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, struct __ns11__prepareOutgoingConsignmentRequest *a, const char *type)
{
	size_t soap_flag_ns5__prepareOutgoingConsignmentRequest = 1;
	short soap_flag;
	a = (struct __ns11__prepareOutgoingConsignmentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__prepareOutgoingConsignmentRequest, sizeof(struct __ns11__prepareOutgoingConsignmentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__prepareOutgoingConsignmentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__prepareOutgoingConsignmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__PrepareOutgoingConsignmentRequest(soap, "ns5:prepareOutgoingConsignmentRequest", &a->ns5__prepareOutgoingConsignmentRequest, "ns5:PrepareOutgoingConsignmentRequest"))
				{	soap_flag_ns5__prepareOutgoingConsignmentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, const struct __ns11__prepareOutgoingConsignmentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__prepareOutgoingConsignmentRequest(soap, tag?tag:"-ns11:prepareOutgoingConsignmentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__prepareOutgoingConsignmentRequest * SOAP_FMAC4 soap_get___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, struct __ns11__prepareOutgoingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__prepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__prepareOutgoingConsignmentRequest * FASTCALL soap_instantiate___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__prepareOutgoingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__prepareOutgoingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__prepareOutgoingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__prepareOutgoingConsignmentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__prepareOutgoingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__prepareOutgoingConsignmentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__prepareOutgoingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__prepareOutgoingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__prepareOutgoingConsignmentRequest %p -> %p\n", q, p));
	*(struct __ns11__prepareOutgoingConsignmentRequest*)p = *(struct __ns11__prepareOutgoingConsignmentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns11__processIncomingConsignmentRequest(struct soap *soap, struct __ns11__processIncomingConsignmentRequest *a)
{
	a->ns5__processIncomingConsignmentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns11__processIncomingConsignmentRequest(struct soap *soap, const struct __ns11__processIncomingConsignmentRequest *a)
{
	soap_serialize_PointerTons5__ProcessIncomingConsignmentRequest(soap, &a->ns5__processIncomingConsignmentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns11__processIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, const struct __ns11__processIncomingConsignmentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTons5__ProcessIncomingConsignmentRequest(soap, "ns5:processIncomingConsignmentRequest", -1, &a->ns5__processIncomingConsignmentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns11__processIncomingConsignmentRequest * FASTCALL soap_in___ns11__processIncomingConsignmentRequest(struct soap *soap, const char *tag, struct __ns11__processIncomingConsignmentRequest *a, const char *type)
{
	size_t soap_flag_ns5__processIncomingConsignmentRequest = 1;
	short soap_flag;
	a = (struct __ns11__processIncomingConsignmentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns11__processIncomingConsignmentRequest, sizeof(struct __ns11__processIncomingConsignmentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns11__processIncomingConsignmentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns5__processIncomingConsignmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons5__ProcessIncomingConsignmentRequest(soap, "ns5:processIncomingConsignmentRequest", &a->ns5__processIncomingConsignmentRequest, "ns5:ProcessIncomingConsignmentRequest"))
				{	soap_flag_ns5__processIncomingConsignmentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns11__processIncomingConsignmentRequest(struct soap *soap, const struct __ns11__processIncomingConsignmentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns11__processIncomingConsignmentRequest(soap, tag?tag:"-ns11:processIncomingConsignmentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns11__processIncomingConsignmentRequest * SOAP_FMAC4 soap_get___ns11__processIncomingConsignmentRequest(struct soap *soap, struct __ns11__processIncomingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns11__processIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns11__processIncomingConsignmentRequest * FASTCALL soap_instantiate___ns11__processIncomingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns11__processIncomingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns11__processIncomingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__processIncomingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(struct __ns11__processIncomingConsignmentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns11__processIncomingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns11__processIncomingConsignmentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns11__processIncomingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns11__processIncomingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns11__processIncomingConsignmentRequest %p -> %p\n", q, p));
	*(struct __ns11__processIncomingConsignmentRequest*)p = *(struct __ns11__processIncomingConsignmentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns10__receiveApplicationResult(struct soap *soap, struct __ns10__receiveApplicationResult *a)
{
	a->ns1__receiveApplicationResultRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns10__receiveApplicationResult(struct soap *soap, const struct __ns10__receiveApplicationResult *a)
{
	soap_serialize_PointerTo_ns1__receiveApplicationResultRequest(soap, &a->ns1__receiveApplicationResultRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns10__receiveApplicationResult(struct soap *soap, const char *tag, int id, const struct __ns10__receiveApplicationResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns1__receiveApplicationResultRequest(soap, "ns1:receiveApplicationResultRequest", -1, &a->ns1__receiveApplicationResultRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__receiveApplicationResult * FASTCALL soap_in___ns10__receiveApplicationResult(struct soap *soap, const char *tag, struct __ns10__receiveApplicationResult *a, const char *type)
{
	size_t soap_flag_ns1__receiveApplicationResultRequest = 1;
	short soap_flag;
	a = (struct __ns10__receiveApplicationResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns10__receiveApplicationResult, sizeof(struct __ns10__receiveApplicationResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns10__receiveApplicationResult(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns1__receiveApplicationResultRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns1__receiveApplicationResultRequest(soap, "ns1:receiveApplicationResultRequest", &a->ns1__receiveApplicationResultRequest, ""))
				{	soap_flag_ns1__receiveApplicationResultRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns10__receiveApplicationResult(struct soap *soap, const struct __ns10__receiveApplicationResult *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns10__receiveApplicationResult(soap, tag?tag:"-ns10:receiveApplicationResult", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns10__receiveApplicationResult * SOAP_FMAC4 soap_get___ns10__receiveApplicationResult(struct soap *soap, struct __ns10__receiveApplicationResult *p, const char *tag, const char *type)
{
	if((p = soap_in___ns10__receiveApplicationResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns10__receiveApplicationResult * FASTCALL soap_instantiate___ns10__receiveApplicationResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns10__receiveApplicationResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns10__receiveApplicationResult, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns10__receiveApplicationResult);
		ASSIGN_PTR(size, sizeof(struct __ns10__receiveApplicationResult));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns10__receiveApplicationResult[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns10__receiveApplicationResult));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns10__receiveApplicationResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns10__receiveApplicationResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns10__receiveApplicationResult %p -> %p\n", q, p));
	*(struct __ns10__receiveApplicationResult*)p = *(struct __ns10__receiveApplicationResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns10__submitApplicationRequest(struct soap *soap, struct __ns10__submitApplicationRequest *a)
{
	a->ns1__submitApplicationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns10__submitApplicationRequest(struct soap *soap, const struct __ns10__submitApplicationRequest *a)
{
	soap_serialize_PointerTo_ns1__submitApplicationRequest(soap, &a->ns1__submitApplicationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns10__submitApplicationRequest(struct soap *soap, const char *tag, int id, const struct __ns10__submitApplicationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns1__submitApplicationRequest(soap, "ns1:submitApplicationRequest", -1, &a->ns1__submitApplicationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns10__submitApplicationRequest * FASTCALL soap_in___ns10__submitApplicationRequest(struct soap *soap, const char *tag, struct __ns10__submitApplicationRequest *a, const char *type)
{
	size_t soap_flag_ns1__submitApplicationRequest = 1;
	short soap_flag;
	a = (struct __ns10__submitApplicationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns10__submitApplicationRequest, sizeof(struct __ns10__submitApplicationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns10__submitApplicationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns1__submitApplicationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns1__submitApplicationRequest(soap, "ns1:submitApplicationRequest", &a->ns1__submitApplicationRequest, ""))
				{	soap_flag_ns1__submitApplicationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns10__submitApplicationRequest(struct soap *soap, const struct __ns10__submitApplicationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns10__submitApplicationRequest(soap, tag?tag:"-ns10:submitApplicationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns10__submitApplicationRequest * SOAP_FMAC4 soap_get___ns10__submitApplicationRequest(struct soap *soap, struct __ns10__submitApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns10__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns10__submitApplicationRequest * FASTCALL soap_instantiate___ns10__submitApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns10__submitApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns10__submitApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns10__submitApplicationRequest);
		ASSIGN_PTR(size, sizeof(struct __ns10__submitApplicationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns10__submitApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns10__submitApplicationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns10__submitApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns10__submitApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns10__submitApplicationRequest %p -> %p\n", q, p));
	*(struct __ns10__submitApplicationRequest*)p = *(struct __ns10__submitApplicationRequest*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	a->__any = NULL;
	a->ns2__accessDeniedFault = NULL;
	a->ns2__entityNotFoundFault = NULL;
	a->ns2__incorrectRequestFault = NULL;
	a->ns2__internalServiceFault = NULL;
	a->ns1__unknownServiceIdFault = NULL;
	a->ns1__unsupportedApplicationDataTypeFault = NULL;
	a->ns2__offsetOutOfRangeFault = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns2__accessDeniedFault);
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns2__entityNotFoundFault);
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns2__incorrectRequestFault);
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns2__internalServiceFault);
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns1__unknownServiceIdFault);
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns1__unsupportedApplicationDataTypeFault);
	soap_serialize_PointerTons3__FaultInfo(soap, &a->ns2__offsetOutOfRangeFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if(soap_out_PointerTons3__FaultInfo(soap, "ns2:accessDeniedFault", -1, &a->ns2__accessDeniedFault, ""))
		return soap->error;
	if(soap_out_PointerTons3__FaultInfo(soap, "ns2:entityNotFoundFault", -1, &a->ns2__entityNotFoundFault, ""))
		return soap->error;
	if(soap_out_PointerTons3__FaultInfo(soap, "ns2:incorrectRequestFault", -1, &a->ns2__incorrectRequestFault, ""))
		return soap->error;
	if(soap_out_PointerTons3__FaultInfo(soap, "ns2:internalServiceFault", -1, &a->ns2__internalServiceFault, ""))
		return soap->error;
	if(soap_out_PointerTons3__FaultInfo(soap, "ns1:unknownServiceIdFault", -1, &a->ns1__unknownServiceIdFault, ""))
		return soap->error;
	if(soap_out_PointerTons3__FaultInfo(soap, "ns1:unsupportedApplicationDataTypeFault", -1, &a->ns1__unsupportedApplicationDataTypeFault, ""))
		return soap->error;
	if(soap_out_PointerTons3__FaultInfo(soap, "ns2:offsetOutOfRangeFault", -1, &a->ns2__offsetOutOfRangeFault, ""))
		return soap->error;
	if(soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * FASTCALL soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns2__accessDeniedFault = 1;
	size_t soap_flag_ns2__entityNotFoundFault = 1;
	size_t soap_flag_ns2__incorrectRequestFault = 1;
	size_t soap_flag_ns2__internalServiceFault = 1;
	size_t soap_flag_ns1__unknownServiceIdFault = 1;
	size_t soap_flag_ns1__unsupportedApplicationDataTypeFault = 1;
	size_t soap_flag_ns2__offsetOutOfRangeFault = 1;
	size_t soap_flag_fault = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns2__accessDeniedFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns2:accessDeniedFault", &a->ns2__accessDeniedFault, "ns3:FaultInfo"))
				{	soap_flag_ns2__accessDeniedFault--;
					continue;
				}
			if(soap_flag_ns2__entityNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns2:entityNotFoundFault", &a->ns2__entityNotFoundFault, "ns3:FaultInfo"))
				{	soap_flag_ns2__entityNotFoundFault--;
					continue;
				}
			if(soap_flag_ns2__incorrectRequestFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns2:incorrectRequestFault", &a->ns2__incorrectRequestFault, "ns3:FaultInfo"))
				{	soap_flag_ns2__incorrectRequestFault--;
					continue;
				}
			if(soap_flag_ns2__internalServiceFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns2:internalServiceFault", &a->ns2__internalServiceFault, "ns3:FaultInfo"))
				{	soap_flag_ns2__internalServiceFault--;
					continue;
				}
			if(soap_flag_ns1__unknownServiceIdFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns1:unknownServiceIdFault", &a->ns1__unknownServiceIdFault, "ns3:FaultInfo"))
				{	soap_flag_ns1__unknownServiceIdFault--;
					continue;
				}
			if(soap_flag_ns1__unsupportedApplicationDataTypeFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns1:unsupportedApplicationDataTypeFault", &a->ns1__unsupportedApplicationDataTypeFault, "ns3:FaultInfo"))
				{	soap_flag_ns1__unsupportedApplicationDataTypeFault--;
					continue;
				}
			if(soap_flag_ns2__offsetOutOfRangeFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTons3__FaultInfo(soap, "ns2:offsetOutOfRangeFault", &a->ns2__offsetOutOfRangeFault, "ns3:FaultInfo"))
				{	soap_flag_ns2__offsetOutOfRangeFault--;
					continue;
				}
			if(soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if(soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	return soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * FASTCALL soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Detail));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Detail));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_VetDocument(struct soap *soap, int choice, const union _ns7__union_VetDocument *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_VetDocument_certifiedBatch:
		soap_serialize_PointerTons7__CertifiedBatch(soap, &a->certifiedBatch);
		break;
	case SOAP_UNION__ns7__union_VetDocument_certifiedConsignment:
		soap_serialize_PointerTons7__CertifiedConsignment(soap, &a->certifiedConsignment);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__union_VetDocument(struct soap *soap, int choice, const union _ns7__union_VetDocument *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_VetDocument_certifiedBatch:
		return soap_out_PointerTons7__CertifiedBatch(soap, "ns7:certifiedBatch", -1, &a->certifiedBatch, "");
	case SOAP_UNION__ns7__union_VetDocument_certifiedConsignment:
		return soap_out_PointerTons7__CertifiedConsignment(soap, "ns7:certifiedConsignment", -1, &a->certifiedConsignment, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_VetDocument * FASTCALL soap_in__ns7__union_VetDocument(struct soap *soap, int *choice, union _ns7__union_VetDocument *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->certifiedBatch = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__CertifiedBatch(soap, "ns7:certifiedBatch", &a->certifiedBatch, "ns7:CertifiedBatch"))
	{	*choice = SOAP_UNION__ns7__union_VetDocument_certifiedBatch;
		return a;
	}
	a->certifiedConsignment = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__CertifiedConsignment(soap, "ns7:certifiedConsignment", &a->certifiedConsignment, "ns7:CertifiedConsignment"))
	{	*choice = SOAP_UNION__ns7__union_VetDocument_certifiedConsignment;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_User(struct soap *soap, int choice, const union _ns7__union_User *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_User_organization:
		soap_serialize_PointerTons6__Organization(soap, &a->organization);
		break;
	case SOAP_UNION__ns7__union_User_businessEntity:
		soap_serialize_PointerTons6__BusinessEntity(soap, &a->businessEntity);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__union_User(struct soap *soap, int choice, const union _ns7__union_User *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_User_organization:
		return soap_out_PointerTons6__Organization(soap, "ns7:organization", -1, &a->organization, "");
	case SOAP_UNION__ns7__union_User_businessEntity:
		return soap_out_PointerTons6__BusinessEntity(soap, "ns7:businessEntity", -1, &a->businessEntity, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_User * FASTCALL soap_in__ns7__union_User(struct soap *soap, int *choice, union _ns7__union_User *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->organization = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Organization(soap, "ns7:organization", &a->organization, "ns6:Organization"))
	{	*choice = SOAP_UNION__ns7__union_User_organization;
		return a;
	}
	a->businessEntity = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__BusinessEntity(soap, "ns7:businessEntity", &a->businessEntity, "ns6:BusinessEntity"))
	{	*choice = SOAP_UNION__ns7__union_User_businessEntity;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_LaboratoryResearchEvent_(struct soap *soap, int choice, const union _ns7__union_LaboratoryResearchEvent_ *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_LaboratoryResearchEvent__indicator:
		soap_serialize_PointerTons6__Indicator(soap, &a->indicator);
		break;
	case SOAP_UNION__ns7__union_LaboratoryResearchEvent__disease:
		soap_serialize_PointerTons6__AnimalDisease(soap, &a->disease);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__union_LaboratoryResearchEvent_(struct soap *soap, int choice, const union _ns7__union_LaboratoryResearchEvent_ *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_LaboratoryResearchEvent__indicator:
		return soap_out_PointerTons6__Indicator(soap, "ns7:indicator", -1, &a->indicator, "");
	case SOAP_UNION__ns7__union_LaboratoryResearchEvent__disease:
		return soap_out_PointerTons6__AnimalDisease(soap, "ns7:disease", -1, &a->disease, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_LaboratoryResearchEvent_ * FASTCALL soap_in__ns7__union_LaboratoryResearchEvent_(struct soap *soap, int *choice, union _ns7__union_LaboratoryResearchEvent_ *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->indicator = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Indicator(soap, "ns7:indicator", &a->indicator, "ns6:Indicator"))
	{	*choice = SOAP_UNION__ns7__union_LaboratoryResearchEvent__indicator;
		return a;
	}
	a->disease = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__AnimalDisease(soap, "ns7:disease", &a->disease, "ns6:AnimalDisease"))
	{	*choice = SOAP_UNION__ns7__union_LaboratoryResearchEvent__disease;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_ShipmentRoutePoint(struct soap *soap, int choice, const union _ns7__union_ShipmentRoutePoint *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_ShipmentRoutePoint_location:
		soap_serialize_PointerTons6__Location(soap, &a->location);
		break;
	case SOAP_UNION__ns7__union_ShipmentRoutePoint_enterprise:
		soap_serialize_PointerTons6__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__union_ShipmentRoutePoint(struct soap *soap, int choice, const union _ns7__union_ShipmentRoutePoint *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_ShipmentRoutePoint_location:
		return soap_out_PointerTons6__Location(soap, "ns7:location", -1, &a->location, "");
	case SOAP_UNION__ns7__union_ShipmentRoutePoint_enterprise:
		return soap_out_PointerTons6__Enterprise(soap, "ns7:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_ShipmentRoutePoint * FASTCALL soap_in__ns7__union_ShipmentRoutePoint(struct soap *soap, int *choice, union _ns7__union_ShipmentRoutePoint *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->location = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Location(soap, "ns7:location", &a->location, "ns6:Location"))
	{	*choice = SOAP_UNION__ns7__union_ShipmentRoutePoint_location;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Enterprise(soap, "ns7:enterprise", &a->enterprise, "ns6:Enterprise"))
	{	*choice = SOAP_UNION__ns7__union_ShipmentRoutePoint_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_WorkingArea(struct soap *soap, int choice, const union _ns7__union_WorkingArea *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_WorkingArea_area:
		soap_serialize_PointerTons6__Area(soap, &a->area);
		break;
	case SOAP_UNION__ns7__union_WorkingArea_enterprise:
		soap_serialize_PointerTons6__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__union_WorkingArea(struct soap *soap, int choice, const union _ns7__union_WorkingArea *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_WorkingArea_area:
		return soap_out_PointerTons6__Area(soap, "ns7:area", -1, &a->area, "");
	case SOAP_UNION__ns7__union_WorkingArea_enterprise:
		return soap_out_PointerTons6__Enterprise(soap, "ns7:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_WorkingArea * FASTCALL soap_in__ns7__union_WorkingArea(struct soap *soap, int *choice, union _ns7__union_WorkingArea *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->area = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Area(soap, "ns7:area", &a->area, "ns6:Area"))
	{	*choice = SOAP_UNION__ns7__union_WorkingArea_area;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Enterprise(soap, "ns7:enterprise", &a->enterprise, "ns6:Enterprise"))
	{	*choice = SOAP_UNION__ns7__union_WorkingArea_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_VeterinaryEvent(struct soap *soap, int choice, const union _ns7__union_VeterinaryEvent *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_VeterinaryEvent_location:
		soap_serialize_PointerTons6__Location(soap, &a->location);
		break;
	case SOAP_UNION__ns7__union_VeterinaryEvent_enterprise:
		soap_serialize_PointerTons6__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__ns7__union_VeterinaryEvent(struct soap *soap, int choice, const union _ns7__union_VeterinaryEvent *a)
{
	switch(choice) {
	
	case SOAP_UNION__ns7__union_VeterinaryEvent_location:
		return soap_out_PointerTons6__Location(soap, "ns7:location", -1, &a->location, "");
	case SOAP_UNION__ns7__union_VeterinaryEvent_enterprise:
		return soap_out_PointerTons6__Enterprise(soap, "ns7:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_VeterinaryEvent * FASTCALL soap_in__ns7__union_VeterinaryEvent(struct soap *soap, int *choice, union _ns7__union_VeterinaryEvent *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->location = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Location(soap, "ns7:location", &a->location, "ns6:Location"))
	{	*choice = SOAP_UNION__ns7__union_VeterinaryEvent_location;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__Enterprise(soap, "ns7:enterprise", &a->enterprise, "ns6:Enterprise"))
	{	*choice = SOAP_UNION__ns7__union_VeterinaryEvent_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** FASTCALL soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	return soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** FASTCALL soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	return soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** FASTCALL soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	return soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getActivityLocationListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, int id, _ns8__getActivityLocationListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getActivityLocationListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse ** FASTCALL soap_in_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, _ns8__getActivityLocationListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getActivityLocationListResponse **)soap_malloc(soap, sizeof(_ns8__getActivityLocationListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getActivityLocationListResponse *)soap_instantiate__ns8__getActivityLocationListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getActivityLocationListResponse ** p = (_ns8__getActivityLocationListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getActivityLocationListResponse, sizeof(_ns8__getActivityLocationListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse);
	return soap_out_PointerTo_ns8__getActivityLocationListResponse(soap, tag?tag:"ns8:getActivityLocationListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getActivityLocationListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getActivityLocationListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, int id, _ns8__getActivityLocationListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getActivityLocationListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest ** FASTCALL soap_in_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, _ns8__getActivityLocationListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getActivityLocationListRequest **)soap_malloc(soap, sizeof(_ns8__getActivityLocationListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getActivityLocationListRequest *)soap_instantiate__ns8__getActivityLocationListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getActivityLocationListRequest ** p = (_ns8__getActivityLocationListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getActivityLocationListRequest, sizeof(_ns8__getActivityLocationListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest);
	return soap_out_PointerTo_ns8__getActivityLocationListRequest(soap, tag?tag:"ns8:getActivityLocationListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getActivityLocationListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessMemberByGLNResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessMemberByGLNResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessMemberByGLNResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessMemberByGLNResponse *)soap_instantiate__ns8__getBusinessMemberByGLNResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessMemberByGLNResponse ** p = (_ns8__getBusinessMemberByGLNResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, sizeof(_ns8__getBusinessMemberByGLNResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse);
	return soap_out_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, tag?tag:"ns8:getBusinessMemberByGLNResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessMemberByGLNRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessMemberByGLNRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessMemberByGLNRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessMemberByGLNRequest *)soap_instantiate__ns8__getBusinessMemberByGLNRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessMemberByGLNRequest ** p = (_ns8__getBusinessMemberByGLNRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, sizeof(_ns8__getBusinessMemberByGLNRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest);
	return soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, tag?tag:"ns8:getBusinessMemberByGLNRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseChangesListResponse *)soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseChangesListResponse ** p = (_ns8__getRussianEnterpriseChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, sizeof(_ns8__getRussianEnterpriseChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse);
	return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, tag?tag:"ns8:getRussianEnterpriseChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseChangesListRequest *)soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseChangesListRequest ** p = (_ns8__getRussianEnterpriseChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, sizeof(_ns8__getRussianEnterpriseChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest);
	return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, tag?tag:"ns8:getRussianEnterpriseChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseChangesListResponse *)soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseChangesListResponse ** p = (_ns8__getForeignEnterpriseChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, sizeof(_ns8__getForeignEnterpriseChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse);
	return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, tag?tag:"ns8:getForeignEnterpriseChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseChangesListRequest *)soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseChangesListRequest ** p = (_ns8__getForeignEnterpriseChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, sizeof(_ns8__getForeignEnterpriseChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest);
	return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, tag?tag:"ns8:getForeignEnterpriseChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseListResponse **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseListResponse *)soap_instantiate__ns8__getRussianEnterpriseListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseListResponse ** p = (_ns8__getRussianEnterpriseListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, sizeof(_ns8__getRussianEnterpriseListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse);
	return soap_out_PointerTo_ns8__getRussianEnterpriseListResponse(soap, tag?tag:"ns8:getRussianEnterpriseListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseListRequest **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseListRequest *)soap_instantiate__ns8__getRussianEnterpriseListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseListRequest ** p = (_ns8__getRussianEnterpriseListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, sizeof(_ns8__getRussianEnterpriseListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest);
	return soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(soap, tag?tag:"ns8:getRussianEnterpriseListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseListResponse **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseListResponse *)soap_instantiate__ns8__getForeignEnterpriseListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseListResponse ** p = (_ns8__getForeignEnterpriseListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, sizeof(_ns8__getForeignEnterpriseListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse);
	return soap_out_PointerTo_ns8__getForeignEnterpriseListResponse(soap, tag?tag:"ns8:getForeignEnterpriseListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseListRequest **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseListRequest *)soap_instantiate__ns8__getForeignEnterpriseListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseListRequest ** p = (_ns8__getForeignEnterpriseListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, sizeof(_ns8__getForeignEnterpriseListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest);
	return soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(soap, tag?tag:"ns8:getForeignEnterpriseListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByUuidResponse *)soap_instantiate__ns8__getEnterpriseByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByUuidResponse ** p = (_ns8__getEnterpriseByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, sizeof(_ns8__getEnterpriseByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse);
	return soap_out_PointerTo_ns8__getEnterpriseByUuidResponse(soap, tag?tag:"ns8:getEnterpriseByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByUuidRequest *)soap_instantiate__ns8__getEnterpriseByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByUuidRequest ** p = (_ns8__getEnterpriseByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, sizeof(_ns8__getEnterpriseByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest);
	return soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(soap, tag?tag:"ns8:getEnterpriseByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByGuidResponse *)soap_instantiate__ns8__getEnterpriseByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByGuidResponse ** p = (_ns8__getEnterpriseByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, sizeof(_ns8__getEnterpriseByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse);
	return soap_out_PointerTo_ns8__getEnterpriseByGuidResponse(soap, tag?tag:"ns8:getEnterpriseByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByGuidRequest *)soap_instantiate__ns8__getEnterpriseByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByGuidRequest ** p = (_ns8__getEnterpriseByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, sizeof(_ns8__getEnterpriseByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest);
	return soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(soap, tag?tag:"ns8:getEnterpriseByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityChangesListResponse *)soap_instantiate__ns8__getBusinessEntityChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityChangesListResponse ** p = (_ns8__getBusinessEntityChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, sizeof(_ns8__getBusinessEntityChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, tag?tag:"ns8:getBusinessEntityChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityChangesListRequest *)soap_instantiate__ns8__getBusinessEntityChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityChangesListRequest ** p = (_ns8__getBusinessEntityChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, sizeof(_ns8__getBusinessEntityChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, tag?tag:"ns8:getBusinessEntityChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityListResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityListResponse *)soap_instantiate__ns8__getBusinessEntityListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityListResponse ** p = (_ns8__getBusinessEntityListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityListResponse, sizeof(_ns8__getBusinessEntityListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityListResponse(soap, tag?tag:"ns8:getBusinessEntityListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityListRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityListRequest *)soap_instantiate__ns8__getBusinessEntityListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityListRequest ** p = (_ns8__getBusinessEntityListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityListRequest, sizeof(_ns8__getBusinessEntityListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityListRequest(soap, tag?tag:"ns8:getBusinessEntityListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByUuidResponse *)soap_instantiate__ns8__getBusinessEntityByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByUuidResponse ** p = (_ns8__getBusinessEntityByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, sizeof(_ns8__getBusinessEntityByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, tag?tag:"ns8:getBusinessEntityByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByUuidRequest *)soap_instantiate__ns8__getBusinessEntityByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByUuidRequest ** p = (_ns8__getBusinessEntityByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, sizeof(_ns8__getBusinessEntityByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, tag?tag:"ns8:getBusinessEntityByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByGuidResponse *)soap_instantiate__ns8__getBusinessEntityByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByGuidResponse ** p = (_ns8__getBusinessEntityByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, sizeof(_ns8__getBusinessEntityByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, tag?tag:"ns8:getBusinessEntityByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByGuidRequest *)soap_instantiate__ns8__getBusinessEntityByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByGuidRequest ** p = (_ns8__getBusinessEntityByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, sizeof(_ns8__getBusinessEntityByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, tag?tag:"ns8:getBusinessEntityByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetAppliedUserAuthorityListResponse(struct soap *soap, ns5__GetAppliedUserAuthorityListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, int id, ns5__GetAppliedUserAuthorityListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListResponse ** FASTCALL soap_in_PointerTons5__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, ns5__GetAppliedUserAuthorityListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetAppliedUserAuthorityListResponse **)soap_malloc(soap, sizeof(ns5__GetAppliedUserAuthorityListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetAppliedUserAuthorityListResponse *)soap_instantiate_ns5__GetAppliedUserAuthorityListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetAppliedUserAuthorityListResponse ** p = (ns5__GetAppliedUserAuthorityListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListResponse, sizeof(ns5__GetAppliedUserAuthorityListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetAppliedUserAuthorityListResponse(struct soap *soap, ns5__GetAppliedUserAuthorityListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListResponse);
	return soap_out_PointerTons5__GetAppliedUserAuthorityListResponse(soap, tag?tag:"ns5:GetAppliedUserAuthorityListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetAppliedUserAuthorityListResponse(struct soap *soap, ns5__GetAppliedUserAuthorityListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetAppliedUserAuthorityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetAppliedUserAuthorityListRequest(struct soap *soap, ns5__GetAppliedUserAuthorityListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, int id, ns5__GetAppliedUserAuthorityListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListRequest ** FASTCALL soap_in_PointerTons5__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, ns5__GetAppliedUserAuthorityListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetAppliedUserAuthorityListRequest **)soap_malloc(soap, sizeof(ns5__GetAppliedUserAuthorityListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetAppliedUserAuthorityListRequest *)soap_instantiate_ns5__GetAppliedUserAuthorityListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetAppliedUserAuthorityListRequest ** p = (ns5__GetAppliedUserAuthorityListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetAppliedUserAuthorityListRequest, sizeof(ns5__GetAppliedUserAuthorityListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetAppliedUserAuthorityListRequest(struct soap *soap, ns5__GetAppliedUserAuthorityListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetAppliedUserAuthorityListRequest);
	return soap_out_PointerTons5__GetAppliedUserAuthorityListRequest(soap, tag?tag:"ns5:GetAppliedUserAuthorityListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetAppliedUserAuthorityListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetAppliedUserAuthorityListRequest(struct soap *soap, ns5__GetAppliedUserAuthorityListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetAppliedUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UnbindBusinessEntityUserResponse(struct soap *soap, ns5__UnbindBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, ns5__UnbindBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserResponse ** FASTCALL soap_in_PointerTons5__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, ns5__UnbindBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UnbindBusinessEntityUserResponse **)soap_malloc(soap, sizeof(ns5__UnbindBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UnbindBusinessEntityUserResponse *)soap_instantiate_ns5__UnbindBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UnbindBusinessEntityUserResponse ** p = (ns5__UnbindBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UnbindBusinessEntityUserResponse, sizeof(ns5__UnbindBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UnbindBusinessEntityUserResponse(struct soap *soap, ns5__UnbindBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserResponse);
	return soap_out_PointerTons5__UnbindBusinessEntityUserResponse(soap, tag?tag:"ns5:UnbindBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTons5__UnbindBusinessEntityUserResponse(struct soap *soap, ns5__UnbindBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UnbindBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UnbindBusinessEntityUserRequest(struct soap *soap, ns5__UnbindBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, ns5__UnbindBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserRequest ** FASTCALL soap_in_PointerTons5__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, ns5__UnbindBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UnbindBusinessEntityUserRequest **)soap_malloc(soap, sizeof(ns5__UnbindBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UnbindBusinessEntityUserRequest *)soap_instantiate_ns5__UnbindBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UnbindBusinessEntityUserRequest ** p = (ns5__UnbindBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UnbindBusinessEntityUserRequest, sizeof(ns5__UnbindBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UnbindBusinessEntityUserRequest(struct soap *soap, ns5__UnbindBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UnbindBusinessEntityUserRequest);
	return soap_out_PointerTons5__UnbindBusinessEntityUserRequest(soap, tag?tag:"ns5:UnbindBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UnbindBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTons5__UnbindBusinessEntityUserRequest(struct soap *soap, ns5__UnbindBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UnbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateUserWorkingAreasResponse(struct soap *soap, ns5__UpdateUserWorkingAreasResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, int id, ns5__UpdateUserWorkingAreasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasResponse ** FASTCALL soap_in_PointerTons5__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, ns5__UpdateUserWorkingAreasResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateUserWorkingAreasResponse **)soap_malloc(soap, sizeof(ns5__UpdateUserWorkingAreasResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateUserWorkingAreasResponse *)soap_instantiate_ns5__UpdateUserWorkingAreasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateUserWorkingAreasResponse ** p = (ns5__UpdateUserWorkingAreasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateUserWorkingAreasResponse, sizeof(ns5__UpdateUserWorkingAreasResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateUserWorkingAreasResponse(struct soap *soap, ns5__UpdateUserWorkingAreasResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasResponse);
	return soap_out_PointerTons5__UpdateUserWorkingAreasResponse(soap, tag?tag:"ns5:UpdateUserWorkingAreasResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasResponse ** SOAP_FMAC4 soap_get_PointerTons5__UpdateUserWorkingAreasResponse(struct soap *soap, ns5__UpdateUserWorkingAreasResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateUserWorkingAreasResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateUserWorkingAreasRequest(struct soap *soap, ns5__UpdateUserWorkingAreasRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, ns5__UpdateUserWorkingAreasRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasRequest ** FASTCALL soap_in_PointerTons5__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, ns5__UpdateUserWorkingAreasRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateUserWorkingAreasRequest **)soap_malloc(soap, sizeof(ns5__UpdateUserWorkingAreasRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateUserWorkingAreasRequest *)soap_instantiate_ns5__UpdateUserWorkingAreasRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateUserWorkingAreasRequest ** p = (ns5__UpdateUserWorkingAreasRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateUserWorkingAreasRequest, sizeof(ns5__UpdateUserWorkingAreasRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateUserWorkingAreasRequest(struct soap *soap, ns5__UpdateUserWorkingAreasRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateUserWorkingAreasRequest);
	return soap_out_PointerTons5__UpdateUserWorkingAreasRequest(soap, tag?tag:"ns5:UpdateUserWorkingAreasRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateUserWorkingAreasRequest ** SOAP_FMAC4 soap_get_PointerTons5__UpdateUserWorkingAreasRequest(struct soap *soap, ns5__UpdateUserWorkingAreasRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateUserAuthoritiesResponse(struct soap *soap, ns5__UpdateUserAuthoritiesResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, int id, ns5__UpdateUserAuthoritiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesResponse ** FASTCALL soap_in_PointerTons5__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, ns5__UpdateUserAuthoritiesResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateUserAuthoritiesResponse **)soap_malloc(soap, sizeof(ns5__UpdateUserAuthoritiesResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateUserAuthoritiesResponse *)soap_instantiate_ns5__UpdateUserAuthoritiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateUserAuthoritiesResponse ** p = (ns5__UpdateUserAuthoritiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateUserAuthoritiesResponse, sizeof(ns5__UpdateUserAuthoritiesResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateUserAuthoritiesResponse(struct soap *soap, ns5__UpdateUserAuthoritiesResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesResponse);
	return soap_out_PointerTons5__UpdateUserAuthoritiesResponse(soap, tag?tag:"ns5:UpdateUserAuthoritiesResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesResponse ** SOAP_FMAC4 soap_get_PointerTons5__UpdateUserAuthoritiesResponse(struct soap *soap, ns5__UpdateUserAuthoritiesResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateUserAuthoritiesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateUserAuthoritiesRequest(struct soap *soap, ns5__UpdateUserAuthoritiesRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, ns5__UpdateUserAuthoritiesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesRequest ** FASTCALL soap_in_PointerTons5__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, ns5__UpdateUserAuthoritiesRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateUserAuthoritiesRequest **)soap_malloc(soap, sizeof(ns5__UpdateUserAuthoritiesRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateUserAuthoritiesRequest *)soap_instantiate_ns5__UpdateUserAuthoritiesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateUserAuthoritiesRequest ** p = (ns5__UpdateUserAuthoritiesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateUserAuthoritiesRequest, sizeof(ns5__UpdateUserAuthoritiesRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateUserAuthoritiesRequest(struct soap *soap, ns5__UpdateUserAuthoritiesRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateUserAuthoritiesRequest);
	return soap_out_PointerTons5__UpdateUserAuthoritiesRequest(soap, tag?tag:"ns5:UpdateUserAuthoritiesRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateUserAuthoritiesRequest ** SOAP_FMAC4 soap_get_PointerTons5__UpdateUserAuthoritiesRequest(struct soap *soap, ns5__UpdateUserAuthoritiesRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetBusinessEntityUserResponse(struct soap *soap, ns5__GetBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, ns5__GetBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserResponse ** FASTCALL soap_in_PointerTons5__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetBusinessEntityUserResponse **)soap_malloc(soap, sizeof(ns5__GetBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetBusinessEntityUserResponse *)soap_instantiate_ns5__GetBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetBusinessEntityUserResponse ** p = (ns5__GetBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetBusinessEntityUserResponse, sizeof(ns5__GetBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetBusinessEntityUserResponse(struct soap *soap, ns5__GetBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetBusinessEntityUserResponse);
	return soap_out_PointerTons5__GetBusinessEntityUserResponse(soap, tag?tag:"ns5:GetBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetBusinessEntityUserResponse(struct soap *soap, ns5__GetBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetBusinessEntityUserRequest(struct soap *soap, ns5__GetBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, ns5__GetBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserRequest ** FASTCALL soap_in_PointerTons5__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetBusinessEntityUserRequest **)soap_malloc(soap, sizeof(ns5__GetBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetBusinessEntityUserRequest *)soap_instantiate_ns5__GetBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetBusinessEntityUserRequest ** p = (ns5__GetBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetBusinessEntityUserRequest, sizeof(ns5__GetBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetBusinessEntityUserRequest(struct soap *soap, ns5__GetBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetBusinessEntityUserRequest);
	return soap_out_PointerTons5__GetBusinessEntityUserRequest(soap, tag?tag:"ns5:GetBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetBusinessEntityUserRequest(struct soap *soap, ns5__GetBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetBusinessEntityUserListResponse(struct soap *soap, ns5__GetBusinessEntityUserListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, int id, ns5__GetBusinessEntityUserListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListResponse ** FASTCALL soap_in_PointerTons5__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetBusinessEntityUserListResponse **)soap_malloc(soap, sizeof(ns5__GetBusinessEntityUserListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetBusinessEntityUserListResponse *)soap_instantiate_ns5__GetBusinessEntityUserListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetBusinessEntityUserListResponse ** p = (ns5__GetBusinessEntityUserListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetBusinessEntityUserListResponse, sizeof(ns5__GetBusinessEntityUserListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetBusinessEntityUserListResponse(struct soap *soap, ns5__GetBusinessEntityUserListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetBusinessEntityUserListResponse);
	return soap_out_PointerTons5__GetBusinessEntityUserListResponse(soap, tag?tag:"ns5:GetBusinessEntityUserListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetBusinessEntityUserListResponse(struct soap *soap, ns5__GetBusinessEntityUserListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetBusinessEntityUserListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetBusinessEntityUserListRequest(struct soap *soap, ns5__GetBusinessEntityUserListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, ns5__GetBusinessEntityUserListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListRequest ** FASTCALL soap_in_PointerTons5__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, ns5__GetBusinessEntityUserListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetBusinessEntityUserListRequest **)soap_malloc(soap, sizeof(ns5__GetBusinessEntityUserListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetBusinessEntityUserListRequest *)soap_instantiate_ns5__GetBusinessEntityUserListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetBusinessEntityUserListRequest ** p = (ns5__GetBusinessEntityUserListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetBusinessEntityUserListRequest, sizeof(ns5__GetBusinessEntityUserListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetBusinessEntityUserListRequest(struct soap *soap, ns5__GetBusinessEntityUserListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetBusinessEntityUserListRequest);
	return soap_out_PointerTons5__GetBusinessEntityUserListRequest(soap, tag?tag:"ns5:GetBusinessEntityUserListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetBusinessEntityUserListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetBusinessEntityUserListRequest(struct soap *soap, ns5__GetBusinessEntityUserListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__AddBusinessEntityUserResponse(struct soap *soap, ns5__AddBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__AddBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, ns5__AddBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__AddBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserResponse ** FASTCALL soap_in_PointerTons5__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, ns5__AddBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__AddBusinessEntityUserResponse **)soap_malloc(soap, sizeof(ns5__AddBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__AddBusinessEntityUserResponse *)soap_instantiate_ns5__AddBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__AddBusinessEntityUserResponse ** p = (ns5__AddBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__AddBusinessEntityUserResponse, sizeof(ns5__AddBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__AddBusinessEntityUserResponse(struct soap *soap, ns5__AddBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__AddBusinessEntityUserResponse);
	return soap_out_PointerTons5__AddBusinessEntityUserResponse(soap, tag?tag:"ns5:AddBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTons5__AddBusinessEntityUserResponse(struct soap *soap, ns5__AddBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__AddBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__AddBusinessEntityUserRequest(struct soap *soap, ns5__AddBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__AddBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, ns5__AddBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__AddBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserRequest ** FASTCALL soap_in_PointerTons5__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, ns5__AddBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__AddBusinessEntityUserRequest **)soap_malloc(soap, sizeof(ns5__AddBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__AddBusinessEntityUserRequest *)soap_instantiate_ns5__AddBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__AddBusinessEntityUserRequest ** p = (ns5__AddBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__AddBusinessEntityUserRequest, sizeof(ns5__AddBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__AddBusinessEntityUserRequest(struct soap *soap, ns5__AddBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__AddBusinessEntityUserRequest);
	return soap_out_PointerTons5__AddBusinessEntityUserRequest(soap, tag?tag:"ns5:AddBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__AddBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTons5__AddBusinessEntityUserRequest(struct soap *soap, ns5__AddBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__AddBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CheckShipmentRegionalizationResponse(struct soap *soap, ns5__CheckShipmentRegionalizationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, int id, ns5__CheckShipmentRegionalizationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationResponse ** FASTCALL soap_in_PointerTons5__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, ns5__CheckShipmentRegionalizationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__CheckShipmentRegionalizationResponse **)soap_malloc(soap, sizeof(ns5__CheckShipmentRegionalizationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__CheckShipmentRegionalizationResponse *)soap_instantiate_ns5__CheckShipmentRegionalizationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__CheckShipmentRegionalizationResponse ** p = (ns5__CheckShipmentRegionalizationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CheckShipmentRegionalizationResponse, sizeof(ns5__CheckShipmentRegionalizationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CheckShipmentRegionalizationResponse(struct soap *soap, ns5__CheckShipmentRegionalizationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationResponse);
	return soap_out_PointerTons5__CheckShipmentRegionalizationResponse(soap, tag?tag:"ns5:CheckShipmentRegionalizationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationResponse ** SOAP_FMAC4 soap_get_PointerTons5__CheckShipmentRegionalizationResponse(struct soap *soap, ns5__CheckShipmentRegionalizationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__CheckShipmentRegionalizationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__CheckShipmentRegionalizationRequest(struct soap *soap, ns5__CheckShipmentRegionalizationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, ns5__CheckShipmentRegionalizationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationRequest ** FASTCALL soap_in_PointerTons5__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, ns5__CheckShipmentRegionalizationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__CheckShipmentRegionalizationRequest **)soap_malloc(soap, sizeof(ns5__CheckShipmentRegionalizationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__CheckShipmentRegionalizationRequest *)soap_instantiate_ns5__CheckShipmentRegionalizationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__CheckShipmentRegionalizationRequest ** p = (ns5__CheckShipmentRegionalizationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__CheckShipmentRegionalizationRequest, sizeof(ns5__CheckShipmentRegionalizationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__CheckShipmentRegionalizationRequest(struct soap *soap, ns5__CheckShipmentRegionalizationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__CheckShipmentRegionalizationRequest);
	return soap_out_PointerTons5__CheckShipmentRegionalizationRequest(soap, tag?tag:"ns5:CheckShipmentRegionalizationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__CheckShipmentRegionalizationRequest ** SOAP_FMAC4 soap_get_PointerTons5__CheckShipmentRegionalizationRequest(struct soap *soap, ns5__CheckShipmentRegionalizationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__CheckShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateVeterinaryEventsResponse(struct soap *soap, ns5__UpdateVeterinaryEventsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, int id, ns5__UpdateVeterinaryEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsResponse ** FASTCALL soap_in_PointerTons5__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, ns5__UpdateVeterinaryEventsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateVeterinaryEventsResponse **)soap_malloc(soap, sizeof(ns5__UpdateVeterinaryEventsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateVeterinaryEventsResponse *)soap_instantiate_ns5__UpdateVeterinaryEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateVeterinaryEventsResponse ** p = (ns5__UpdateVeterinaryEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateVeterinaryEventsResponse, sizeof(ns5__UpdateVeterinaryEventsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateVeterinaryEventsResponse(struct soap *soap, ns5__UpdateVeterinaryEventsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsResponse);
	return soap_out_PointerTons5__UpdateVeterinaryEventsResponse(soap, tag?tag:"ns5:UpdateVeterinaryEventsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsResponse ** SOAP_FMAC4 soap_get_PointerTons5__UpdateVeterinaryEventsResponse(struct soap *soap, ns5__UpdateVeterinaryEventsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateVeterinaryEventsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateVeterinaryEventsRequest(struct soap *soap, ns5__UpdateVeterinaryEventsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, ns5__UpdateVeterinaryEventsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsRequest ** FASTCALL soap_in_PointerTons5__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, ns5__UpdateVeterinaryEventsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateVeterinaryEventsRequest **)soap_malloc(soap, sizeof(ns5__UpdateVeterinaryEventsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateVeterinaryEventsRequest *)soap_instantiate_ns5__UpdateVeterinaryEventsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateVeterinaryEventsRequest ** p = (ns5__UpdateVeterinaryEventsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateVeterinaryEventsRequest, sizeof(ns5__UpdateVeterinaryEventsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateVeterinaryEventsRequest(struct soap *soap, ns5__UpdateVeterinaryEventsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateVeterinaryEventsRequest);
	return soap_out_PointerTons5__UpdateVeterinaryEventsRequest(soap, tag?tag:"ns5:UpdateVeterinaryEventsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateVeterinaryEventsRequest ** SOAP_FMAC4 soap_get_PointerTons5__UpdateVeterinaryEventsRequest(struct soap *soap, ns5__UpdateVeterinaryEventsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateTransportMovementDetailsResponse(struct soap *soap, ns5__UpdateTransportMovementDetailsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, int id, ns5__UpdateTransportMovementDetailsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsResponse ** FASTCALL soap_in_PointerTons5__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, ns5__UpdateTransportMovementDetailsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateTransportMovementDetailsResponse **)soap_malloc(soap, sizeof(ns5__UpdateTransportMovementDetailsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateTransportMovementDetailsResponse *)soap_instantiate_ns5__UpdateTransportMovementDetailsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateTransportMovementDetailsResponse ** p = (ns5__UpdateTransportMovementDetailsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsResponse, sizeof(ns5__UpdateTransportMovementDetailsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateTransportMovementDetailsResponse(struct soap *soap, ns5__UpdateTransportMovementDetailsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsResponse);
	return soap_out_PointerTons5__UpdateTransportMovementDetailsResponse(soap, tag?tag:"ns5:UpdateTransportMovementDetailsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsResponse ** SOAP_FMAC4 soap_get_PointerTons5__UpdateTransportMovementDetailsResponse(struct soap *soap, ns5__UpdateTransportMovementDetailsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateTransportMovementDetailsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UpdateTransportMovementDetailsRequest(struct soap *soap, ns5__UpdateTransportMovementDetailsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, ns5__UpdateTransportMovementDetailsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsRequest ** FASTCALL soap_in_PointerTons5__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, ns5__UpdateTransportMovementDetailsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__UpdateTransportMovementDetailsRequest **)soap_malloc(soap, sizeof(ns5__UpdateTransportMovementDetailsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__UpdateTransportMovementDetailsRequest *)soap_instantiate_ns5__UpdateTransportMovementDetailsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__UpdateTransportMovementDetailsRequest ** p = (ns5__UpdateTransportMovementDetailsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UpdateTransportMovementDetailsRequest, sizeof(ns5__UpdateTransportMovementDetailsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UpdateTransportMovementDetailsRequest(struct soap *soap, ns5__UpdateTransportMovementDetailsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UpdateTransportMovementDetailsRequest);
	return soap_out_PointerTons5__UpdateTransportMovementDetailsRequest(soap, tag?tag:"ns5:UpdateTransportMovementDetailsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UpdateTransportMovementDetailsRequest ** SOAP_FMAC4 soap_get_PointerTons5__UpdateTransportMovementDetailsRequest(struct soap *soap, ns5__UpdateTransportMovementDetailsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__UpdateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryVersionListResponse(struct soap *soap, ns5__GetStockEntryVersionListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryVersionListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, int id, ns5__GetStockEntryVersionListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryVersionListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListResponse ** FASTCALL soap_in_PointerTons5__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, ns5__GetStockEntryVersionListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryVersionListResponse **)soap_malloc(soap, sizeof(ns5__GetStockEntryVersionListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryVersionListResponse *)soap_instantiate_ns5__GetStockEntryVersionListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryVersionListResponse ** p = (ns5__GetStockEntryVersionListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryVersionListResponse, sizeof(ns5__GetStockEntryVersionListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryVersionListResponse(struct soap *soap, ns5__GetStockEntryVersionListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryVersionListResponse);
	return soap_out_PointerTons5__GetStockEntryVersionListResponse(soap, tag?tag:"ns5:GetStockEntryVersionListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryVersionListResponse(struct soap *soap, ns5__GetStockEntryVersionListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryVersionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryVersionListRequest(struct soap *soap, ns5__GetStockEntryVersionListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryVersionListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, ns5__GetStockEntryVersionListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryVersionListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListRequest ** FASTCALL soap_in_PointerTons5__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, ns5__GetStockEntryVersionListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryVersionListRequest **)soap_malloc(soap, sizeof(ns5__GetStockEntryVersionListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryVersionListRequest *)soap_instantiate_ns5__GetStockEntryVersionListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryVersionListRequest ** p = (ns5__GetStockEntryVersionListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryVersionListRequest, sizeof(ns5__GetStockEntryVersionListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryVersionListRequest(struct soap *soap, ns5__GetStockEntryVersionListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryVersionListRequest);
	return soap_out_PointerTons5__GetStockEntryVersionListRequest(soap, tag?tag:"ns5:GetStockEntryVersionListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryVersionListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryVersionListRequest(struct soap *soap, ns5__GetStockEntryVersionListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryChangesListResponse(struct soap *soap, ns5__GetStockEntryChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, int id, ns5__GetStockEntryChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListResponse ** FASTCALL soap_in_PointerTons5__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, ns5__GetStockEntryChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryChangesListResponse **)soap_malloc(soap, sizeof(ns5__GetStockEntryChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryChangesListResponse *)soap_instantiate_ns5__GetStockEntryChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryChangesListResponse ** p = (ns5__GetStockEntryChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryChangesListResponse, sizeof(ns5__GetStockEntryChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryChangesListResponse(struct soap *soap, ns5__GetStockEntryChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryChangesListResponse);
	return soap_out_PointerTons5__GetStockEntryChangesListResponse(soap, tag?tag:"ns5:GetStockEntryChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryChangesListResponse(struct soap *soap, ns5__GetStockEntryChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryChangesListRequest(struct soap *soap, ns5__GetStockEntryChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, ns5__GetStockEntryChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListRequest ** FASTCALL soap_in_PointerTons5__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, ns5__GetStockEntryChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryChangesListRequest **)soap_malloc(soap, sizeof(ns5__GetStockEntryChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryChangesListRequest *)soap_instantiate_ns5__GetStockEntryChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryChangesListRequest ** p = (ns5__GetStockEntryChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryChangesListRequest, sizeof(ns5__GetStockEntryChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryChangesListRequest(struct soap *soap, ns5__GetStockEntryChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryChangesListRequest);
	return soap_out_PointerTons5__GetStockEntryChangesListRequest(soap, tag?tag:"ns5:GetStockEntryChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryChangesListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryChangesListRequest(struct soap *soap, ns5__GetStockEntryChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryListResponse(struct soap *soap, ns5__GetStockEntryListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryListResponse(struct soap *soap, const char *tag, int id, ns5__GetStockEntryListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryListResponse ** FASTCALL soap_in_PointerTons5__GetStockEntryListResponse(struct soap *soap, const char *tag, ns5__GetStockEntryListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryListResponse **)soap_malloc(soap, sizeof(ns5__GetStockEntryListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryListResponse *)soap_instantiate_ns5__GetStockEntryListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryListResponse ** p = (ns5__GetStockEntryListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryListResponse, sizeof(ns5__GetStockEntryListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryListResponse(struct soap *soap, ns5__GetStockEntryListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryListResponse);
	return soap_out_PointerTons5__GetStockEntryListResponse(soap, tag?tag:"ns5:GetStockEntryListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryListResponse(struct soap *soap, ns5__GetStockEntryListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryListRequest(struct soap *soap, ns5__GetStockEntryListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryListRequest(struct soap *soap, const char *tag, int id, ns5__GetStockEntryListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryListRequest ** FASTCALL soap_in_PointerTons5__GetStockEntryListRequest(struct soap *soap, const char *tag, ns5__GetStockEntryListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryListRequest **)soap_malloc(soap, sizeof(ns5__GetStockEntryListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryListRequest *)soap_instantiate_ns5__GetStockEntryListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryListRequest ** p = (ns5__GetStockEntryListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryListRequest, sizeof(ns5__GetStockEntryListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryListRequest(struct soap *soap, ns5__GetStockEntryListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryListRequest);
	return soap_out_PointerTons5__GetStockEntryListRequest(soap, tag?tag:"ns5:GetStockEntryListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryListRequest(struct soap *soap, ns5__GetStockEntryListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryByUuidResponse(struct soap *soap, ns5__GetStockEntryByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, int id, ns5__GetStockEntryByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidResponse ** FASTCALL soap_in_PointerTons5__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, ns5__GetStockEntryByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryByUuidResponse **)soap_malloc(soap, sizeof(ns5__GetStockEntryByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryByUuidResponse *)soap_instantiate_ns5__GetStockEntryByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryByUuidResponse ** p = (ns5__GetStockEntryByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryByUuidResponse, sizeof(ns5__GetStockEntryByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryByUuidResponse(struct soap *soap, ns5__GetStockEntryByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryByUuidResponse);
	return soap_out_PointerTons5__GetStockEntryByUuidResponse(soap, tag?tag:"ns5:GetStockEntryByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryByUuidResponse(struct soap *soap, ns5__GetStockEntryByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryByUuidRequest(struct soap *soap, ns5__GetStockEntryByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, ns5__GetStockEntryByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidRequest ** FASTCALL soap_in_PointerTons5__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, ns5__GetStockEntryByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryByUuidRequest **)soap_malloc(soap, sizeof(ns5__GetStockEntryByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryByUuidRequest *)soap_instantiate_ns5__GetStockEntryByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryByUuidRequest ** p = (ns5__GetStockEntryByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryByUuidRequest, sizeof(ns5__GetStockEntryByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryByUuidRequest(struct soap *soap, ns5__GetStockEntryByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryByUuidRequest);
	return soap_out_PointerTons5__GetStockEntryByUuidRequest(soap, tag?tag:"ns5:GetStockEntryByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryByUuidRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryByUuidRequest(struct soap *soap, ns5__GetStockEntryByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryByGuidResponse(struct soap *soap, ns5__GetStockEntryByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, int id, ns5__GetStockEntryByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidResponse ** FASTCALL soap_in_PointerTons5__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, ns5__GetStockEntryByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryByGuidResponse **)soap_malloc(soap, sizeof(ns5__GetStockEntryByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryByGuidResponse *)soap_instantiate_ns5__GetStockEntryByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryByGuidResponse ** p = (ns5__GetStockEntryByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryByGuidResponse, sizeof(ns5__GetStockEntryByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryByGuidResponse(struct soap *soap, ns5__GetStockEntryByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryByGuidResponse);
	return soap_out_PointerTons5__GetStockEntryByGuidResponse(soap, tag?tag:"ns5:GetStockEntryByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryByGuidResponse(struct soap *soap, ns5__GetStockEntryByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetStockEntryByGuidRequest(struct soap *soap, ns5__GetStockEntryByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetStockEntryByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, ns5__GetStockEntryByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetStockEntryByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidRequest ** FASTCALL soap_in_PointerTons5__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, ns5__GetStockEntryByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetStockEntryByGuidRequest **)soap_malloc(soap, sizeof(ns5__GetStockEntryByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetStockEntryByGuidRequest *)soap_instantiate_ns5__GetStockEntryByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetStockEntryByGuidRequest ** p = (ns5__GetStockEntryByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetStockEntryByGuidRequest, sizeof(ns5__GetStockEntryByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetStockEntryByGuidRequest(struct soap *soap, ns5__GetStockEntryByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetStockEntryByGuidRequest);
	return soap_out_PointerTons5__GetStockEntryByGuidRequest(soap, tag?tag:"ns5:GetStockEntryByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetStockEntryByGuidRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetStockEntryByGuidRequest(struct soap *soap, ns5__GetStockEntryByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetVetDocumentChangesListResponse(struct soap *soap, ns5__GetVetDocumentChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, int id, ns5__GetVetDocumentChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListResponse ** FASTCALL soap_in_PointerTons5__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, ns5__GetVetDocumentChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetVetDocumentChangesListResponse **)soap_malloc(soap, sizeof(ns5__GetVetDocumentChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetVetDocumentChangesListResponse *)soap_instantiate_ns5__GetVetDocumentChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetVetDocumentChangesListResponse ** p = (ns5__GetVetDocumentChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetVetDocumentChangesListResponse, sizeof(ns5__GetVetDocumentChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetVetDocumentChangesListResponse(struct soap *soap, ns5__GetVetDocumentChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetVetDocumentChangesListResponse);
	return soap_out_PointerTons5__GetVetDocumentChangesListResponse(soap, tag?tag:"ns5:GetVetDocumentChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetVetDocumentChangesListResponse(struct soap *soap, ns5__GetVetDocumentChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetVetDocumentChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetVetDocumentChangesListRequest(struct soap *soap, ns5__GetVetDocumentChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, ns5__GetVetDocumentChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListRequest ** FASTCALL soap_in_PointerTons5__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, ns5__GetVetDocumentChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetVetDocumentChangesListRequest **)soap_malloc(soap, sizeof(ns5__GetVetDocumentChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetVetDocumentChangesListRequest *)soap_instantiate_ns5__GetVetDocumentChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetVetDocumentChangesListRequest ** p = (ns5__GetVetDocumentChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetVetDocumentChangesListRequest, sizeof(ns5__GetVetDocumentChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetVetDocumentChangesListRequest(struct soap *soap, ns5__GetVetDocumentChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetVetDocumentChangesListRequest);
	return soap_out_PointerTons5__GetVetDocumentChangesListRequest(soap, tag?tag:"ns5:GetVetDocumentChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetVetDocumentChangesListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetVetDocumentChangesListRequest(struct soap *soap, ns5__GetVetDocumentChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetVetDocumentListResponse(struct soap *soap, ns5__GetVetDocumentListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetVetDocumentListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetVetDocumentListResponse(struct soap *soap, const char *tag, int id, ns5__GetVetDocumentListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetVetDocumentListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetVetDocumentListResponse ** FASTCALL soap_in_PointerTons5__GetVetDocumentListResponse(struct soap *soap, const char *tag, ns5__GetVetDocumentListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetVetDocumentListResponse **)soap_malloc(soap, sizeof(ns5__GetVetDocumentListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetVetDocumentListResponse *)soap_instantiate_ns5__GetVetDocumentListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetVetDocumentListResponse ** p = (ns5__GetVetDocumentListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetVetDocumentListResponse, sizeof(ns5__GetVetDocumentListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetVetDocumentListResponse(struct soap *soap, ns5__GetVetDocumentListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetVetDocumentListResponse);
	return soap_out_PointerTons5__GetVetDocumentListResponse(soap, tag?tag:"ns5:GetVetDocumentListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetVetDocumentListResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetVetDocumentListResponse(struct soap *soap, ns5__GetVetDocumentListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetVetDocumentListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetVetDocumentListRequest(struct soap *soap, ns5__GetVetDocumentListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetVetDocumentListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetVetDocumentListRequest(struct soap *soap, const char *tag, int id, ns5__GetVetDocumentListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetVetDocumentListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetVetDocumentListRequest ** FASTCALL soap_in_PointerTons5__GetVetDocumentListRequest(struct soap *soap, const char *tag, ns5__GetVetDocumentListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetVetDocumentListRequest **)soap_malloc(soap, sizeof(ns5__GetVetDocumentListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetVetDocumentListRequest *)soap_instantiate_ns5__GetVetDocumentListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetVetDocumentListRequest ** p = (ns5__GetVetDocumentListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetVetDocumentListRequest, sizeof(ns5__GetVetDocumentListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetVetDocumentListRequest(struct soap *soap, ns5__GetVetDocumentListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetVetDocumentListRequest);
	return soap_out_PointerTons5__GetVetDocumentListRequest(soap, tag?tag:"ns5:GetVetDocumentListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetVetDocumentListRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetVetDocumentListRequest(struct soap *soap, ns5__GetVetDocumentListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetVetDocumentByUuidResponse(struct soap *soap, ns5__GetVetDocumentByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, int id, ns5__GetVetDocumentByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidResponse ** FASTCALL soap_in_PointerTons5__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, ns5__GetVetDocumentByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetVetDocumentByUuidResponse **)soap_malloc(soap, sizeof(ns5__GetVetDocumentByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetVetDocumentByUuidResponse *)soap_instantiate_ns5__GetVetDocumentByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetVetDocumentByUuidResponse ** p = (ns5__GetVetDocumentByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetVetDocumentByUuidResponse, sizeof(ns5__GetVetDocumentByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetVetDocumentByUuidResponse(struct soap *soap, ns5__GetVetDocumentByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetVetDocumentByUuidResponse);
	return soap_out_PointerTons5__GetVetDocumentByUuidResponse(soap, tag?tag:"ns5:GetVetDocumentByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidResponse ** SOAP_FMAC4 soap_get_PointerTons5__GetVetDocumentByUuidResponse(struct soap *soap, ns5__GetVetDocumentByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetVetDocumentByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__GetVetDocumentByUuidRequest(struct soap *soap, ns5__GetVetDocumentByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, ns5__GetVetDocumentByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidRequest ** FASTCALL soap_in_PointerTons5__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, ns5__GetVetDocumentByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__GetVetDocumentByUuidRequest **)soap_malloc(soap, sizeof(ns5__GetVetDocumentByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__GetVetDocumentByUuidRequest *)soap_instantiate_ns5__GetVetDocumentByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__GetVetDocumentByUuidRequest ** p = (ns5__GetVetDocumentByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__GetVetDocumentByUuidRequest, sizeof(ns5__GetVetDocumentByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__GetVetDocumentByUuidRequest(struct soap *soap, ns5__GetVetDocumentByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__GetVetDocumentByUuidRequest);
	return soap_out_PointerTons5__GetVetDocumentByUuidRequest(soap, tag?tag:"ns5:GetVetDocumentByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__GetVetDocumentByUuidRequest ** SOAP_FMAC4 soap_get_PointerTons5__GetVetDocumentByUuidRequest(struct soap *soap, ns5__GetVetDocumentByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__GetVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyProducerStockListResponse(struct soap *soap, ns5__ModifyProducerStockListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyProducerStockListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyProducerStockListResponse(struct soap *soap, const char *tag, int id, ns5__ModifyProducerStockListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyProducerStockListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyProducerStockListResponse ** FASTCALL soap_in_PointerTons5__ModifyProducerStockListResponse(struct soap *soap, const char *tag, ns5__ModifyProducerStockListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyProducerStockListResponse **)soap_malloc(soap, sizeof(ns5__ModifyProducerStockListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyProducerStockListResponse *)soap_instantiate_ns5__ModifyProducerStockListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyProducerStockListResponse ** p = (ns5__ModifyProducerStockListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyProducerStockListResponse, sizeof(ns5__ModifyProducerStockListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyProducerStockListResponse(struct soap *soap, ns5__ModifyProducerStockListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyProducerStockListResponse);
	return soap_out_PointerTons5__ModifyProducerStockListResponse(soap, tag?tag:"ns5:ModifyProducerStockListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyProducerStockListResponse ** SOAP_FMAC4 soap_get_PointerTons5__ModifyProducerStockListResponse(struct soap *soap, ns5__ModifyProducerStockListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyProducerStockListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyProducerStockListRequest(struct soap *soap, ns5__ModifyProducerStockListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyProducerStockListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyProducerStockListRequest(struct soap *soap, const char *tag, int id, ns5__ModifyProducerStockListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyProducerStockListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyProducerStockListRequest ** FASTCALL soap_in_PointerTons5__ModifyProducerStockListRequest(struct soap *soap, const char *tag, ns5__ModifyProducerStockListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyProducerStockListRequest **)soap_malloc(soap, sizeof(ns5__ModifyProducerStockListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyProducerStockListRequest *)soap_instantiate_ns5__ModifyProducerStockListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyProducerStockListRequest ** p = (ns5__ModifyProducerStockListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyProducerStockListRequest, sizeof(ns5__ModifyProducerStockListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyProducerStockListRequest(struct soap *soap, ns5__ModifyProducerStockListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyProducerStockListRequest);
	return soap_out_PointerTons5__ModifyProducerStockListRequest(soap, tag?tag:"ns5:ModifyProducerStockListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyProducerStockListRequest ** SOAP_FMAC4 soap_get_PointerTons5__ModifyProducerStockListRequest(struct soap *soap, ns5__ModifyProducerStockListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ResolveDiscrepancyResponse(struct soap *soap, ns5__ResolveDiscrepancyResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ResolveDiscrepancyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, int id, ns5__ResolveDiscrepancyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ResolveDiscrepancyResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyResponse ** FASTCALL soap_in_PointerTons5__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, ns5__ResolveDiscrepancyResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ResolveDiscrepancyResponse **)soap_malloc(soap, sizeof(ns5__ResolveDiscrepancyResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ResolveDiscrepancyResponse *)soap_instantiate_ns5__ResolveDiscrepancyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ResolveDiscrepancyResponse ** p = (ns5__ResolveDiscrepancyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ResolveDiscrepancyResponse, sizeof(ns5__ResolveDiscrepancyResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ResolveDiscrepancyResponse(struct soap *soap, ns5__ResolveDiscrepancyResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ResolveDiscrepancyResponse);
	return soap_out_PointerTons5__ResolveDiscrepancyResponse(soap, tag?tag:"ns5:ResolveDiscrepancyResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyResponse ** SOAP_FMAC4 soap_get_PointerTons5__ResolveDiscrepancyResponse(struct soap *soap, ns5__ResolveDiscrepancyResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ResolveDiscrepancyResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ResolveDiscrepancyRequest(struct soap *soap, ns5__ResolveDiscrepancyRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ResolveDiscrepancyRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, ns5__ResolveDiscrepancyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ResolveDiscrepancyRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyRequest ** FASTCALL soap_in_PointerTons5__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, ns5__ResolveDiscrepancyRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ResolveDiscrepancyRequest **)soap_malloc(soap, sizeof(ns5__ResolveDiscrepancyRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ResolveDiscrepancyRequest *)soap_instantiate_ns5__ResolveDiscrepancyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ResolveDiscrepancyRequest ** p = (ns5__ResolveDiscrepancyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ResolveDiscrepancyRequest, sizeof(ns5__ResolveDiscrepancyRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ResolveDiscrepancyRequest(struct soap *soap, ns5__ResolveDiscrepancyRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ResolveDiscrepancyRequest);
	return soap_out_PointerTons5__ResolveDiscrepancyRequest(soap, tag?tag:"ns5:ResolveDiscrepancyRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ResolveDiscrepancyRequest ** SOAP_FMAC4 soap_get_PointerTons5__ResolveDiscrepancyRequest(struct soap *soap, ns5__ResolveDiscrepancyRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ResolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyActivityLocationsResponse(struct soap *soap, ns5__ModifyActivityLocationsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyActivityLocationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, int id, ns5__ModifyActivityLocationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyActivityLocationsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsResponse ** FASTCALL soap_in_PointerTons5__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, ns5__ModifyActivityLocationsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyActivityLocationsResponse **)soap_malloc(soap, sizeof(ns5__ModifyActivityLocationsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyActivityLocationsResponse *)soap_instantiate_ns5__ModifyActivityLocationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyActivityLocationsResponse ** p = (ns5__ModifyActivityLocationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyActivityLocationsResponse, sizeof(ns5__ModifyActivityLocationsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyActivityLocationsResponse(struct soap *soap, ns5__ModifyActivityLocationsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyActivityLocationsResponse);
	return soap_out_PointerTons5__ModifyActivityLocationsResponse(soap, tag?tag:"ns5:ModifyActivityLocationsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsResponse ** SOAP_FMAC4 soap_get_PointerTons5__ModifyActivityLocationsResponse(struct soap *soap, ns5__ModifyActivityLocationsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyActivityLocationsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyActivityLocationsRequest(struct soap *soap, ns5__ModifyActivityLocationsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyActivityLocationsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, ns5__ModifyActivityLocationsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyActivityLocationsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsRequest ** FASTCALL soap_in_PointerTons5__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, ns5__ModifyActivityLocationsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyActivityLocationsRequest **)soap_malloc(soap, sizeof(ns5__ModifyActivityLocationsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyActivityLocationsRequest *)soap_instantiate_ns5__ModifyActivityLocationsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyActivityLocationsRequest ** p = (ns5__ModifyActivityLocationsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyActivityLocationsRequest, sizeof(ns5__ModifyActivityLocationsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyActivityLocationsRequest(struct soap *soap, ns5__ModifyActivityLocationsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyActivityLocationsRequest);
	return soap_out_PointerTons5__ModifyActivityLocationsRequest(soap, tag?tag:"ns5:ModifyActivityLocationsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyActivityLocationsRequest ** SOAP_FMAC4 soap_get_PointerTons5__ModifyActivityLocationsRequest(struct soap *soap, ns5__ModifyActivityLocationsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyEnterpriseResponse(struct soap *soap, ns5__ModifyEnterpriseResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyEnterpriseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyEnterpriseResponse(struct soap *soap, const char *tag, int id, ns5__ModifyEnterpriseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyEnterpriseResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyEnterpriseResponse ** FASTCALL soap_in_PointerTons5__ModifyEnterpriseResponse(struct soap *soap, const char *tag, ns5__ModifyEnterpriseResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyEnterpriseResponse **)soap_malloc(soap, sizeof(ns5__ModifyEnterpriseResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyEnterpriseResponse *)soap_instantiate_ns5__ModifyEnterpriseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyEnterpriseResponse ** p = (ns5__ModifyEnterpriseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyEnterpriseResponse, sizeof(ns5__ModifyEnterpriseResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyEnterpriseResponse(struct soap *soap, ns5__ModifyEnterpriseResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyEnterpriseResponse);
	return soap_out_PointerTons5__ModifyEnterpriseResponse(soap, tag?tag:"ns5:ModifyEnterpriseResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyEnterpriseResponse ** SOAP_FMAC4 soap_get_PointerTons5__ModifyEnterpriseResponse(struct soap *soap, ns5__ModifyEnterpriseResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyEnterpriseResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyEnterpriseRequest(struct soap *soap, ns5__ModifyEnterpriseRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyEnterpriseRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyEnterpriseRequest(struct soap *soap, const char *tag, int id, ns5__ModifyEnterpriseRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyEnterpriseRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyEnterpriseRequest ** FASTCALL soap_in_PointerTons5__ModifyEnterpriseRequest(struct soap *soap, const char *tag, ns5__ModifyEnterpriseRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyEnterpriseRequest **)soap_malloc(soap, sizeof(ns5__ModifyEnterpriseRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyEnterpriseRequest *)soap_instantiate_ns5__ModifyEnterpriseRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyEnterpriseRequest ** p = (ns5__ModifyEnterpriseRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyEnterpriseRequest, sizeof(ns5__ModifyEnterpriseRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyEnterpriseRequest(struct soap *soap, ns5__ModifyEnterpriseRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyEnterpriseRequest);
	return soap_out_PointerTons5__ModifyEnterpriseRequest(soap, tag?tag:"ns5:ModifyEnterpriseRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyEnterpriseRequest ** SOAP_FMAC4 soap_get_PointerTons5__ModifyEnterpriseRequest(struct soap *soap, ns5__ModifyEnterpriseRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyBusinessEntityResponse(struct soap *soap, ns5__ModifyBusinessEntityResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyBusinessEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, int id, ns5__ModifyBusinessEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyBusinessEntityResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityResponse ** FASTCALL soap_in_PointerTons5__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, ns5__ModifyBusinessEntityResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyBusinessEntityResponse **)soap_malloc(soap, sizeof(ns5__ModifyBusinessEntityResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyBusinessEntityResponse *)soap_instantiate_ns5__ModifyBusinessEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyBusinessEntityResponse ** p = (ns5__ModifyBusinessEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyBusinessEntityResponse, sizeof(ns5__ModifyBusinessEntityResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyBusinessEntityResponse(struct soap *soap, ns5__ModifyBusinessEntityResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyBusinessEntityResponse);
	return soap_out_PointerTons5__ModifyBusinessEntityResponse(soap, tag?tag:"ns5:ModifyBusinessEntityResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityResponse ** SOAP_FMAC4 soap_get_PointerTons5__ModifyBusinessEntityResponse(struct soap *soap, ns5__ModifyBusinessEntityResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyBusinessEntityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ModifyBusinessEntityRequest(struct soap *soap, ns5__ModifyBusinessEntityRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ModifyBusinessEntityRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, ns5__ModifyBusinessEntityRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ModifyBusinessEntityRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityRequest ** FASTCALL soap_in_PointerTons5__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, ns5__ModifyBusinessEntityRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ModifyBusinessEntityRequest **)soap_malloc(soap, sizeof(ns5__ModifyBusinessEntityRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ModifyBusinessEntityRequest *)soap_instantiate_ns5__ModifyBusinessEntityRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ModifyBusinessEntityRequest ** p = (ns5__ModifyBusinessEntityRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ModifyBusinessEntityRequest, sizeof(ns5__ModifyBusinessEntityRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ModifyBusinessEntityRequest(struct soap *soap, ns5__ModifyBusinessEntityRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ModifyBusinessEntityRequest);
	return soap_out_PointerTons5__ModifyBusinessEntityRequest(soap, tag?tag:"ns5:ModifyBusinessEntityRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ModifyBusinessEntityRequest ** SOAP_FMAC4 soap_get_PointerTons5__ModifyBusinessEntityRequest(struct soap *soap, ns5__ModifyBusinessEntityRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ModifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__WithdrawVetDocumentResponse(struct soap *soap, ns5__WithdrawVetDocumentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__WithdrawVetDocumentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, int id, ns5__WithdrawVetDocumentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__WithdrawVetDocumentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentResponse ** FASTCALL soap_in_PointerTons5__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, ns5__WithdrawVetDocumentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__WithdrawVetDocumentResponse **)soap_malloc(soap, sizeof(ns5__WithdrawVetDocumentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__WithdrawVetDocumentResponse *)soap_instantiate_ns5__WithdrawVetDocumentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__WithdrawVetDocumentResponse ** p = (ns5__WithdrawVetDocumentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__WithdrawVetDocumentResponse, sizeof(ns5__WithdrawVetDocumentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__WithdrawVetDocumentResponse(struct soap *soap, ns5__WithdrawVetDocumentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__WithdrawVetDocumentResponse);
	return soap_out_PointerTons5__WithdrawVetDocumentResponse(soap, tag?tag:"ns5:WithdrawVetDocumentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentResponse ** SOAP_FMAC4 soap_get_PointerTons5__WithdrawVetDocumentResponse(struct soap *soap, ns5__WithdrawVetDocumentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__WithdrawVetDocumentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__WithdrawVetDocumentRequest(struct soap *soap, ns5__WithdrawVetDocumentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__WithdrawVetDocumentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, ns5__WithdrawVetDocumentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__WithdrawVetDocumentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentRequest ** FASTCALL soap_in_PointerTons5__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, ns5__WithdrawVetDocumentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__WithdrawVetDocumentRequest **)soap_malloc(soap, sizeof(ns5__WithdrawVetDocumentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__WithdrawVetDocumentRequest *)soap_instantiate_ns5__WithdrawVetDocumentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__WithdrawVetDocumentRequest ** p = (ns5__WithdrawVetDocumentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__WithdrawVetDocumentRequest, sizeof(ns5__WithdrawVetDocumentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__WithdrawVetDocumentRequest(struct soap *soap, ns5__WithdrawVetDocumentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__WithdrawVetDocumentRequest);
	return soap_out_PointerTons5__WithdrawVetDocumentRequest(soap, tag?tag:"ns5:WithdrawVetDocumentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__WithdrawVetDocumentRequest ** SOAP_FMAC4 soap_get_PointerTons5__WithdrawVetDocumentRequest(struct soap *soap, ns5__WithdrawVetDocumentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__WithdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__MergeStockEntriesResponse(struct soap *soap, ns5__MergeStockEntriesResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__MergeStockEntriesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__MergeStockEntriesResponse(struct soap *soap, const char *tag, int id, ns5__MergeStockEntriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__MergeStockEntriesResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__MergeStockEntriesResponse ** FASTCALL soap_in_PointerTons5__MergeStockEntriesResponse(struct soap *soap, const char *tag, ns5__MergeStockEntriesResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__MergeStockEntriesResponse **)soap_malloc(soap, sizeof(ns5__MergeStockEntriesResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__MergeStockEntriesResponse *)soap_instantiate_ns5__MergeStockEntriesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__MergeStockEntriesResponse ** p = (ns5__MergeStockEntriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__MergeStockEntriesResponse, sizeof(ns5__MergeStockEntriesResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__MergeStockEntriesResponse(struct soap *soap, ns5__MergeStockEntriesResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__MergeStockEntriesResponse);
	return soap_out_PointerTons5__MergeStockEntriesResponse(soap, tag?tag:"ns5:MergeStockEntriesResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__MergeStockEntriesResponse ** SOAP_FMAC4 soap_get_PointerTons5__MergeStockEntriesResponse(struct soap *soap, ns5__MergeStockEntriesResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__MergeStockEntriesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__MergeStockEntriesRequest(struct soap *soap, ns5__MergeStockEntriesRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__MergeStockEntriesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__MergeStockEntriesRequest(struct soap *soap, const char *tag, int id, ns5__MergeStockEntriesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__MergeStockEntriesRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__MergeStockEntriesRequest ** FASTCALL soap_in_PointerTons5__MergeStockEntriesRequest(struct soap *soap, const char *tag, ns5__MergeStockEntriesRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__MergeStockEntriesRequest **)soap_malloc(soap, sizeof(ns5__MergeStockEntriesRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__MergeStockEntriesRequest *)soap_instantiate_ns5__MergeStockEntriesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__MergeStockEntriesRequest ** p = (ns5__MergeStockEntriesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__MergeStockEntriesRequest, sizeof(ns5__MergeStockEntriesRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__MergeStockEntriesRequest(struct soap *soap, ns5__MergeStockEntriesRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__MergeStockEntriesRequest);
	return soap_out_PointerTons5__MergeStockEntriesRequest(soap, tag?tag:"ns5:MergeStockEntriesRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__MergeStockEntriesRequest ** SOAP_FMAC4 soap_get_PointerTons5__MergeStockEntriesRequest(struct soap *soap, ns5__MergeStockEntriesRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__MergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RegisterProductionOperationResponse(struct soap *soap, ns5__RegisterProductionOperationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__RegisterProductionOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__RegisterProductionOperationResponse(struct soap *soap, const char *tag, int id, ns5__RegisterProductionOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__RegisterProductionOperationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RegisterProductionOperationResponse ** FASTCALL soap_in_PointerTons5__RegisterProductionOperationResponse(struct soap *soap, const char *tag, ns5__RegisterProductionOperationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__RegisterProductionOperationResponse **)soap_malloc(soap, sizeof(ns5__RegisterProductionOperationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__RegisterProductionOperationResponse *)soap_instantiate_ns5__RegisterProductionOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__RegisterProductionOperationResponse ** p = (ns5__RegisterProductionOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__RegisterProductionOperationResponse, sizeof(ns5__RegisterProductionOperationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RegisterProductionOperationResponse(struct soap *soap, ns5__RegisterProductionOperationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__RegisterProductionOperationResponse);
	return soap_out_PointerTons5__RegisterProductionOperationResponse(soap, tag?tag:"ns5:RegisterProductionOperationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RegisterProductionOperationResponse ** SOAP_FMAC4 soap_get_PointerTons5__RegisterProductionOperationResponse(struct soap *soap, ns5__RegisterProductionOperationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__RegisterProductionOperationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__RegisterProductionOperationRequest(struct soap *soap, ns5__RegisterProductionOperationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__RegisterProductionOperationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__RegisterProductionOperationRequest(struct soap *soap, const char *tag, int id, ns5__RegisterProductionOperationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__RegisterProductionOperationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__RegisterProductionOperationRequest ** FASTCALL soap_in_PointerTons5__RegisterProductionOperationRequest(struct soap *soap, const char *tag, ns5__RegisterProductionOperationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__RegisterProductionOperationRequest **)soap_malloc(soap, sizeof(ns5__RegisterProductionOperationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__RegisterProductionOperationRequest *)soap_instantiate_ns5__RegisterProductionOperationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__RegisterProductionOperationRequest ** p = (ns5__RegisterProductionOperationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__RegisterProductionOperationRequest, sizeof(ns5__RegisterProductionOperationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__RegisterProductionOperationRequest(struct soap *soap, ns5__RegisterProductionOperationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__RegisterProductionOperationRequest);
	return soap_out_PointerTons5__RegisterProductionOperationRequest(soap, tag?tag:"ns5:RegisterProductionOperationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__RegisterProductionOperationRequest ** SOAP_FMAC4 soap_get_PointerTons5__RegisterProductionOperationRequest(struct soap *soap, ns5__RegisterProductionOperationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__RegisterProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__PrepareOutgoingConsignmentResponse(struct soap *soap, ns5__PrepareOutgoingConsignmentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, int id, ns5__PrepareOutgoingConsignmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentResponse ** FASTCALL soap_in_PointerTons5__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, ns5__PrepareOutgoingConsignmentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__PrepareOutgoingConsignmentResponse **)soap_malloc(soap, sizeof(ns5__PrepareOutgoingConsignmentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__PrepareOutgoingConsignmentResponse *)soap_instantiate_ns5__PrepareOutgoingConsignmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__PrepareOutgoingConsignmentResponse ** p = (ns5__PrepareOutgoingConsignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentResponse, sizeof(ns5__PrepareOutgoingConsignmentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__PrepareOutgoingConsignmentResponse(struct soap *soap, ns5__PrepareOutgoingConsignmentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentResponse);
	return soap_out_PointerTons5__PrepareOutgoingConsignmentResponse(soap, tag?tag:"ns5:PrepareOutgoingConsignmentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentResponse ** SOAP_FMAC4 soap_get_PointerTons5__PrepareOutgoingConsignmentResponse(struct soap *soap, ns5__PrepareOutgoingConsignmentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__PrepareOutgoingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__PrepareOutgoingConsignmentRequest(struct soap *soap, ns5__PrepareOutgoingConsignmentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, ns5__PrepareOutgoingConsignmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentRequest ** FASTCALL soap_in_PointerTons5__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, ns5__PrepareOutgoingConsignmentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__PrepareOutgoingConsignmentRequest **)soap_malloc(soap, sizeof(ns5__PrepareOutgoingConsignmentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__PrepareOutgoingConsignmentRequest *)soap_instantiate_ns5__PrepareOutgoingConsignmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__PrepareOutgoingConsignmentRequest ** p = (ns5__PrepareOutgoingConsignmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__PrepareOutgoingConsignmentRequest, sizeof(ns5__PrepareOutgoingConsignmentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__PrepareOutgoingConsignmentRequest(struct soap *soap, ns5__PrepareOutgoingConsignmentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__PrepareOutgoingConsignmentRequest);
	return soap_out_PointerTons5__PrepareOutgoingConsignmentRequest(soap, tag?tag:"ns5:PrepareOutgoingConsignmentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__PrepareOutgoingConsignmentRequest ** SOAP_FMAC4 soap_get_PointerTons5__PrepareOutgoingConsignmentRequest(struct soap *soap, ns5__PrepareOutgoingConsignmentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__PrepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ProcessIncomingConsignmentResponse(struct soap *soap, ns5__ProcessIncomingConsignmentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, int id, ns5__ProcessIncomingConsignmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentResponse ** FASTCALL soap_in_PointerTons5__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, ns5__ProcessIncomingConsignmentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ProcessIncomingConsignmentResponse **)soap_malloc(soap, sizeof(ns5__ProcessIncomingConsignmentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ProcessIncomingConsignmentResponse *)soap_instantiate_ns5__ProcessIncomingConsignmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ProcessIncomingConsignmentResponse ** p = (ns5__ProcessIncomingConsignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ProcessIncomingConsignmentResponse, sizeof(ns5__ProcessIncomingConsignmentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ProcessIncomingConsignmentResponse(struct soap *soap, ns5__ProcessIncomingConsignmentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentResponse);
	return soap_out_PointerTons5__ProcessIncomingConsignmentResponse(soap, tag?tag:"ns5:ProcessIncomingConsignmentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentResponse ** SOAP_FMAC4 soap_get_PointerTons5__ProcessIncomingConsignmentResponse(struct soap *soap, ns5__ProcessIncomingConsignmentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ProcessIncomingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ProcessIncomingConsignmentRequest(struct soap *soap, ns5__ProcessIncomingConsignmentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons5__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, ns5__ProcessIncomingConsignmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentRequest ** FASTCALL soap_in_PointerTons5__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, ns5__ProcessIncomingConsignmentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns5__ProcessIncomingConsignmentRequest **)soap_malloc(soap, sizeof(ns5__ProcessIncomingConsignmentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns5__ProcessIncomingConsignmentRequest *)soap_instantiate_ns5__ProcessIncomingConsignmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns5__ProcessIncomingConsignmentRequest ** p = (ns5__ProcessIncomingConsignmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ProcessIncomingConsignmentRequest, sizeof(ns5__ProcessIncomingConsignmentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ProcessIncomingConsignmentRequest(struct soap *soap, ns5__ProcessIncomingConsignmentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ProcessIncomingConsignmentRequest);
	return soap_out_PointerTons5__ProcessIncomingConsignmentRequest(soap, tag?tag:"ns5:ProcessIncomingConsignmentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ProcessIncomingConsignmentRequest ** SOAP_FMAC4 soap_get_PointerTons5__ProcessIncomingConsignmentRequest(struct soap *soap, ns5__ProcessIncomingConsignmentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons5__ProcessIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__receiveApplicationResultResponse(struct soap *soap, _ns1__receiveApplicationResultResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns1__receiveApplicationResultResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns1__receiveApplicationResultResponse(struct soap *soap, const char *tag, int id, _ns1__receiveApplicationResultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__receiveApplicationResultResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__receiveApplicationResultResponse ** FASTCALL soap_in_PointerTo_ns1__receiveApplicationResultResponse(struct soap *soap, const char *tag, _ns1__receiveApplicationResultResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns1__receiveApplicationResultResponse **)soap_malloc(soap, sizeof(_ns1__receiveApplicationResultResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns1__receiveApplicationResultResponse *)soap_instantiate__ns1__receiveApplicationResultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns1__receiveApplicationResultResponse ** p = (_ns1__receiveApplicationResultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__receiveApplicationResultResponse, sizeof(_ns1__receiveApplicationResultResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__receiveApplicationResultResponse(struct soap *soap, _ns1__receiveApplicationResultResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__receiveApplicationResultResponse);
	return soap_out_PointerTo_ns1__receiveApplicationResultResponse(soap, tag?tag:"ns1:receiveApplicationResultResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__receiveApplicationResultResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__receiveApplicationResultResponse(struct soap *soap, _ns1__receiveApplicationResultResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns1__receiveApplicationResultResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__receiveApplicationResultRequest(struct soap *soap, _ns1__receiveApplicationResultRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns1__receiveApplicationResultRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns1__receiveApplicationResultRequest(struct soap *soap, const char *tag, int id, _ns1__receiveApplicationResultRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__receiveApplicationResultRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__receiveApplicationResultRequest ** FASTCALL soap_in_PointerTo_ns1__receiveApplicationResultRequest(struct soap *soap, const char *tag, _ns1__receiveApplicationResultRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns1__receiveApplicationResultRequest **)soap_malloc(soap, sizeof(_ns1__receiveApplicationResultRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns1__receiveApplicationResultRequest *)soap_instantiate__ns1__receiveApplicationResultRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns1__receiveApplicationResultRequest ** p = (_ns1__receiveApplicationResultRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__receiveApplicationResultRequest, sizeof(_ns1__receiveApplicationResultRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__receiveApplicationResultRequest(struct soap *soap, _ns1__receiveApplicationResultRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__receiveApplicationResultRequest);
	return soap_out_PointerTo_ns1__receiveApplicationResultRequest(soap, tag?tag:"ns1:receiveApplicationResultRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__receiveApplicationResultRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__receiveApplicationResultRequest(struct soap *soap, _ns1__receiveApplicationResultRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns1__receiveApplicationResultRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__submitApplicationResponse(struct soap *soap, _ns1__submitApplicationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns1__submitApplicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns1__submitApplicationResponse(struct soap *soap, const char *tag, int id, _ns1__submitApplicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__submitApplicationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__submitApplicationResponse ** FASTCALL soap_in_PointerTo_ns1__submitApplicationResponse(struct soap *soap, const char *tag, _ns1__submitApplicationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns1__submitApplicationResponse **)soap_malloc(soap, sizeof(_ns1__submitApplicationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns1__submitApplicationResponse *)soap_instantiate__ns1__submitApplicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns1__submitApplicationResponse ** p = (_ns1__submitApplicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__submitApplicationResponse, sizeof(_ns1__submitApplicationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__submitApplicationResponse(struct soap *soap, _ns1__submitApplicationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__submitApplicationResponse);
	return soap_out_PointerTo_ns1__submitApplicationResponse(soap, tag?tag:"ns1:submitApplicationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__submitApplicationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__submitApplicationResponse(struct soap *soap, _ns1__submitApplicationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns1__submitApplicationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__submitApplicationRequest(struct soap *soap, _ns1__submitApplicationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns1__submitApplicationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns1__submitApplicationRequest(struct soap *soap, const char *tag, int id, _ns1__submitApplicationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__submitApplicationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__submitApplicationRequest ** FASTCALL soap_in_PointerTo_ns1__submitApplicationRequest(struct soap *soap, const char *tag, _ns1__submitApplicationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns1__submitApplicationRequest **)soap_malloc(soap, sizeof(_ns1__submitApplicationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns1__submitApplicationRequest *)soap_instantiate__ns1__submitApplicationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns1__submitApplicationRequest ** p = (_ns1__submitApplicationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__submitApplicationRequest, sizeof(_ns1__submitApplicationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__submitApplicationRequest(struct soap *soap, _ns1__submitApplicationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__submitApplicationRequest);
	return soap_out_PointerTo_ns1__submitApplicationRequest(soap, tag?tag:"ns1:submitApplicationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__submitApplicationRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__submitApplicationRequest(struct soap *soap, _ns1__submitApplicationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns1__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FaultInfo(struct soap *soap, ns3__FaultInfo *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__FaultInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__FaultInfo(struct soap *soap, const char *tag, int id, ns3__FaultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__FaultInfo);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__FaultInfo ** FASTCALL soap_in_PointerTons3__FaultInfo(struct soap *soap, const char *tag, ns3__FaultInfo **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns3__FaultInfo **)soap_malloc(soap, sizeof(ns3__FaultInfo *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns3__FaultInfo *)soap_instantiate_ns3__FaultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns3__FaultInfo ** p = (ns3__FaultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__FaultInfo, sizeof(ns3__FaultInfo), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FaultInfo(struct soap *soap, ns3__FaultInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__FaultInfo);
	return soap_out_PointerTons3__FaultInfo(soap, tag?tag:"ns3:FaultInfo", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FaultInfo ** SOAP_FMAC4 soap_get_PointerTons3__FaultInfo(struct soap *soap, ns3__FaultInfo **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__FaultInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__StockEntryBlankFilter(struct soap *soap, enum ns7__StockEntryBlankFilter *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns7__StockEntryBlankFilter);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__StockEntryBlankFilter(struct soap *soap, const char *tag, int id, enum ns7__StockEntryBlankFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__StockEntryBlankFilter);
	return (id < 0) ? soap->error : soap_out_ns7__StockEntryBlankFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns7__StockEntryBlankFilter ** FASTCALL soap_in_PointerTons7__StockEntryBlankFilter(struct soap *soap, const char *tag, enum ns7__StockEntryBlankFilter **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns7__StockEntryBlankFilter **)soap_malloc(soap, sizeof(enum ns7__StockEntryBlankFilter *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__StockEntryBlankFilter(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns7__StockEntryBlankFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockEntryBlankFilter, sizeof(enum ns7__StockEntryBlankFilter), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__StockEntryBlankFilter(struct soap *soap, enum ns7__StockEntryBlankFilter *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__StockEntryBlankFilter);
	return soap_out_PointerTons7__StockEntryBlankFilter(soap, tag?tag:"ns7:StockEntryBlankFilter", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__StockEntryBlankFilter ** SOAP_FMAC4 soap_get_PointerTons7__StockEntryBlankFilter(struct soap *soap, enum ns7__StockEntryBlankFilter **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__StockEntryBlankFilter(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__StockEntryEventList(struct soap *soap, ns7__StockEntryEventList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__StockEntryEventList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__StockEntryEventList(struct soap *soap, const char *tag, int id, ns7__StockEntryEventList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__StockEntryEventList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__StockEntryEventList ** FASTCALL soap_in_PointerTons7__StockEntryEventList(struct soap *soap, const char *tag, ns7__StockEntryEventList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockEntryEventList **)soap_malloc(soap, sizeof(ns7__StockEntryEventList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__StockEntryEventList *)soap_instantiate_ns7__StockEntryEventList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__StockEntryEventList ** p = (ns7__StockEntryEventList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockEntryEventList, sizeof(ns7__StockEntryEventList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__StockEntryEventList(struct soap *soap, ns7__StockEntryEventList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__StockEntryEventList);
	return soap_out_PointerTons7__StockEntryEventList(soap, tag?tag:"ns7:StockEntryEventList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockEntryEventList ** SOAP_FMAC4 soap_get_PointerTons7__StockEntryEventList(struct soap *soap, ns7__StockEntryEventList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__StockEntryEventList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__DiscrepancyReason(struct soap *soap, ns7__DiscrepancyReason *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__DiscrepancyReason))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__DiscrepancyReason(struct soap *soap, const char *tag, int id, ns7__DiscrepancyReason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__DiscrepancyReason);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__DiscrepancyReason ** FASTCALL soap_in_PointerTons7__DiscrepancyReason(struct soap *soap, const char *tag, ns7__DiscrepancyReason **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__DiscrepancyReason **)soap_malloc(soap, sizeof(ns7__DiscrepancyReason *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__DiscrepancyReason *)soap_instantiate_ns7__DiscrepancyReason(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__DiscrepancyReason ** p = (ns7__DiscrepancyReason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__DiscrepancyReason, sizeof(ns7__DiscrepancyReason), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__DiscrepancyReason(struct soap *soap, ns7__DiscrepancyReason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__DiscrepancyReason);
	return soap_out_PointerTons7__DiscrepancyReason(soap, tag?tag:"ns7:DiscrepancyReason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__DiscrepancyReason ** SOAP_FMAC4 soap_get_PointerTons7__DiscrepancyReason(struct soap *soap, ns7__DiscrepancyReason **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__DiscrepancyReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__VetDocumentStatusChange))
		soap_serialize_PointerTons7__VetDocumentStatusChange(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, ns7__VetDocumentStatusChange **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__VetDocumentStatusChange);
	return (id < 0) ? soap->error : soap_out_PointerTons7__VetDocumentStatusChange(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__VetDocumentStatusChange *** FASTCALL soap_in_PointerToPointerTons7__VetDocumentStatusChange(struct soap *soap, const char *tag, ns7__VetDocumentStatusChange ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VetDocumentStatusChange ***)soap_malloc(soap, sizeof(ns7__VetDocumentStatusChange **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__VetDocumentStatusChange(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__VetDocumentStatusChange ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__VetDocumentStatusChange, sizeof(ns7__VetDocumentStatusChange *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__VetDocumentStatusChange);
	return soap_out_PointerToPointerTons7__VetDocumentStatusChange(soap, tag?tag:"ns7:VetDocumentStatusChange", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VetDocumentStatusChange *** SOAP_FMAC4 soap_get_PointerToPointerTons7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__VetDocumentStatusChange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, ns7__VetDocumentStatusChange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VetDocumentStatusChange);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__VetDocumentStatusChange ** FASTCALL soap_in_PointerTons7__VetDocumentStatusChange(struct soap *soap, const char *tag, ns7__VetDocumentStatusChange **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VetDocumentStatusChange **)soap_malloc(soap, sizeof(ns7__VetDocumentStatusChange *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__VetDocumentStatusChange *)soap_instantiate_ns7__VetDocumentStatusChange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__VetDocumentStatusChange ** p = (ns7__VetDocumentStatusChange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocumentStatusChange, sizeof(ns7__VetDocumentStatusChange), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VetDocumentStatusChange);
	return soap_out_PointerTons7__VetDocumentStatusChange(soap, tag?tag:"ns7:VetDocumentStatusChange", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VetDocumentStatusChange ** SOAP_FMAC4 soap_get_PointerTons7__VetDocumentStatusChange(struct soap *soap, ns7__VetDocumentStatusChange **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VeterinaryAuthentication(struct soap *soap, ns7__VeterinaryAuthentication *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__VeterinaryAuthentication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VeterinaryAuthentication(struct soap *soap, const char *tag, int id, ns7__VeterinaryAuthentication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VeterinaryAuthentication);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__VeterinaryAuthentication ** FASTCALL soap_in_PointerTons7__VeterinaryAuthentication(struct soap *soap, const char *tag, ns7__VeterinaryAuthentication **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VeterinaryAuthentication **)soap_malloc(soap, sizeof(ns7__VeterinaryAuthentication *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__VeterinaryAuthentication *)soap_instantiate_ns7__VeterinaryAuthentication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__VeterinaryAuthentication ** p = (ns7__VeterinaryAuthentication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VeterinaryAuthentication, sizeof(ns7__VeterinaryAuthentication), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VeterinaryAuthentication(struct soap *soap, ns7__VeterinaryAuthentication *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VeterinaryAuthentication);
	return soap_out_PointerTons7__VeterinaryAuthentication(soap, tag?tag:"ns7:VeterinaryAuthentication", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VeterinaryAuthentication ** SOAP_FMAC4 soap_get_PointerTons7__VeterinaryAuthentication(struct soap *soap, ns7__VeterinaryAuthentication **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VeterinaryAuthentication(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__CertifiedConsignment(struct soap *soap, ns7__CertifiedConsignment *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__CertifiedConsignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__CertifiedConsignment(struct soap *soap, const char *tag, int id, ns7__CertifiedConsignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__CertifiedConsignment);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__CertifiedConsignment ** FASTCALL soap_in_PointerTons7__CertifiedConsignment(struct soap *soap, const char *tag, ns7__CertifiedConsignment **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__CertifiedConsignment **)soap_malloc(soap, sizeof(ns7__CertifiedConsignment *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__CertifiedConsignment *)soap_instantiate_ns7__CertifiedConsignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__CertifiedConsignment ** p = (ns7__CertifiedConsignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__CertifiedConsignment, sizeof(ns7__CertifiedConsignment), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__CertifiedConsignment(struct soap *soap, ns7__CertifiedConsignment *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__CertifiedConsignment);
	return soap_out_PointerTons7__CertifiedConsignment(soap, tag?tag:"ns7:CertifiedConsignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__CertifiedConsignment ** SOAP_FMAC4 soap_get_PointerTons7__CertifiedConsignment(struct soap *soap, ns7__CertifiedConsignment **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__CertifiedConsignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__CertifiedBatch(struct soap *soap, ns7__CertifiedBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__CertifiedBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__CertifiedBatch(struct soap *soap, const char *tag, int id, ns7__CertifiedBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__CertifiedBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__CertifiedBatch ** FASTCALL soap_in_PointerTons7__CertifiedBatch(struct soap *soap, const char *tag, ns7__CertifiedBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__CertifiedBatch **)soap_malloc(soap, sizeof(ns7__CertifiedBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__CertifiedBatch *)soap_instantiate_ns7__CertifiedBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__CertifiedBatch ** p = (ns7__CertifiedBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__CertifiedBatch, sizeof(ns7__CertifiedBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__CertifiedBatch(struct soap *soap, ns7__CertifiedBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__CertifiedBatch);
	return soap_out_PointerTons7__CertifiedBatch(soap, tag?tag:"ns7:CertifiedBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__CertifiedBatch ** SOAP_FMAC4 soap_get_PointerTons7__CertifiedBatch(struct soap *soap, ns7__CertifiedBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__CertifiedBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VetDocumentForm(struct soap *soap, enum ns7__VetDocumentForm *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns7__VetDocumentForm);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VetDocumentForm(struct soap *soap, const char *tag, int id, enum ns7__VetDocumentForm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VetDocumentForm);
	return (id < 0) ? soap->error : soap_out_ns7__VetDocumentForm(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns7__VetDocumentForm ** FASTCALL soap_in_PointerTons7__VetDocumentForm(struct soap *soap, const char *tag, enum ns7__VetDocumentForm **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns7__VetDocumentForm **)soap_malloc(soap, sizeof(enum ns7__VetDocumentForm *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__VetDocumentForm(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns7__VetDocumentForm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocumentForm, sizeof(enum ns7__VetDocumentForm), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VetDocumentForm(struct soap *soap, enum ns7__VetDocumentForm *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VetDocumentForm);
	return soap_out_PointerTons7__VetDocumentForm(soap, tag?tag:"ns7:VetDocumentForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VetDocumentForm ** SOAP_FMAC4 soap_get_PointerTons7__VetDocumentForm(struct soap *soap, enum ns7__VetDocumentForm **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VetDocumentForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__RegionalizationStatus))
		soap_serialize_PointerTons6__RegionalizationStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__RegionalizationStatus(struct soap *soap, const char *tag, int id, ns6__RegionalizationStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__RegionalizationStatus);
	return (id < 0) ? soap->error : soap_out_PointerTons6__RegionalizationStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__RegionalizationStatus *** FASTCALL soap_in_PointerToPointerTons6__RegionalizationStatus(struct soap *soap, const char *tag, ns6__RegionalizationStatus ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationStatus ***)soap_malloc(soap, sizeof(ns6__RegionalizationStatus **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__RegionalizationStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__RegionalizationStatus, sizeof(ns6__RegionalizationStatus *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__RegionalizationStatus);
	return soap_out_PointerToPointerTons6__RegionalizationStatus(soap, tag?tag:"ns6:RegionalizationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationStatus *** SOAP_FMAC4 soap_get_PointerToPointerTons6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Area(struct soap *soap, ns6__Area **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Area))
		soap_serialize_PointerTons6__Area(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Area(struct soap *soap, const char *tag, int id, ns6__Area **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Area);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Area(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Area *** FASTCALL soap_in_PointerToPointerTons6__Area(struct soap *soap, const char *tag, ns6__Area ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Area ***)soap_malloc(soap, sizeof(ns6__Area **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Area(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Area ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Area, sizeof(ns6__Area *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Area(struct soap *soap, ns6__Area **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Area);
	return soap_out_PointerToPointerTons6__Area(soap, tag?tag:"ns6:Area", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Area *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Area(struct soap *soap, ns6__Area ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__RegionalizationRequirement))
		soap_serialize_PointerTons6__RegionalizationRequirement(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__RegionalizationRequirement(struct soap *soap, const char *tag, int id, ns6__RegionalizationRequirement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__RegionalizationRequirement);
	return (id < 0) ? soap->error : soap_out_PointerTons6__RegionalizationRequirement(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__RegionalizationRequirement *** FASTCALL soap_in_PointerToPointerTons6__RegionalizationRequirement(struct soap *soap, const char *tag, ns6__RegionalizationRequirement ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationRequirement ***)soap_malloc(soap, sizeof(ns6__RegionalizationRequirement **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__RegionalizationRequirement(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationRequirement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__RegionalizationRequirement, sizeof(ns6__RegionalizationRequirement *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__RegionalizationRequirement);
	return soap_out_PointerToPointerTons6__RegionalizationRequirement(soap, tag?tag:"ns6:RegionalizationRequirement", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationRequirement *** SOAP_FMAC4 soap_get_PointerToPointerTons6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationRequirement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationRequirement(struct soap *soap, const char *tag, int id, ns6__RegionalizationRequirement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationRequirement);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationRequirement ** FASTCALL soap_in_PointerTons6__RegionalizationRequirement(struct soap *soap, const char *tag, ns6__RegionalizationRequirement **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationRequirement **)soap_malloc(soap, sizeof(ns6__RegionalizationRequirement *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationRequirement *)soap_instantiate_ns6__RegionalizationRequirement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationRequirement ** p = (ns6__RegionalizationRequirement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationRequirement, sizeof(ns6__RegionalizationRequirement), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationRequirement);
	return soap_out_PointerTons6__RegionalizationRequirement(soap, tag?tag:"ns6:RegionalizationRequirement", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationRequirement ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationRequirement(struct soap *soap, ns6__RegionalizationRequirement **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationDecision(struct soap *soap, enum ns6__RegionalizationDecision *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationDecision);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationDecision(struct soap *soap, const char *tag, int id, enum ns6__RegionalizationDecision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationDecision);
	return (id < 0) ? soap->error : soap_out_ns6__RegionalizationDecision(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__RegionalizationDecision ** FASTCALL soap_in_PointerTons6__RegionalizationDecision(struct soap *soap, const char *tag, enum ns6__RegionalizationDecision **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__RegionalizationDecision **)soap_malloc(soap, sizeof(enum ns6__RegionalizationDecision *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__RegionalizationDecision(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__RegionalizationDecision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationDecision, sizeof(enum ns6__RegionalizationDecision), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationDecision(struct soap *soap, enum ns6__RegionalizationDecision *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationDecision);
	return soap_out_PointerTons6__RegionalizationDecision(soap, tag?tag:"ns6:RegionalizationDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__RegionalizationDecision ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationDecision(struct soap *soap, enum ns6__RegionalizationDecision **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationStatus(struct soap *soap, const char *tag, int id, ns6__RegionalizationStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationStatus);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationStatus ** FASTCALL soap_in_PointerTons6__RegionalizationStatus(struct soap *soap, const char *tag, ns6__RegionalizationStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationStatus **)soap_malloc(soap, sizeof(ns6__RegionalizationStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationStatus *)soap_instantiate_ns6__RegionalizationStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationStatus ** p = (ns6__RegionalizationStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationStatus, sizeof(ns6__RegionalizationStatus), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationStatus);
	return soap_out_PointerTons6__RegionalizationStatus(soap, tag?tag:"ns6:RegionalizationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationStatus ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationStatus(struct soap *soap, ns6__RegionalizationStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Packaging(struct soap *soap, ns6__Packaging *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Packaging))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Packaging(struct soap *soap, const char *tag, int id, ns6__Packaging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Packaging);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Packaging ** FASTCALL soap_in_PointerTons6__Packaging(struct soap *soap, const char *tag, ns6__Packaging **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Packaging **)soap_malloc(soap, sizeof(ns6__Packaging *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Packaging *)soap_instantiate_ns6__Packaging(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Packaging ** p = (ns6__Packaging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Packaging, sizeof(ns6__Packaging), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Packaging(struct soap *soap, ns6__Packaging *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Packaging);
	return soap_out_PointerTons6__Packaging(soap, tag?tag:"ns6:Packaging", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Packaging ** SOAP_FMAC4 soap_get_PointerTons6__Packaging(struct soap *soap, ns6__Packaging **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Packaging(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__ProductItemProducing))
		soap_serialize_PointerTons6__ProductItemProducing(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__ProductItemProducing(struct soap *soap, const char *tag, int id, ns6__ProductItemProducing **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__ProductItemProducing);
	return (id < 0) ? soap->error : soap_out_PointerTons6__ProductItemProducing(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__ProductItemProducing *** FASTCALL soap_in_PointerToPointerTons6__ProductItemProducing(struct soap *soap, const char *tag, ns6__ProductItemProducing ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductItemProducing ***)soap_malloc(soap, sizeof(ns6__ProductItemProducing **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__ProductItemProducing(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__ProductItemProducing ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__ProductItemProducing, sizeof(ns6__ProductItemProducing *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__ProductItemProducing);
	return soap_out_PointerToPointerTons6__ProductItemProducing(soap, tag?tag:"ns6:ProductItemProducing", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductItemProducing *** SOAP_FMAC4 soap_get_PointerToPointerTons6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ProductItemProducing))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ProductItemProducing(struct soap *soap, const char *tag, int id, ns6__ProductItemProducing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProductItemProducing);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ProductItemProducing ** FASTCALL soap_in_PointerTons6__ProductItemProducing(struct soap *soap, const char *tag, ns6__ProductItemProducing **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductItemProducing **)soap_malloc(soap, sizeof(ns6__ProductItemProducing *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ProductItemProducing *)soap_instantiate_ns6__ProductItemProducing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ProductItemProducing ** p = (ns6__ProductItemProducing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProductItemProducing, sizeof(ns6__ProductItemProducing), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ProductItemProducing);
	return soap_out_PointerTons6__ProductItemProducing(soap, tag?tag:"ns6:ProductItemProducing", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductItemProducing ** SOAP_FMAC4 soap_get_PointerTons6__ProductItemProducing(struct soap *soap, ns6__ProductItemProducing **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__BusinessEntity_activityLocation(struct soap *soap, _ns6__BusinessEntity_activityLocation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns6__BusinessEntity_activityLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns6__BusinessEntity_activityLocation(struct soap *soap, const char *tag, int id, _ns6__BusinessEntity_activityLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__BusinessEntity_activityLocation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__BusinessEntity_activityLocation ** FASTCALL soap_in_PointerTo_ns6__BusinessEntity_activityLocation(struct soap *soap, const char *tag, _ns6__BusinessEntity_activityLocation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns6__BusinessEntity_activityLocation **)soap_malloc(soap, sizeof(_ns6__BusinessEntity_activityLocation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns6__BusinessEntity_activityLocation *)soap_instantiate__ns6__BusinessEntity_activityLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns6__BusinessEntity_activityLocation ** p = (_ns6__BusinessEntity_activityLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__BusinessEntity_activityLocation, sizeof(_ns6__BusinessEntity_activityLocation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__BusinessEntity_activityLocation(struct soap *soap, _ns6__BusinessEntity_activityLocation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__BusinessEntity_activityLocation);
	return soap_out_PointerTo_ns6__BusinessEntity_activityLocation(soap, tag?tag:"ns6:BusinessEntity-activityLocation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns6__BusinessEntity_activityLocation ** SOAP_FMAC4 soap_get_PointerTo_ns6__BusinessEntity_activityLocation(struct soap *soap, _ns6__BusinessEntity_activityLocation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns6__BusinessEntity_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__IncorporationForm(struct soap *soap, ns6__IncorporationForm *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__IncorporationForm))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__IncorporationForm(struct soap *soap, const char *tag, int id, ns6__IncorporationForm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__IncorporationForm);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__IncorporationForm ** FASTCALL soap_in_PointerTons6__IncorporationForm(struct soap *soap, const char *tag, ns6__IncorporationForm **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__IncorporationForm **)soap_malloc(soap, sizeof(ns6__IncorporationForm *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__IncorporationForm *)soap_instantiate_ns6__IncorporationForm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__IncorporationForm ** p = (ns6__IncorporationForm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__IncorporationForm, sizeof(ns6__IncorporationForm), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__IncorporationForm(struct soap *soap, ns6__IncorporationForm *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__IncorporationForm);
	return soap_out_PointerTons6__IncorporationForm(soap, tag?tag:"ns6:IncorporationForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__IncorporationForm ** SOAP_FMAC4 soap_get_PointerTons6__IncorporationForm(struct soap *soap, ns6__IncorporationForm **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__IncorporationForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__BusinessEntityType(struct soap *soap, enum ns6__BusinessEntityType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__BusinessEntityType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__BusinessEntityType(struct soap *soap, const char *tag, int id, enum ns6__BusinessEntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__BusinessEntityType);
	return (id < 0) ? soap->error : soap_out_ns6__BusinessEntityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__BusinessEntityType ** FASTCALL soap_in_PointerTons6__BusinessEntityType(struct soap *soap, const char *tag, enum ns6__BusinessEntityType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__BusinessEntityType **)soap_malloc(soap, sizeof(enum ns6__BusinessEntityType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__BusinessEntityType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__BusinessEntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__BusinessEntityType, sizeof(enum ns6__BusinessEntityType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__BusinessEntityType(struct soap *soap, enum ns6__BusinessEntityType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__BusinessEntityType);
	return soap_out_PointerTons6__BusinessEntityType(soap, tag?tag:"ns6:BusinessEntityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__BusinessEntityType ** SOAP_FMAC4 soap_get_PointerTons6__BusinessEntityType(struct soap *soap, enum ns6__BusinessEntityType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__BusinessEntityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration))
		soap_serialize_PointerTons6__EnterpriseOfficialRegistration(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, ns6__EnterpriseOfficialRegistration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration);
	return (id < 0) ? soap->error : soap_out_PointerTons6__EnterpriseOfficialRegistration(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__EnterpriseOfficialRegistration *** FASTCALL soap_in_PointerToPointerTons6__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, ns6__EnterpriseOfficialRegistration ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseOfficialRegistration ***)soap_malloc(soap, sizeof(ns6__EnterpriseOfficialRegistration **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__EnterpriseOfficialRegistration(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseOfficialRegistration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration, sizeof(ns6__EnterpriseOfficialRegistration *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__EnterpriseOfficialRegistration);
	return soap_out_PointerToPointerTons6__EnterpriseOfficialRegistration(soap, tag?tag:"ns6:EnterpriseOfficialRegistration", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseOfficialRegistration *** SOAP_FMAC4 soap_get_PointerToPointerTons6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseOfficialRegistration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, ns6__EnterpriseOfficialRegistration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseOfficialRegistration);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__EnterpriseOfficialRegistration ** FASTCALL soap_in_PointerTons6__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, ns6__EnterpriseOfficialRegistration **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseOfficialRegistration **)soap_malloc(soap, sizeof(ns6__EnterpriseOfficialRegistration *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__EnterpriseOfficialRegistration *)soap_instantiate_ns6__EnterpriseOfficialRegistration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__EnterpriseOfficialRegistration ** p = (ns6__EnterpriseOfficialRegistration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseOfficialRegistration, sizeof(ns6__EnterpriseOfficialRegistration), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseOfficialRegistration);
	return soap_out_PointerTons6__EnterpriseOfficialRegistration(soap, tag?tag:"ns6:EnterpriseOfficialRegistration", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseOfficialRegistration ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseOfficialRegistration(struct soap *soap, ns6__EnterpriseOfficialRegistration **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseActivityList(struct soap *soap, ns6__EnterpriseActivityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseActivityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseActivityList(struct soap *soap, const char *tag, int id, ns6__EnterpriseActivityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseActivityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__EnterpriseActivityList ** FASTCALL soap_in_PointerTons6__EnterpriseActivityList(struct soap *soap, const char *tag, ns6__EnterpriseActivityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseActivityList **)soap_malloc(soap, sizeof(ns6__EnterpriseActivityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__EnterpriseActivityList *)soap_instantiate_ns6__EnterpriseActivityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__EnterpriseActivityList ** p = (ns6__EnterpriseActivityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseActivityList, sizeof(ns6__EnterpriseActivityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseActivityList(struct soap *soap, ns6__EnterpriseActivityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseActivityList);
	return soap_out_PointerTons6__EnterpriseActivityList(soap, tag?tag:"ns6:EnterpriseActivityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseActivityList ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseActivityList(struct soap *soap, ns6__EnterpriseActivityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseActivityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseNumberList(struct soap *soap, ns6__EnterpriseNumberList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseNumberList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseNumberList(struct soap *soap, const char *tag, int id, ns6__EnterpriseNumberList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseNumberList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__EnterpriseNumberList ** FASTCALL soap_in_PointerTons6__EnterpriseNumberList(struct soap *soap, const char *tag, ns6__EnterpriseNumberList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseNumberList **)soap_malloc(soap, sizeof(ns6__EnterpriseNumberList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__EnterpriseNumberList *)soap_instantiate_ns6__EnterpriseNumberList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__EnterpriseNumberList ** p = (ns6__EnterpriseNumberList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseNumberList, sizeof(ns6__EnterpriseNumberList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseNumberList(struct soap *soap, ns6__EnterpriseNumberList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseNumberList);
	return soap_out_PointerTons6__EnterpriseNumberList(soap, tag?tag:"ns6:EnterpriseNumberList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseNumberList ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseNumberList(struct soap *soap, ns6__EnterpriseNumberList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseNumberList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseType))
		soap_serialize_ns6__EnterpriseType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseType);
	return (id < 0) ? soap->error : soap_out_ns6__EnterpriseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons6__EnterpriseType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__EnterpriseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseType);
	return soap_out_PointerTons6__EnterpriseType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__PackingCodeType(struct soap *soap, enum ns6__PackingCodeType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__PackingCodeType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__PackingCodeType(struct soap *soap, const char *tag, int id, enum ns6__PackingCodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__PackingCodeType);
	return (id < 0) ? soap->error : soap_out_ns6__PackingCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__PackingCodeType ** FASTCALL soap_in_PointerTons6__PackingCodeType(struct soap *soap, const char *tag, enum ns6__PackingCodeType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__PackingCodeType **)soap_malloc(soap, sizeof(enum ns6__PackingCodeType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__PackingCodeType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__PackingCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__PackingCodeType, sizeof(enum ns6__PackingCodeType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__PackingCodeType(struct soap *soap, enum ns6__PackingCodeType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__PackingCodeType);
	return soap_out_PointerTons6__PackingCodeType(soap, tag?tag:"ns6:PackingCodeType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__PackingCodeType ** SOAP_FMAC4 soap_get_PointerTons6__PackingCodeType(struct soap *soap, enum ns6__PackingCodeType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__PackingCodeType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__UUID(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__UUID))
		soap_serialize_ns3__UUID(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__UUID(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__UUID);
	return (id < 0) ? soap->error : soap_out_ns3__UUID(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__UUID(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__UUID(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__UUID, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__UUID(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__UUID);
	return soap_out_PointerTons3__UUID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__UUID(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__UUID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__StockEntrySearchPattern(struct soap *soap, ns7__StockEntrySearchPattern *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__StockEntrySearchPattern))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__StockEntrySearchPattern(struct soap *soap, const char *tag, int id, ns7__StockEntrySearchPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__StockEntrySearchPattern);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__StockEntrySearchPattern ** FASTCALL soap_in_PointerTons7__StockEntrySearchPattern(struct soap *soap, const char *tag, ns7__StockEntrySearchPattern **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockEntrySearchPattern **)soap_malloc(soap, sizeof(ns7__StockEntrySearchPattern *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__StockEntrySearchPattern *)soap_instantiate_ns7__StockEntrySearchPattern(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__StockEntrySearchPattern ** p = (ns7__StockEntrySearchPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockEntrySearchPattern, sizeof(ns7__StockEntrySearchPattern), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__StockEntrySearchPattern(struct soap *soap, ns7__StockEntrySearchPattern *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__StockEntrySearchPattern);
	return soap_out_PointerTons7__StockEntrySearchPattern(soap, tag?tag:"ns7:StockEntrySearchPattern", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockEntrySearchPattern ** SOAP_FMAC4 soap_get_PointerTons7__StockEntrySearchPattern(struct soap *soap, ns7__StockEntrySearchPattern **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__StockEntrySearchPattern(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VetDocumentStatus(struct soap *soap, enum ns7__VetDocumentStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns7__VetDocumentStatus);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VetDocumentStatus(struct soap *soap, const char *tag, int id, enum ns7__VetDocumentStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VetDocumentStatus);
	return (id < 0) ? soap->error : soap_out_ns7__VetDocumentStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns7__VetDocumentStatus ** FASTCALL soap_in_PointerTons7__VetDocumentStatus(struct soap *soap, const char *tag, enum ns7__VetDocumentStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns7__VetDocumentStatus **)soap_malloc(soap, sizeof(enum ns7__VetDocumentStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__VetDocumentStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns7__VetDocumentStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocumentStatus, sizeof(enum ns7__VetDocumentStatus), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VetDocumentStatus(struct soap *soap, enum ns7__VetDocumentStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VetDocumentStatus);
	return soap_out_PointerTons7__VetDocumentStatus(soap, tag?tag:"ns7:VetDocumentStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VetDocumentStatus ** SOAP_FMAC4 soap_get_PointerTons7__VetDocumentStatus(struct soap *soap, enum ns7__VetDocumentStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VetDocumentStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VetDocumentType(struct soap *soap, enum ns7__VetDocumentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns7__VetDocumentType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VetDocumentType(struct soap *soap, const char *tag, int id, enum ns7__VetDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VetDocumentType);
	return (id < 0) ? soap->error : soap_out_ns7__VetDocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns7__VetDocumentType ** FASTCALL soap_in_PointerTons7__VetDocumentType(struct soap *soap, const char *tag, enum ns7__VetDocumentType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns7__VetDocumentType **)soap_malloc(soap, sizeof(enum ns7__VetDocumentType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__VetDocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns7__VetDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocumentType, sizeof(enum ns7__VetDocumentType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VetDocumentType(struct soap *soap, enum ns7__VetDocumentType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VetDocumentType);
	return soap_out_PointerTons7__VetDocumentType(soap, tag?tag:"ns7:VetDocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VetDocumentType ** SOAP_FMAC4 soap_get_PointerTons7__VetDocumentType(struct soap *soap, enum ns7__VetDocumentType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VetDocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__PSLModificationOperation(struct soap *soap, ns7__PSLModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__PSLModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__PSLModificationOperation(struct soap *soap, const char *tag, int id, ns7__PSLModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__PSLModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__PSLModificationOperation ** FASTCALL soap_in_PointerTons7__PSLModificationOperation(struct soap *soap, const char *tag, ns7__PSLModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__PSLModificationOperation **)soap_malloc(soap, sizeof(ns7__PSLModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__PSLModificationOperation *)soap_instantiate_ns7__PSLModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__PSLModificationOperation ** p = (ns7__PSLModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__PSLModificationOperation, sizeof(ns7__PSLModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__PSLModificationOperation(struct soap *soap, ns7__PSLModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__PSLModificationOperation);
	return soap_out_PointerTons7__PSLModificationOperation(soap, tag?tag:"ns7:PSLModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__PSLModificationOperation ** SOAP_FMAC4 soap_get_PointerTons7__PSLModificationOperation(struct soap *soap, ns7__PSLModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__PSLModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__StockDiscrepancy))
		soap_serialize_PointerTons7__StockDiscrepancy(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__StockDiscrepancy(struct soap *soap, const char *tag, int id, ns7__StockDiscrepancy **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__StockDiscrepancy);
	return (id < 0) ? soap->error : soap_out_PointerTons7__StockDiscrepancy(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__StockDiscrepancy *** FASTCALL soap_in_PointerToPointerTons7__StockDiscrepancy(struct soap *soap, const char *tag, ns7__StockDiscrepancy ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockDiscrepancy ***)soap_malloc(soap, sizeof(ns7__StockDiscrepancy **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__StockDiscrepancy(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__StockDiscrepancy ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__StockDiscrepancy, sizeof(ns7__StockDiscrepancy *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__StockDiscrepancy);
	return soap_out_PointerToPointerTons7__StockDiscrepancy(soap, tag?tag:"ns7:StockDiscrepancy", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockDiscrepancy *** SOAP_FMAC4 soap_get_PointerToPointerTons7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__StockDiscrepancy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__StockDiscrepancy(struct soap *soap, const char *tag, int id, ns7__StockDiscrepancy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__StockDiscrepancy);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__StockDiscrepancy ** FASTCALL soap_in_PointerTons7__StockDiscrepancy(struct soap *soap, const char *tag, ns7__StockDiscrepancy **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockDiscrepancy **)soap_malloc(soap, sizeof(ns7__StockDiscrepancy *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__StockDiscrepancy *)soap_instantiate_ns7__StockDiscrepancy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__StockDiscrepancy ** p = (ns7__StockDiscrepancy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockDiscrepancy, sizeof(ns7__StockDiscrepancy), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__StockDiscrepancy);
	return soap_out_PointerTons7__StockDiscrepancy(soap, tag?tag:"ns7:StockDiscrepancy", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockDiscrepancy ** SOAP_FMAC4 soap_get_PointerTons7__StockDiscrepancy(struct soap *soap, ns7__StockDiscrepancy **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__BEActivityLocationsModificationOperation(struct soap *soap, ns7__BEActivityLocationsModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, int id, ns7__BEActivityLocationsModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__BEActivityLocationsModificationOperation ** FASTCALL soap_in_PointerTons7__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, ns7__BEActivityLocationsModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__BEActivityLocationsModificationOperation **)soap_malloc(soap, sizeof(ns7__BEActivityLocationsModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__BEActivityLocationsModificationOperation *)soap_instantiate_ns7__BEActivityLocationsModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__BEActivityLocationsModificationOperation ** p = (ns7__BEActivityLocationsModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__BEActivityLocationsModificationOperation, sizeof(ns7__BEActivityLocationsModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__BEActivityLocationsModificationOperation(struct soap *soap, ns7__BEActivityLocationsModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__BEActivityLocationsModificationOperation);
	return soap_out_PointerTons7__BEActivityLocationsModificationOperation(soap, tag?tag:"ns7:BEActivityLocationsModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__BEActivityLocationsModificationOperation ** SOAP_FMAC4 soap_get_PointerTons7__BEActivityLocationsModificationOperation(struct soap *soap, ns7__BEActivityLocationsModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__BEActivityLocationsModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ENTModificationOperation(struct soap *soap, ns7__ENTModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ENTModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ENTModificationOperation(struct soap *soap, const char *tag, int id, ns7__ENTModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ENTModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ENTModificationOperation ** FASTCALL soap_in_PointerTons7__ENTModificationOperation(struct soap *soap, const char *tag, ns7__ENTModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ENTModificationOperation **)soap_malloc(soap, sizeof(ns7__ENTModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ENTModificationOperation *)soap_instantiate_ns7__ENTModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ENTModificationOperation ** p = (ns7__ENTModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ENTModificationOperation, sizeof(ns7__ENTModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ENTModificationOperation(struct soap *soap, ns7__ENTModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ENTModificationOperation);
	return soap_out_PointerTons7__ENTModificationOperation(soap, tag?tag:"ns7:ENTModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ENTModificationOperation ** SOAP_FMAC4 soap_get_PointerTons7__ENTModificationOperation(struct soap *soap, ns7__ENTModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ENTModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__BEModificationOperation(struct soap *soap, ns7__BEModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__BEModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__BEModificationOperation(struct soap *soap, const char *tag, int id, ns7__BEModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__BEModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__BEModificationOperation ** FASTCALL soap_in_PointerTons7__BEModificationOperation(struct soap *soap, const char *tag, ns7__BEModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__BEModificationOperation **)soap_malloc(soap, sizeof(ns7__BEModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__BEModificationOperation *)soap_instantiate_ns7__BEModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__BEModificationOperation ** p = (ns7__BEModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__BEModificationOperation, sizeof(ns7__BEModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__BEModificationOperation(struct soap *soap, ns7__BEModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__BEModificationOperation);
	return soap_out_PointerTons7__BEModificationOperation(soap, tag?tag:"ns7:BEModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__BEModificationOperation ** SOAP_FMAC4 soap_get_PointerTons7__BEModificationOperation(struct soap *soap, ns7__BEModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__BEModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__MergeStockEntriesOperation(struct soap *soap, ns7__MergeStockEntriesOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__MergeStockEntriesOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__MergeStockEntriesOperation(struct soap *soap, const char *tag, int id, ns7__MergeStockEntriesOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__MergeStockEntriesOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__MergeStockEntriesOperation ** FASTCALL soap_in_PointerTons7__MergeStockEntriesOperation(struct soap *soap, const char *tag, ns7__MergeStockEntriesOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__MergeStockEntriesOperation **)soap_malloc(soap, sizeof(ns7__MergeStockEntriesOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__MergeStockEntriesOperation *)soap_instantiate_ns7__MergeStockEntriesOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__MergeStockEntriesOperation ** p = (ns7__MergeStockEntriesOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__MergeStockEntriesOperation, sizeof(ns7__MergeStockEntriesOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__MergeStockEntriesOperation(struct soap *soap, ns7__MergeStockEntriesOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__MergeStockEntriesOperation);
	return soap_out_PointerTons7__MergeStockEntriesOperation(soap, tag?tag:"ns7:MergeStockEntriesOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__MergeStockEntriesOperation ** SOAP_FMAC4 soap_get_PointerTons7__MergeStockEntriesOperation(struct soap *soap, ns7__MergeStockEntriesOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__MergeStockEntriesOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ProductionOperation(struct soap *soap, ns7__ProductionOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ProductionOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ProductionOperation(struct soap *soap, const char *tag, int id, ns7__ProductionOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ProductionOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ProductionOperation ** FASTCALL soap_in_PointerTons7__ProductionOperation(struct soap *soap, const char *tag, ns7__ProductionOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ProductionOperation **)soap_malloc(soap, sizeof(ns7__ProductionOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ProductionOperation *)soap_instantiate_ns7__ProductionOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ProductionOperation ** p = (ns7__ProductionOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ProductionOperation, sizeof(ns7__ProductionOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ProductionOperation(struct soap *soap, ns7__ProductionOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ProductionOperation);
	return soap_out_PointerTons7__ProductionOperation(soap, tag?tag:"ns7:ProductionOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ProductionOperation ** SOAP_FMAC4 soap_get_PointerTons7__ProductionOperation(struct soap *soap, ns7__ProductionOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ProductionOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__Delivery(struct soap *soap, ns7__Delivery **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__Delivery))
		soap_serialize_PointerTons7__Delivery(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__Delivery(struct soap *soap, const char *tag, int id, ns7__Delivery **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__Delivery);
	return (id < 0) ? soap->error : soap_out_PointerTons7__Delivery(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__Delivery *** FASTCALL soap_in_PointerToPointerTons7__Delivery(struct soap *soap, const char *tag, ns7__Delivery ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Delivery ***)soap_malloc(soap, sizeof(ns7__Delivery **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__Delivery(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__Delivery ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__Delivery, sizeof(ns7__Delivery *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__Delivery(struct soap *soap, ns7__Delivery **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__Delivery);
	return soap_out_PointerToPointerTons7__Delivery(soap, tag?tag:"ns7:Delivery", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Delivery *** SOAP_FMAC4 soap_get_PointerToPointerTons7__Delivery(struct soap *soap, ns7__Delivery ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__DiscrepancyReport))
		soap_serialize_PointerTons7__DiscrepancyReport(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__DiscrepancyReport(struct soap *soap, const char *tag, int id, ns7__DiscrepancyReport **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__DiscrepancyReport);
	return (id < 0) ? soap->error : soap_out_PointerTons7__DiscrepancyReport(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__DiscrepancyReport *** FASTCALL soap_in_PointerToPointerTons7__DiscrepancyReport(struct soap *soap, const char *tag, ns7__DiscrepancyReport ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__DiscrepancyReport ***)soap_malloc(soap, sizeof(ns7__DiscrepancyReport **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__DiscrepancyReport(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__DiscrepancyReport ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__DiscrepancyReport, sizeof(ns7__DiscrepancyReport *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__DiscrepancyReport);
	return soap_out_PointerToPointerTons7__DiscrepancyReport(soap, tag?tag:"ns7:DiscrepancyReport", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__DiscrepancyReport *** SOAP_FMAC4 soap_get_PointerToPointerTons7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__DiscrepancyReport))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__DiscrepancyReport(struct soap *soap, const char *tag, int id, ns7__DiscrepancyReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__DiscrepancyReport);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__DiscrepancyReport ** FASTCALL soap_in_PointerTons7__DiscrepancyReport(struct soap *soap, const char *tag, ns7__DiscrepancyReport **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__DiscrepancyReport **)soap_malloc(soap, sizeof(ns7__DiscrepancyReport *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__DiscrepancyReport *)soap_instantiate_ns7__DiscrepancyReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__DiscrepancyReport ** p = (ns7__DiscrepancyReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__DiscrepancyReport, sizeof(ns7__DiscrepancyReport), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__DiscrepancyReport);
	return soap_out_PointerTons7__DiscrepancyReport(soap, tag?tag:"ns7:DiscrepancyReport", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__DiscrepancyReport ** SOAP_FMAC4 soap_get_PointerTons7__DiscrepancyReport(struct soap *soap, ns7__DiscrepancyReport **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__DeliveryFactList(struct soap *soap, ns7__DeliveryFactList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__DeliveryFactList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__DeliveryFactList(struct soap *soap, const char *tag, int id, ns7__DeliveryFactList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__DeliveryFactList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__DeliveryFactList ** FASTCALL soap_in_PointerTons7__DeliveryFactList(struct soap *soap, const char *tag, ns7__DeliveryFactList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__DeliveryFactList **)soap_malloc(soap, sizeof(ns7__DeliveryFactList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__DeliveryFactList *)soap_instantiate_ns7__DeliveryFactList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__DeliveryFactList ** p = (ns7__DeliveryFactList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__DeliveryFactList, sizeof(ns7__DeliveryFactList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__DeliveryFactList(struct soap *soap, ns7__DeliveryFactList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__DeliveryFactList);
	return soap_out_PointerTons7__DeliveryFactList(soap, tag?tag:"ns7:DeliveryFactList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__DeliveryFactList ** SOAP_FMAC4 soap_get_PointerTons7__DeliveryFactList(struct soap *soap, ns7__DeliveryFactList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__DeliveryFactList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__Delivery(struct soap *soap, ns7__Delivery *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__Delivery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__Delivery(struct soap *soap, const char *tag, int id, ns7__Delivery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__Delivery);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__Delivery ** FASTCALL soap_in_PointerTons7__Delivery(struct soap *soap, const char *tag, ns7__Delivery **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Delivery **)soap_malloc(soap, sizeof(ns7__Delivery *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__Delivery *)soap_instantiate_ns7__Delivery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__Delivery ** p = (ns7__Delivery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Delivery, sizeof(ns7__Delivery), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__Delivery(struct soap *soap, ns7__Delivery *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__Delivery);
	return soap_out_PointerTons7__Delivery(soap, tag?tag:"ns7:Delivery", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Delivery ** SOAP_FMAC4 soap_get_PointerTons7__Delivery(struct soap *soap, ns7__Delivery **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__WorkingArea(struct soap *soap, ns7__WorkingArea **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__WorkingArea))
		soap_serialize_PointerTons7__WorkingArea(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__WorkingArea(struct soap *soap, const char *tag, int id, ns7__WorkingArea **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__WorkingArea);
	return (id < 0) ? soap->error : soap_out_PointerTons7__WorkingArea(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__WorkingArea *** FASTCALL soap_in_PointerToPointerTons7__WorkingArea(struct soap *soap, const char *tag, ns7__WorkingArea ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__WorkingArea ***)soap_malloc(soap, sizeof(ns7__WorkingArea **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__WorkingArea(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__WorkingArea ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__WorkingArea, sizeof(ns7__WorkingArea *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__WorkingArea(struct soap *soap, ns7__WorkingArea **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__WorkingArea);
	return soap_out_PointerToPointerTons7__WorkingArea(soap, tag?tag:"ns7:WorkingArea", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__WorkingArea *** SOAP_FMAC4 soap_get_PointerToPointerTons7__WorkingArea(struct soap *soap, ns7__WorkingArea ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__WorkingArea(struct soap *soap, ns7__WorkingArea *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__WorkingArea))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__WorkingArea(struct soap *soap, const char *tag, int id, ns7__WorkingArea *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__WorkingArea);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__WorkingArea ** FASTCALL soap_in_PointerTons7__WorkingArea(struct soap *soap, const char *tag, ns7__WorkingArea **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__WorkingArea **)soap_malloc(soap, sizeof(ns7__WorkingArea *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__WorkingArea *)soap_instantiate_ns7__WorkingArea(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__WorkingArea ** p = (ns7__WorkingArea **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__WorkingArea, sizeof(ns7__WorkingArea), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__WorkingArea(struct soap *soap, ns7__WorkingArea *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__WorkingArea);
	return soap_out_PointerTons7__WorkingArea(soap, tag?tag:"ns7:WorkingArea", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__WorkingArea ** SOAP_FMAC4 soap_get_PointerTons7__WorkingArea(struct soap *soap, ns7__WorkingArea **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__WorkingAreaList(struct soap *soap, ns7__WorkingAreaList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__WorkingAreaList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__WorkingAreaList(struct soap *soap, const char *tag, int id, ns7__WorkingAreaList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__WorkingAreaList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__WorkingAreaList ** FASTCALL soap_in_PointerTons7__WorkingAreaList(struct soap *soap, const char *tag, ns7__WorkingAreaList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__WorkingAreaList **)soap_malloc(soap, sizeof(ns7__WorkingAreaList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__WorkingAreaList *)soap_instantiate_ns7__WorkingAreaList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__WorkingAreaList ** p = (ns7__WorkingAreaList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__WorkingAreaList, sizeof(ns7__WorkingAreaList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__WorkingAreaList(struct soap *soap, ns7__WorkingAreaList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__WorkingAreaList);
	return soap_out_PointerTons7__WorkingAreaList(soap, tag?tag:"ns7:WorkingAreaList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__WorkingAreaList ** SOAP_FMAC4 soap_get_PointerTons7__WorkingAreaList(struct soap *soap, ns7__WorkingAreaList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__WorkingAreaList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SNILSType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__SNILSType))
		soap_serialize_ns7__SNILSType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__SNILSType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SNILSType);
	return (id < 0) ? soap->error : soap_out_ns7__SNILSType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons7__SNILSType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__SNILSType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SNILSType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SNILSType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__SNILSType);
	return soap_out_PointerTons7__SNILSType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons7__SNILSType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__SNILSType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__MedicinalDrug(struct soap *soap, ns6__MedicinalDrug *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__MedicinalDrug))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__MedicinalDrug(struct soap *soap, const char *tag, int id, ns6__MedicinalDrug *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__MedicinalDrug);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__MedicinalDrug ** FASTCALL soap_in_PointerTons6__MedicinalDrug(struct soap *soap, const char *tag, ns6__MedicinalDrug **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__MedicinalDrug **)soap_malloc(soap, sizeof(ns6__MedicinalDrug *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__MedicinalDrug *)soap_instantiate_ns6__MedicinalDrug(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__MedicinalDrug ** p = (ns6__MedicinalDrug **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__MedicinalDrug, sizeof(ns6__MedicinalDrug), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__MedicinalDrug(struct soap *soap, ns6__MedicinalDrug *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__MedicinalDrug);
	return soap_out_PointerTons6__MedicinalDrug(soap, tag?tag:"ns6:MedicinalDrug", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__MedicinalDrug ** SOAP_FMAC4 soap_get_PointerTons6__MedicinalDrug(struct soap *soap, ns6__MedicinalDrug **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__MedicinalDrug(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Indicator(struct soap *soap, ns6__Indicator *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Indicator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Indicator(struct soap *soap, const char *tag, int id, ns6__Indicator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Indicator);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Indicator ** FASTCALL soap_in_PointerTons6__Indicator(struct soap *soap, const char *tag, ns6__Indicator **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Indicator **)soap_malloc(soap, sizeof(ns6__Indicator *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Indicator *)soap_instantiate_ns6__Indicator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Indicator ** p = (ns6__Indicator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Indicator, sizeof(ns6__Indicator), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Indicator(struct soap *soap, ns6__Indicator *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Indicator);
	return soap_out_PointerTons6__Indicator(soap, tag?tag:"ns6:Indicator", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Indicator ** SOAP_FMAC4 soap_get_PointerTons6__Indicator(struct soap *soap, ns6__Indicator **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Indicator(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DocumentType(struct soap *soap, enum ns6__DocumentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__DocumentType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__DocumentType(struct soap *soap, const char *tag, int id, enum ns6__DocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DocumentType);
	return (id < 0) ? soap->error : soap_out_ns6__DocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__DocumentType ** FASTCALL soap_in_PointerTons6__DocumentType(struct soap *soap, const char *tag, enum ns6__DocumentType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__DocumentType **)soap_malloc(soap, sizeof(enum ns6__DocumentType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__DocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__DocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DocumentType, sizeof(enum ns6__DocumentType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DocumentType(struct soap *soap, enum ns6__DocumentType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DocumentType);
	return soap_out_PointerTons6__DocumentType(soap, tag?tag:"ns6:DocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__DocumentType ** SOAP_FMAC4 soap_get_PointerTons6__DocumentType(struct soap *soap, enum ns6__DocumentType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__DocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ConsignmentDocumentList(struct soap *soap, ns7__ConsignmentDocumentList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ConsignmentDocumentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ConsignmentDocumentList(struct soap *soap, const char *tag, int id, ns7__ConsignmentDocumentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ConsignmentDocumentList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ConsignmentDocumentList ** FASTCALL soap_in_PointerTons7__ConsignmentDocumentList(struct soap *soap, const char *tag, ns7__ConsignmentDocumentList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ConsignmentDocumentList **)soap_malloc(soap, sizeof(ns7__ConsignmentDocumentList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ConsignmentDocumentList *)soap_instantiate_ns7__ConsignmentDocumentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ConsignmentDocumentList ** p = (ns7__ConsignmentDocumentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ConsignmentDocumentList, sizeof(ns7__ConsignmentDocumentList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ConsignmentDocumentList(struct soap *soap, ns7__ConsignmentDocumentList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ConsignmentDocumentList);
	return soap_out_PointerTons7__ConsignmentDocumentList(soap, tag?tag:"ns7:ConsignmentDocumentList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ConsignmentDocumentList ** SOAP_FMAC4 soap_get_PointerTons7__ConsignmentDocumentList(struct soap *soap, ns7__ConsignmentDocumentList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ConsignmentDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__Consignment(struct soap *soap, ns7__Consignment **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__Consignment))
		soap_serialize_PointerTons7__Consignment(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__Consignment(struct soap *soap, const char *tag, int id, ns7__Consignment **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__Consignment);
	return (id < 0) ? soap->error : soap_out_PointerTons7__Consignment(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__Consignment *** FASTCALL soap_in_PointerToPointerTons7__Consignment(struct soap *soap, const char *tag, ns7__Consignment ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Consignment ***)soap_malloc(soap, sizeof(ns7__Consignment **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__Consignment(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__Consignment ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__Consignment, sizeof(ns7__Consignment *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__Consignment(struct soap *soap, ns7__Consignment **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__Consignment);
	return soap_out_PointerToPointerTons7__Consignment(soap, tag?tag:"ns7:Consignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Consignment *** SOAP_FMAC4 soap_get_PointerToPointerTons7__Consignment(struct soap *soap, ns7__Consignment ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__Consignment(struct soap *soap, ns7__Consignment *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__Consignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__Consignment(struct soap *soap, const char *tag, int id, ns7__Consignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__Consignment);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__Consignment ** FASTCALL soap_in_PointerTons7__Consignment(struct soap *soap, const char *tag, ns7__Consignment **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Consignment **)soap_malloc(soap, sizeof(ns7__Consignment *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__Consignment *)soap_instantiate_ns7__Consignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__Consignment ** p = (ns7__Consignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Consignment, sizeof(ns7__Consignment), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__Consignment(struct soap *soap, ns7__Consignment *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__Consignment);
	return soap_out_PointerTons7__Consignment(soap, tag?tag:"ns7:Consignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Consignment ** SOAP_FMAC4 soap_get_PointerTons7__Consignment(struct soap *soap, ns7__Consignment **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__BusinessMember(struct soap *soap, ns6__BusinessMember **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__BusinessMember))
		soap_serialize_PointerTons6__BusinessMember(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__BusinessMember(struct soap *soap, const char *tag, int id, ns6__BusinessMember **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__BusinessMember);
	return (id < 0) ? soap->error : soap_out_PointerTons6__BusinessMember(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__BusinessMember *** FASTCALL soap_in_PointerToPointerTons6__BusinessMember(struct soap *soap, const char *tag, ns6__BusinessMember ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__BusinessMember ***)soap_malloc(soap, sizeof(ns6__BusinessMember **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__BusinessMember(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__BusinessMember ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__BusinessMember, sizeof(ns6__BusinessMember *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__BusinessMember(struct soap *soap, ns6__BusinessMember **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__BusinessMember);
	return soap_out_PointerToPointerTons6__BusinessMember(soap, tag?tag:"ns6:BusinessMember", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__BusinessMember *** SOAP_FMAC4 soap_get_PointerToPointerTons6__BusinessMember(struct soap *soap, ns6__BusinessMember ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__ResearchMethod(struct soap *soap, ns6__ResearchMethod **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__ResearchMethod))
		soap_serialize_PointerTons6__ResearchMethod(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__ResearchMethod(struct soap *soap, const char *tag, int id, ns6__ResearchMethod **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__ResearchMethod);
	return (id < 0) ? soap->error : soap_out_PointerTons6__ResearchMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__ResearchMethod *** FASTCALL soap_in_PointerToPointerTons6__ResearchMethod(struct soap *soap, const char *tag, ns6__ResearchMethod ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ResearchMethod ***)soap_malloc(soap, sizeof(ns6__ResearchMethod **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__ResearchMethod(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__ResearchMethod ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__ResearchMethod, sizeof(ns6__ResearchMethod *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__ResearchMethod(struct soap *soap, ns6__ResearchMethod **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__ResearchMethod);
	return soap_out_PointerToPointerTons6__ResearchMethod(soap, tag?tag:"ns6:ResearchMethod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ResearchMethod *** SOAP_FMAC4 soap_get_PointerToPointerTons6__ResearchMethod(struct soap *soap, ns6__ResearchMethod ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__AnimalDisease(struct soap *soap, ns6__AnimalDisease **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__AnimalDisease))
		soap_serialize_PointerTons6__AnimalDisease(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__AnimalDisease(struct soap *soap, const char *tag, int id, ns6__AnimalDisease **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__AnimalDisease);
	return (id < 0) ? soap->error : soap_out_PointerTons6__AnimalDisease(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__AnimalDisease *** FASTCALL soap_in_PointerToPointerTons6__AnimalDisease(struct soap *soap, const char *tag, ns6__AnimalDisease ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__AnimalDisease ***)soap_malloc(soap, sizeof(ns6__AnimalDisease **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__AnimalDisease(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__AnimalDisease ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__AnimalDisease, sizeof(ns6__AnimalDisease *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__AnimalDisease(struct soap *soap, ns6__AnimalDisease **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__AnimalDisease);
	return soap_out_PointerToPointerTons6__AnimalDisease(soap, tag?tag:"ns6:AnimalDisease", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__AnimalDisease *** SOAP_FMAC4 soap_get_PointerToPointerTons6__AnimalDisease(struct soap *soap, ns6__AnimalDisease ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__RegionalizationRegionStatus))
		soap_serialize_PointerTons6__RegionalizationRegionStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, ns6__RegionalizationRegionStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__RegionalizationRegionStatus);
	return (id < 0) ? soap->error : soap_out_PointerTons6__RegionalizationRegionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatus *** FASTCALL soap_in_PointerToPointerTons6__RegionalizationRegionStatus(struct soap *soap, const char *tag, ns6__RegionalizationRegionStatus ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationRegionStatus ***)soap_malloc(soap, sizeof(ns6__RegionalizationRegionStatus **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__RegionalizationRegionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationRegionStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__RegionalizationRegionStatus, sizeof(ns6__RegionalizationRegionStatus *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__RegionalizationRegionStatus);
	return soap_out_PointerToPointerTons6__RegionalizationRegionStatus(soap, tag?tag:"ns6:RegionalizationRegionStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatus *** SOAP_FMAC4 soap_get_PointerToPointerTons6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationRegionStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, ns6__RegionalizationRegionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationRegionStatus);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatus ** FASTCALL soap_in_PointerTons6__RegionalizationRegionStatus(struct soap *soap, const char *tag, ns6__RegionalizationRegionStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationRegionStatus **)soap_malloc(soap, sizeof(ns6__RegionalizationRegionStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationRegionStatus *)soap_instantiate_ns6__RegionalizationRegionStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationRegionStatus ** p = (ns6__RegionalizationRegionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationRegionStatus, sizeof(ns6__RegionalizationRegionStatus), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationRegionStatus);
	return soap_out_PointerTons6__RegionalizationRegionStatus(soap, tag?tag:"ns6:RegionalizationRegionStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatus ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationRegionStatus(struct soap *soap, ns6__RegionalizationRegionStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__ProductItem(struct soap *soap, ns6__ProductItem **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__ProductItem))
		soap_serialize_PointerTons6__ProductItem(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__ProductItem(struct soap *soap, const char *tag, int id, ns6__ProductItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__ProductItem);
	return (id < 0) ? soap->error : soap_out_PointerTons6__ProductItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__ProductItem *** FASTCALL soap_in_PointerToPointerTons6__ProductItem(struct soap *soap, const char *tag, ns6__ProductItem ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductItem ***)soap_malloc(soap, sizeof(ns6__ProductItem **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__ProductItem(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__ProductItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__ProductItem, sizeof(ns6__ProductItem *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__ProductItem(struct soap *soap, ns6__ProductItem **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__ProductItem);
	return soap_out_PointerToPointerTons6__ProductItem(soap, tag?tag:"ns6:ProductItem", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductItem *** SOAP_FMAC4 soap_get_PointerToPointerTons6__ProductItem(struct soap *soap, ns6__ProductItem ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__SubProduct(struct soap *soap, ns6__SubProduct **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__SubProduct))
		soap_serialize_PointerTons6__SubProduct(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__SubProduct(struct soap *soap, const char *tag, int id, ns6__SubProduct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__SubProduct);
	return (id < 0) ? soap->error : soap_out_PointerTons6__SubProduct(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__SubProduct *** FASTCALL soap_in_PointerToPointerTons6__SubProduct(struct soap *soap, const char *tag, ns6__SubProduct ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__SubProduct ***)soap_malloc(soap, sizeof(ns6__SubProduct **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__SubProduct(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__SubProduct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__SubProduct, sizeof(ns6__SubProduct *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__SubProduct(struct soap *soap, ns6__SubProduct **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__SubProduct);
	return soap_out_PointerToPointerTons6__SubProduct(soap, tag?tag:"ns6:SubProduct", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SubProduct *** SOAP_FMAC4 soap_get_PointerToPointerTons6__SubProduct(struct soap *soap, ns6__SubProduct ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Product(struct soap *soap, ns6__Product **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Product))
		soap_serialize_PointerTons6__Product(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Product(struct soap *soap, const char *tag, int id, ns6__Product **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Product);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Product(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Product *** FASTCALL soap_in_PointerToPointerTons6__Product(struct soap *soap, const char *tag, ns6__Product ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Product ***)soap_malloc(soap, sizeof(ns6__Product **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Product(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Product ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Product, sizeof(ns6__Product *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Product(struct soap *soap, ns6__Product **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Product);
	return soap_out_PointerToPointerTons6__Product(soap, tag?tag:"ns6:Product", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Product *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Product(struct soap *soap, ns6__Product ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__EnterpriseActivity))
		soap_serialize_PointerTons6__EnterpriseActivity(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__EnterpriseActivity(struct soap *soap, const char *tag, int id, ns6__EnterpriseActivity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__EnterpriseActivity);
	return (id < 0) ? soap->error : soap_out_PointerTons6__EnterpriseActivity(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__EnterpriseActivity *** FASTCALL soap_in_PointerToPointerTons6__EnterpriseActivity(struct soap *soap, const char *tag, ns6__EnterpriseActivity ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseActivity ***)soap_malloc(soap, sizeof(ns6__EnterpriseActivity **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__EnterpriseActivity(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__EnterpriseActivity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__EnterpriseActivity, sizeof(ns6__EnterpriseActivity *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__EnterpriseActivity);
	return soap_out_PointerToPointerTons6__EnterpriseActivity(soap, tag?tag:"ns6:EnterpriseActivity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseActivity *** SOAP_FMAC4 soap_get_PointerToPointerTons6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseActivity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseActivity(struct soap *soap, const char *tag, int id, ns6__EnterpriseActivity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseActivity);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__EnterpriseActivity ** FASTCALL soap_in_PointerTons6__EnterpriseActivity(struct soap *soap, const char *tag, ns6__EnterpriseActivity **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseActivity **)soap_malloc(soap, sizeof(ns6__EnterpriseActivity *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__EnterpriseActivity *)soap_instantiate_ns6__EnterpriseActivity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__EnterpriseActivity ** p = (ns6__EnterpriseActivity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseActivity, sizeof(ns6__EnterpriseActivity), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseActivity);
	return soap_out_PointerTons6__EnterpriseActivity(soap, tag?tag:"ns6:EnterpriseActivity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseActivity ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseActivity(struct soap *soap, ns6__EnterpriseActivity **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Street(struct soap *soap, ns6__Street **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Street))
		soap_serialize_PointerTons6__Street(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Street(struct soap *soap, const char *tag, int id, ns6__Street **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Street);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Street(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Street *** FASTCALL soap_in_PointerToPointerTons6__Street(struct soap *soap, const char *tag, ns6__Street ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Street ***)soap_malloc(soap, sizeof(ns6__Street **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Street(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Street ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Street, sizeof(ns6__Street *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Street(struct soap *soap, ns6__Street **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Street);
	return soap_out_PointerToPointerTons6__Street(soap, tag?tag:"ns6:Street", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Street *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Street(struct soap *soap, ns6__Street ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Locality(struct soap *soap, ns6__Locality **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Locality))
		soap_serialize_PointerTons6__Locality(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Locality(struct soap *soap, const char *tag, int id, ns6__Locality **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Locality);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Locality(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Locality *** FASTCALL soap_in_PointerToPointerTons6__Locality(struct soap *soap, const char *tag, ns6__Locality ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Locality ***)soap_malloc(soap, sizeof(ns6__Locality **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Locality(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Locality ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Locality, sizeof(ns6__Locality *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Locality(struct soap *soap, ns6__Locality **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Locality);
	return soap_out_PointerToPointerTons6__Locality(soap, tag?tag:"ns6:Locality", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Locality *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Locality(struct soap *soap, ns6__Locality ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__District(struct soap *soap, ns6__District **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__District))
		soap_serialize_PointerTons6__District(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__District(struct soap *soap, const char *tag, int id, ns6__District **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__District);
	return (id < 0) ? soap->error : soap_out_PointerTons6__District(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__District *** FASTCALL soap_in_PointerToPointerTons6__District(struct soap *soap, const char *tag, ns6__District ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__District ***)soap_malloc(soap, sizeof(ns6__District **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__District(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__District ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__District, sizeof(ns6__District *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__District(struct soap *soap, ns6__District **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__District);
	return soap_out_PointerToPointerTons6__District(soap, tag?tag:"ns6:District", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__District *** SOAP_FMAC4 soap_get_PointerToPointerTons6__District(struct soap *soap, ns6__District ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Region(struct soap *soap, ns6__Region **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Region))
		soap_serialize_PointerTons6__Region(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Region(struct soap *soap, const char *tag, int id, ns6__Region **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Region);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Region(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Region *** FASTCALL soap_in_PointerToPointerTons6__Region(struct soap *soap, const char *tag, ns6__Region ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Region ***)soap_malloc(soap, sizeof(ns6__Region **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Region(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Region ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Region, sizeof(ns6__Region *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Region(struct soap *soap, ns6__Region **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Region);
	return soap_out_PointerToPointerTons6__Region(soap, tag?tag:"ns6:Region", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Region *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Region(struct soap *soap, ns6__Region ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Country(struct soap *soap, ns6__Country **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Country))
		soap_serialize_PointerTons6__Country(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Country(struct soap *soap, const char *tag, int id, ns6__Country **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Country);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Country(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Country *** FASTCALL soap_in_PointerToPointerTons6__Country(struct soap *soap, const char *tag, ns6__Country ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Country ***)soap_malloc(soap, sizeof(ns6__Country **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Country(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Country ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Country, sizeof(ns6__Country *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Country(struct soap *soap, ns6__Country **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Country);
	return soap_out_PointerToPointerTons6__Country(soap, tag?tag:"ns6:Country", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Country *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Country(struct soap *soap, ns6__Country ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Unit(struct soap *soap, ns6__Unit **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Unit))
		soap_serialize_PointerTons6__Unit(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Unit(struct soap *soap, const char *tag, int id, ns6__Unit **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Unit);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Unit(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Unit *** FASTCALL soap_in_PointerToPointerTons6__Unit(struct soap *soap, const char *tag, ns6__Unit ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Unit ***)soap_malloc(soap, sizeof(ns6__Unit **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Unit(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Unit ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Unit, sizeof(ns6__Unit *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Unit(struct soap *soap, ns6__Unit **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Unit);
	return soap_out_PointerToPointerTons6__Unit(soap, tag?tag:"ns6:Unit", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Unit *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Unit(struct soap *soap, ns6__Unit ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Purpose(struct soap *soap, ns6__Purpose **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Purpose))
		soap_serialize_PointerTons6__Purpose(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Purpose(struct soap *soap, const char *tag, int id, ns6__Purpose **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Purpose);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Purpose(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Purpose *** FASTCALL soap_in_PointerToPointerTons6__Purpose(struct soap *soap, const char *tag, ns6__Purpose ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Purpose ***)soap_malloc(soap, sizeof(ns6__Purpose **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Purpose(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Purpose ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Purpose, sizeof(ns6__Purpose *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Purpose(struct soap *soap, ns6__Purpose **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Purpose);
	return soap_out_PointerToPointerTons6__Purpose(soap, tag?tag:"ns6:Purpose", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Purpose *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Purpose(struct soap *soap, ns6__Purpose ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__AuthorityList(struct soap *soap, ns7__AuthorityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__AuthorityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__AuthorityList(struct soap *soap, const char *tag, int id, ns7__AuthorityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__AuthorityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__AuthorityList ** FASTCALL soap_in_PointerTons7__AuthorityList(struct soap *soap, const char *tag, ns7__AuthorityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__AuthorityList **)soap_malloc(soap, sizeof(ns7__AuthorityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__AuthorityList *)soap_instantiate_ns7__AuthorityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__AuthorityList ** p = (ns7__AuthorityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AuthorityList, sizeof(ns7__AuthorityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__AuthorityList(struct soap *soap, ns7__AuthorityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__AuthorityList);
	return soap_out_PointerTons7__AuthorityList(soap, tag?tag:"ns7:AuthorityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__AuthorityList ** SOAP_FMAC4 soap_get_PointerTons7__AuthorityList(struct soap *soap, ns7__AuthorityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__AuthorityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__UserList(struct soap *soap, ns7__UserList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__UserList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__UserList(struct soap *soap, const char *tag, int id, ns7__UserList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__UserList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__UserList ** FASTCALL soap_in_PointerTons7__UserList(struct soap *soap, const char *tag, ns7__UserList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__UserList **)soap_malloc(soap, sizeof(ns7__UserList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__UserList *)soap_instantiate_ns7__UserList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__UserList ** p = (ns7__UserList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__UserList, sizeof(ns7__UserList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__UserList(struct soap *soap, ns7__UserList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__UserList);
	return soap_out_PointerTons7__UserList(soap, tag?tag:"ns7:UserList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__UserList ** SOAP_FMAC4 soap_get_PointerTons7__UserList(struct soap *soap, ns7__UserList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__UserList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__User(struct soap *soap, ns7__User **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__User))
		soap_serialize_PointerTons7__User(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__User(struct soap *soap, const char *tag, int id, ns7__User **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__User);
	return (id < 0) ? soap->error : soap_out_PointerTons7__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__User *** FASTCALL soap_in_PointerToPointerTons7__User(struct soap *soap, const char *tag, ns7__User ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__User ***)soap_malloc(soap, sizeof(ns7__User **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__User(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__User ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__User, sizeof(ns7__User *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__User(struct soap *soap, ns7__User **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__User);
	return soap_out_PointerToPointerTons7__User(soap, tag?tag:"ns7:User", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__User *** SOAP_FMAC4 soap_get_PointerToPointerTons7__User(struct soap *soap, ns7__User ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__RouteSectionR13nRules))
		soap_serialize_PointerTons7__RouteSectionR13nRules(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, ns7__RouteSectionR13nRules **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__RouteSectionR13nRules);
	return (id < 0) ? soap->error : soap_out_PointerTons7__RouteSectionR13nRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__RouteSectionR13nRules *** FASTCALL soap_in_PointerToPointerTons7__RouteSectionR13nRules(struct soap *soap, const char *tag, ns7__RouteSectionR13nRules ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__RouteSectionR13nRules ***)soap_malloc(soap, sizeof(ns7__RouteSectionR13nRules **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__RouteSectionR13nRules(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__RouteSectionR13nRules ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__RouteSectionR13nRules, sizeof(ns7__RouteSectionR13nRules *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__RouteSectionR13nRules);
	return soap_out_PointerToPointerTons7__RouteSectionR13nRules(soap, tag?tag:"ns7:RouteSectionR13nRules", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__RouteSectionR13nRules *** SOAP_FMAC4 soap_get_PointerToPointerTons7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__RouteSectionR13nRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, ns7__RouteSectionR13nRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__RouteSectionR13nRules);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__RouteSectionR13nRules ** FASTCALL soap_in_PointerTons7__RouteSectionR13nRules(struct soap *soap, const char *tag, ns7__RouteSectionR13nRules **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__RouteSectionR13nRules **)soap_malloc(soap, sizeof(ns7__RouteSectionR13nRules *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__RouteSectionR13nRules *)soap_instantiate_ns7__RouteSectionR13nRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__RouteSectionR13nRules ** p = (ns7__RouteSectionR13nRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__RouteSectionR13nRules, sizeof(ns7__RouteSectionR13nRules), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__RouteSectionR13nRules);
	return soap_out_PointerTons7__RouteSectionR13nRules(soap, tag?tag:"ns7:RouteSectionR13nRules", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__RouteSectionR13nRules ** SOAP_FMAC4 soap_get_PointerTons7__RouteSectionR13nRules(struct soap *soap, ns7__RouteSectionR13nRules **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VetDocumentList(struct soap *soap, ns7__VetDocumentList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__VetDocumentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VetDocumentList(struct soap *soap, const char *tag, int id, ns7__VetDocumentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VetDocumentList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__VetDocumentList ** FASTCALL soap_in_PointerTons7__VetDocumentList(struct soap *soap, const char *tag, ns7__VetDocumentList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VetDocumentList **)soap_malloc(soap, sizeof(ns7__VetDocumentList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__VetDocumentList *)soap_instantiate_ns7__VetDocumentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__VetDocumentList ** p = (ns7__VetDocumentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocumentList, sizeof(ns7__VetDocumentList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VetDocumentList(struct soap *soap, ns7__VetDocumentList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VetDocumentList);
	return soap_out_PointerTons7__VetDocumentList(soap, tag?tag:"ns7:VetDocumentList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VetDocumentList ** SOAP_FMAC4 soap_get_PointerTons7__VetDocumentList(struct soap *soap, ns7__VetDocumentList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VetDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Enterprise(struct soap *soap, ns6__Enterprise **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Enterprise))
		soap_serialize_PointerTons6__Enterprise(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Enterprise(struct soap *soap, const char *tag, int id, ns6__Enterprise **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Enterprise);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Enterprise(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Enterprise *** FASTCALL soap_in_PointerToPointerTons6__Enterprise(struct soap *soap, const char *tag, ns6__Enterprise ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Enterprise ***)soap_malloc(soap, sizeof(ns6__Enterprise **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Enterprise(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Enterprise ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Enterprise, sizeof(ns6__Enterprise *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Enterprise(struct soap *soap, ns6__Enterprise **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Enterprise);
	return soap_out_PointerToPointerTons6__Enterprise(soap, tag?tag:"ns6:Enterprise", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Enterprise *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Enterprise(struct soap *soap, ns6__Enterprise ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__BusinessEntity(struct soap *soap, ns6__BusinessEntity **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__BusinessEntity))
		soap_serialize_PointerTons6__BusinessEntity(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__BusinessEntity(struct soap *soap, const char *tag, int id, ns6__BusinessEntity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__BusinessEntity);
	return (id < 0) ? soap->error : soap_out_PointerTons6__BusinessEntity(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__BusinessEntity *** FASTCALL soap_in_PointerToPointerTons6__BusinessEntity(struct soap *soap, const char *tag, ns6__BusinessEntity ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__BusinessEntity ***)soap_malloc(soap, sizeof(ns6__BusinessEntity **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__BusinessEntity(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__BusinessEntity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__BusinessEntity, sizeof(ns6__BusinessEntity *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__BusinessEntity(struct soap *soap, ns6__BusinessEntity **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__BusinessEntity);
	return soap_out_PointerToPointerTons6__BusinessEntity(soap, tag?tag:"ns6:BusinessEntity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__BusinessEntity *** SOAP_FMAC4 soap_get_PointerToPointerTons6__BusinessEntity(struct soap *soap, ns6__BusinessEntity ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__OTPToken(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__OTPToken))
		soap_serialize_ns6__OTPToken(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__OTPToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__OTPToken);
	return (id < 0) ? soap->error : soap_out_ns6__OTPToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons6__OTPToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__OTPToken(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__OTPToken, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__OTPToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__OTPToken);
	return soap_out_PointerTons6__OTPToken(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons6__OTPToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__OTPToken(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__VersionStatus(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__VersionStatus))
		soap_serialize_ns3__VersionStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__VersionStatus(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__VersionStatus);
	return (id < 0) ? soap->error : soap_out_ns3__VersionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__VersionStatus(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__VersionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__VersionStatus, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__VersionStatus(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__VersionStatus);
	return soap_out_PointerTons3__VersionStatus(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__VersionStatus(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__VersionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ResearchMethodList(struct soap *soap, ns6__ResearchMethodList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ResearchMethodList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ResearchMethodList(struct soap *soap, const char *tag, int id, ns6__ResearchMethodList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ResearchMethodList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ResearchMethodList ** FASTCALL soap_in_PointerTons6__ResearchMethodList(struct soap *soap, const char *tag, ns6__ResearchMethodList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ResearchMethodList **)soap_malloc(soap, sizeof(ns6__ResearchMethodList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ResearchMethodList *)soap_instantiate_ns6__ResearchMethodList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ResearchMethodList ** p = (ns6__ResearchMethodList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ResearchMethodList, sizeof(ns6__ResearchMethodList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ResearchMethodList(struct soap *soap, ns6__ResearchMethodList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ResearchMethodList);
	return soap_out_PointerTons6__ResearchMethodList(soap, tag?tag:"ns6:ResearchMethodList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ResearchMethodList ** SOAP_FMAC4 soap_get_PointerTons6__ResearchMethodList(struct soap *soap, ns6__ResearchMethodList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ResearchMethodList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ResearchMethod(struct soap *soap, ns6__ResearchMethod *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ResearchMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ResearchMethod(struct soap *soap, const char *tag, int id, ns6__ResearchMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ResearchMethod);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ResearchMethod ** FASTCALL soap_in_PointerTons6__ResearchMethod(struct soap *soap, const char *tag, ns6__ResearchMethod **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ResearchMethod **)soap_malloc(soap, sizeof(ns6__ResearchMethod *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ResearchMethod *)soap_instantiate_ns6__ResearchMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ResearchMethod ** p = (ns6__ResearchMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ResearchMethod, sizeof(ns6__ResearchMethod), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ResearchMethod(struct soap *soap, ns6__ResearchMethod *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ResearchMethod);
	return soap_out_PointerTons6__ResearchMethod(soap, tag?tag:"ns6:ResearchMethod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ResearchMethod ** SOAP_FMAC4 soap_get_PointerTons6__ResearchMethod(struct soap *soap, ns6__ResearchMethod **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AnimalDiseaseList(struct soap *soap, ns6__AnimalDiseaseList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__AnimalDiseaseList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__AnimalDiseaseList(struct soap *soap, const char *tag, int id, ns6__AnimalDiseaseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AnimalDiseaseList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__AnimalDiseaseList ** FASTCALL soap_in_PointerTons6__AnimalDiseaseList(struct soap *soap, const char *tag, ns6__AnimalDiseaseList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__AnimalDiseaseList **)soap_malloc(soap, sizeof(ns6__AnimalDiseaseList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__AnimalDiseaseList *)soap_instantiate_ns6__AnimalDiseaseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__AnimalDiseaseList ** p = (ns6__AnimalDiseaseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AnimalDiseaseList, sizeof(ns6__AnimalDiseaseList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AnimalDiseaseList(struct soap *soap, ns6__AnimalDiseaseList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__AnimalDiseaseList);
	return soap_out_PointerTons6__AnimalDiseaseList(soap, tag?tag:"ns6:AnimalDiseaseList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__AnimalDiseaseList ** SOAP_FMAC4 soap_get_PointerTons6__AnimalDiseaseList(struct soap *soap, ns6__AnimalDiseaseList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__AnimalDiseaseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationShippingRuleList(struct soap *soap, ns6__RegionalizationShippingRuleList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationShippingRuleList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationShippingRuleList(struct soap *soap, const char *tag, int id, ns6__RegionalizationShippingRuleList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationShippingRuleList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRuleList ** FASTCALL soap_in_PointerTons6__RegionalizationShippingRuleList(struct soap *soap, const char *tag, ns6__RegionalizationShippingRuleList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationShippingRuleList **)soap_malloc(soap, sizeof(ns6__RegionalizationShippingRuleList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationShippingRuleList *)soap_instantiate_ns6__RegionalizationShippingRuleList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationShippingRuleList ** p = (ns6__RegionalizationShippingRuleList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationShippingRuleList, sizeof(ns6__RegionalizationShippingRuleList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationShippingRuleList(struct soap *soap, ns6__RegionalizationShippingRuleList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationShippingRuleList);
	return soap_out_PointerTons6__RegionalizationShippingRuleList(soap, tag?tag:"ns6:RegionalizationShippingRuleList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationShippingRuleList ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationShippingRuleList(struct soap *soap, ns6__RegionalizationShippingRuleList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationShippingRuleList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationRegionStatusList(struct soap *soap, ns6__RegionalizationRegionStatusList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationRegionStatusList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationRegionStatusList(struct soap *soap, const char *tag, int id, ns6__RegionalizationRegionStatusList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationRegionStatusList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatusList ** FASTCALL soap_in_PointerTons6__RegionalizationRegionStatusList(struct soap *soap, const char *tag, ns6__RegionalizationRegionStatusList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationRegionStatusList **)soap_malloc(soap, sizeof(ns6__RegionalizationRegionStatusList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationRegionStatusList *)soap_instantiate_ns6__RegionalizationRegionStatusList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationRegionStatusList ** p = (ns6__RegionalizationRegionStatusList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationRegionStatusList, sizeof(ns6__RegionalizationRegionStatusList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationRegionStatusList(struct soap *soap, ns6__RegionalizationRegionStatusList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationRegionStatusList);
	return soap_out_PointerTons6__RegionalizationRegionStatusList(soap, tag?tag:"ns6:RegionalizationRegionStatusList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationRegionStatusList ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationRegionStatusList(struct soap *soap, ns6__RegionalizationRegionStatusList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationRegionStatusList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationConditionList(struct soap *soap, ns6__RegionalizationConditionList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationConditionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationConditionList(struct soap *soap, const char *tag, int id, ns6__RegionalizationConditionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationConditionList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionList ** FASTCALL soap_in_PointerTons6__RegionalizationConditionList(struct soap *soap, const char *tag, ns6__RegionalizationConditionList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationConditionList **)soap_malloc(soap, sizeof(ns6__RegionalizationConditionList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationConditionList *)soap_instantiate_ns6__RegionalizationConditionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationConditionList ** p = (ns6__RegionalizationConditionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationConditionList, sizeof(ns6__RegionalizationConditionList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationConditionList(struct soap *soap, ns6__RegionalizationConditionList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationConditionList);
	return soap_out_PointerTons6__RegionalizationConditionList(soap, tag?tag:"ns6:RegionalizationConditionList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationConditionList ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationConditionList(struct soap *soap, ns6__RegionalizationConditionList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationConditionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ActivityLocationList(struct soap *soap, ns6__ActivityLocationList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ActivityLocationList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ActivityLocationList(struct soap *soap, const char *tag, int id, ns6__ActivityLocationList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ActivityLocationList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ActivityLocationList ** FASTCALL soap_in_PointerTons6__ActivityLocationList(struct soap *soap, const char *tag, ns6__ActivityLocationList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ActivityLocationList **)soap_malloc(soap, sizeof(ns6__ActivityLocationList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ActivityLocationList *)soap_instantiate_ns6__ActivityLocationList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ActivityLocationList ** p = (ns6__ActivityLocationList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ActivityLocationList, sizeof(ns6__ActivityLocationList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ActivityLocationList(struct soap *soap, ns6__ActivityLocationList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ActivityLocationList);
	return soap_out_PointerTons6__ActivityLocationList(soap, tag?tag:"ns6:ActivityLocationList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ActivityLocationList ** SOAP_FMAC4 soap_get_PointerTons6__ActivityLocationList(struct soap *soap, ns6__ActivityLocationList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseGroup(struct soap *soap, enum ns6__EnterpriseGroup *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseGroup);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseGroup(struct soap *soap, const char *tag, int id, enum ns6__EnterpriseGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseGroup);
	return (id < 0) ? soap->error : soap_out_ns6__EnterpriseGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__EnterpriseGroup ** FASTCALL soap_in_PointerTons6__EnterpriseGroup(struct soap *soap, const char *tag, enum ns6__EnterpriseGroup **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__EnterpriseGroup **)soap_malloc(soap, sizeof(enum ns6__EnterpriseGroup *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__EnterpriseGroup(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__EnterpriseGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseGroup, sizeof(enum ns6__EnterpriseGroup), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseGroup(struct soap *soap, enum ns6__EnterpriseGroup *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseGroup);
	return soap_out_PointerTons6__EnterpriseGroup(soap, tag?tag:"ns6:EnterpriseGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__EnterpriseGroup ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseGroup(struct soap *soap, enum ns6__EnterpriseGroup **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StreetList(struct soap *soap, ns6__StreetList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__StreetList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__StreetList(struct soap *soap, const char *tag, int id, ns6__StreetList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StreetList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__StreetList ** FASTCALL soap_in_PointerTons6__StreetList(struct soap *soap, const char *tag, ns6__StreetList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__StreetList **)soap_malloc(soap, sizeof(ns6__StreetList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__StreetList *)soap_instantiate_ns6__StreetList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__StreetList ** p = (ns6__StreetList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StreetList, sizeof(ns6__StreetList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StreetList(struct soap *soap, ns6__StreetList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__StreetList);
	return soap_out_PointerTons6__StreetList(soap, tag?tag:"ns6:StreetList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__StreetList ** SOAP_FMAC4 soap_get_PointerTons6__StreetList(struct soap *soap, ns6__StreetList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__StreetList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__LocalityList(struct soap *soap, ns6__LocalityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__LocalityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__LocalityList(struct soap *soap, const char *tag, int id, ns6__LocalityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__LocalityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__LocalityList ** FASTCALL soap_in_PointerTons6__LocalityList(struct soap *soap, const char *tag, ns6__LocalityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__LocalityList **)soap_malloc(soap, sizeof(ns6__LocalityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__LocalityList *)soap_instantiate_ns6__LocalityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__LocalityList ** p = (ns6__LocalityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__LocalityList, sizeof(ns6__LocalityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__LocalityList(struct soap *soap, ns6__LocalityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__LocalityList);
	return soap_out_PointerTons6__LocalityList(soap, tag?tag:"ns6:LocalityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__LocalityList ** SOAP_FMAC4 soap_get_PointerTons6__LocalityList(struct soap *soap, ns6__LocalityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__LocalityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DistrictList(struct soap *soap, ns6__DistrictList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__DistrictList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__DistrictList(struct soap *soap, const char *tag, int id, ns6__DistrictList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DistrictList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DistrictList ** FASTCALL soap_in_PointerTons6__DistrictList(struct soap *soap, const char *tag, ns6__DistrictList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__DistrictList **)soap_malloc(soap, sizeof(ns6__DistrictList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__DistrictList *)soap_instantiate_ns6__DistrictList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__DistrictList ** p = (ns6__DistrictList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DistrictList, sizeof(ns6__DistrictList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DistrictList(struct soap *soap, ns6__DistrictList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DistrictList);
	return soap_out_PointerTons6__DistrictList(soap, tag?tag:"ns6:DistrictList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DistrictList ** SOAP_FMAC4 soap_get_PointerTons6__DistrictList(struct soap *soap, ns6__DistrictList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__DistrictList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionList(struct soap *soap, ns6__RegionList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionList(struct soap *soap, const char *tag, int id, ns6__RegionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionList ** FASTCALL soap_in_PointerTons6__RegionList(struct soap *soap, const char *tag, ns6__RegionList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionList **)soap_malloc(soap, sizeof(ns6__RegionList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionList *)soap_instantiate_ns6__RegionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionList ** p = (ns6__RegionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionList, sizeof(ns6__RegionList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionList(struct soap *soap, ns6__RegionList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionList);
	return soap_out_PointerTons6__RegionList(soap, tag?tag:"ns6:RegionList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionList ** SOAP_FMAC4 soap_get_PointerTons6__RegionList(struct soap *soap, ns6__RegionList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__CountryList(struct soap *soap, ns6__CountryList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__CountryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__CountryList(struct soap *soap, const char *tag, int id, ns6__CountryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__CountryList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__CountryList ** FASTCALL soap_in_PointerTons6__CountryList(struct soap *soap, const char *tag, ns6__CountryList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__CountryList **)soap_malloc(soap, sizeof(ns6__CountryList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__CountryList *)soap_instantiate_ns6__CountryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__CountryList ** p = (ns6__CountryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__CountryList, sizeof(ns6__CountryList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__CountryList(struct soap *soap, ns6__CountryList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__CountryList);
	return soap_out_PointerTons6__CountryList(soap, tag?tag:"ns6:CountryList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__CountryList ** SOAP_FMAC4 soap_get_PointerTons6__CountryList(struct soap *soap, ns6__CountryList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__CountryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SubProductList(struct soap *soap, ns6__SubProductList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__SubProductList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__SubProductList(struct soap *soap, const char *tag, int id, ns6__SubProductList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SubProductList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SubProductList ** FASTCALL soap_in_PointerTons6__SubProductList(struct soap *soap, const char *tag, ns6__SubProductList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__SubProductList **)soap_malloc(soap, sizeof(ns6__SubProductList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__SubProductList *)soap_instantiate_ns6__SubProductList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__SubProductList ** p = (ns6__SubProductList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SubProductList, sizeof(ns6__SubProductList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SubProductList(struct soap *soap, ns6__SubProductList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SubProductList);
	return soap_out_PointerTons6__SubProductList(soap, tag?tag:"ns6:SubProductList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SubProductList ** SOAP_FMAC4 soap_get_PointerTons6__SubProductList(struct soap *soap, ns6__SubProductList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__SubProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProductList(struct soap *soap, ns6__ProductList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ProductList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ProductList(struct soap *soap, const char *tag, int id, ns6__ProductList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProductList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ProductList ** FASTCALL soap_in_PointerTons6__ProductList(struct soap *soap, const char *tag, ns6__ProductList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductList **)soap_malloc(soap, sizeof(ns6__ProductList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ProductList *)soap_instantiate_ns6__ProductList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ProductList ** p = (ns6__ProductList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProductList, sizeof(ns6__ProductList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProductList(struct soap *soap, ns6__ProductList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ProductList);
	return soap_out_PointerTons6__ProductList(soap, tag?tag:"ns6:ProductList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductList ** SOAP_FMAC4 soap_get_PointerTons6__ProductList(struct soap *soap, ns6__ProductList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UnitList(struct soap *soap, ns6__UnitList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__UnitList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__UnitList(struct soap *soap, const char *tag, int id, ns6__UnitList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UnitList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__UnitList ** FASTCALL soap_in_PointerTons6__UnitList(struct soap *soap, const char *tag, ns6__UnitList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__UnitList **)soap_malloc(soap, sizeof(ns6__UnitList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__UnitList *)soap_instantiate_ns6__UnitList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__UnitList ** p = (ns6__UnitList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UnitList, sizeof(ns6__UnitList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UnitList(struct soap *soap, ns6__UnitList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__UnitList);
	return soap_out_PointerTons6__UnitList(soap, tag?tag:"ns6:UnitList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UnitList ** SOAP_FMAC4 soap_get_PointerTons6__UnitList(struct soap *soap, ns6__UnitList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__UnitList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DateInterval(struct soap *soap, ns3__DateInterval *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__DateInterval))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__DateInterval(struct soap *soap, const char *tag, int id, ns3__DateInterval *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__DateInterval);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__DateInterval ** FASTCALL soap_in_PointerTons3__DateInterval(struct soap *soap, const char *tag, ns3__DateInterval **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns3__DateInterval **)soap_malloc(soap, sizeof(ns3__DateInterval *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns3__DateInterval *)soap_instantiate_ns3__DateInterval(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns3__DateInterval ** p = (ns3__DateInterval **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DateInterval, sizeof(ns3__DateInterval), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DateInterval(struct soap *soap, ns3__DateInterval *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__DateInterval);
	return soap_out_PointerTons3__DateInterval(soap, tag?tag:"ns3:DateInterval", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DateInterval ** SOAP_FMAC4 soap_get_PointerTons3__DateInterval(struct soap *soap, ns3__DateInterval **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__DateInterval(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__PurposeList(struct soap *soap, ns6__PurposeList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__PurposeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__PurposeList(struct soap *soap, const char *tag, int id, ns6__PurposeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__PurposeList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__PurposeList ** FASTCALL soap_in_PointerTons6__PurposeList(struct soap *soap, const char *tag, ns6__PurposeList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__PurposeList **)soap_malloc(soap, sizeof(ns6__PurposeList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__PurposeList *)soap_instantiate_ns6__PurposeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__PurposeList ** p = (ns6__PurposeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__PurposeList, sizeof(ns6__PurposeList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__PurposeList(struct soap *soap, ns6__PurposeList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__PurposeList);
	return soap_out_PointerTons6__PurposeList(soap, tag?tag:"ns6:PurposeList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__PurposeList ** SOAP_FMAC4 soap_get_PointerTons6__PurposeList(struct soap *soap, ns6__PurposeList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__PurposeList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ListOptions(struct soap *soap, ns3__ListOptions *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__ListOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__ListOptions(struct soap *soap, const char *tag, int id, ns3__ListOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ListOptions);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ListOptions ** FASTCALL soap_in_PointerTons3__ListOptions(struct soap *soap, const char *tag, ns3__ListOptions **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns3__ListOptions **)soap_malloc(soap, sizeof(ns3__ListOptions *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns3__ListOptions *)soap_instantiate_ns3__ListOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns3__ListOptions ** p = (ns3__ListOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ListOptions, sizeof(ns3__ListOptions), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ListOptions(struct soap *soap, ns3__ListOptions *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ListOptions);
	return soap_out_PointerTons3__ListOptions(soap, tag?tag:"ns3:ListOptions", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ListOptions ** SOAP_FMAC4 soap_get_PointerTons3__ListOptions(struct soap *soap, ns3__ListOptions **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__ListOptions(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Area(struct soap *soap, ns6__Area *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Area))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Area(struct soap *soap, const char *tag, int id, ns6__Area *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Area);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Area ** FASTCALL soap_in_PointerTons6__Area(struct soap *soap, const char *tag, ns6__Area **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Area **)soap_malloc(soap, sizeof(ns6__Area *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Area *)soap_instantiate_ns6__Area(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Area ** p = (ns6__Area **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Area, sizeof(ns6__Area), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Area(struct soap *soap, ns6__Area *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Area);
	return soap_out_PointerTons6__Area(soap, tag?tag:"ns6:Area", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Area ** SOAP_FMAC4 soap_get_PointerTons6__Area(struct soap *soap, ns6__Area **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__UserAuthority(struct soap *soap, ns7__UserAuthority **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__UserAuthority))
		soap_serialize_PointerTons7__UserAuthority(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__UserAuthority(struct soap *soap, const char *tag, int id, ns7__UserAuthority **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__UserAuthority);
	return (id < 0) ? soap->error : soap_out_PointerTons7__UserAuthority(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__UserAuthority *** FASTCALL soap_in_PointerToPointerTons7__UserAuthority(struct soap *soap, const char *tag, ns7__UserAuthority ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__UserAuthority ***)soap_malloc(soap, sizeof(ns7__UserAuthority **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__UserAuthority(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__UserAuthority ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__UserAuthority, sizeof(ns7__UserAuthority *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__UserAuthority(struct soap *soap, ns7__UserAuthority **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__UserAuthority);
	return soap_out_PointerToPointerTons7__UserAuthority(soap, tag?tag:"ns7:UserAuthority", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__UserAuthority *** SOAP_FMAC4 soap_get_PointerToPointerTons7__UserAuthority(struct soap *soap, ns7__UserAuthority ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__UserAuthority(struct soap *soap, ns7__UserAuthority *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__UserAuthority))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__UserAuthority(struct soap *soap, const char *tag, int id, ns7__UserAuthority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__UserAuthority);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__UserAuthority ** FASTCALL soap_in_PointerTons7__UserAuthority(struct soap *soap, const char *tag, ns7__UserAuthority **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__UserAuthority **)soap_malloc(soap, sizeof(ns7__UserAuthority *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__UserAuthority *)soap_instantiate_ns7__UserAuthority(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__UserAuthority ** p = (ns7__UserAuthority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__UserAuthority, sizeof(ns7__UserAuthority), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__UserAuthority(struct soap *soap, ns7__UserAuthority *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__UserAuthority);
	return soap_out_PointerTons7__UserAuthority(soap, tag?tag:"ns7:UserAuthority", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__UserAuthority ** SOAP_FMAC4 soap_get_PointerTons7__UserAuthority(struct soap *soap, ns7__UserAuthority **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__RegionalizationShippingRule))
		soap_serialize_PointerTons6__RegionalizationShippingRule(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, ns6__RegionalizationShippingRule **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__RegionalizationShippingRule);
	return (id < 0) ? soap->error : soap_out_PointerTons6__RegionalizationShippingRule(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRule *** FASTCALL soap_in_PointerToPointerTons6__RegionalizationShippingRule(struct soap *soap, const char *tag, ns6__RegionalizationShippingRule ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationShippingRule ***)soap_malloc(soap, sizeof(ns6__RegionalizationShippingRule **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__RegionalizationShippingRule(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationShippingRule ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__RegionalizationShippingRule, sizeof(ns6__RegionalizationShippingRule *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__RegionalizationShippingRule);
	return soap_out_PointerToPointerTons6__RegionalizationShippingRule(soap, tag?tag:"ns6:RegionalizationShippingRule", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationShippingRule *** SOAP_FMAC4 soap_get_PointerToPointerTons6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationShippingRule))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, ns6__RegionalizationShippingRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationShippingRule);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationShippingRule ** FASTCALL soap_in_PointerTons6__RegionalizationShippingRule(struct soap *soap, const char *tag, ns6__RegionalizationShippingRule **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationShippingRule **)soap_malloc(soap, sizeof(ns6__RegionalizationShippingRule *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationShippingRule *)soap_instantiate_ns6__RegionalizationShippingRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationShippingRule ** p = (ns6__RegionalizationShippingRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationShippingRule, sizeof(ns6__RegionalizationShippingRule), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationShippingRule);
	return soap_out_PointerTons6__RegionalizationShippingRule(soap, tag?tag:"ns6:RegionalizationShippingRule", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationShippingRule ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationShippingRule(struct soap *soap, ns6__RegionalizationShippingRule **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__SequenceNumber(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__SequenceNumber))
		soap_serialize_ns3__SequenceNumber(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__SequenceNumber(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__SequenceNumber);
	return (id < 0) ? soap->error : soap_out_ns3__SequenceNumber(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__SequenceNumber(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__SequenceNumber(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__SequenceNumber, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__SequenceNumber(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__SequenceNumber);
	return soap_out_PointerTons3__SequenceNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__SequenceNumber(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__SequenceNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__QuarantineEvent))
		soap_serialize_PointerTons7__QuarantineEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__QuarantineEvent(struct soap *soap, const char *tag, int id, ns7__QuarantineEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__QuarantineEvent);
	return (id < 0) ? soap->error : soap_out_PointerTons7__QuarantineEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__QuarantineEvent *** FASTCALL soap_in_PointerToPointerTons7__QuarantineEvent(struct soap *soap, const char *tag, ns7__QuarantineEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__QuarantineEvent ***)soap_malloc(soap, sizeof(ns7__QuarantineEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__QuarantineEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__QuarantineEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__QuarantineEvent, sizeof(ns7__QuarantineEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__QuarantineEvent);
	return soap_out_PointerToPointerTons7__QuarantineEvent(soap, tag?tag:"ns7:QuarantineEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__QuarantineEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__RegionalizationClause))
		soap_serialize_PointerTons7__RegionalizationClause(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__RegionalizationClause(struct soap *soap, const char *tag, int id, ns7__RegionalizationClause **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__RegionalizationClause);
	return (id < 0) ? soap->error : soap_out_PointerTons7__RegionalizationClause(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__RegionalizationClause *** FASTCALL soap_in_PointerToPointerTons7__RegionalizationClause(struct soap *soap, const char *tag, ns7__RegionalizationClause ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__RegionalizationClause ***)soap_malloc(soap, sizeof(ns7__RegionalizationClause **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__RegionalizationClause(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__RegionalizationClause ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__RegionalizationClause, sizeof(ns7__RegionalizationClause *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__RegionalizationClause);
	return soap_out_PointerToPointerTons7__RegionalizationClause(soap, tag?tag:"ns7:RegionalizationClause", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__RegionalizationClause *** SOAP_FMAC4 soap_get_PointerToPointerTons7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__RegionalizationClause))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__RegionalizationClause(struct soap *soap, const char *tag, int id, ns7__RegionalizationClause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__RegionalizationClause);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__RegionalizationClause ** FASTCALL soap_in_PointerTons7__RegionalizationClause(struct soap *soap, const char *tag, ns7__RegionalizationClause **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__RegionalizationClause **)soap_malloc(soap, sizeof(ns7__RegionalizationClause *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__RegionalizationClause *)soap_instantiate_ns7__RegionalizationClause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__RegionalizationClause ** p = (ns7__RegionalizationClause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__RegionalizationClause, sizeof(ns7__RegionalizationClause), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__RegionalizationClause);
	return soap_out_PointerTons7__RegionalizationClause(soap, tag?tag:"ns7:RegionalizationClause", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__RegionalizationClause ** SOAP_FMAC4 soap_get_PointerTons7__RegionalizationClause(struct soap *soap, ns7__RegionalizationClause **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__VeterinaryEvent))
		soap_serialize_PointerTons7__VeterinaryEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__VeterinaryEvent(struct soap *soap, const char *tag, int id, ns7__VeterinaryEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__VeterinaryEvent);
	return (id < 0) ? soap->error : soap_out_PointerTons7__VeterinaryEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__VeterinaryEvent *** FASTCALL soap_in_PointerToPointerTons7__VeterinaryEvent(struct soap *soap, const char *tag, ns7__VeterinaryEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VeterinaryEvent ***)soap_malloc(soap, sizeof(ns7__VeterinaryEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__VeterinaryEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__VeterinaryEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__VeterinaryEvent, sizeof(ns7__VeterinaryEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__VeterinaryEvent);
	return soap_out_PointerToPointerTons7__VeterinaryEvent(soap, tag?tag:"ns7:VeterinaryEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VeterinaryEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__VeterinaryEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VeterinaryEvent(struct soap *soap, const char *tag, int id, ns7__VeterinaryEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VeterinaryEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__VeterinaryEvent ** FASTCALL soap_in_PointerTons7__VeterinaryEvent(struct soap *soap, const char *tag, ns7__VeterinaryEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VeterinaryEvent **)soap_malloc(soap, sizeof(ns7__VeterinaryEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__VeterinaryEvent *)soap_instantiate_ns7__VeterinaryEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__VeterinaryEvent ** p = (ns7__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VeterinaryEvent, sizeof(ns7__VeterinaryEvent), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__LaboratoryResearchEvent, sizeof(ns7__LaboratoryResearchEvent), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AnimalMedicationEvent, sizeof(ns7__AnimalMedicationEvent), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__QuarantineEvent, sizeof(ns7__QuarantineEvent), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VeterinaryEvent);
	return soap_out_PointerTons7__VeterinaryEvent(soap, tag?tag:"ns7:VeterinaryEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VeterinaryEvent ** SOAP_FMAC4 soap_get_PointerTons7__VeterinaryEvent(struct soap *soap, ns7__VeterinaryEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__AnimalMedicationEvent))
		soap_serialize_PointerTons7__AnimalMedicationEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, ns7__AnimalMedicationEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__AnimalMedicationEvent);
	return (id < 0) ? soap->error : soap_out_PointerTons7__AnimalMedicationEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__AnimalMedicationEvent *** FASTCALL soap_in_PointerToPointerTons7__AnimalMedicationEvent(struct soap *soap, const char *tag, ns7__AnimalMedicationEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__AnimalMedicationEvent ***)soap_malloc(soap, sizeof(ns7__AnimalMedicationEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__AnimalMedicationEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__AnimalMedicationEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__AnimalMedicationEvent, sizeof(ns7__AnimalMedicationEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__AnimalMedicationEvent);
	return soap_out_PointerToPointerTons7__AnimalMedicationEvent(soap, tag?tag:"ns7:AnimalMedicationEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__AnimalMedicationEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__AnimalMedicationEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, ns7__AnimalMedicationEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__AnimalMedicationEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__AnimalMedicationEvent ** FASTCALL soap_in_PointerTons7__AnimalMedicationEvent(struct soap *soap, const char *tag, ns7__AnimalMedicationEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__AnimalMedicationEvent **)soap_malloc(soap, sizeof(ns7__AnimalMedicationEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__AnimalMedicationEvent *)soap_instantiate_ns7__AnimalMedicationEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__AnimalMedicationEvent ** p = (ns7__AnimalMedicationEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AnimalMedicationEvent, sizeof(ns7__AnimalMedicationEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__AnimalMedicationEvent);
	return soap_out_PointerTons7__AnimalMedicationEvent(soap, tag?tag:"ns7:AnimalMedicationEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__AnimalMedicationEvent ** SOAP_FMAC4 soap_get_PointerTons7__AnimalMedicationEvent(struct soap *soap, ns7__AnimalMedicationEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__QuarantineEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__QuarantineEvent(struct soap *soap, const char *tag, int id, ns7__QuarantineEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__QuarantineEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__QuarantineEvent ** FASTCALL soap_in_PointerTons7__QuarantineEvent(struct soap *soap, const char *tag, ns7__QuarantineEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__QuarantineEvent **)soap_malloc(soap, sizeof(ns7__QuarantineEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__QuarantineEvent *)soap_instantiate_ns7__QuarantineEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__QuarantineEvent ** p = (ns7__QuarantineEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__QuarantineEvent, sizeof(ns7__QuarantineEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__QuarantineEvent);
	return soap_out_PointerTons7__QuarantineEvent(soap, tag?tag:"ns7:QuarantineEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__QuarantineEvent ** SOAP_FMAC4 soap_get_PointerTons7__QuarantineEvent(struct soap *soap, ns7__QuarantineEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__LaboratoryResearchEvent))
		soap_serialize_PointerTons7__LaboratoryResearchEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, ns7__LaboratoryResearchEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__LaboratoryResearchEvent);
	return (id < 0) ? soap->error : soap_out_PointerTons7__LaboratoryResearchEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__LaboratoryResearchEvent *** FASTCALL soap_in_PointerToPointerTons7__LaboratoryResearchEvent(struct soap *soap, const char *tag, ns7__LaboratoryResearchEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__LaboratoryResearchEvent ***)soap_malloc(soap, sizeof(ns7__LaboratoryResearchEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__LaboratoryResearchEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__LaboratoryResearchEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__LaboratoryResearchEvent, sizeof(ns7__LaboratoryResearchEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__LaboratoryResearchEvent);
	return soap_out_PointerToPointerTons7__LaboratoryResearchEvent(soap, tag?tag:"ns7:LaboratoryResearchEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__LaboratoryResearchEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__LaboratoryResearchEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, ns7__LaboratoryResearchEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__LaboratoryResearchEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__LaboratoryResearchEvent ** FASTCALL soap_in_PointerTons7__LaboratoryResearchEvent(struct soap *soap, const char *tag, ns7__LaboratoryResearchEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__LaboratoryResearchEvent **)soap_malloc(soap, sizeof(ns7__LaboratoryResearchEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__LaboratoryResearchEvent *)soap_instantiate_ns7__LaboratoryResearchEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__LaboratoryResearchEvent ** p = (ns7__LaboratoryResearchEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__LaboratoryResearchEvent, sizeof(ns7__LaboratoryResearchEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__LaboratoryResearchEvent);
	return soap_out_PointerTons7__LaboratoryResearchEvent(soap, tag?tag:"ns7:LaboratoryResearchEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__LaboratoryResearchEvent ** SOAP_FMAC4 soap_get_PointerTons7__LaboratoryResearchEvent(struct soap *soap, ns7__LaboratoryResearchEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__AnimalSpentPeriod(struct soap *soap, enum ns7__AnimalSpentPeriod *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns7__AnimalSpentPeriod);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__AnimalSpentPeriod(struct soap *soap, const char *tag, int id, enum ns7__AnimalSpentPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__AnimalSpentPeriod);
	return (id < 0) ? soap->error : soap_out_ns7__AnimalSpentPeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns7__AnimalSpentPeriod ** FASTCALL soap_in_PointerTons7__AnimalSpentPeriod(struct soap *soap, const char *tag, enum ns7__AnimalSpentPeriod **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns7__AnimalSpentPeriod **)soap_malloc(soap, sizeof(enum ns7__AnimalSpentPeriod *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__AnimalSpentPeriod(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns7__AnimalSpentPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__AnimalSpentPeriod, sizeof(enum ns7__AnimalSpentPeriod), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__AnimalSpentPeriod(struct soap *soap, enum ns7__AnimalSpentPeriod *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__AnimalSpentPeriod);
	return soap_out_PointerTons7__AnimalSpentPeriod(soap, tag?tag:"ns7:AnimalSpentPeriod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__AnimalSpentPeriod ** SOAP_FMAC4 soap_get_PointerTons7__AnimalSpentPeriod(struct soap *soap, enum ns7__AnimalSpentPeriod **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__AnimalSpentPeriod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ResearchResult(struct soap *soap, enum ns6__ResearchResult *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__ResearchResult);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ResearchResult(struct soap *soap, const char *tag, int id, enum ns6__ResearchResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ResearchResult);
	return (id < 0) ? soap->error : soap_out_ns6__ResearchResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__ResearchResult ** FASTCALL soap_in_PointerTons6__ResearchResult(struct soap *soap, const char *tag, enum ns6__ResearchResult **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__ResearchResult **)soap_malloc(soap, sizeof(enum ns6__ResearchResult *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__ResearchResult(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__ResearchResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ResearchResult, sizeof(enum ns6__ResearchResult), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ResearchResult(struct soap *soap, enum ns6__ResearchResult *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ResearchResult);
	return soap_out_PointerTons6__ResearchResult(soap, tag?tag:"ns6:ResearchResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ResearchResult ** SOAP_FMAC4 soap_get_PointerTons6__ResearchResult(struct soap *soap, enum ns6__ResearchResult **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ResearchResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Purpose(struct soap *soap, ns6__Purpose *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Purpose))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Purpose(struct soap *soap, const char *tag, int id, ns6__Purpose *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Purpose);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Purpose ** FASTCALL soap_in_PointerTons6__Purpose(struct soap *soap, const char *tag, ns6__Purpose **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Purpose **)soap_malloc(soap, sizeof(ns6__Purpose *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Purpose *)soap_instantiate_ns6__Purpose(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Purpose ** p = (ns6__Purpose **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Purpose, sizeof(ns6__Purpose), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Purpose(struct soap *soap, ns6__Purpose *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Purpose);
	return soap_out_PointerTons6__Purpose(soap, tag?tag:"ns6:Purpose", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Purpose ** SOAP_FMAC4 soap_get_PointerTons6__Purpose(struct soap *soap, ns6__Purpose **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__Document(struct soap *soap, ns7__Document **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__Document))
		soap_serialize_PointerTons7__Document(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__Document(struct soap *soap, const char *tag, int id, ns7__Document **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__Document);
	return (id < 0) ? soap->error : soap_out_PointerTons7__Document(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__Document *** FASTCALL soap_in_PointerToPointerTons7__Document(struct soap *soap, const char *tag, ns7__Document ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Document ***)soap_malloc(soap, sizeof(ns7__Document **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__Document(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__Document ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__Document, sizeof(ns7__Document *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__Document(struct soap *soap, ns7__Document **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__Document);
	return soap_out_PointerToPointerTons7__Document(soap, tag?tag:"ns7:Document", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Document *** SOAP_FMAC4 soap_get_PointerToPointerTons7__Document(struct soap *soap, ns7__Document ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__Document(struct soap *soap, ns7__Document *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__Document))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__Document(struct soap *soap, const char *tag, int id, ns7__Document *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__Document);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__Document ** FASTCALL soap_in_PointerTons7__Document(struct soap *soap, const char *tag, ns7__Document **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Document **)soap_malloc(soap, sizeof(ns7__Document *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__Document *)soap_instantiate_ns7__Document(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__Document ** p = (ns7__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Document, sizeof(ns7__Document), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocument, sizeof(ns7__VetDocument), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__DiscrepancyReport, sizeof(ns7__DiscrepancyReport), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Waybill, sizeof(ns7__Waybill), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ReferencedDocument, sizeof(ns7__ReferencedDocument), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__Document(struct soap *soap, ns7__Document *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__Document);
	return soap_out_PointerTons7__Document(soap, tag?tag:"ns7:Document", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Document ** SOAP_FMAC4 soap_get_PointerTons7__Document(struct soap *soap, ns7__Document **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Organization(struct soap *soap, ns6__Organization *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Organization))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Organization(struct soap *soap, const char *tag, int id, ns6__Organization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Organization);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Organization ** FASTCALL soap_in_PointerTons6__Organization(struct soap *soap, const char *tag, ns6__Organization **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Organization **)soap_malloc(soap, sizeof(ns6__Organization *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Organization *)soap_instantiate_ns6__Organization(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Organization ** p = (ns6__Organization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Organization, sizeof(ns6__Organization), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Organization(struct soap *soap, ns6__Organization *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Organization);
	return soap_out_PointerTons6__Organization(soap, tag?tag:"ns6:Organization", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Organization ** SOAP_FMAC4 soap_get_PointerTons6__Organization(struct soap *soap, ns6__Organization **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Organization(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Location(struct soap *soap, ns6__Location *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Location))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Location(struct soap *soap, const char *tag, int id, ns6__Location *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Location);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Location ** FASTCALL soap_in_PointerTons6__Location(struct soap *soap, const char *tag, ns6__Location **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Location **)soap_malloc(soap, sizeof(ns6__Location *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Location *)soap_instantiate_ns6__Location(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Location ** p = (ns6__Location **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Location, sizeof(ns6__Location), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Location(struct soap *soap, ns6__Location *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Location);
	return soap_out_PointerTons6__Location(soap, tag?tag:"ns6:Location", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Location ** SOAP_FMAC4 soap_get_PointerTons6__Location(struct soap *soap, ns6__Location **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Location(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VeterinaryEventType(struct soap *soap, enum ns7__VeterinaryEventType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns7__VeterinaryEventType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VeterinaryEventType(struct soap *soap, const char *tag, int id, enum ns7__VeterinaryEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VeterinaryEventType);
	return (id < 0) ? soap->error : soap_out_ns7__VeterinaryEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns7__VeterinaryEventType ** FASTCALL soap_in_PointerTons7__VeterinaryEventType(struct soap *soap, const char *tag, enum ns7__VeterinaryEventType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns7__VeterinaryEventType **)soap_malloc(soap, sizeof(enum ns7__VeterinaryEventType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns7__VeterinaryEventType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns7__VeterinaryEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VeterinaryEventType, sizeof(enum ns7__VeterinaryEventType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VeterinaryEventType(struct soap *soap, enum ns7__VeterinaryEventType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VeterinaryEventType);
	return soap_out_PointerTons7__VeterinaryEventType(soap, tag?tag:"ns7:VeterinaryEventType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__VeterinaryEventType ** SOAP_FMAC4 soap_get_PointerTons7__VeterinaryEventType(struct soap *soap, enum ns7__VeterinaryEventType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VeterinaryEventType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ShipmentRoute(struct soap *soap, ns7__ShipmentRoute *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ShipmentRoute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ShipmentRoute(struct soap *soap, const char *tag, int id, ns7__ShipmentRoute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ShipmentRoute);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ShipmentRoute ** FASTCALL soap_in_PointerTons7__ShipmentRoute(struct soap *soap, const char *tag, ns7__ShipmentRoute **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ShipmentRoute **)soap_malloc(soap, sizeof(ns7__ShipmentRoute *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ShipmentRoute *)soap_instantiate_ns7__ShipmentRoute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ShipmentRoute ** p = (ns7__ShipmentRoute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ShipmentRoute, sizeof(ns7__ShipmentRoute), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ShipmentRoute(struct soap *soap, ns7__ShipmentRoute *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ShipmentRoute);
	return soap_out_PointerTons7__ShipmentRoute(soap, tag?tag:"ns7:ShipmentRoute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ShipmentRoute ** SOAP_FMAC4 soap_get_PointerTons7__ShipmentRoute(struct soap *soap, ns7__ShipmentRoute **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ShipmentRoute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__TransportationStorageType(struct soap *soap, enum ns6__TransportationStorageType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__TransportationStorageType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__TransportationStorageType(struct soap *soap, const char *tag, int id, enum ns6__TransportationStorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__TransportationStorageType);
	return (id < 0) ? soap->error : soap_out_ns6__TransportationStorageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__TransportationStorageType ** FASTCALL soap_in_PointerTons6__TransportationStorageType(struct soap *soap, const char *tag, enum ns6__TransportationStorageType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__TransportationStorageType **)soap_malloc(soap, sizeof(enum ns6__TransportationStorageType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__TransportationStorageType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__TransportationStorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__TransportationStorageType, sizeof(enum ns6__TransportationStorageType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__TransportationStorageType(struct soap *soap, enum ns6__TransportationStorageType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__TransportationStorageType);
	return soap_out_PointerTons6__TransportationStorageType(soap, tag?tag:"ns6:TransportationStorageType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__TransportationStorageType ** SOAP_FMAC4 soap_get_PointerTons6__TransportationStorageType(struct soap *soap, enum ns6__TransportationStorageType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__TransportationStorageType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__TransportInfo(struct soap *soap, ns7__TransportInfo *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__TransportInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__TransportInfo(struct soap *soap, const char *tag, int id, ns7__TransportInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__TransportInfo);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__TransportInfo ** FASTCALL soap_in_PointerTons7__TransportInfo(struct soap *soap, const char *tag, ns7__TransportInfo **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__TransportInfo **)soap_malloc(soap, sizeof(ns7__TransportInfo *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__TransportInfo *)soap_instantiate_ns7__TransportInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__TransportInfo ** p = (ns7__TransportInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__TransportInfo, sizeof(ns7__TransportInfo), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__TransportInfo(struct soap *soap, ns7__TransportInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__TransportInfo);
	return soap_out_PointerTons7__TransportInfo(soap, tag?tag:"ns7:TransportInfo", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__TransportInfo ** SOAP_FMAC4 soap_get_PointerTons7__TransportInfo(struct soap *soap, ns7__TransportInfo **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__TransportInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__Batch(struct soap *soap, ns7__Batch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__Batch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__Batch(struct soap *soap, const char *tag, int id, ns7__Batch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__Batch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__Batch ** FASTCALL soap_in_PointerTons7__Batch(struct soap *soap, const char *tag, ns7__Batch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Batch **)soap_malloc(soap, sizeof(ns7__Batch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__Batch *)soap_instantiate_ns7__Batch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__Batch ** p = (ns7__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Batch, sizeof(ns7__Batch), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Consignment, sizeof(ns7__Consignment), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ProductiveBatch, sizeof(ns7__ProductiveBatch), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__Batch(struct soap *soap, ns7__Batch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__Batch);
	return soap_out_PointerTons7__Batch(soap, tag?tag:"ns7:Batch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Batch ** SOAP_FMAC4 soap_get_PointerTons7__Batch(struct soap *soap, ns7__Batch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__Batch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseList(struct soap *soap, ns6__EnterpriseList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseList(struct soap *soap, const char *tag, int id, ns6__EnterpriseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__EnterpriseList ** FASTCALL soap_in_PointerTons6__EnterpriseList(struct soap *soap, const char *tag, ns6__EnterpriseList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__EnterpriseList **)soap_malloc(soap, sizeof(ns6__EnterpriseList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__EnterpriseList *)soap_instantiate_ns6__EnterpriseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__EnterpriseList ** p = (ns6__EnterpriseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseList, sizeof(ns6__EnterpriseList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseList(struct soap *soap, ns6__EnterpriseList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseList);
	return soap_out_PointerTons6__EnterpriseList(soap, tag?tag:"ns6:EnterpriseList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__EnterpriseList ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseList(struct soap *soap, ns6__EnterpriseList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _ns7__BEActivityLocationsModificationOperation_activityLocation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, int id, _ns7__BEActivityLocationsModificationOperation_activityLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__BEActivityLocationsModificationOperation_activityLocation ** FASTCALL soap_in_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, _ns7__BEActivityLocationsModificationOperation_activityLocation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns7__BEActivityLocationsModificationOperation_activityLocation **)soap_malloc(soap, sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns7__BEActivityLocationsModificationOperation_activityLocation *)soap_instantiate__ns7__BEActivityLocationsModificationOperation_activityLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns7__BEActivityLocationsModificationOperation_activityLocation ** p = (_ns7__BEActivityLocationsModificationOperation_activityLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__BEActivityLocationsModificationOperation_activityLocation, sizeof(_ns7__BEActivityLocationsModificationOperation_activityLocation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _ns7__BEActivityLocationsModificationOperation_activityLocation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation);
	return soap_out_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(soap, tag?tag:"ns7:BEActivityLocationsModificationOperation-activityLocation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__BEActivityLocationsModificationOperation_activityLocation ** SOAP_FMAC4 soap_get_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _ns7__BEActivityLocationsModificationOperation_activityLocation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns7__BEActivityLocationsModificationOperation_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__GLNType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__GLNType))
		soap_serialize_ns6__GLNType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__GLNType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__GLNType);
	return (id < 0) ? soap->error : soap_out_ns6__GLNType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons6__GLNType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__GLNType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__GLNType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__GLNType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__GLNType);
	return soap_out_PointerTons6__GLNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons6__GLNType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__GLNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__BusinessEntityList(struct soap *soap, ns6__BusinessEntityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__BusinessEntityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__BusinessEntityList(struct soap *soap, const char *tag, int id, ns6__BusinessEntityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__BusinessEntityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__BusinessEntityList ** FASTCALL soap_in_PointerTons6__BusinessEntityList(struct soap *soap, const char *tag, ns6__BusinessEntityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__BusinessEntityList **)soap_malloc(soap, sizeof(ns6__BusinessEntityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__BusinessEntityList *)soap_instantiate_ns6__BusinessEntityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__BusinessEntityList ** p = (ns6__BusinessEntityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__BusinessEntityList, sizeof(ns6__BusinessEntityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__BusinessEntityList(struct soap *soap, ns6__BusinessEntityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__BusinessEntityList);
	return soap_out_PointerTons6__BusinessEntityList(soap, tag?tag:"ns6:BusinessEntityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__BusinessEntityList ** SOAP_FMAC4 soap_get_PointerTons6__BusinessEntityList(struct soap *soap, ns6__BusinessEntityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__BusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProductItemList(struct soap *soap, ns6__ProductItemList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ProductItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ProductItemList(struct soap *soap, const char *tag, int id, ns6__ProductItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProductItemList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ProductItemList ** FASTCALL soap_in_PointerTons6__ProductItemList(struct soap *soap, const char *tag, ns6__ProductItemList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductItemList **)soap_malloc(soap, sizeof(ns6__ProductItemList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ProductItemList *)soap_instantiate_ns6__ProductItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ProductItemList ** p = (ns6__ProductItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProductItemList, sizeof(ns6__ProductItemList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProductItemList(struct soap *soap, ns6__ProductItemList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ProductItemList);
	return soap_out_PointerTons6__ProductItemList(soap, tag?tag:"ns6:ProductItemList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductItemList ** SOAP_FMAC4 soap_get_PointerTons6__ProductItemList(struct soap *soap, ns6__ProductItemList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__StockEntry(struct soap *soap, ns7__StockEntry **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__StockEntry))
		soap_serialize_PointerTons7__StockEntry(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__StockEntry(struct soap *soap, const char *tag, int id, ns7__StockEntry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__StockEntry);
	return (id < 0) ? soap->error : soap_out_PointerTons7__StockEntry(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__StockEntry *** FASTCALL soap_in_PointerToPointerTons7__StockEntry(struct soap *soap, const char *tag, ns7__StockEntry ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockEntry ***)soap_malloc(soap, sizeof(ns7__StockEntry **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__StockEntry(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__StockEntry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__StockEntry, sizeof(ns7__StockEntry *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__StockEntry(struct soap *soap, ns7__StockEntry **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__StockEntry);
	return soap_out_PointerToPointerTons7__StockEntry(soap, tag?tag:"ns7:StockEntry", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockEntry *** SOAP_FMAC4 soap_get_PointerToPointerTons7__StockEntry(struct soap *soap, ns7__StockEntry ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RegisterModificationType(struct soap *soap, enum ns3__RegisterModificationType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns3__RegisterModificationType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__RegisterModificationType(struct soap *soap, const char *tag, int id, enum ns3__RegisterModificationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__RegisterModificationType);
	return (id < 0) ? soap->error : soap_out_ns3__RegisterModificationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns3__RegisterModificationType ** FASTCALL soap_in_PointerTons3__RegisterModificationType(struct soap *soap, const char *tag, enum ns3__RegisterModificationType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns3__RegisterModificationType **)soap_malloc(soap, sizeof(enum ns3__RegisterModificationType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__RegisterModificationType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns3__RegisterModificationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__RegisterModificationType, sizeof(enum ns3__RegisterModificationType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RegisterModificationType(struct soap *soap, enum ns3__RegisterModificationType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__RegisterModificationType);
	return soap_out_PointerTons3__RegisterModificationType(soap, tag?tag:"ns3:RegisterModificationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__RegisterModificationType ** SOAP_FMAC4 soap_get_PointerTons3__RegisterModificationType(struct soap *soap, enum ns3__RegisterModificationType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__RegisterModificationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__ProcessingProcedure))
		soap_serialize_PointerTons7__ProcessingProcedure(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__ProcessingProcedure(struct soap *soap, const char *tag, int id, ns7__ProcessingProcedure **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__ProcessingProcedure);
	return (id < 0) ? soap->error : soap_out_PointerTons7__ProcessingProcedure(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__ProcessingProcedure *** FASTCALL soap_in_PointerToPointerTons7__ProcessingProcedure(struct soap *soap, const char *tag, ns7__ProcessingProcedure ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ProcessingProcedure ***)soap_malloc(soap, sizeof(ns7__ProcessingProcedure **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__ProcessingProcedure(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__ProcessingProcedure ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__ProcessingProcedure, sizeof(ns7__ProcessingProcedure *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__ProcessingProcedure);
	return soap_out_PointerToPointerTons7__ProcessingProcedure(soap, tag?tag:"ns7:ProcessingProcedure", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ProcessingProcedure *** SOAP_FMAC4 soap_get_PointerToPointerTons7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ProcessingProcedure))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ProcessingProcedure(struct soap *soap, const char *tag, int id, ns7__ProcessingProcedure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ProcessingProcedure);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ProcessingProcedure ** FASTCALL soap_in_PointerTons7__ProcessingProcedure(struct soap *soap, const char *tag, ns7__ProcessingProcedure **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ProcessingProcedure **)soap_malloc(soap, sizeof(ns7__ProcessingProcedure *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ProcessingProcedure *)soap_instantiate_ns7__ProcessingProcedure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ProcessingProcedure ** p = (ns7__ProcessingProcedure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ProcessingProcedure, sizeof(ns7__ProcessingProcedure), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ProcessingProcedure);
	return soap_out_PointerTons7__ProcessingProcedure(soap, tag?tag:"ns7:ProcessingProcedure", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ProcessingProcedure ** SOAP_FMAC4 soap_get_PointerTons7__ProcessingProcedure(struct soap *soap, ns7__ProcessingProcedure **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__ProductiveBatch))
		soap_serialize_PointerTons7__ProductiveBatch(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__ProductiveBatch(struct soap *soap, const char *tag, int id, ns7__ProductiveBatch **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__ProductiveBatch);
	return (id < 0) ? soap->error : soap_out_PointerTons7__ProductiveBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__ProductiveBatch *** FASTCALL soap_in_PointerToPointerTons7__ProductiveBatch(struct soap *soap, const char *tag, ns7__ProductiveBatch ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ProductiveBatch ***)soap_malloc(soap, sizeof(ns7__ProductiveBatch **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__ProductiveBatch(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__ProductiveBatch ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__ProductiveBatch, sizeof(ns7__ProductiveBatch *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__ProductiveBatch);
	return soap_out_PointerToPointerTons7__ProductiveBatch(soap, tag?tag:"ns7:ProductiveBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ProductiveBatch *** SOAP_FMAC4 soap_get_PointerToPointerTons7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ProductiveBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ProductiveBatch(struct soap *soap, const char *tag, int id, ns7__ProductiveBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ProductiveBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ProductiveBatch ** FASTCALL soap_in_PointerTons7__ProductiveBatch(struct soap *soap, const char *tag, ns7__ProductiveBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ProductiveBatch **)soap_malloc(soap, sizeof(ns7__ProductiveBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ProductiveBatch *)soap_instantiate_ns7__ProductiveBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ProductiveBatch ** p = (ns7__ProductiveBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ProductiveBatch, sizeof(ns7__ProductiveBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ProductiveBatch);
	return soap_out_PointerTons7__ProductiveBatch(soap, tag?tag:"ns7:ProductiveBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ProductiveBatch ** SOAP_FMAC4 soap_get_PointerTons7__ProductiveBatch(struct soap *soap, ns7__ProductiveBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__RawBatch(struct soap *soap, ns7__RawBatch **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__RawBatch))
		soap_serialize_PointerTons7__RawBatch(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__RawBatch(struct soap *soap, const char *tag, int id, ns7__RawBatch **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__RawBatch);
	return (id < 0) ? soap->error : soap_out_PointerTons7__RawBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__RawBatch *** FASTCALL soap_in_PointerToPointerTons7__RawBatch(struct soap *soap, const char *tag, ns7__RawBatch ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__RawBatch ***)soap_malloc(soap, sizeof(ns7__RawBatch **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__RawBatch(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__RawBatch ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__RawBatch, sizeof(ns7__RawBatch *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__RawBatch(struct soap *soap, ns7__RawBatch **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__RawBatch);
	return soap_out_PointerToPointerTons7__RawBatch(soap, tag?tag:"ns7:RawBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__RawBatch *** SOAP_FMAC4 soap_get_PointerToPointerTons7__RawBatch(struct soap *soap, ns7__RawBatch ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__RawBatch(struct soap *soap, ns7__RawBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__RawBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__RawBatch(struct soap *soap, const char *tag, int id, ns7__RawBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__RawBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__RawBatch ** FASTCALL soap_in_PointerTons7__RawBatch(struct soap *soap, const char *tag, ns7__RawBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__RawBatch **)soap_malloc(soap, sizeof(ns7__RawBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__RawBatch *)soap_instantiate_ns7__RawBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__RawBatch ** p = (ns7__RawBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__RawBatch, sizeof(ns7__RawBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__RawBatch(struct soap *soap, ns7__RawBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__RawBatch);
	return soap_out_PointerTons7__RawBatch(soap, tag?tag:"ns7:RawBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__RawBatch ** SOAP_FMAC4 soap_get_PointerTons7__RawBatch(struct soap *soap, ns7__RawBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__ShipmentRoutePoint))
		soap_serialize_PointerTons7__ShipmentRoutePoint(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, ns7__ShipmentRoutePoint **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__ShipmentRoutePoint);
	return (id < 0) ? soap->error : soap_out_PointerTons7__ShipmentRoutePoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__ShipmentRoutePoint *** FASTCALL soap_in_PointerToPointerTons7__ShipmentRoutePoint(struct soap *soap, const char *tag, ns7__ShipmentRoutePoint ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ShipmentRoutePoint ***)soap_malloc(soap, sizeof(ns7__ShipmentRoutePoint **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__ShipmentRoutePoint(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__ShipmentRoutePoint ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__ShipmentRoutePoint, sizeof(ns7__ShipmentRoutePoint *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__ShipmentRoutePoint);
	return soap_out_PointerToPointerTons7__ShipmentRoutePoint(soap, tag?tag:"ns7:ShipmentRoutePoint", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ShipmentRoutePoint *** SOAP_FMAC4 soap_get_PointerToPointerTons7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ShipmentRoutePoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, ns7__ShipmentRoutePoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ShipmentRoutePoint);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ShipmentRoutePoint ** FASTCALL soap_in_PointerTons7__ShipmentRoutePoint(struct soap *soap, const char *tag, ns7__ShipmentRoutePoint **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ShipmentRoutePoint **)soap_malloc(soap, sizeof(ns7__ShipmentRoutePoint *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ShipmentRoutePoint *)soap_instantiate_ns7__ShipmentRoutePoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ShipmentRoutePoint ** p = (ns7__ShipmentRoutePoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ShipmentRoutePoint, sizeof(ns7__ShipmentRoutePoint), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ShipmentRoutePoint);
	return soap_out_PointerTons7__ShipmentRoutePoint(soap, tag?tag:"ns7:ShipmentRoutePoint", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ShipmentRoutePoint ** SOAP_FMAC4 soap_get_PointerTons7__ShipmentRoutePoint(struct soap *soap, ns7__ShipmentRoutePoint **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__TransportNumber(struct soap *soap, ns7__TransportNumber *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__TransportNumber))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__TransportNumber(struct soap *soap, const char *tag, int id, ns7__TransportNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__TransportNumber);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__TransportNumber ** FASTCALL soap_in_PointerTons7__TransportNumber(struct soap *soap, const char *tag, ns7__TransportNumber **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__TransportNumber **)soap_malloc(soap, sizeof(ns7__TransportNumber *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__TransportNumber *)soap_instantiate_ns7__TransportNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__TransportNumber ** p = (ns7__TransportNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__TransportNumber, sizeof(ns7__TransportNumber), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__TransportNumber(struct soap *soap, ns7__TransportNumber *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__TransportNumber);
	return soap_out_PointerTons7__TransportNumber(soap, tag?tag:"ns7:TransportNumber", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__TransportNumber ** SOAP_FMAC4 soap_get_PointerTons7__TransportNumber(struct soap *soap, ns7__TransportNumber **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__TransportNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__TransportType(struct soap *soap, enum ns6__TransportType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__TransportType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__TransportType(struct soap *soap, const char *tag, int id, enum ns6__TransportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__TransportType);
	return (id < 0) ? soap->error : soap_out_ns6__TransportType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__TransportType ** FASTCALL soap_in_PointerTons6__TransportType(struct soap *soap, const char *tag, enum ns6__TransportType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__TransportType **)soap_malloc(soap, sizeof(enum ns6__TransportType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__TransportType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__TransportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__TransportType, sizeof(enum ns6__TransportType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__TransportType(struct soap *soap, enum ns6__TransportType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__TransportType);
	return soap_out_PointerTons6__TransportType(soap, tag?tag:"ns6:TransportType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__TransportType ** SOAP_FMAC4 soap_get_PointerTons6__TransportType(struct soap *soap, enum ns6__TransportType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__TransportType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__StockEntryList(struct soap *soap, ns7__StockEntryList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__StockEntryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__StockEntryList(struct soap *soap, const char *tag, int id, ns7__StockEntryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__StockEntryList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__StockEntryList ** FASTCALL soap_in_PointerTons7__StockEntryList(struct soap *soap, const char *tag, ns7__StockEntryList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockEntryList **)soap_malloc(soap, sizeof(ns7__StockEntryList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__StockEntryList *)soap_instantiate_ns7__StockEntryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__StockEntryList ** p = (ns7__StockEntryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockEntryList, sizeof(ns7__StockEntryList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__StockEntryList(struct soap *soap, ns7__StockEntryList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__StockEntryList);
	return soap_out_PointerTons7__StockEntryList(soap, tag?tag:"ns7:StockEntryList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockEntryList ** SOAP_FMAC4 soap_get_PointerTons7__StockEntryList(struct soap *soap, ns7__StockEntryList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__StockEntryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ComplexDate(struct soap *soap, ns6__ComplexDate *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ComplexDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ComplexDate(struct soap *soap, const char *tag, int id, ns6__ComplexDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ComplexDate);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ComplexDate ** FASTCALL soap_in_PointerTons6__ComplexDate(struct soap *soap, const char *tag, ns6__ComplexDate **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ComplexDate **)soap_malloc(soap, sizeof(ns6__ComplexDate *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ComplexDate *)soap_instantiate_ns6__ComplexDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ComplexDate ** p = (ns6__ComplexDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ComplexDate, sizeof(ns6__ComplexDate), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ComplexDate(struct soap *soap, ns6__ComplexDate *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ComplexDate);
	return soap_out_PointerTons6__ComplexDate(soap, tag?tag:"ns6:ComplexDate", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ComplexDate ** SOAP_FMAC4 soap_get_PointerTons6__ComplexDate(struct soap *soap, ns6__ComplexDate **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__ReferencedDocument))
		soap_serialize_PointerTons7__ReferencedDocument(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__ReferencedDocument(struct soap *soap, const char *tag, int id, ns7__ReferencedDocument **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__ReferencedDocument);
	return (id < 0) ? soap->error : soap_out_PointerTons7__ReferencedDocument(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__ReferencedDocument *** FASTCALL soap_in_PointerToPointerTons7__ReferencedDocument(struct soap *soap, const char *tag, ns7__ReferencedDocument ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ReferencedDocument ***)soap_malloc(soap, sizeof(ns7__ReferencedDocument **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__ReferencedDocument(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__ReferencedDocument ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__ReferencedDocument, sizeof(ns7__ReferencedDocument *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__ReferencedDocument);
	return soap_out_PointerToPointerTons7__ReferencedDocument(soap, tag?tag:"ns7:ReferencedDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ReferencedDocument *** SOAP_FMAC4 soap_get_PointerToPointerTons7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__ReferencedDocument))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__ReferencedDocument(struct soap *soap, const char *tag, int id, ns7__ReferencedDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ReferencedDocument);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__ReferencedDocument ** FASTCALL soap_in_PointerTons7__ReferencedDocument(struct soap *soap, const char *tag, ns7__ReferencedDocument **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__ReferencedDocument **)soap_malloc(soap, sizeof(ns7__ReferencedDocument *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__ReferencedDocument *)soap_instantiate_ns7__ReferencedDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__ReferencedDocument ** p = (ns7__ReferencedDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ReferencedDocument, sizeof(ns7__ReferencedDocument), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__ReferencedDocument);
	return soap_out_PointerTons7__ReferencedDocument(soap, tag?tag:"ns7:ReferencedDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__ReferencedDocument ** SOAP_FMAC4 soap_get_PointerTons7__ReferencedDocument(struct soap *soap, ns7__ReferencedDocument **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons7__VetDocument(struct soap *soap, ns7__VetDocument **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons7__VetDocument))
		soap_serialize_PointerTons7__VetDocument(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons7__VetDocument(struct soap *soap, const char *tag, int id, ns7__VetDocument **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons7__VetDocument);
	return (id < 0) ? soap->error : soap_out_PointerTons7__VetDocument(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns7__VetDocument *** FASTCALL soap_in_PointerToPointerTons7__VetDocument(struct soap *soap, const char *tag, ns7__VetDocument ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VetDocument ***)soap_malloc(soap, sizeof(ns7__VetDocument **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons7__VetDocument(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns7__VetDocument ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons7__VetDocument, sizeof(ns7__VetDocument *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons7__VetDocument(struct soap *soap, ns7__VetDocument **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons7__VetDocument);
	return soap_out_PointerToPointerTons7__VetDocument(soap, tag?tag:"ns7:VetDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VetDocument *** SOAP_FMAC4 soap_get_PointerToPointerTons7__VetDocument(struct soap *soap, ns7__VetDocument ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons7__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__VetDocument(struct soap *soap, ns7__VetDocument *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__VetDocument))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__VetDocument(struct soap *soap, const char *tag, int id, ns7__VetDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__VetDocument);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__VetDocument ** FASTCALL soap_in_PointerTons7__VetDocument(struct soap *soap, const char *tag, ns7__VetDocument **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__VetDocument **)soap_malloc(soap, sizeof(ns7__VetDocument *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__VetDocument *)soap_instantiate_ns7__VetDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__VetDocument ** p = (ns7__VetDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__VetDocument, sizeof(ns7__VetDocument), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__VetDocument(struct soap *soap, ns7__VetDocument *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__VetDocument);
	return soap_out_PointerTons7__VetDocument(soap, tag?tag:"ns7:VetDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__VetDocument ** SOAP_FMAC4 soap_get_PointerTons7__VetDocument(struct soap *soap, ns7__VetDocument **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__Waybill(struct soap *soap, ns7__Waybill *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__Waybill))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__Waybill(struct soap *soap, const char *tag, int id, ns7__Waybill *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__Waybill);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__Waybill ** FASTCALL soap_in_PointerTons7__Waybill(struct soap *soap, const char *tag, ns7__Waybill **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__Waybill **)soap_malloc(soap, sizeof(ns7__Waybill *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__Waybill *)soap_instantiate_ns7__Waybill(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__Waybill ** p = (ns7__Waybill **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Waybill, sizeof(ns7__Waybill), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__Waybill(struct soap *soap, ns7__Waybill *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__Waybill);
	return soap_out_PointerTons7__Waybill(soap, tag?tag:"ns7:Waybill", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__Waybill ** SOAP_FMAC4 soap_get_PointerTons7__Waybill(struct soap *soap, ns7__Waybill **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__Waybill(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__User(struct soap *soap, ns7__User *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__User))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__User(struct soap *soap, const char *tag, int id, ns7__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__User);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__User ** FASTCALL soap_in_PointerTons7__User(struct soap *soap, const char *tag, ns7__User **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__User **)soap_malloc(soap, sizeof(ns7__User *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__User *)soap_instantiate_ns7__User(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__User ** p = (ns7__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__User, sizeof(ns7__User), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__User(struct soap *soap, ns7__User *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__User);
	return soap_out_PointerTons7__User(soap, tag?tag:"ns7:User", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__User ** SOAP_FMAC4 soap_get_PointerTons7__User(struct soap *soap, ns7__User **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__DeliveryInspection(struct soap *soap, ns7__DeliveryInspection *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__DeliveryInspection))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__DeliveryInspection(struct soap *soap, const char *tag, int id, ns7__DeliveryInspection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__DeliveryInspection);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__DeliveryInspection ** FASTCALL soap_in_PointerTons7__DeliveryInspection(struct soap *soap, const char *tag, ns7__DeliveryInspection **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__DeliveryInspection **)soap_malloc(soap, sizeof(ns7__DeliveryInspection *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__DeliveryInspection *)soap_instantiate_ns7__DeliveryInspection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__DeliveryInspection ** p = (ns7__DeliveryInspection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__DeliveryInspection, sizeof(ns7__DeliveryInspection), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__DeliveryInspection(struct soap *soap, ns7__DeliveryInspection *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__DeliveryInspection);
	return soap_out_PointerTons7__DeliveryInspection(soap, tag?tag:"ns7:DeliveryInspection", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__DeliveryInspection ** SOAP_FMAC4 soap_get_PointerTons7__DeliveryInspection(struct soap *soap, ns7__DeliveryInspection **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__DeliveryInspection(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__StockEntry(struct soap *soap, ns7__StockEntry *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__StockEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__StockEntry(struct soap *soap, const char *tag, int id, ns7__StockEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__StockEntry);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__StockEntry ** FASTCALL soap_in_PointerTons7__StockEntry(struct soap *soap, const char *tag, ns7__StockEntry **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__StockEntry **)soap_malloc(soap, sizeof(ns7__StockEntry *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__StockEntry *)soap_instantiate_ns7__StockEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__StockEntry ** p = (ns7__StockEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockEntry, sizeof(ns7__StockEntry), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns7__StockEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__StockEntrySearchPattern, sizeof(ns7__StockEntrySearchPattern), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__StockEntry(struct soap *soap, ns7__StockEntry *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__StockEntry);
	return soap_out_PointerTons7__StockEntry(soap, tag?tag:"ns7:StockEntry", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__StockEntry ** SOAP_FMAC4 soap_get_PointerTons7__StockEntry(struct soap *soap, ns7__StockEntry **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__PackageList(struct soap *soap, ns6__PackageList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__PackageList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__PackageList(struct soap *soap, const char *tag, int id, ns6__PackageList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__PackageList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__PackageList ** FASTCALL soap_in_PointerTons6__PackageList(struct soap *soap, const char *tag, ns6__PackageList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__PackageList **)soap_malloc(soap, sizeof(ns6__PackageList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__PackageList *)soap_instantiate_ns6__PackageList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__PackageList ** p = (ns6__PackageList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__PackageList, sizeof(ns6__PackageList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__PackageList(struct soap *soap, ns6__PackageList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__PackageList);
	return soap_out_PointerTons6__PackageList(soap, tag?tag:"ns6:PackageList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__PackageList ** SOAP_FMAC4 soap_get_PointerTons6__PackageList(struct soap *soap, ns6__PackageList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__PackageList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__BatchOrigin(struct soap *soap, ns7__BatchOrigin *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__BatchOrigin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__BatchOrigin(struct soap *soap, const char *tag, int id, ns7__BatchOrigin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__BatchOrigin);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__BatchOrigin ** FASTCALL soap_in_PointerTons7__BatchOrigin(struct soap *soap, const char *tag, ns7__BatchOrigin **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__BatchOrigin **)soap_malloc(soap, sizeof(ns7__BatchOrigin *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__BatchOrigin *)soap_instantiate_ns7__BatchOrigin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__BatchOrigin ** p = (ns7__BatchOrigin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__BatchOrigin, sizeof(ns7__BatchOrigin), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__BatchOrigin(struct soap *soap, ns7__BatchOrigin *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__BatchOrigin);
	return soap_out_PointerTons7__BatchOrigin(soap, tag?tag:"ns7:BatchOrigin", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__BatchOrigin ** SOAP_FMAC4 soap_get_PointerTons7__BatchOrigin(struct soap *soap, ns7__BatchOrigin **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__BatchOrigin(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__GoodsDate(struct soap *soap, ns7__GoodsDate *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns7__GoodsDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons7__GoodsDate(struct soap *soap, const char *tag, int id, ns7__GoodsDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__GoodsDate);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__GoodsDate ** FASTCALL soap_in_PointerTons7__GoodsDate(struct soap *soap, const char *tag, ns7__GoodsDate **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns7__GoodsDate **)soap_malloc(soap, sizeof(ns7__GoodsDate *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns7__GoodsDate *)soap_instantiate_ns7__GoodsDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns7__GoodsDate ** p = (ns7__GoodsDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__GoodsDate, sizeof(ns7__GoodsDate), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__GoodsDate(struct soap *soap, ns7__GoodsDate *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__GoodsDate);
	return soap_out_PointerTons7__GoodsDate(soap, tag?tag:"ns7:GoodsDate", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns7__GoodsDate ** SOAP_FMAC4 soap_get_PointerTons7__GoodsDate(struct soap *soap, ns7__GoodsDate **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons7__GoodsDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProductItem(struct soap *soap, ns6__ProductItem *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ProductItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ProductItem(struct soap *soap, const char *tag, int id, ns6__ProductItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProductItem);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ProductItem ** FASTCALL soap_in_PointerTons6__ProductItem(struct soap *soap, const char *tag, ns6__ProductItem **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductItem **)soap_malloc(soap, sizeof(ns6__ProductItem *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ProductItem *)soap_instantiate_ns6__ProductItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ProductItem ** p = (ns6__ProductItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProductItem, sizeof(ns6__ProductItem), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProductItem(struct soap *soap, ns6__ProductItem *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ProductItem);
	return soap_out_PointerTons6__ProductItem(soap, tag?tag:"ns6:ProductItem", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductItem ** SOAP_FMAC4 soap_get_PointerTons6__ProductItem(struct soap *soap, ns6__ProductItem **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__SubProduct(struct soap *soap, ns6__SubProduct *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__SubProduct))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__SubProduct(struct soap *soap, const char *tag, int id, ns6__SubProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__SubProduct);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__SubProduct ** FASTCALL soap_in_PointerTons6__SubProduct(struct soap *soap, const char *tag, ns6__SubProduct **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__SubProduct **)soap_malloc(soap, sizeof(ns6__SubProduct *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__SubProduct *)soap_instantiate_ns6__SubProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__SubProduct ** p = (ns6__SubProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__SubProduct, sizeof(ns6__SubProduct), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__SubProduct(struct soap *soap, ns6__SubProduct *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__SubProduct);
	return soap_out_PointerTons6__SubProduct(soap, tag?tag:"ns6:SubProduct", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__SubProduct ** SOAP_FMAC4 soap_get_PointerTons6__SubProduct(struct soap *soap, ns6__SubProduct **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Product(struct soap *soap, ns6__Product *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Product))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Product(struct soap *soap, const char *tag, int id, ns6__Product *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Product);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Product ** FASTCALL soap_in_PointerTons6__Product(struct soap *soap, const char *tag, ns6__Product **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Product **)soap_malloc(soap, sizeof(ns6__Product *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Product *)soap_instantiate_ns6__Product(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Product ** p = (ns6__Product **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Product, sizeof(ns6__Product), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Product(struct soap *soap, ns6__Product *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Product);
	return soap_out_PointerTons6__Product(soap, tag?tag:"ns6:Product", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Product ** SOAP_FMAC4 soap_get_PointerTons6__Product(struct soap *soap, ns6__Product **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProductType(struct soap *soap, enum ns6__ProductType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__ProductType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ProductType(struct soap *soap, const char *tag, int id, enum ns6__ProductType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProductType);
	return (id < 0) ? soap->error : soap_out_ns6__ProductType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__ProductType ** FASTCALL soap_in_PointerTons6__ProductType(struct soap *soap, const char *tag, enum ns6__ProductType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__ProductType **)soap_malloc(soap, sizeof(enum ns6__ProductType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__ProductType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__ProductType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProductType, sizeof(enum ns6__ProductType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProductType(struct soap *soap, enum ns6__ProductType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ProductType);
	return soap_out_PointerTons6__ProductType(soap, tag?tag:"ns6:ProductType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ProductType ** SOAP_FMAC4 soap_get_PointerTons6__ProductType(struct soap *soap, enum ns6__ProductType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ProductType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__RegionalizationConditionGroup))
		soap_serialize_PointerTons6__RegionalizationConditionGroup(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, ns6__RegionalizationConditionGroup **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__RegionalizationConditionGroup);
	return (id < 0) ? soap->error : soap_out_PointerTons6__RegionalizationConditionGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionGroup *** FASTCALL soap_in_PointerToPointerTons6__RegionalizationConditionGroup(struct soap *soap, const char *tag, ns6__RegionalizationConditionGroup ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationConditionGroup ***)soap_malloc(soap, sizeof(ns6__RegionalizationConditionGroup **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__RegionalizationConditionGroup(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationConditionGroup ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__RegionalizationConditionGroup, sizeof(ns6__RegionalizationConditionGroup *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__RegionalizationConditionGroup);
	return soap_out_PointerToPointerTons6__RegionalizationConditionGroup(soap, tag?tag:"ns6:RegionalizationConditionGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationConditionGroup *** SOAP_FMAC4 soap_get_PointerToPointerTons6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationConditionGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, ns6__RegionalizationConditionGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationConditionGroup);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationConditionGroup ** FASTCALL soap_in_PointerTons6__RegionalizationConditionGroup(struct soap *soap, const char *tag, ns6__RegionalizationConditionGroup **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationConditionGroup **)soap_malloc(soap, sizeof(ns6__RegionalizationConditionGroup *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationConditionGroup *)soap_instantiate_ns6__RegionalizationConditionGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationConditionGroup ** p = (ns6__RegionalizationConditionGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationConditionGroup, sizeof(ns6__RegionalizationConditionGroup), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationConditionGroup);
	return soap_out_PointerTons6__RegionalizationConditionGroup(soap, tag?tag:"ns6:RegionalizationConditionGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationConditionGroup ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationConditionGroup(struct soap *soap, ns6__RegionalizationConditionGroup **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AnimalDisease(struct soap *soap, ns6__AnimalDisease *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__AnimalDisease))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__AnimalDisease(struct soap *soap, const char *tag, int id, ns6__AnimalDisease *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AnimalDisease);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__AnimalDisease ** FASTCALL soap_in_PointerTons6__AnimalDisease(struct soap *soap, const char *tag, ns6__AnimalDisease **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__AnimalDisease **)soap_malloc(soap, sizeof(ns6__AnimalDisease *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__AnimalDisease *)soap_instantiate_ns6__AnimalDisease(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__AnimalDisease ** p = (ns6__AnimalDisease **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AnimalDisease, sizeof(ns6__AnimalDisease), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AnimalDisease(struct soap *soap, ns6__AnimalDisease *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__AnimalDisease);
	return soap_out_PointerTons6__AnimalDisease(soap, tag?tag:"ns6:AnimalDisease", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__AnimalDisease ** SOAP_FMAC4 soap_get_PointerTons6__AnimalDisease(struct soap *soap, ns6__AnimalDisease **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__RegionalizationCondition))
		soap_serialize_PointerTons6__RegionalizationCondition(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__RegionalizationCondition(struct soap *soap, const char *tag, int id, ns6__RegionalizationCondition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__RegionalizationCondition);
	return (id < 0) ? soap->error : soap_out_PointerTons6__RegionalizationCondition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__RegionalizationCondition *** FASTCALL soap_in_PointerToPointerTons6__RegionalizationCondition(struct soap *soap, const char *tag, ns6__RegionalizationCondition ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationCondition ***)soap_malloc(soap, sizeof(ns6__RegionalizationCondition **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__RegionalizationCondition(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__RegionalizationCondition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__RegionalizationCondition, sizeof(ns6__RegionalizationCondition *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__RegionalizationCondition);
	return soap_out_PointerToPointerTons6__RegionalizationCondition(soap, tag?tag:"ns6:RegionalizationCondition", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationCondition *** SOAP_FMAC4 soap_get_PointerToPointerTons6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__RegionalizationCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__RegionalizationCondition(struct soap *soap, const char *tag, int id, ns6__RegionalizationCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RegionalizationCondition);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RegionalizationCondition ** FASTCALL soap_in_PointerTons6__RegionalizationCondition(struct soap *soap, const char *tag, ns6__RegionalizationCondition **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__RegionalizationCondition **)soap_malloc(soap, sizeof(ns6__RegionalizationCondition *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__RegionalizationCondition *)soap_instantiate_ns6__RegionalizationCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__RegionalizationCondition ** p = (ns6__RegionalizationCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RegionalizationCondition, sizeof(ns6__RegionalizationCondition), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RegionalizationCondition);
	return soap_out_PointerTons6__RegionalizationCondition(soap, tag?tag:"ns6:RegionalizationCondition", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__RegionalizationCondition ** SOAP_FMAC4 soap_get_PointerTons6__RegionalizationCondition(struct soap *soap, ns6__RegionalizationCondition **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__BusinessMember(struct soap *soap, ns6__BusinessMember *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__BusinessMember))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__BusinessMember(struct soap *soap, const char *tag, int id, ns6__BusinessMember *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__BusinessMember);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__BusinessMember ** FASTCALL soap_in_PointerTons6__BusinessMember(struct soap *soap, const char *tag, ns6__BusinessMember **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__BusinessMember **)soap_malloc(soap, sizeof(ns6__BusinessMember *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__BusinessMember *)soap_instantiate_ns6__BusinessMember(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__BusinessMember ** p = (ns6__BusinessMember **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__BusinessMember, sizeof(ns6__BusinessMember), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__BusinessMember(struct soap *soap, ns6__BusinessMember *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__BusinessMember);
	return soap_out_PointerTons6__BusinessMember(soap, tag?tag:"ns6:BusinessMember", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__BusinessMember ** SOAP_FMAC4 soap_get_PointerTons6__BusinessMember(struct soap *soap, ns6__BusinessMember **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Identifier(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__Identifier))
		soap_serialize_ns3__Identifier(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__Identifier(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Identifier);
	return (id < 0) ? soap->error : soap_out_ns3__Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__Identifier(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Identifier, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Identifier(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__Identifier);
	return soap_out_PointerTons3__Identifier(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__Identifier(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__Identifier(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Address(struct soap *soap, ns6__Address *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Address))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Address(struct soap *soap, const char *tag, int id, ns6__Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Address);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Address ** FASTCALL soap_in_PointerTons6__Address(struct soap *soap, const char *tag, ns6__Address **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Address **)soap_malloc(soap, sizeof(ns6__Address *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Address *)soap_instantiate_ns6__Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Address ** p = (ns6__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Address, sizeof(ns6__Address), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns6__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Area, sizeof(ns6__Area), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Address(struct soap *soap, ns6__Address *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Address);
	return soap_out_PointerTons6__Address(soap, tag?tag:"ns6:Address", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Address ** SOAP_FMAC4 soap_get_PointerTons6__Address(struct soap *soap, ns6__Address **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Address(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Unit(struct soap *soap, ns6__Unit *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Unit))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Unit(struct soap *soap, const char *tag, int id, ns6__Unit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Unit);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Unit ** FASTCALL soap_in_PointerTons6__Unit(struct soap *soap, const char *tag, ns6__Unit **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Unit **)soap_malloc(soap, sizeof(ns6__Unit *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Unit *)soap_instantiate_ns6__Unit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Unit ** p = (ns6__Unit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Unit, sizeof(ns6__Unit), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Unit(struct soap *soap, ns6__Unit *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Unit);
	return soap_out_PointerTons6__Unit(soap, tag?tag:"ns6:Unit", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Unit ** SOAP_FMAC4 soap_get_PointerTons6__Unit(struct soap *soap, ns6__Unit **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Decimal(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__Decimal))
		soap_serialize_ns3__Decimal(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__Decimal(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Decimal);
	return (id < 0) ? soap->error : soap_out_ns3__Decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__Decimal(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__Decimal(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Decimal, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Decimal(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__Decimal);
	return soap_out_PointerTons3__Decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__Decimal(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__Decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Minute(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__Minute);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Minute(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Minute);
	return (id < 0) ? soap->error : soap_out_ns6__Minute(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTons6__Minute(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__Minute(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Minute, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Minute(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Minute);
	return soap_out_PointerTons6__Minute(soap, tag?tag:"ns6:Minute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons6__Minute(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Minute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Hour(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__Hour);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Hour(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Hour);
	return (id < 0) ? soap->error : soap_out_ns6__Hour(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTons6__Hour(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__Hour(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Hour, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Hour(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Hour);
	return soap_out_PointerTons6__Hour(soap, tag?tag:"ns6:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons6__Hour(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Day(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__Day);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Day(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Day);
	return (id < 0) ? soap->error : soap_out_ns6__Day(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTons6__Day(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__Day(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Day, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Day(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Day);
	return soap_out_PointerTons6__Day(soap, tag?tag:"ns6:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons6__Day(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Month(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__Month);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Month(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Month);
	return (id < 0) ? soap->error : soap_out_ns6__Month(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTons6__Month(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__Month(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Month, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Month(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Month);
	return soap_out_PointerTons6__Month(soap, tag?tag:"ns6:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons6__Month(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Year(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__Year);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Year(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Year);
	return (id < 0) ? soap->error : soap_out_ns6__Year(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerTons6__Year(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__Year(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Year, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Year(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Year);
	return soap_out_PointerTons6__Year(soap, tag?tag:"ns6:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons6__Year(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Package(struct soap *soap, ns6__Package **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Package))
		soap_serialize_PointerTons6__Package(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Package(struct soap *soap, const char *tag, int id, ns6__Package **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Package);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Package(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Package *** FASTCALL soap_in_PointerToPointerTons6__Package(struct soap *soap, const char *tag, ns6__Package ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Package ***)soap_malloc(soap, sizeof(ns6__Package **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Package(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Package ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Package, sizeof(ns6__Package *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Package(struct soap *soap, ns6__Package **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Package);
	return soap_out_PointerToPointerTons6__Package(soap, tag?tag:"ns6:Package", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Package *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Package(struct soap *soap, ns6__Package ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Package(struct soap *soap, ns6__Package *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Package))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Package(struct soap *soap, const char *tag, int id, ns6__Package *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Package);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Package ** FASTCALL soap_in_PointerTons6__Package(struct soap *soap, const char *tag, ns6__Package **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Package **)soap_malloc(soap, sizeof(ns6__Package *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Package *)soap_instantiate_ns6__Package(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Package ** p = (ns6__Package **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Package, sizeof(ns6__Package), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Package(struct soap *soap, ns6__Package *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Package);
	return soap_out_PointerTons6__Package(soap, tag?tag:"ns6:Package", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Package ** SOAP_FMAC4 soap_get_PointerTons6__Package(struct soap *soap, ns6__Package **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__ProductMarks(struct soap *soap, ns6__ProductMarks **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__ProductMarks))
		soap_serialize_PointerTons6__ProductMarks(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__ProductMarks(struct soap *soap, const char *tag, int id, ns6__ProductMarks **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__ProductMarks);
	return (id < 0) ? soap->error : soap_out_PointerTons6__ProductMarks(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__ProductMarks *** FASTCALL soap_in_PointerToPointerTons6__ProductMarks(struct soap *soap, const char *tag, ns6__ProductMarks ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductMarks ***)soap_malloc(soap, sizeof(ns6__ProductMarks **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__ProductMarks(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__ProductMarks ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__ProductMarks, sizeof(ns6__ProductMarks *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__ProductMarks(struct soap *soap, ns6__ProductMarks **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__ProductMarks);
	return soap_out_PointerToPointerTons6__ProductMarks(soap, tag?tag:"ns6:ProductMarks", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductMarks *** SOAP_FMAC4 soap_get_PointerToPointerTons6__ProductMarks(struct soap *soap, ns6__ProductMarks ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProductMarks(struct soap *soap, ns6__ProductMarks *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__ProductMarks))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__ProductMarks(struct soap *soap, const char *tag, int id, ns6__ProductMarks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProductMarks);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ProductMarks ** FASTCALL soap_in_PointerTons6__ProductMarks(struct soap *soap, const char *tag, ns6__ProductMarks **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__ProductMarks **)soap_malloc(soap, sizeof(ns6__ProductMarks *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__ProductMarks *)soap_instantiate_ns6__ProductMarks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__ProductMarks ** p = (ns6__ProductMarks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProductMarks, sizeof(ns6__ProductMarks), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProductMarks(struct soap *soap, ns6__ProductMarks *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ProductMarks);
	return soap_out_PointerTons6__ProductMarks(soap, tag?tag:"ns6:ProductMarks", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ProductMarks ** SOAP_FMAC4 soap_get_PointerTons6__ProductMarks(struct soap *soap, ns6__ProductMarks **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__PackingType(struct soap *soap, ns6__PackingType *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__PackingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__PackingType(struct soap *soap, const char *tag, int id, ns6__PackingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__PackingType);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__PackingType ** FASTCALL soap_in_PointerTons6__PackingType(struct soap *soap, const char *tag, ns6__PackingType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__PackingType **)soap_malloc(soap, sizeof(ns6__PackingType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__PackingType *)soap_instantiate_ns6__PackingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__PackingType ** p = (ns6__PackingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__PackingType, sizeof(ns6__PackingType), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__PackingType(struct soap *soap, ns6__PackingType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__PackingType);
	return soap_out_PointerTons6__PackingType(soap, tag?tag:"ns6:PackingType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__PackingType ** SOAP_FMAC4 soap_get_PointerTons6__PackingType(struct soap *soap, ns6__PackingType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__PackingType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__BusinessEntity(struct soap *soap, ns6__BusinessEntity *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__BusinessEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__BusinessEntity(struct soap *soap, const char *tag, int id, ns6__BusinessEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__BusinessEntity);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__BusinessEntity ** FASTCALL soap_in_PointerTons6__BusinessEntity(struct soap *soap, const char *tag, ns6__BusinessEntity **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__BusinessEntity **)soap_malloc(soap, sizeof(ns6__BusinessEntity *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__BusinessEntity *)soap_instantiate_ns6__BusinessEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__BusinessEntity ** p = (ns6__BusinessEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__BusinessEntity, sizeof(ns6__BusinessEntity), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__BusinessEntity(struct soap *soap, ns6__BusinessEntity *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__BusinessEntity);
	return soap_out_PointerTons6__BusinessEntity(soap, tag?tag:"ns6:BusinessEntity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__BusinessEntity ** SOAP_FMAC4 soap_get_PointerTons6__BusinessEntity(struct soap *soap, ns6__BusinessEntity **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__String255(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__String255))
		soap_serialize_ns3__String255(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__String255(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__String255);
	return (id < 0) ? soap->error : soap_out_ns3__String255(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__String255(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__String255(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__String255, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__String255(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__String255);
	return soap_out_PointerTons3__String255(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__String255(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__String255(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons6__Producer(struct soap *soap, ns6__Producer **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons6__Producer))
		soap_serialize_PointerTons6__Producer(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons6__Producer(struct soap *soap, const char *tag, int id, ns6__Producer **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons6__Producer);
	return (id < 0) ? soap->error : soap_out_PointerTons6__Producer(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns6__Producer *** FASTCALL soap_in_PointerToPointerTons6__Producer(struct soap *soap, const char *tag, ns6__Producer ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Producer ***)soap_malloc(soap, sizeof(ns6__Producer **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons6__Producer(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns6__Producer ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons6__Producer, sizeof(ns6__Producer *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons6__Producer(struct soap *soap, ns6__Producer **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons6__Producer);
	return soap_out_PointerToPointerTons6__Producer(soap, tag?tag:"ns6:Producer", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Producer *** SOAP_FMAC4 soap_get_PointerToPointerTons6__Producer(struct soap *soap, ns6__Producer ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons6__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Producer(struct soap *soap, ns6__Producer *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Producer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Producer(struct soap *soap, const char *tag, int id, ns6__Producer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Producer);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Producer ** FASTCALL soap_in_PointerTons6__Producer(struct soap *soap, const char *tag, ns6__Producer **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Producer **)soap_malloc(soap, sizeof(ns6__Producer *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Producer *)soap_instantiate_ns6__Producer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Producer ** p = (ns6__Producer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Producer, sizeof(ns6__Producer), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Producer(struct soap *soap, ns6__Producer *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Producer);
	return soap_out_PointerTons6__Producer(soap, tag?tag:"ns6:Producer", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Producer ** SOAP_FMAC4 soap_get_PointerTons6__Producer(struct soap *soap, ns6__Producer **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EnterpriseRole(struct soap *soap, enum ns6__EnterpriseRole *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns6__EnterpriseRole);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__EnterpriseRole(struct soap *soap, const char *tag, int id, enum ns6__EnterpriseRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EnterpriseRole);
	return (id < 0) ? soap->error : soap_out_ns6__EnterpriseRole(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns6__EnterpriseRole ** FASTCALL soap_in_PointerTons6__EnterpriseRole(struct soap *soap, const char *tag, enum ns6__EnterpriseRole **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns6__EnterpriseRole **)soap_malloc(soap, sizeof(enum ns6__EnterpriseRole *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns6__EnterpriseRole(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns6__EnterpriseRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EnterpriseRole, sizeof(enum ns6__EnterpriseRole), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EnterpriseRole(struct soap *soap, enum ns6__EnterpriseRole *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__EnterpriseRole);
	return soap_out_PointerTons6__EnterpriseRole(soap, tag?tag:"ns6:EnterpriseRole", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__EnterpriseRole ** SOAP_FMAC4 soap_get_PointerTons6__EnterpriseRole(struct soap *soap, enum ns6__EnterpriseRole **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__EnterpriseRole(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Enterprise(struct soap *soap, ns6__Enterprise *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Enterprise))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Enterprise(struct soap *soap, const char *tag, int id, ns6__Enterprise *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Enterprise);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Enterprise ** FASTCALL soap_in_PointerTons6__Enterprise(struct soap *soap, const char *tag, ns6__Enterprise **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Enterprise **)soap_malloc(soap, sizeof(ns6__Enterprise *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Enterprise *)soap_instantiate_ns6__Enterprise(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Enterprise ** p = (ns6__Enterprise **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Enterprise, sizeof(ns6__Enterprise), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Enterprise(struct soap *soap, ns6__Enterprise *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Enterprise);
	return soap_out_PointerTons6__Enterprise(soap, tag?tag:"ns6:Enterprise", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Enterprise ** SOAP_FMAC4 soap_get_PointerTons6__Enterprise(struct soap *soap, ns6__Enterprise **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__NText(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__NText))
		soap_serialize_ns3__NText(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__NText(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__NText);
	return (id < 0) ? soap->error : soap_out_ns3__NText(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTons3__NText(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns3__NText(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__NText, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__NText(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__NText);
	return soap_out_PointerTons3__NText(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons3__NText(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__NText(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Street(struct soap *soap, ns6__Street *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Street))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Street(struct soap *soap, const char *tag, int id, ns6__Street *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Street);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Street ** FASTCALL soap_in_PointerTons6__Street(struct soap *soap, const char *tag, ns6__Street **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Street **)soap_malloc(soap, sizeof(ns6__Street *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Street *)soap_instantiate_ns6__Street(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Street ** p = (ns6__Street **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Street, sizeof(ns6__Street), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Street(struct soap *soap, ns6__Street *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Street);
	return soap_out_PointerTons6__Street(soap, tag?tag:"ns6:Street", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Street ** SOAP_FMAC4 soap_get_PointerTons6__Street(struct soap *soap, ns6__Street **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Locality(struct soap *soap, ns6__Locality *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Locality))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Locality(struct soap *soap, const char *tag, int id, ns6__Locality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Locality);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Locality ** FASTCALL soap_in_PointerTons6__Locality(struct soap *soap, const char *tag, ns6__Locality **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Locality **)soap_malloc(soap, sizeof(ns6__Locality *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Locality *)soap_instantiate_ns6__Locality(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Locality ** p = (ns6__Locality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Locality, sizeof(ns6__Locality), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Locality(struct soap *soap, ns6__Locality *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Locality);
	return soap_out_PointerTons6__Locality(soap, tag?tag:"ns6:Locality", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Locality ** SOAP_FMAC4 soap_get_PointerTons6__Locality(struct soap *soap, ns6__Locality **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__District(struct soap *soap, ns6__District *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__District))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__District(struct soap *soap, const char *tag, int id, ns6__District *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__District);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__District ** FASTCALL soap_in_PointerTons6__District(struct soap *soap, const char *tag, ns6__District **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__District **)soap_malloc(soap, sizeof(ns6__District *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__District *)soap_instantiate_ns6__District(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__District ** p = (ns6__District **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__District, sizeof(ns6__District), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__District(struct soap *soap, ns6__District *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__District);
	return soap_out_PointerTons6__District(soap, tag?tag:"ns6:District", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__District ** SOAP_FMAC4 soap_get_PointerTons6__District(struct soap *soap, ns6__District **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Region(struct soap *soap, ns6__Region *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Region))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Region(struct soap *soap, const char *tag, int id, ns6__Region *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Region);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Region ** FASTCALL soap_in_PointerTons6__Region(struct soap *soap, const char *tag, ns6__Region **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Region **)soap_malloc(soap, sizeof(ns6__Region *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Region *)soap_instantiate_ns6__Region(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Region ** p = (ns6__Region **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Region, sizeof(ns6__Region), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Region(struct soap *soap, ns6__Region *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Region);
	return soap_out_PointerTons6__Region(soap, tag?tag:"ns6:Region", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Region ** SOAP_FMAC4 soap_get_PointerTons6__Region(struct soap *soap, ns6__Region **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__FederalDistrict(struct soap *soap, ns6__FederalDistrict *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__FederalDistrict))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__FederalDistrict(struct soap *soap, const char *tag, int id, ns6__FederalDistrict *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__FederalDistrict);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__FederalDistrict ** FASTCALL soap_in_PointerTons6__FederalDistrict(struct soap *soap, const char *tag, ns6__FederalDistrict **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__FederalDistrict **)soap_malloc(soap, sizeof(ns6__FederalDistrict *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__FederalDistrict *)soap_instantiate_ns6__FederalDistrict(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__FederalDistrict ** p = (ns6__FederalDistrict **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__FederalDistrict, sizeof(ns6__FederalDistrict), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__FederalDistrict(struct soap *soap, ns6__FederalDistrict *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__FederalDistrict);
	return soap_out_PointerTons6__FederalDistrict(soap, tag?tag:"ns6:FederalDistrict", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__FederalDistrict ** SOAP_FMAC4 soap_get_PointerTons6__FederalDistrict(struct soap *soap, ns6__FederalDistrict **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__FederalDistrict(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Country(struct soap *soap, ns6__Country *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns6__Country))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons6__Country(struct soap *soap, const char *tag, int id, ns6__Country *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Country);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Country ** FASTCALL soap_in_PointerTons6__Country(struct soap *soap, const char *tag, ns6__Country **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns6__Country **)soap_malloc(soap, sizeof(ns6__Country *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns6__Country *)soap_instantiate_ns6__Country(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns6__Country ** p = (ns6__Country **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Country, sizeof(ns6__Country), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Country(struct soap *soap, ns6__Country *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Country);
	return soap_out_PointerTons6__Country(soap, tag?tag:"ns6:Country", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns6__Country ** SOAP_FMAC4 soap_get_PointerTons6__Country(struct soap *soap, ns6__Country **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons6__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__BusinessError(struct soap *soap, ns4__BusinessError **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__BusinessError))
		soap_serialize_PointerTons4__BusinessError(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons4__BusinessError(struct soap *soap, const char *tag, int id, ns4__BusinessError **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__BusinessError);
	return (id < 0) ? soap->error : soap_out_PointerTons4__BusinessError(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__BusinessError *** FASTCALL soap_in_PointerToPointerTons4__BusinessError(struct soap *soap, const char *tag, ns4__BusinessError ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns4__BusinessError ***)soap_malloc(soap, sizeof(ns4__BusinessError **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons4__BusinessError(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns4__BusinessError ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__BusinessError, sizeof(ns4__BusinessError *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__BusinessError(struct soap *soap, ns4__BusinessError **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__BusinessError);
	return soap_out_PointerToPointerTons4__BusinessError(soap, tag?tag:"ns4:BusinessError", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns4__BusinessError *** SOAP_FMAC4 soap_get_PointerToPointerTons4__BusinessError(struct soap *soap, ns4__BusinessError ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons4__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__BusinessError(struct soap *soap, ns4__BusinessError *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns4__BusinessError))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__BusinessError(struct soap *soap, const char *tag, int id, ns4__BusinessError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__BusinessError);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__BusinessError ** FASTCALL soap_in_PointerTons4__BusinessError(struct soap *soap, const char *tag, ns4__BusinessError **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns4__BusinessError **)soap_malloc(soap, sizeof(ns4__BusinessError *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns4__BusinessError *)soap_instantiate_ns4__BusinessError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns4__BusinessError ** p = (ns4__BusinessError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__BusinessError, sizeof(ns4__BusinessError), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__BusinessError(struct soap *soap, ns4__BusinessError *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__BusinessError);
	return soap_out_PointerTons4__BusinessError(soap, tag?tag:"ns4:BusinessError", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns4__BusinessError ** SOAP_FMAC4 soap_get_PointerTons4__BusinessError(struct soap *soap, ns4__BusinessError **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ContentEncoding(struct soap *soap, enum ns4__ContentEncoding *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__ContentEncoding);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__ContentEncoding(struct soap *soap, const char *tag, int id, enum ns4__ContentEncoding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ContentEncoding);
	return (id < 0) ? soap->error : soap_out_ns4__ContentEncoding(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__ContentEncoding ** FASTCALL soap_in_PointerTons4__ContentEncoding(struct soap *soap, const char *tag, enum ns4__ContentEncoding **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns4__ContentEncoding **)soap_malloc(soap, sizeof(enum ns4__ContentEncoding *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns4__ContentEncoding(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns4__ContentEncoding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ContentEncoding, sizeof(enum ns4__ContentEncoding), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ContentEncoding(struct soap *soap, enum ns4__ContentEncoding *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ContentEncoding);
	return soap_out_PointerTons4__ContentEncoding(soap, tag?tag:"ns4:ContentEncoding", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ContentEncoding ** SOAP_FMAC4 soap_get_PointerTons4__ContentEncoding(struct soap *soap, enum ns4__ContentEncoding **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__ContentEncoding(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__BusinessErrorList(struct soap *soap, ns4__BusinessErrorList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns4__BusinessErrorList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__BusinessErrorList(struct soap *soap, const char *tag, int id, ns4__BusinessErrorList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__BusinessErrorList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__BusinessErrorList ** FASTCALL soap_in_PointerTons4__BusinessErrorList(struct soap *soap, const char *tag, ns4__BusinessErrorList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns4__BusinessErrorList **)soap_malloc(soap, sizeof(ns4__BusinessErrorList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns4__BusinessErrorList *)soap_instantiate_ns4__BusinessErrorList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns4__BusinessErrorList ** p = (ns4__BusinessErrorList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__BusinessErrorList, sizeof(ns4__BusinessErrorList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__BusinessErrorList(struct soap *soap, ns4__BusinessErrorList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__BusinessErrorList);
	return soap_out_PointerTons4__BusinessErrorList(soap, tag?tag:"ns4:BusinessErrorList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns4__BusinessErrorList ** SOAP_FMAC4 soap_get_PointerTons4__BusinessErrorList(struct soap *soap, ns4__BusinessErrorList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__BusinessErrorList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ApplicationResultWrapper(struct soap *soap, ns4__ApplicationResultWrapper *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns4__ApplicationResultWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__ApplicationResultWrapper(struct soap *soap, const char *tag, int id, ns4__ApplicationResultWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ApplicationResultWrapper);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ApplicationResultWrapper ** FASTCALL soap_in_PointerTons4__ApplicationResultWrapper(struct soap *soap, const char *tag, ns4__ApplicationResultWrapper **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns4__ApplicationResultWrapper **)soap_malloc(soap, sizeof(ns4__ApplicationResultWrapper *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns4__ApplicationResultWrapper *)soap_instantiate_ns4__ApplicationResultWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns4__ApplicationResultWrapper ** p = (ns4__ApplicationResultWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ApplicationResultWrapper, sizeof(ns4__ApplicationResultWrapper), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ApplicationResultWrapper(struct soap *soap, ns4__ApplicationResultWrapper *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ApplicationResultWrapper);
	return soap_out_PointerTons4__ApplicationResultWrapper(soap, tag?tag:"ns4:ApplicationResultWrapper", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ApplicationResultWrapper ** SOAP_FMAC4 soap_get_PointerTons4__ApplicationResultWrapper(struct soap *soap, ns4__ApplicationResultWrapper **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__ApplicationResultWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ApplicationDataWrapper(struct soap *soap, ns4__ApplicationDataWrapper *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns4__ApplicationDataWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__ApplicationDataWrapper(struct soap *soap, const char *tag, int id, ns4__ApplicationDataWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ApplicationDataWrapper);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ApplicationDataWrapper ** FASTCALL soap_in_PointerTons4__ApplicationDataWrapper(struct soap *soap, const char *tag, ns4__ApplicationDataWrapper **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns4__ApplicationDataWrapper **)soap_malloc(soap, sizeof(ns4__ApplicationDataWrapper *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns4__ApplicationDataWrapper *)soap_instantiate_ns4__ApplicationDataWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns4__ApplicationDataWrapper ** p = (ns4__ApplicationDataWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ApplicationDataWrapper, sizeof(ns4__ApplicationDataWrapper), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ApplicationDataWrapper(struct soap *soap, ns4__ApplicationDataWrapper *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ApplicationDataWrapper);
	return soap_out_PointerTons4__ApplicationDataWrapper(soap, tag?tag:"ns4:ApplicationDataWrapper", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ApplicationDataWrapper ** SOAP_FMAC4 soap_get_PointerTons4__ApplicationDataWrapper(struct soap *soap, ns4__ApplicationDataWrapper **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__ApplicationDataWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ApplicationStatus(struct soap *soap, enum ns4__ApplicationStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns4__ApplicationStatus);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__ApplicationStatus(struct soap *soap, const char *tag, int id, enum ns4__ApplicationStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ApplicationStatus);
	return (id < 0) ? soap->error : soap_out_ns4__ApplicationStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__ApplicationStatus ** FASTCALL soap_in_PointerTons4__ApplicationStatus(struct soap *soap, const char *tag, enum ns4__ApplicationStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ns4__ApplicationStatus **)soap_malloc(soap, sizeof(enum ns4__ApplicationStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ns4__ApplicationStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ns4__ApplicationStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ApplicationStatus, sizeof(enum ns4__ApplicationStatus), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ApplicationStatus(struct soap *soap, enum ns4__ApplicationStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ApplicationStatus);
	return soap_out_PointerTons4__ApplicationStatus(soap, tag?tag:"ns4:ApplicationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__ApplicationStatus ** SOAP_FMAC4 soap_get_PointerTons4__ApplicationStatus(struct soap *soap, enum ns4__ApplicationStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__ApplicationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__Error(struct soap *soap, ns3__Error **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__Error))
		soap_serialize_PointerTons3__Error(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTons3__Error(struct soap *soap, const char *tag, int id, ns3__Error **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__Error);
	return (id < 0) ? soap->error : soap_out_PointerTons3__Error(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__Error *** FASTCALL soap_in_PointerToPointerTons3__Error(struct soap *soap, const char *tag, ns3__Error ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns3__Error ***)soap_malloc(soap, sizeof(ns3__Error **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTons3__Error(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ns3__Error ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__Error, sizeof(ns3__Error *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__Error(struct soap *soap, ns3__Error **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__Error);
	return soap_out_PointerToPointerTons3__Error(soap, tag?tag:"ns3:Error", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Error *** SOAP_FMAC4 soap_get_PointerToPointerTons3__Error(struct soap *soap, ns3__Error ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTons3__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Error(struct soap *soap, ns3__Error *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns3__Error))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons3__Error(struct soap *soap, const char *tag, int id, ns3__Error *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Error);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__Error ** FASTCALL soap_in_PointerTons3__Error(struct soap *soap, const char *tag, ns3__Error **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns3__Error **)soap_malloc(soap, sizeof(ns3__Error *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns3__Error *)soap_instantiate_ns3__Error(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns3__Error ** p = (ns3__Error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Error, sizeof(ns3__Error), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns3__Error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__BusinessError, sizeof(ns4__BusinessError), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Error(struct soap *soap, ns3__Error *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__Error);
	return soap_out_PointerTons3__Error(soap, tag?tag:"ns3:Error", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Error ** SOAP_FMAC4 soap_get_PointerTons3__Error(struct soap *soap, ns3__Error **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons3__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	return (id < 0) ? soap->error : soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** FASTCALL soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	return soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobool(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	return (id < 0) ? soap->error : soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** FASTCALL soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	return soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	return (id < 0) ? soap->error : soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	return soap_out_PointerToint(soap, tag?tag:"int", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	return (id < 0) ? soap->error : soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** FASTCALL soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	return soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTotime(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__Application(struct soap *soap, ns4__Application *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ns4__Application))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTons4__Application(struct soap *soap, const char *tag, int id, ns4__Application *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__Application);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__Application ** FASTCALL soap_in_PointerTons4__Application(struct soap *soap, const char *tag, ns4__Application **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ns4__Application **)soap_malloc(soap, sizeof(ns4__Application *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ns4__Application *)soap_instantiate_ns4__Application(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ns4__Application ** p = (ns4__Application **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__Application, sizeof(ns4__Application), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__Application(struct soap *soap, ns4__Application *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__Application);
	return soap_out_PointerTons4__Application(soap, tag?tag:"ns4:Application", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ns4__Application ** SOAP_FMAC4 soap_get_PointerTons4__Application(struct soap *soap, ns4__Application **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTons4__Application(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__VetDocumentStatusChangeReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns7__VetDocumentStatusChangeReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns7__VetDocumentStatusChangeReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns7__VetDocumentStatusChangeReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__VetDocumentStatusChangeReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__VetDocumentStatusChangeReason);
	return soap_out_ns7__VetDocumentStatusChangeReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns7__VetDocumentStatusChangeReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__VetDocumentStatusChangeReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__GRNType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__GRNType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__GRNType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__GRNType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__GRNType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__GRNType);
	return soap_out_ns6__GRNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__GRNType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__GRNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__SNILSType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns7__SNILSType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns7__SNILSType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns7__SNILSType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SNILSType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__SNILSType);
	return soap_out_ns7__SNILSType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns7__SNILSType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__SNILSType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns7__StockEntryNumber(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns7__StockEntryNumber);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns7__StockEntryNumber(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns7__StockEntryNumber, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__StockEntryNumber(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns7__StockEntryNumber);
	return soap_out_ns7__StockEntryNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns7__StockEntryNumber(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns7__StockEntryNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__OTPToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__OTPToken);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__OTPToken(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__OTPToken, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__OTPToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__OTPToken);
	return soap_out_ns6__OTPToken(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__OTPToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__OTPToken(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__GTINType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__GTINType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__GTINType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__GTINType, 1, 8, 14);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__GTINType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__GTINType);
	return soap_out_ns6__GTINType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__GTINType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__GTINType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__GLNType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__GLNType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__GLNType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__GLNType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__GLNType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__GLNType);
	return soap_out_ns6__GLNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__GLNType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__GLNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__ENTModificationReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__ENTModificationReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__ENTModificationReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__ENTModificationReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ENTModificationReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ENTModificationReason);
	return soap_out_ns6__ENTModificationReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__ENTModificationReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__ENTModificationReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__BEModificationReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__BEModificationReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__BEModificationReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__BEModificationReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__BEModificationReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__BEModificationReason);
	return soap_out_ns6__BEModificationReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__BEModificationReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__BEModificationReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__EnterpriseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__EnterpriseType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__EnterpriseType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__EnterpriseType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EnterpriseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__EnterpriseType);
	return soap_out_ns6__EnterpriseType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__EnterpriseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__EnterpriseType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Code3(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__Code3);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__Code3(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__Code3, 1, 0, 3);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Code3(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Code3);
	return soap_out_ns6__Code3(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__Code3(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Code3(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns6__Code(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__Code);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns6__Code(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__Code, 1, 0, 2);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Code(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Code);
	return soap_out_ns6__Code(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__Code(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns6__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns4__APIKey(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns4__APIKey);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns4__APIKey(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns4__APIKey, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__APIKey(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__APIKey);
	return soap_out_ns4__APIKey(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns4__APIKey(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns4__APIKey(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__SequenceNumber(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__SequenceNumber);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__SequenceNumber(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__SequenceNumber, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__SequenceNumber(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__SequenceNumber);
	return soap_out_ns3__SequenceNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__SequenceNumber(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__SequenceNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__Identifier(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__Identifier);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__Identifier(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__Identifier, 1, 0, 100);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__Identifier(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__Identifier);
	return soap_out_ns3__Identifier(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__Identifier(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__Identifier(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__VersionStatus(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__VersionStatus);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__VersionStatus(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__VersionStatus, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__VersionStatus(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__VersionStatus);
	return soap_out_ns3__VersionStatus(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__VersionStatus(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__VersionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__Decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__Decimal);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__Decimal(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__Decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__Decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__Decimal);
	return soap_out_ns3__Decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__Decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__Decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__String32(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__String32);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__String32(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__String32, 1, 0, 32);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__String32(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__String32);
	return soap_out_ns3__String32(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__String32(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__String32(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__String255(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__String255);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__String255(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__String255, 1, 0, 255);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__String255(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__String255);
	return soap_out_ns3__String255(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__String255(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__String255(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__NText(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__NText);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__NText(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__NText, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__NText(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__NText);
	return soap_out_ns3__NText(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__NText(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__NText(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__Text(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__Text);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__Text(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__Text, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__Text(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__Text);
	return soap_out_ns3__Text(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__Text(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__Text(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ns3__UUID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__UUID);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ns3__UUID(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__UUID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__UUID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__UUID);
	return soap_out_ns3__UUID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__UUID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ns3__UUID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	return soap_out_xsd__token(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__token(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	return soap_out_xsd__positiveInteger(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	return soap_out_xsd__nonNegativeInteger(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	return soap_out_xsd__integer(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__integer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	return soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	return soap_out_xsd__date(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__date(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	return (id < 0) ? soap->error : soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** FASTCALL soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	return soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__Name);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__Name(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__Name, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__Name);
	return soap_out_xsd__Name(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__Name(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	return soap_out_xsd__NCName(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__IDREF);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__IDREF(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__IDREF, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	return soap_out_xsd__IDREF(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	return soap_out_xsd__ID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__ID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * FASTCALL soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	return soap_out__QName(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in__QName(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int FASTCALL soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * FASTCALL soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	return soap_out_string(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_string(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of vetisamsC.cpp */

/* vetisamsC.cpp
   Generated by gSOAP 2.8.8 from vetisams.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "slib.h"
#include "vetisamsH.h"
#pragma hdrstop

SOAP_SOURCE_STAMP("@(#) vetisamsC.cpp ver 2.8.8 2018-01-02 13:58:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void FASTCALL soap_serializeheader(struct soap *soap)
{
	if(soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int FASTCALL soap_putheader(struct soap *soap)
{
	if(soap->header) {
		soap->part = SOAP_IN_HEADER;
		if(soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if(!soap->header) {
		if((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void FASTCALL soap_fault(struct soap *soap)
{
	if(!soap->fault) {
		soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if(!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if(soap->version == 2 && !soap->fault->SOAP_ENV__Code) {
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if(soap->version == 2 && !soap->fault->SOAP_ENV__Reason) {
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if(soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	return soap->fault ? soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL) : SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2) {
		if(!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode) {
			soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2) {
		if(soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 1) {
		if(!soap->fault->detail) {
			soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if(!soap->fault->SOAP_ENV__Detail) {
		soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if(soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if(soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int FASTCALL soap_getindependent(struct soap *soap)
{
	int t;
	if(soap->version == 1) {
		for(;;) {
			if(!soap_getelement(soap, &t))
				if(soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if(oneof2(soap->error, SOAP_NO_TAG, SOAP_EOF))
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	(void)type;
	if(soap_peek_element(soap))
		return NULL;
	if(!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch(*type) {
	case SOAP_TYPE_byte: return soap_in_byte(soap, 0, 0, "xsd:byte");
	case SOAP_TYPE_ent__Minute: return soap_in_ent__Minute(soap, 0, 0, "ent:Minute");
	case SOAP_TYPE_ent__Hour: return soap_in_ent__Hour(soap, 0, 0, "ent:Hour");
	case SOAP_TYPE_ent__Day: return soap_in_ent__Day(soap, 0, 0, "ent:Day");
	case SOAP_TYPE_ent__Month: return soap_in_ent__Month(soap, 0, 0, "ent:Month");
	case SOAP_TYPE_ent__Year: return soap_in_ent__Year(soap, 0, 0, "ent:Year");
	case SOAP_TYPE_int: return soap_in_int(soap, 0, 0, "xsd:int");
	case SOAP_TYPE_LONG64: return soap_in_LONG64(soap, 0, 0, "xsd:long");
	case SOAP_TYPE_unsignedByte: return soap_in_unsignedByte(soap, 0, 0, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt: return soap_in_unsignedInt(soap, 0, 0, "xsd:unsignedInt");
	case SOAP_TYPE_time: return soap_in_time(soap, 0, 0, "xsd:dateTime");
	case SOAP_TYPE_bool: return soap_in_bool(soap, 0, 0, "xsd:boolean");
	case SOAP_TYPE_vd__AnimalSpentPeriod: return soap_in_vd__AnimalSpentPeriod(soap, 0, 0, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_vd__VetDocumentStatus: return soap_in_vd__VetDocumentStatus(soap, 0, 0, "vd:VetDocumentStatus");
	case SOAP_TYPE_vd__VetDocumentType: return soap_in_vd__VetDocumentType(soap, 0, 0, "vd:VetDocumentType");
	case SOAP_TYPE_vd__VetDocumentForm: return soap_in_vd__VetDocumentForm(soap, 0, 0, "vd:VetDocumentForm");
	case SOAP_TYPE_vd__DeliveryInspectionResult: return soap_in_vd__DeliveryInspectionResult(soap, 0, 0, "vd:DeliveryInspectionResult");
	case SOAP_TYPE_vd__DeliveryDecision: return soap_in_vd__DeliveryDecision(soap, 0, 0, "vd:DeliveryDecision");
	case SOAP_TYPE_ent__ProductMarkingClass: return soap_in_ent__ProductMarkingClass(soap, 0, 0, "ent:ProductMarkingClass");
	case SOAP_TYPE_ent__TransportationStorageType: return soap_in_ent__TransportationStorageType(soap, 0, 0, "ent:TransportationStorageType");
	case SOAP_TYPE_ent__DocumentNature: return soap_in_ent__DocumentNature(soap, 0, 0, "ent:DocumentNature");
	case SOAP_TYPE_ent__EnterpriseRole: return soap_in_ent__EnterpriseRole(soap, 0, 0, "ent:EnterpriseRole");
	case SOAP_TYPE_vd__ProcessingProcedureType: return soap_in_vd__ProcessingProcedureType(soap, 0, 0, "vd:ProcessingProcedureType");
	case SOAP_TYPE_vd__VeterinaryEventType: return soap_in_vd__VeterinaryEventType(soap, 0, 0, "vd:VeterinaryEventType");
	case SOAP_TYPE_vd__StockEntryBlankFilter: return soap_in_vd__StockEntryBlankFilter(soap, 0, 0, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_ent__VaccinationType: return soap_in_ent__VaccinationType(soap, 0, 0, "ent:VaccinationType");
	case SOAP_TYPE_ent__ProsperityType: return soap_in_ent__ProsperityType(soap, 0, 0, "ent:ProsperityType");
	case SOAP_TYPE_ent__RegionalizationDecision: return soap_in_ent__RegionalizationDecision(soap, 0, 0, "ent:RegionalizationDecision");
	case SOAP_TYPE_ent__ResearchResult: return soap_in_ent__ResearchResult(soap, 0, 0, "ent:ResearchResult");
	case SOAP_TYPE_ent__TransportType: return soap_in_ent__TransportType(soap, 0, 0, "ent:TransportType");
	case SOAP_TYPE_ent__ReferenceType: return soap_in_ent__ReferenceType(soap, 0, 0, "ent:ReferenceType");
	case SOAP_TYPE_ent__DocumentType: return soap_in_ent__DocumentType(soap, 0, 0, "ent:DocumentType");
	case SOAP_TYPE_ent__ProductType: return soap_in_ent__ProductType(soap, 0, 0, "ent:ProductType");
	case SOAP_TYPE_ent__BusinessEntityType: return soap_in_ent__BusinessEntityType(soap, 0, 0, "ent:BusinessEntityType");
	case SOAP_TYPE_ent__EnterpriseGroup: return soap_in_ent__EnterpriseGroup(soap, 0, 0, "ent:EnterpriseGroup");
	case SOAP_TYPE_ent__PackingCodeType: return soap_in_ent__PackingCodeType(soap, 0, 0, "ent:PackingCodeType");
	case SOAP_TYPE_ent__PackageLevelType: return soap_in_ent__PackageLevelType(soap, 0, 0, "ent:PackageLevelType");
	case SOAP_TYPE_app__ContentEncoding: return soap_in_app__ContentEncoding(soap, 0, 0, "app:ContentEncoding");
	case SOAP_TYPE_app__ApplicationStatus: return soap_in_app__ApplicationStatus(soap, 0, 0, "app:ApplicationStatus");
	case SOAP_TYPE_base__RegisterModificationType: return soap_in_base__RegisterModificationType(soap, 0, 0, "base:RegisterModificationType");
	case SOAP_TYPE_app__BinaryContent: return soap_in_app__BinaryContent(soap, 0, 0, "app:BinaryContent");
	case SOAP_TYPE_vd__WorkingArea: return soap_in_vd__WorkingArea(soap, 0, 0, "vd:WorkingArea");
	case SOAP_TYPE_vd__UserAuthority: return soap_in_vd__UserAuthority(soap, 0, 0, "vd:UserAuthority");
	case SOAP_TYPE_vd__WorkingAreaList: return soap_in_vd__WorkingAreaList(soap, 0, 0, "vd:WorkingAreaList");
	case SOAP_TYPE_vd__AuthorityList: return soap_in_vd__AuthorityList(soap, 0, 0, "vd:AuthorityList");
	case SOAP_TYPE_vd__UserList: return soap_in_vd__UserList(soap, 0, 0, "vd:UserList");
	case SOAP_TYPE_vd__User: return soap_in_vd__User(soap, 0, 0, "vd:User");
	case SOAP_TYPE_vd__ProcessingProcedure: return soap_in_vd__ProcessingProcedure(soap, 0, 0, "vd:ProcessingProcedure");
	case SOAP_TYPE_vd__RouteSectionR13nRules: return soap_in_vd__RouteSectionR13nRules(soap, 0, 0, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_vd__RegionalizationClause: return soap_in_vd__RegionalizationClause(soap, 0, 0, "vd:RegionalizationClause");
	case SOAP_TYPE_vd__VetDocumentStatusChange: return soap_in_vd__VetDocumentStatusChange(soap, 0, 0, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_vd__StockEntryEventList: return soap_in_vd__StockEntryEventList(soap, 0, 0, "vd:StockEntryEventList");
	case SOAP_TYPE_vd__BatchOrigin: return soap_in_vd__BatchOrigin(soap, 0, 0, "vd:BatchOrigin");
	case SOAP_TYPE_vd__VeterinaryAuthentication: return soap_in_vd__VeterinaryAuthentication(soap, 0, 0, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_vd__QuarantineEvent: return soap_in_vd__QuarantineEvent(soap, 0, 0, "vd:QuarantineEvent");
	case SOAP_TYPE_vd__AnimalMedicationEvent: return soap_in_vd__AnimalMedicationEvent(soap, 0, 0, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_vd__LaboratoryResearchEvent: return soap_in_vd__LaboratoryResearchEvent(soap, 0, 0, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_vd__VeterinaryEvent: return soap_in_vd__VeterinaryEvent(soap, 0, 0, "vd:VeterinaryEvent");
	case SOAP_TYPE_vd__ReferencedDocument: return soap_in_vd__ReferencedDocument(soap, 0, 0, "vd:ReferencedDocument");
	case SOAP_TYPE_vd__CertifiedConsignment: return soap_in_vd__CertifiedConsignment(soap, 0, 0, "vd:CertifiedConsignment");
	case SOAP_TYPE_vd__CertifiedBatch: return soap_in_vd__CertifiedBatch(soap, 0, 0, "vd:CertifiedBatch");
	case SOAP_TYPE_vd__ENTModificationOperation: return soap_in_vd__ENTModificationOperation(soap, 0, 0, "vd:ENTModificationOperation");
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: return soap_in_vd__BEActivityLocationsModificationOperation(soap, 0, 0, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_vd__BEModificationOperation: return soap_in_vd__BEModificationOperation(soap, 0, 0, "vd:BEModificationOperation");
	case SOAP_TYPE_vd__PSLModificationOperation: return soap_in_vd__PSLModificationOperation(soap, 0, 0, "vd:PSLModificationOperation");
	case SOAP_TYPE_vd__MergeStockEntriesOperation: return soap_in_vd__MergeStockEntriesOperation(soap, 0, 0, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_vd__ProductionOperation: return soap_in_vd__ProductionOperation(soap, 0, 0, "vd:ProductionOperation");
	case SOAP_TYPE_vd__ShipmentRoute: return soap_in_vd__ShipmentRoute(soap, 0, 0, "vd:ShipmentRoute");
	case SOAP_TYPE_vd__ShipmentRoutePoint: return soap_in_vd__ShipmentRoutePoint(soap, 0, 0, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_vd__TransportNumber: return soap_in_vd__TransportNumber(soap, 0, 0, "vd:TransportNumber");
	case SOAP_TYPE_vd__TransportInfo: return soap_in_vd__TransportInfo(soap, 0, 0, "vd:TransportInfo");
	case SOAP_TYPE_vd__Waybill: return soap_in_vd__Waybill(soap, 0, 0, "vd:Waybill");
	case SOAP_TYPE_vd__Document: return soap_in_vd__Document(soap, 0, 0, "vd:Document");
	case SOAP_TYPE_vd__StockEntrySearchPattern: return soap_in_vd__StockEntrySearchPattern(soap, 0, 0, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_vd__StockDiscrepancy: return soap_in_vd__StockDiscrepancy(soap, 0, 0, "vd:StockDiscrepancy");
	case SOAP_TYPE_vd__StockEntryList: return soap_in_vd__StockEntryList(soap, 0, 0, "vd:StockEntryList");
	case SOAP_TYPE_vd__StockEntry: return soap_in_vd__StockEntry(soap, 0, 0, "vd:StockEntry");
	case SOAP_TYPE_vd__DiscrepancyReason: return soap_in_vd__DiscrepancyReason(soap, 0, 0, "vd:DiscrepancyReason");
	case SOAP_TYPE_vd__DiscrepancyReport: return soap_in_vd__DiscrepancyReport(soap, 0, 0, "vd:DiscrepancyReport");
	case SOAP_TYPE_vd__VetDocumentList: return soap_in_vd__VetDocumentList(soap, 0, 0, "vd:VetDocumentList");
	case SOAP_TYPE_vd__GoodsDate: return soap_in_vd__GoodsDate(soap, 0, 0, "vd:GoodsDate");
	case SOAP_TYPE_vd__ConsignmentDocumentList: return soap_in_vd__ConsignmentDocumentList(soap, 0, 0, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_vd__DeliveryInspection: return soap_in_vd__DeliveryInspection(soap, 0, 0, "vd:DeliveryInspection");
	case SOAP_TYPE_vd__DeliveryFactList: return soap_in_vd__DeliveryFactList(soap, 0, 0, "vd:DeliveryFactList");
	case SOAP_TYPE_vd__Delivery: return soap_in_vd__Delivery(soap, 0, 0, "vd:Delivery");
	case SOAP_TYPE_vd__ProductiveBatch: return soap_in_vd__ProductiveBatch(soap, 0, 0, "vd:ProductiveBatch");
	case SOAP_TYPE_vd__RawBatch: return soap_in_vd__RawBatch(soap, 0, 0, "vd:RawBatch");
	case SOAP_TYPE_vd__Consignment: return soap_in_vd__Consignment(soap, 0, 0, "vd:Consignment");
	case SOAP_TYPE_vd__Batch: return soap_in_vd__Batch(soap, 0, 0, "vd:Batch");
	case SOAP_TYPE_vd__VetDocument: return soap_in_vd__VetDocument(soap, 0, 0, "vd:VetDocument");
	case SOAP_TYPE_ent__ActivityLocationList: return soap_in_ent__ActivityLocationList(soap, 0, 0, "ent:ActivityLocationList");
	case SOAP_TYPE_ent__ResearchMethodList: return soap_in_ent__ResearchMethodList(soap, 0, 0, "ent:ResearchMethodList");
	case SOAP_TYPE_ent__AnimalDiseaseList: return soap_in_ent__AnimalDiseaseList(soap, 0, 0, "ent:AnimalDiseaseList");
	case SOAP_TYPE_ent__RegionalizationShippingRuleList: return soap_in_ent__RegionalizationShippingRuleList(soap, 0, 0, "ent:RegionalizationShippingRuleList");
	case SOAP_TYPE_ent__RegionalizationRegionStatusList: return soap_in_ent__RegionalizationRegionStatusList(soap, 0, 0, "ent:RegionalizationRegionStatusList");
	case SOAP_TYPE_ent__RegionalizationConditionList: return soap_in_ent__RegionalizationConditionList(soap, 0, 0, "ent:RegionalizationConditionList");
	case SOAP_TYPE_ent__Area: return soap_in_ent__Area(soap, 0, 0, "ent:Area");
	case SOAP_TYPE_ent__RegionalizationRegionStatus: return soap_in_ent__RegionalizationRegionStatus(soap, 0, 0, "ent:RegionalizationRegionStatus");
	case SOAP_TYPE_ent__RegionalizationStatus: return soap_in_ent__RegionalizationStatus(soap, 0, 0, "ent:RegionalizationStatus");
	case SOAP_TYPE_ent__RegionalizationShippingRule: return soap_in_ent__RegionalizationShippingRule(soap, 0, 0, "ent:RegionalizationShippingRule");
	case SOAP_TYPE_ent__RegionalizationRequirement: return soap_in_ent__RegionalizationRequirement(soap, 0, 0, "ent:RegionalizationRequirement");
	case SOAP_TYPE_ent__RegionalizationConditionGroup: return soap_in_ent__RegionalizationConditionGroup(soap, 0, 0, "ent:RegionalizationConditionGroup");
	case SOAP_TYPE_ent__RegionalizationCondition: return soap_in_ent__RegionalizationCondition(soap, 0, 0, "ent:RegionalizationCondition");
	case SOAP_TYPE_ent__MedicinalDrug: return soap_in_ent__MedicinalDrug(soap, 0, 0, "ent:MedicinalDrug");
	case SOAP_TYPE_ent__ResearchMethod: return soap_in_ent__ResearchMethod(soap, 0, 0, "ent:ResearchMethod");
	case SOAP_TYPE_ent__AnimalDisease: return soap_in_ent__AnimalDisease(soap, 0, 0, "ent:AnimalDisease");
	case SOAP_TYPE_ent__Indicator: return soap_in_ent__Indicator(soap, 0, 0, "ent:Indicator");
	case SOAP_TYPE_ent__Organization: return soap_in_ent__Organization(soap, 0, 0, "ent:Organization");
	case SOAP_TYPE_ent__EnterpriseOfficialRegistration: return soap_in_ent__EnterpriseOfficialRegistration(soap, 0, 0, "ent:EnterpriseOfficialRegistration");
	case SOAP_TYPE_ent__Location: return soap_in_ent__Location(soap, 0, 0, "ent:Location");
	case SOAP_TYPE_ent__Packaging: return soap_in_ent__Packaging(soap, 0, 0, "ent:Packaging");
	case SOAP_TYPE_ent__ProductItemProducing: return soap_in_ent__ProductItemProducing(soap, 0, 0, "ent:ProductItemProducing");
	case SOAP_TYPE_ent__ComplexDate: return soap_in_ent__ComplexDate(soap, 0, 0, "ent:ComplexDate");
	case SOAP_TYPE_ent__PackageList: return soap_in_ent__PackageList(soap, 0, 0, "ent:PackageList");
	case SOAP_TYPE_ent__Package: return soap_in_ent__Package(soap, 0, 0, "ent:Package");
	case SOAP_TYPE_ent__ProductMarks: return soap_in_ent__ProductMarks(soap, 0, 0, "ent:ProductMarks");
	case SOAP_TYPE_ent__ProductItemList: return soap_in_ent__ProductItemList(soap, 0, 0, "ent:ProductItemList");
	case SOAP_TYPE_ent__SubProductList: return soap_in_ent__SubProductList(soap, 0, 0, "ent:SubProductList");
	case SOAP_TYPE_ent__ProductList: return soap_in_ent__ProductList(soap, 0, 0, "ent:ProductList");
	case SOAP_TYPE_ent__SubProduct: return soap_in_ent__SubProduct(soap, 0, 0, "ent:SubProduct");
	case SOAP_TYPE_ent__Product: return soap_in_ent__Product(soap, 0, 0, "ent:Product");
	case SOAP_TYPE_ent__ProductItem: return soap_in_ent__ProductItem(soap, 0, 0, "ent:ProductItem");
	case SOAP_TYPE_ent__BusinessEntityList: return soap_in_ent__BusinessEntityList(soap, 0, 0, "ent:BusinessEntityList");
	case SOAP_TYPE_ent__IncorporationForm: return soap_in_ent__IncorporationForm(soap, 0, 0, "ent:IncorporationForm");
	case SOAP_TYPE_ent__BusinessEntity: return soap_in_ent__BusinessEntity(soap, 0, 0, "ent:BusinessEntity");
	case SOAP_TYPE_ent__BusinessMember: return soap_in_ent__BusinessMember(soap, 0, 0, "ent:BusinessMember");
	case SOAP_TYPE_ent__EnterpriseList: return soap_in_ent__EnterpriseList(soap, 0, 0, "ent:EnterpriseList");
	case SOAP_TYPE_ent__EnterpriseNumberList: return soap_in_ent__EnterpriseNumberList(soap, 0, 0, "ent:EnterpriseNumberList");
	case SOAP_TYPE_ent__ProducerList: return soap_in_ent__ProducerList(soap, 0, 0, "ent:ProducerList");
	case SOAP_TYPE_ent__Producer: return soap_in_ent__Producer(soap, 0, 0, "ent:Producer");
	case SOAP_TYPE_ent__EnterpriseActivity: return soap_in_ent__EnterpriseActivity(soap, 0, 0, "ent:EnterpriseActivity");
	case SOAP_TYPE_ent__EnterpriseActivityList: return soap_in_ent__EnterpriseActivityList(soap, 0, 0, "ent:EnterpriseActivityList");
	case SOAP_TYPE_ent__Enterprise: return soap_in_ent__Enterprise(soap, 0, 0, "ent:Enterprise");
	case SOAP_TYPE_ent__StreetList: return soap_in_ent__StreetList(soap, 0, 0, "ent:StreetList");
	case SOAP_TYPE_ent__LocalityList: return soap_in_ent__LocalityList(soap, 0, 0, "ent:LocalityList");
	case SOAP_TYPE_ent__DistrictList: return soap_in_ent__DistrictList(soap, 0, 0, "ent:DistrictList");
	case SOAP_TYPE_ent__RegionList: return soap_in_ent__RegionList(soap, 0, 0, "ent:RegionList");
	case SOAP_TYPE_ent__CountryList: return soap_in_ent__CountryList(soap, 0, 0, "ent:CountryList");
	case SOAP_TYPE_ent__Address: return soap_in_ent__Address(soap, 0, 0, "ent:Address");
	case SOAP_TYPE_ent__Street: return soap_in_ent__Street(soap, 0, 0, "ent:Street");
	case SOAP_TYPE_ent__Locality: return soap_in_ent__Locality(soap, 0, 0, "ent:Locality");
	case SOAP_TYPE_ent__District: return soap_in_ent__District(soap, 0, 0, "ent:District");
	case SOAP_TYPE_ent__Region: return soap_in_ent__Region(soap, 0, 0, "ent:Region");
	case SOAP_TYPE_ent__AddressObjectView: return soap_in_ent__AddressObjectView(soap, 0, 0, "ent:AddressObjectView");
	case SOAP_TYPE_ent__FederalDistrict: return soap_in_ent__FederalDistrict(soap, 0, 0, "ent:FederalDistrict");
	case SOAP_TYPE_ent__Country: return soap_in_ent__Country(soap, 0, 0, "ent:Country");
	case SOAP_TYPE_ent__UnitList: return soap_in_ent__UnitList(soap, 0, 0, "ent:UnitList");
	case SOAP_TYPE_ent__PurposeList: return soap_in_ent__PurposeList(soap, 0, 0, "ent:PurposeList");
	case SOAP_TYPE_ent__PackingType: return soap_in_ent__PackingType(soap, 0, 0, "ent:PackingType");
	case SOAP_TYPE_ent__Unit: return soap_in_ent__Unit(soap, 0, 0, "ent:Unit");
	case SOAP_TYPE_ent__Purpose: return soap_in_ent__Purpose(soap, 0, 0, "ent:Purpose");
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse: return soap_in_merc__GetAppliedUserAuthorityListResponse(soap, 0, 0, "merc:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest: return soap_in_merc__GetAppliedUserAuthorityListRequest(soap, 0, 0, "merc:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_merc__UnbindBusinessEntityUserResponse: return soap_in_merc__UnbindBusinessEntityUserResponse(soap, 0, 0, "merc:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_merc__UnbindBusinessEntityUserRequest: return soap_in_merc__UnbindBusinessEntityUserRequest(soap, 0, 0, "merc:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_merc__UpdateUserWorkingAreasResponse: return soap_in_merc__UpdateUserWorkingAreasResponse(soap, 0, 0, "merc:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_merc__UpdateUserWorkingAreasRequest: return soap_in_merc__UpdateUserWorkingAreasRequest(soap, 0, 0, "merc:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_merc__UpdateUserAuthoritiesResponse: return soap_in_merc__UpdateUserAuthoritiesResponse(soap, 0, 0, "merc:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_merc__UpdateUserAuthoritiesRequest: return soap_in_merc__UpdateUserAuthoritiesRequest(soap, 0, 0, "merc:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_merc__GetBusinessEntityUserResponse: return soap_in_merc__GetBusinessEntityUserResponse(soap, 0, 0, "merc:GetBusinessEntityUserResponse");
	case SOAP_TYPE_merc__GetBusinessEntityUserRequest: return soap_in_merc__GetBusinessEntityUserRequest(soap, 0, 0, "merc:GetBusinessEntityUserRequest");
	case SOAP_TYPE_merc__GetBusinessEntityUserListResponse: return soap_in_merc__GetBusinessEntityUserListResponse(soap, 0, 0, "merc:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_merc__GetBusinessEntityUserListRequest: return soap_in_merc__GetBusinessEntityUserListRequest(soap, 0, 0, "merc:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_merc__AddBusinessEntityUserResponse: return soap_in_merc__AddBusinessEntityUserResponse(soap, 0, 0, "merc:AddBusinessEntityUserResponse");
	case SOAP_TYPE_merc__AddBusinessEntityUserRequest: return soap_in_merc__AddBusinessEntityUserRequest(soap, 0, 0, "merc:AddBusinessEntityUserRequest");
	case SOAP_TYPE_merc__CheckShipmentRegionalizationResponse: return soap_in_merc__CheckShipmentRegionalizationResponse(soap, 0, 0, "merc:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_merc__CheckShipmentRegionalizationRequest: return soap_in_merc__CheckShipmentRegionalizationRequest(soap, 0, 0, "merc:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_merc__UpdateVeterinaryEventsResponse: return soap_in_merc__UpdateVeterinaryEventsResponse(soap, 0, 0, "merc:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_merc__UpdateVeterinaryEventsRequest: return soap_in_merc__UpdateVeterinaryEventsRequest(soap, 0, 0, "merc:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse: return soap_in_merc__UpdateTransportMovementDetailsResponse(soap, 0, 0, "merc:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest: return soap_in_merc__UpdateTransportMovementDetailsRequest(soap, 0, 0, "merc:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_merc__GetStockEntryVersionListResponse: return soap_in_merc__GetStockEntryVersionListResponse(soap, 0, 0, "merc:GetStockEntryVersionListResponse");
	case SOAP_TYPE_merc__GetStockEntryVersionListRequest: return soap_in_merc__GetStockEntryVersionListRequest(soap, 0, 0, "merc:GetStockEntryVersionListRequest");
	case SOAP_TYPE_merc__GetStockEntryListResponse: return soap_in_merc__GetStockEntryListResponse(soap, 0, 0, "merc:GetStockEntryListResponse");
	case SOAP_TYPE_merc__GetStockEntryListRequest: return soap_in_merc__GetStockEntryListRequest(soap, 0, 0, "merc:GetStockEntryListRequest");
	case SOAP_TYPE_merc__GetStockEntryChangesListResponse: return soap_in_merc__GetStockEntryChangesListResponse(soap, 0, 0, "merc:GetStockEntryChangesListResponse");
	case SOAP_TYPE_merc__GetStockEntryChangesListRequest: return soap_in_merc__GetStockEntryChangesListRequest(soap, 0, 0, "merc:GetStockEntryChangesListRequest");
	case SOAP_TYPE_merc__GetStockEntryByUuidResponse: return soap_in_merc__GetStockEntryByUuidResponse(soap, 0, 0, "merc:GetStockEntryByUuidResponse");
	case SOAP_TYPE_merc__GetStockEntryByUuidRequest: return soap_in_merc__GetStockEntryByUuidRequest(soap, 0, 0, "merc:GetStockEntryByUuidRequest");
	case SOAP_TYPE_merc__GetStockEntryByGuidResponse: return soap_in_merc__GetStockEntryByGuidResponse(soap, 0, 0, "merc:GetStockEntryByGuidResponse");
	case SOAP_TYPE_merc__GetStockEntryByGuidRequest: return soap_in_merc__GetStockEntryByGuidRequest(soap, 0, 0, "merc:GetStockEntryByGuidRequest");
	case SOAP_TYPE_merc__GetVetDocumentChangesListResponse: return soap_in_merc__GetVetDocumentChangesListResponse(soap, 0, 0, "merc:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_merc__GetVetDocumentChangesListRequest: return soap_in_merc__GetVetDocumentChangesListRequest(soap, 0, 0, "merc:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_merc__GetVetDocumentListResponse: return soap_in_merc__GetVetDocumentListResponse(soap, 0, 0, "merc:GetVetDocumentListResponse");
	case SOAP_TYPE_merc__GetVetDocumentListRequest: return soap_in_merc__GetVetDocumentListRequest(soap, 0, 0, "merc:GetVetDocumentListRequest");
	case SOAP_TYPE_merc__GetVetDocumentByUuidResponse: return soap_in_merc__GetVetDocumentByUuidResponse(soap, 0, 0, "merc:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_merc__GetVetDocumentByUuidRequest: return soap_in_merc__GetVetDocumentByUuidRequest(soap, 0, 0, "merc:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_merc__ModifyProducerStockListResponse: return soap_in_merc__ModifyProducerStockListResponse(soap, 0, 0, "merc:ModifyProducerStockListResponse");
	case SOAP_TYPE_merc__ModifyProducerStockListRequest: return soap_in_merc__ModifyProducerStockListRequest(soap, 0, 0, "merc:ModifyProducerStockListRequest");
	case SOAP_TYPE_merc__ResolveDiscrepancyResponse: return soap_in_merc__ResolveDiscrepancyResponse(soap, 0, 0, "merc:ResolveDiscrepancyResponse");
	case SOAP_TYPE_merc__ResolveDiscrepancyRequest: return soap_in_merc__ResolveDiscrepancyRequest(soap, 0, 0, "merc:ResolveDiscrepancyRequest");
	case SOAP_TYPE_merc__ModifyActivityLocationsResponse: return soap_in_merc__ModifyActivityLocationsResponse(soap, 0, 0, "merc:ModifyActivityLocationsResponse");
	case SOAP_TYPE_merc__ModifyActivityLocationsRequest: return soap_in_merc__ModifyActivityLocationsRequest(soap, 0, 0, "merc:ModifyActivityLocationsRequest");
	case SOAP_TYPE_merc__ModifyEnterpriseResponse: return soap_in_merc__ModifyEnterpriseResponse(soap, 0, 0, "merc:ModifyEnterpriseResponse");
	case SOAP_TYPE_merc__ModifyEnterpriseRequest: return soap_in_merc__ModifyEnterpriseRequest(soap, 0, 0, "merc:ModifyEnterpriseRequest");
	case SOAP_TYPE_merc__ModifyBusinessEntityResponse: return soap_in_merc__ModifyBusinessEntityResponse(soap, 0, 0, "merc:ModifyBusinessEntityResponse");
	case SOAP_TYPE_merc__ModifyBusinessEntityRequest: return soap_in_merc__ModifyBusinessEntityRequest(soap, 0, 0, "merc:ModifyBusinessEntityRequest");
	case SOAP_TYPE_merc__WithdrawVetDocumentResponse: return soap_in_merc__WithdrawVetDocumentResponse(soap, 0, 0, "merc:WithdrawVetDocumentResponse");
	case SOAP_TYPE_merc__WithdrawVetDocumentRequest: return soap_in_merc__WithdrawVetDocumentRequest(soap, 0, 0, "merc:WithdrawVetDocumentRequest");
	case SOAP_TYPE_merc__MergeStockEntriesResponse: return soap_in_merc__MergeStockEntriesResponse(soap, 0, 0, "merc:MergeStockEntriesResponse");
	case SOAP_TYPE_merc__MergeStockEntriesRequest: return soap_in_merc__MergeStockEntriesRequest(soap, 0, 0, "merc:MergeStockEntriesRequest");
	case SOAP_TYPE_merc__RegisterProductionOperationResponse: return soap_in_merc__RegisterProductionOperationResponse(soap, 0, 0, "merc:RegisterProductionOperationResponse");
	case SOAP_TYPE_merc__RegisterProductionOperationRequest: return soap_in_merc__RegisterProductionOperationRequest(soap, 0, 0, "merc:RegisterProductionOperationRequest");
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse: return soap_in_merc__PrepareOutgoingConsignmentResponse(soap, 0, 0, "merc:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest: return soap_in_merc__PrepareOutgoingConsignmentRequest(soap, 0, 0, "merc:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_merc__ProcessIncomingConsignmentResponse: return soap_in_merc__ProcessIncomingConsignmentResponse(soap, 0, 0, "merc:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_merc__ProcessIncomingConsignmentRequest: return soap_in_merc__ProcessIncomingConsignmentRequest(soap, 0, 0, "merc:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_merc__MercuryApplicationRequest: return soap_in_merc__MercuryApplicationRequest(soap, 0, 0, "merc:MercuryApplicationRequest");
	case SOAP_TYPE_app__BusinessError: return soap_in_app__BusinessError(soap, 0, 0, "app:BusinessError");
	case SOAP_TYPE_app__BusinessErrorList: return soap_in_app__BusinessErrorList(soap, 0, 0, "app:BusinessErrorList");
	case SOAP_TYPE_app__ApplicationResultData: return soap_in_app__ApplicationResultData(soap, 0, 0, "app:ApplicationResultData");
	case SOAP_TYPE_app__ApplicationData: return soap_in_app__ApplicationData(soap, 0, 0, "app:ApplicationData");
	case SOAP_TYPE_app__ApplicationResultWrapper: return soap_in_app__ApplicationResultWrapper(soap, 0, 0, "app:ApplicationResultWrapper");
	case SOAP_TYPE_app__ApplicationDataWrapper: return soap_in_app__ApplicationDataWrapper(soap, 0, 0, "app:ApplicationDataWrapper");
	case SOAP_TYPE_app__Application: return soap_in_app__Application(soap, 0, 0, "app:Application");
	case SOAP_TYPE_base__Error: return soap_in_base__Error(soap, 0, 0, "base:Error");
	case SOAP_TYPE_base__FaultInfo: return soap_in_base__FaultInfo(soap, 0, 0, "base:FaultInfo");
	case SOAP_TYPE_base__EntityList: return soap_in_base__EntityList(soap, 0, 0, "base:EntityList");
	case SOAP_TYPE_base__DateInterval: return soap_in_base__DateInterval(soap, 0, 0, "base:DateInterval");
	case SOAP_TYPE_base__ListOptions: return soap_in_base__ListOptions(soap, 0, 0, "base:ListOptions");
	case SOAP_TYPE_base__GenericVersioningEntity: return soap_in_base__GenericVersioningEntity(soap, 0, 0, "base:GenericVersioningEntity");
	case SOAP_TYPE_base__GenericEntity: return soap_in_base__GenericEntity(soap, 0, 0, "base:GenericEntity");
	case SOAP_TYPE_xsd__base64Binary: return soap_in_xsd__base64Binary(soap, 0, 0, "xsd:base64Binary");
	case SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListResponse: return soap_in_PointerTomerc__GetAppliedUserAuthorityListResponse(soap, 0, 0, "merc:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListRequest: return soap_in_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, 0, 0, "merc:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserResponse: return soap_in_PointerTomerc__UnbindBusinessEntityUserResponse(soap, 0, 0, "merc:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserRequest: return soap_in_PointerTomerc__UnbindBusinessEntityUserRequest(soap, 0, 0, "merc:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasResponse: return soap_in_PointerTomerc__UpdateUserWorkingAreasResponse(soap, 0, 0, "merc:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasRequest: return soap_in_PointerTomerc__UpdateUserWorkingAreasRequest(soap, 0, 0, "merc:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesResponse: return soap_in_PointerTomerc__UpdateUserAuthoritiesResponse(soap, 0, 0, "merc:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesRequest: return soap_in_PointerTomerc__UpdateUserAuthoritiesRequest(soap, 0, 0, "merc:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserResponse: return soap_in_PointerTomerc__GetBusinessEntityUserResponse(soap, 0, 0, "merc:GetBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserRequest: return soap_in_PointerTomerc__GetBusinessEntityUserRequest(soap, 0, 0, "merc:GetBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListResponse: return soap_in_PointerTomerc__GetBusinessEntityUserListResponse(soap, 0, 0, "merc:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListRequest: return soap_in_PointerTomerc__GetBusinessEntityUserListRequest(soap, 0, 0, "merc:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_PointerTomerc__AddBusinessEntityUserResponse: return soap_in_PointerTomerc__AddBusinessEntityUserResponse(soap, 0, 0, "merc:AddBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTomerc__AddBusinessEntityUserRequest: return soap_in_PointerTomerc__AddBusinessEntityUserRequest(soap, 0, 0, "merc:AddBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationResponse: return soap_in_PointerTomerc__CheckShipmentRegionalizationResponse(soap, 0, 0, "merc:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationRequest: return soap_in_PointerTomerc__CheckShipmentRegionalizationRequest(soap, 0, 0, "merc:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsResponse: return soap_in_PointerTomerc__UpdateVeterinaryEventsResponse(soap, 0, 0, "merc:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsRequest: return soap_in_PointerTomerc__UpdateVeterinaryEventsRequest(soap, 0, 0, "merc:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsResponse: return soap_in_PointerTomerc__UpdateTransportMovementDetailsResponse(soap, 0, 0, "merc:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsRequest: return soap_in_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, 0, 0, "merc:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryVersionListResponse: return soap_in_PointerTomerc__GetStockEntryVersionListResponse(soap, 0, 0, "merc:GetStockEntryVersionListResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryVersionListRequest: return soap_in_PointerTomerc__GetStockEntryVersionListRequest(soap, 0, 0, "merc:GetStockEntryVersionListRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryChangesListResponse: return soap_in_PointerTomerc__GetStockEntryChangesListResponse(soap, 0, 0, "merc:GetStockEntryChangesListResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryChangesListRequest: return soap_in_PointerTomerc__GetStockEntryChangesListRequest(soap, 0, 0, "merc:GetStockEntryChangesListRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryListResponse: return soap_in_PointerTomerc__GetStockEntryListResponse(soap, 0, 0, "merc:GetStockEntryListResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryListRequest: return soap_in_PointerTomerc__GetStockEntryListRequest(soap, 0, 0, "merc:GetStockEntryListRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByUuidResponse: return soap_in_PointerTomerc__GetStockEntryByUuidResponse(soap, 0, 0, "merc:GetStockEntryByUuidResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByUuidRequest: return soap_in_PointerTomerc__GetStockEntryByUuidRequest(soap, 0, 0, "merc:GetStockEntryByUuidRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByGuidResponse: return soap_in_PointerTomerc__GetStockEntryByGuidResponse(soap, 0, 0, "merc:GetStockEntryByGuidResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByGuidRequest: return soap_in_PointerTomerc__GetStockEntryByGuidRequest(soap, 0, 0, "merc:GetStockEntryByGuidRequest");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListResponse: return soap_in_PointerTomerc__GetVetDocumentChangesListResponse(soap, 0, 0, "merc:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListRequest: return soap_in_PointerTomerc__GetVetDocumentChangesListRequest(soap, 0, 0, "merc:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentListResponse: return soap_in_PointerTomerc__GetVetDocumentListResponse(soap, 0, 0, "merc:GetVetDocumentListResponse");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentListRequest: return soap_in_PointerTomerc__GetVetDocumentListRequest(soap, 0, 0, "merc:GetVetDocumentListRequest");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidResponse: return soap_in_PointerTomerc__GetVetDocumentByUuidResponse(soap, 0, 0, "merc:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidRequest: return soap_in_PointerTomerc__GetVetDocumentByUuidRequest(soap, 0, 0, "merc:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_PointerTomerc__ModifyProducerStockListResponse: return soap_in_PointerTomerc__ModifyProducerStockListResponse(soap, 0, 0, "merc:ModifyProducerStockListResponse");
	case SOAP_TYPE_PointerTomerc__ModifyProducerStockListRequest: return soap_in_PointerTomerc__ModifyProducerStockListRequest(soap, 0, 0, "merc:ModifyProducerStockListRequest");
	case SOAP_TYPE_PointerTomerc__ResolveDiscrepancyResponse: return soap_in_PointerTomerc__ResolveDiscrepancyResponse(soap, 0, 0, "merc:ResolveDiscrepancyResponse");
	case SOAP_TYPE_PointerTomerc__ResolveDiscrepancyRequest: return soap_in_PointerTomerc__ResolveDiscrepancyRequest(soap, 0, 0, "merc:ResolveDiscrepancyRequest");
	case SOAP_TYPE_PointerTomerc__ModifyActivityLocationsResponse: return soap_in_PointerTomerc__ModifyActivityLocationsResponse(soap, 0, 0, "merc:ModifyActivityLocationsResponse");
	case SOAP_TYPE_PointerTomerc__ModifyActivityLocationsRequest: return soap_in_PointerTomerc__ModifyActivityLocationsRequest(soap, 0, 0, "merc:ModifyActivityLocationsRequest");
	case SOAP_TYPE_PointerTomerc__ModifyEnterpriseResponse: return soap_in_PointerTomerc__ModifyEnterpriseResponse(soap, 0, 0, "merc:ModifyEnterpriseResponse");
	case SOAP_TYPE_PointerTomerc__ModifyEnterpriseRequest: return soap_in_PointerTomerc__ModifyEnterpriseRequest(soap, 0, 0, "merc:ModifyEnterpriseRequest");
	case SOAP_TYPE_PointerTomerc__ModifyBusinessEntityResponse: return soap_in_PointerTomerc__ModifyBusinessEntityResponse(soap, 0, 0, "merc:ModifyBusinessEntityResponse");
	case SOAP_TYPE_PointerTomerc__ModifyBusinessEntityRequest: return soap_in_PointerTomerc__ModifyBusinessEntityRequest(soap, 0, 0, "merc:ModifyBusinessEntityRequest");
	case SOAP_TYPE_PointerTomerc__WithdrawVetDocumentResponse: return soap_in_PointerTomerc__WithdrawVetDocumentResponse(soap, 0, 0, "merc:WithdrawVetDocumentResponse");
	case SOAP_TYPE_PointerTomerc__WithdrawVetDocumentRequest: return soap_in_PointerTomerc__WithdrawVetDocumentRequest(soap, 0, 0, "merc:WithdrawVetDocumentRequest");
	case SOAP_TYPE_PointerTomerc__MergeStockEntriesResponse: return soap_in_PointerTomerc__MergeStockEntriesResponse(soap, 0, 0, "merc:MergeStockEntriesResponse");
	case SOAP_TYPE_PointerTomerc__MergeStockEntriesRequest: return soap_in_PointerTomerc__MergeStockEntriesRequest(soap, 0, 0, "merc:MergeStockEntriesRequest");
	case SOAP_TYPE_PointerTomerc__RegisterProductionOperationResponse: return soap_in_PointerTomerc__RegisterProductionOperationResponse(soap, 0, 0, "merc:RegisterProductionOperationResponse");
	case SOAP_TYPE_PointerTomerc__RegisterProductionOperationRequest: return soap_in_PointerTomerc__RegisterProductionOperationRequest(soap, 0, 0, "merc:RegisterProductionOperationRequest");
	case SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentResponse: return soap_in_PointerTomerc__PrepareOutgoingConsignmentResponse(soap, 0, 0, "merc:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentRequest: return soap_in_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, 0, 0, "merc:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentResponse: return soap_in_PointerTomerc__ProcessIncomingConsignmentResponse(soap, 0, 0, "merc:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentRequest: return soap_in_PointerTomerc__ProcessIncomingConsignmentRequest(soap, 0, 0, "merc:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse: return soap_in_PointerTo_ws__receiveApplicationResultResponse(soap, 0, 0, "ws:receiveApplicationResultResponse");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest: return soap_in_PointerTo_ws__receiveApplicationResultRequest(soap, 0, 0, "ws:receiveApplicationResultRequest");
	case SOAP_TYPE_PointerTo_ws__submitApplicationResponse: return soap_in_PointerTo_ws__submitApplicationResponse(soap, 0, 0, "ws:submitApplicationResponse");
	case SOAP_TYPE_PointerTo_ws__submitApplicationRequest: return soap_in_PointerTo_ws__submitApplicationRequest(soap, 0, 0, "ws:submitApplicationRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemChangesListResponse: return soap_in_PointerTo_ns8__getProductItemChangesListResponse(soap, 0, 0, "ns8:getProductItemChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemChangesListRequest: return soap_in_PointerTo_ns8__getProductItemChangesListRequest(soap, 0, 0, "ns8:getProductItemChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemListResponse: return soap_in_PointerTo_ns8__getProductItemListResponse(soap, 0, 0, "ns8:getProductItemListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemListRequest: return soap_in_PointerTo_ns8__getProductItemListRequest(soap, 0, 0, "ns8:getProductItemListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByUuidResponse: return soap_in_PointerTo_ns8__getProductItemByUuidResponse(soap, 0, 0, "ns8:getProductItemByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByUuidRequest: return soap_in_PointerTo_ns8__getProductItemByUuidRequest(soap, 0, 0, "ns8:getProductItemByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByGuidResponse: return soap_in_PointerTo_ns8__getProductItemByGuidResponse(soap, 0, 0, "ns8:getProductItemByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByGuidRequest: return soap_in_PointerTo_ns8__getProductItemByGuidRequest(soap, 0, 0, "ns8:getProductItemByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductChangesListResponse: return soap_in_PointerTo_ns8__getSubProductChangesListResponse(soap, 0, 0, "ns8:getSubProductChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductChangesListRequest: return soap_in_PointerTo_ns8__getSubProductChangesListRequest(soap, 0, 0, "ns8:getSubProductChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByProductListResponse: return soap_in_PointerTo_ns8__getSubProductByProductListResponse(soap, 0, 0, "ns8:getSubProductByProductListResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByProductListRequest: return soap_in_PointerTo_ns8__getSubProductByProductListRequest(soap, 0, 0, "ns8:getSubProductByProductListRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByUuidResponse: return soap_in_PointerTo_ns8__getSubProductByUuidResponse(soap, 0, 0, "ns8:getSubProductByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByUuidRequest: return soap_in_PointerTo_ns8__getSubProductByUuidRequest(soap, 0, 0, "ns8:getSubProductByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByGuidResponse: return soap_in_PointerTo_ns8__getSubProductByGuidResponse(soap, 0, 0, "ns8:getSubProductByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByGuidRequest: return soap_in_PointerTo_ns8__getSubProductByGuidRequest(soap, 0, 0, "ns8:getSubProductByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductChangesListResponse: return soap_in_PointerTo_ns8__getProductChangesListResponse(soap, 0, 0, "ns8:getProductChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductChangesListRequest: return soap_in_PointerTo_ns8__getProductChangesListRequest(soap, 0, 0, "ns8:getProductChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductByTypeListResponse: return soap_in_PointerTo_ns8__getProductByTypeListResponse(soap, 0, 0, "ns8:getProductByTypeListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductByTypeListRequest: return soap_in_PointerTo_ns8__getProductByTypeListRequest(soap, 0, 0, "ns8:getProductByTypeListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductByUuidResponse: return soap_in_PointerTo_ns8__getProductByUuidResponse(soap, 0, 0, "ns8:getProductByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductByUuidRequest: return soap_in_PointerTo_ns8__getProductByUuidRequest(soap, 0, 0, "ns8:getProductByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductByGuidResponse: return soap_in_PointerTo_ns8__getProductByGuidResponse(soap, 0, 0, "ns8:getProductByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductByGuidRequest: return soap_in_PointerTo_ns8__getProductByGuidRequest(soap, 0, 0, "ns8:getProductByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse: return soap_in_PointerTo_ns8__getActivityLocationListResponse(soap, 0, 0, "ns8:getActivityLocationListResponse");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest: return soap_in_PointerTo_ns8__getActivityLocationListRequest(soap, 0, 0, "ns8:getActivityLocationListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse: return soap_in_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, 0, 0, "ns8:getBusinessMemberByGLNResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest: return soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, 0, 0, "ns8:getBusinessMemberByGLNRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse: return soap_in_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, 0, 0, "ns8:getRussianEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest: return soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, 0, 0, "ns8:getRussianEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse: return soap_in_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, 0, 0, "ns8:getForeignEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest: return soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, 0, 0, "ns8:getForeignEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse: return soap_in_PointerTo_ns8__getRussianEnterpriseListResponse(soap, 0, 0, "ns8:getRussianEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest: return soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(soap, 0, 0, "ns8:getRussianEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse: return soap_in_PointerTo_ns8__getForeignEnterpriseListResponse(soap, 0, 0, "ns8:getForeignEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest: return soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(soap, 0, 0, "ns8:getForeignEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse: return soap_in_PointerTo_ns8__getEnterpriseByUuidResponse(soap, 0, 0, "ns8:getEnterpriseByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest: return soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(soap, 0, 0, "ns8:getEnterpriseByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse: return soap_in_PointerTo_ns8__getEnterpriseByGuidResponse(soap, 0, 0, "ns8:getEnterpriseByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest: return soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(soap, 0, 0, "ns8:getEnterpriseByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse: return soap_in_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, 0, 0, "ns8:getBusinessEntityChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest: return soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, 0, 0, "ns8:getBusinessEntityChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse: return soap_in_PointerTo_ns8__getBusinessEntityListResponse(soap, 0, 0, "ns8:getBusinessEntityListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest: return soap_in_PointerTo_ns8__getBusinessEntityListRequest(soap, 0, 0, "ns8:getBusinessEntityListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse: return soap_in_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, 0, 0, "ns8:getBusinessEntityByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest: return soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, 0, 0, "ns8:getBusinessEntityByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse: return soap_in_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, 0, 0, "ns8:getBusinessEntityByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest: return soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, 0, 0, "ns8:getBusinessEntityByGuidRequest");
	case SOAP_TYPE_PointerTobase__FaultInfo: return soap_in_PointerTobase__FaultInfo(soap, 0, 0, "base:FaultInfo");
	case SOAP_TYPE_PointerTovd__StockEntryBlankFilter: return soap_in_PointerTovd__StockEntryBlankFilter(soap, 0, 0, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_PointerTovd__StockEntryEventList: return soap_in_PointerTovd__StockEntryEventList(soap, 0, 0, "vd:StockEntryEventList");
	case SOAP_TYPE_PointerTovd__DiscrepancyReason: return soap_in_PointerTovd__DiscrepancyReason(soap, 0, 0, "vd:DiscrepancyReason");
	case SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange: return soap_in_PointerToPointerTovd__VetDocumentStatusChange(soap, 0, 0, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VetDocumentStatusChange: return soap_in_PointerTovd__VetDocumentStatusChange(soap, 0, 0, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VeterinaryAuthentication: return soap_in_PointerTovd__VeterinaryAuthentication(soap, 0, 0, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_PointerTovd__CertifiedConsignment: return soap_in_PointerTovd__CertifiedConsignment(soap, 0, 0, "vd:CertifiedConsignment");
	case SOAP_TYPE_PointerTovd__CertifiedBatch: return soap_in_PointerTovd__CertifiedBatch(soap, 0, 0, "vd:CertifiedBatch");
	case SOAP_TYPE_PointerTovd__VetDocumentForm: return soap_in_PointerTovd__VetDocumentForm(soap, 0, 0, "vd:VetDocumentForm");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationStatus: return soap_in_PointerToPointerToent__RegionalizationStatus(soap, 0, 0, "ent:RegionalizationStatus");
	case SOAP_TYPE_PointerToPointerToent__Area: return soap_in_PointerToPointerToent__Area(soap, 0, 0, "ent:Area");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationRequirement: return soap_in_PointerToPointerToent__RegionalizationRequirement(soap, 0, 0, "ent:RegionalizationRequirement");
	case SOAP_TYPE_PointerToent__RegionalizationRequirement: return soap_in_PointerToent__RegionalizationRequirement(soap, 0, 0, "ent:RegionalizationRequirement");
	case SOAP_TYPE_PointerToent__RegionalizationDecision: return soap_in_PointerToent__RegionalizationDecision(soap, 0, 0, "ent:RegionalizationDecision");
	case SOAP_TYPE_PointerToent__RegionalizationStatus: return soap_in_PointerToent__RegionalizationStatus(soap, 0, 0, "ent:RegionalizationStatus");
	case SOAP_TYPE_PointerToent__Packaging: return soap_in_PointerToent__Packaging(soap, 0, 0, "ent:Packaging");
	case SOAP_TYPE_PointerToPointerToent__ProductItemProducing: return soap_in_PointerToPointerToent__ProductItemProducing(soap, 0, 0, "ent:ProductItemProducing");
	case SOAP_TYPE_PointerToent__ProductItemProducing: return soap_in_PointerToent__ProductItemProducing(soap, 0, 0, "ent:ProductItemProducing");
	case SOAP_TYPE_PointerTo_ent__BusinessEntity_activityLocation: return soap_in_PointerTo_ent__BusinessEntity_activityLocation(soap, 0, 0, "ent:BusinessEntity-activityLocation");
	case SOAP_TYPE_PointerToent__IncorporationForm: return soap_in_PointerToent__IncorporationForm(soap, 0, 0, "ent:IncorporationForm");
	case SOAP_TYPE_PointerToent__BusinessEntityType: return soap_in_PointerToent__BusinessEntityType(soap, 0, 0, "ent:BusinessEntityType");
	case SOAP_TYPE_PointerToPointerToent__EnterpriseOfficialRegistration: return soap_in_PointerToPointerToent__EnterpriseOfficialRegistration(soap, 0, 0, "ent:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration: return soap_in_PointerToent__EnterpriseOfficialRegistration(soap, 0, 0, "ent:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerToent__EnterpriseActivityList: return soap_in_PointerToent__EnterpriseActivityList(soap, 0, 0, "ent:EnterpriseActivityList");
	case SOAP_TYPE_PointerToent__EnterpriseNumberList: return soap_in_PointerToent__EnterpriseNumberList(soap, 0, 0, "ent:EnterpriseNumberList");
	case SOAP_TYPE_PointerToent__EnterpriseType: return soap_in_PointerToent__EnterpriseType(soap, 0, 0, "ent:EnterpriseType");
	case SOAP_TYPE_PointerToent__PackingCodeType: return soap_in_PointerToent__PackingCodeType(soap, 0, 0, "ent:PackingCodeType");
	case SOAP_TYPE_PointerTobase__UUID: return soap_in_PointerTobase__UUID(soap, 0, 0, "base:UUID");
	case SOAP_TYPE_PointerTovd__StockEntrySearchPattern: return soap_in_PointerTovd__StockEntrySearchPattern(soap, 0, 0, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_PointerTovd__VetDocumentStatus: return soap_in_PointerTovd__VetDocumentStatus(soap, 0, 0, "vd:VetDocumentStatus");
	case SOAP_TYPE_PointerTovd__VetDocumentType: return soap_in_PointerTovd__VetDocumentType(soap, 0, 0, "vd:VetDocumentType");
	case SOAP_TYPE_PointerTovd__PSLModificationOperation: return soap_in_PointerTovd__PSLModificationOperation(soap, 0, 0, "vd:PSLModificationOperation");
	case SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy: return soap_in_PointerToPointerTovd__StockDiscrepancy(soap, 0, 0, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__StockDiscrepancy: return soap_in_PointerTovd__StockDiscrepancy(soap, 0, 0, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation: return soap_in_PointerTovd__BEActivityLocationsModificationOperation(soap, 0, 0, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_PointerTovd__ENTModificationOperation: return soap_in_PointerTovd__ENTModificationOperation(soap, 0, 0, "vd:ENTModificationOperation");
	case SOAP_TYPE_PointerTovd__BEModificationOperation: return soap_in_PointerTovd__BEModificationOperation(soap, 0, 0, "vd:BEModificationOperation");
	case SOAP_TYPE_PointerTovd__MergeStockEntriesOperation: return soap_in_PointerTovd__MergeStockEntriesOperation(soap, 0, 0, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_PointerTovd__ProductionOperation: return soap_in_PointerTovd__ProductionOperation(soap, 0, 0, "vd:ProductionOperation");
	case SOAP_TYPE_PointerToPointerTovd__Delivery: return soap_in_PointerToPointerTovd__Delivery(soap, 0, 0, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport: return soap_in_PointerToPointerTovd__DiscrepancyReport(soap, 0, 0, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DiscrepancyReport: return soap_in_PointerTovd__DiscrepancyReport(soap, 0, 0, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DeliveryFactList: return soap_in_PointerTovd__DeliveryFactList(soap, 0, 0, "vd:DeliveryFactList");
	case SOAP_TYPE_PointerTovd__Delivery: return soap_in_PointerTovd__Delivery(soap, 0, 0, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__WorkingArea: return soap_in_PointerToPointerTovd__WorkingArea(soap, 0, 0, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingArea: return soap_in_PointerTovd__WorkingArea(soap, 0, 0, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingAreaList: return soap_in_PointerTovd__WorkingAreaList(soap, 0, 0, "vd:WorkingAreaList");
	case SOAP_TYPE_PointerTovd__SNILSType: return soap_in_PointerTovd__SNILSType(soap, 0, 0, "vd:SNILSType");
	case SOAP_TYPE_PointerToent__MedicinalDrug: return soap_in_PointerToent__MedicinalDrug(soap, 0, 0, "ent:MedicinalDrug");
	case SOAP_TYPE_PointerToent__Indicator: return soap_in_PointerToent__Indicator(soap, 0, 0, "ent:Indicator");
	case SOAP_TYPE_PointerToent__DocumentType: return soap_in_PointerToent__DocumentType(soap, 0, 0, "ent:DocumentType");
	case SOAP_TYPE_PointerTovd__ConsignmentDocumentList: return soap_in_PointerTovd__ConsignmentDocumentList(soap, 0, 0, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_PointerToPointerTovd__Consignment: return soap_in_PointerToPointerTovd__Consignment(soap, 0, 0, "vd:Consignment");
	case SOAP_TYPE_PointerTovd__Consignment: return soap_in_PointerTovd__Consignment(soap, 0, 0, "vd:Consignment");
	case SOAP_TYPE_PointerToPointerToent__BusinessMember: return soap_in_PointerToPointerToent__BusinessMember(soap, 0, 0, "ent:BusinessMember");
	case SOAP_TYPE_PointerToPointerToent__ResearchMethod: return soap_in_PointerToPointerToent__ResearchMethod(soap, 0, 0, "ent:ResearchMethod");
	case SOAP_TYPE_PointerToPointerToent__AnimalDisease: return soap_in_PointerToPointerToent__AnimalDisease(soap, 0, 0, "ent:AnimalDisease");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationRegionStatus: return soap_in_PointerToPointerToent__RegionalizationRegionStatus(soap, 0, 0, "ent:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToent__RegionalizationRegionStatus: return soap_in_PointerToent__RegionalizationRegionStatus(soap, 0, 0, "ent:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToPointerToent__ProductItem: return soap_in_PointerToPointerToent__ProductItem(soap, 0, 0, "ent:ProductItem");
	case SOAP_TYPE_PointerToPointerToent__SubProduct: return soap_in_PointerToPointerToent__SubProduct(soap, 0, 0, "ent:SubProduct");
	case SOAP_TYPE_PointerToPointerToent__Product: return soap_in_PointerToPointerToent__Product(soap, 0, 0, "ent:Product");
	case SOAP_TYPE_PointerToPointerToent__EnterpriseActivity: return soap_in_PointerToPointerToent__EnterpriseActivity(soap, 0, 0, "ent:EnterpriseActivity");
	case SOAP_TYPE_PointerToent__EnterpriseActivity: return soap_in_PointerToent__EnterpriseActivity(soap, 0, 0, "ent:EnterpriseActivity");
	case SOAP_TYPE_PointerToPointerToent__Street: return soap_in_PointerToPointerToent__Street(soap, 0, 0, "ent:Street");
	case SOAP_TYPE_PointerToPointerToent__Locality: return soap_in_PointerToPointerToent__Locality(soap, 0, 0, "ent:Locality");
	case SOAP_TYPE_PointerToPointerToent__District: return soap_in_PointerToPointerToent__District(soap, 0, 0, "ent:District");
	case SOAP_TYPE_PointerToPointerToent__Region: return soap_in_PointerToPointerToent__Region(soap, 0, 0, "ent:Region");
	case SOAP_TYPE_PointerToPointerToent__Country: return soap_in_PointerToPointerToent__Country(soap, 0, 0, "ent:Country");
	case SOAP_TYPE_PointerToPointerToent__Unit: return soap_in_PointerToPointerToent__Unit(soap, 0, 0, "ent:Unit");
	case SOAP_TYPE_PointerToPointerToent__Purpose: return soap_in_PointerToPointerToent__Purpose(soap, 0, 0, "ent:Purpose");
	case SOAP_TYPE_PointerTovd__AuthorityList: return soap_in_PointerTovd__AuthorityList(soap, 0, 0, "vd:AuthorityList");
	case SOAP_TYPE_PointerTovd__UserList: return soap_in_PointerTovd__UserList(soap, 0, 0, "vd:UserList");
	case SOAP_TYPE_PointerToPointerTovd__User: return soap_in_PointerToPointerTovd__User(soap, 0, 0, "vd:User");
	case SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules: return soap_in_PointerToPointerTovd__RouteSectionR13nRules(soap, 0, 0, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__RouteSectionR13nRules: return soap_in_PointerTovd__RouteSectionR13nRules(soap, 0, 0, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__VetDocumentList: return soap_in_PointerTovd__VetDocumentList(soap, 0, 0, "vd:VetDocumentList");
	case SOAP_TYPE_PointerToPointerToent__Enterprise: return soap_in_PointerToPointerToent__Enterprise(soap, 0, 0, "ent:Enterprise");
	case SOAP_TYPE_PointerToPointerToent__BusinessEntity: return soap_in_PointerToPointerToent__BusinessEntity(soap, 0, 0, "ent:BusinessEntity");
	case SOAP_TYPE_PointerToent__OTPToken: return soap_in_PointerToent__OTPToken(soap, 0, 0, "ent:OTPToken");
	case SOAP_TYPE_PointerTobase__VersionStatus: return soap_in_PointerTobase__VersionStatus(soap, 0, 0, "base:VersionStatus");
	case SOAP_TYPE_PointerToent__ResearchMethodList: return soap_in_PointerToent__ResearchMethodList(soap, 0, 0, "ent:ResearchMethodList");
	case SOAP_TYPE_PointerToent__ResearchMethod: return soap_in_PointerToent__ResearchMethod(soap, 0, 0, "ent:ResearchMethod");
	case SOAP_TYPE_PointerToent__AnimalDiseaseList: return soap_in_PointerToent__AnimalDiseaseList(soap, 0, 0, "ent:AnimalDiseaseList");
	case SOAP_TYPE_PointerToent__RegionalizationShippingRuleList: return soap_in_PointerToent__RegionalizationShippingRuleList(soap, 0, 0, "ent:RegionalizationShippingRuleList");
	case SOAP_TYPE_PointerToent__RegionalizationRegionStatusList: return soap_in_PointerToent__RegionalizationRegionStatusList(soap, 0, 0, "ent:RegionalizationRegionStatusList");
	case SOAP_TYPE_PointerToent__RegionalizationConditionList: return soap_in_PointerToent__RegionalizationConditionList(soap, 0, 0, "ent:RegionalizationConditionList");
	case SOAP_TYPE_PointerToent__ActivityLocationList: return soap_in_PointerToent__ActivityLocationList(soap, 0, 0, "ent:ActivityLocationList");
	case SOAP_TYPE_PointerToent__EnterpriseGroup: return soap_in_PointerToent__EnterpriseGroup(soap, 0, 0, "ent:EnterpriseGroup");
	case SOAP_TYPE_PointerToent__StreetList: return soap_in_PointerToent__StreetList(soap, 0, 0, "ent:StreetList");
	case SOAP_TYPE_PointerToent__LocalityList: return soap_in_PointerToent__LocalityList(soap, 0, 0, "ent:LocalityList");
	case SOAP_TYPE_PointerToent__DistrictList: return soap_in_PointerToent__DistrictList(soap, 0, 0, "ent:DistrictList");
	case SOAP_TYPE_PointerToent__RegionList: return soap_in_PointerToent__RegionList(soap, 0, 0, "ent:RegionList");
	case SOAP_TYPE_PointerToent__CountryList: return soap_in_PointerToent__CountryList(soap, 0, 0, "ent:CountryList");
	case SOAP_TYPE_PointerToent__SubProductList: return soap_in_PointerToent__SubProductList(soap, 0, 0, "ent:SubProductList");
	case SOAP_TYPE_PointerToent__ProductList: return soap_in_PointerToent__ProductList(soap, 0, 0, "ent:ProductList");
	case SOAP_TYPE_PointerToent__UnitList: return soap_in_PointerToent__UnitList(soap, 0, 0, "ent:UnitList");
	case SOAP_TYPE_PointerTobase__DateInterval: return soap_in_PointerTobase__DateInterval(soap, 0, 0, "base:DateInterval");
	case SOAP_TYPE_PointerToent__PurposeList: return soap_in_PointerToent__PurposeList(soap, 0, 0, "ent:PurposeList");
	case SOAP_TYPE_PointerTobase__ListOptions: return soap_in_PointerTobase__ListOptions(soap, 0, 0, "base:ListOptions");
	case SOAP_TYPE_PointerToent__Area: return soap_in_PointerToent__Area(soap, 0, 0, "ent:Area");
	case SOAP_TYPE_PointerToPointerTovd__UserAuthority: return soap_in_PointerToPointerTovd__UserAuthority(soap, 0, 0, "vd:UserAuthority");
	case SOAP_TYPE_PointerTovd__UserAuthority: return soap_in_PointerTovd__UserAuthority(soap, 0, 0, "vd:UserAuthority");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationShippingRule: return soap_in_PointerToPointerToent__RegionalizationShippingRule(soap, 0, 0, "ent:RegionalizationShippingRule");
	case SOAP_TYPE_PointerToent__RegionalizationShippingRule: return soap_in_PointerToent__RegionalizationShippingRule(soap, 0, 0, "ent:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTobase__SequenceNumber: return soap_in_PointerTobase__SequenceNumber(soap, 0, 0, "base:SequenceNumber");
	case SOAP_TYPE_PointerToPointerTovd__QuarantineEvent: return soap_in_PointerToPointerTovd__QuarantineEvent(soap, 0, 0, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__RegionalizationClause: return soap_in_PointerToPointerTovd__RegionalizationClause(soap, 0, 0, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerTovd__RegionalizationClause: return soap_in_PointerTovd__RegionalizationClause(soap, 0, 0, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent: return soap_in_PointerToPointerTovd__VeterinaryEvent(soap, 0, 0, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerTovd__VeterinaryEvent: return soap_in_PointerTovd__VeterinaryEvent(soap, 0, 0, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent: return soap_in_PointerToPointerTovd__AnimalMedicationEvent(soap, 0, 0, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__AnimalMedicationEvent: return soap_in_PointerTovd__AnimalMedicationEvent(soap, 0, 0, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__QuarantineEvent: return soap_in_PointerTovd__QuarantineEvent(soap, 0, 0, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent: return soap_in_PointerToPointerTovd__LaboratoryResearchEvent(soap, 0, 0, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__LaboratoryResearchEvent: return soap_in_PointerTovd__LaboratoryResearchEvent(soap, 0, 0, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__AnimalSpentPeriod: return soap_in_PointerTovd__AnimalSpentPeriod(soap, 0, 0, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_PointerToent__ResearchResult: return soap_in_PointerToent__ResearchResult(soap, 0, 0, "ent:ResearchResult");
	case SOAP_TYPE_PointerToent__Purpose: return soap_in_PointerToent__Purpose(soap, 0, 0, "ent:Purpose");
	case SOAP_TYPE_PointerToPointerTovd__Document: return soap_in_PointerToPointerTovd__Document(soap, 0, 0, "vd:Document");
	case SOAP_TYPE_PointerTovd__Document: return soap_in_PointerTovd__Document(soap, 0, 0, "vd:Document");
	case SOAP_TYPE_PointerToent__Organization: return soap_in_PointerToent__Organization(soap, 0, 0, "ent:Organization");
	case SOAP_TYPE_PointerToent__Location: return soap_in_PointerToent__Location(soap, 0, 0, "ent:Location");
	case SOAP_TYPE_PointerTovd__VeterinaryEventType: return soap_in_PointerTovd__VeterinaryEventType(soap, 0, 0, "vd:VeterinaryEventType");
	case SOAP_TYPE_PointerTovd__ShipmentRoute: return soap_in_PointerTovd__ShipmentRoute(soap, 0, 0, "vd:ShipmentRoute");
	case SOAP_TYPE_PointerToent__TransportationStorageType: return soap_in_PointerToent__TransportationStorageType(soap, 0, 0, "ent:TransportationStorageType");
	case SOAP_TYPE_PointerTovd__TransportInfo: return soap_in_PointerTovd__TransportInfo(soap, 0, 0, "vd:TransportInfo");
	case SOAP_TYPE_PointerTovd__Batch: return soap_in_PointerTovd__Batch(soap, 0, 0, "vd:Batch");
	case SOAP_TYPE_PointerToent__EnterpriseList: return soap_in_PointerToent__EnterpriseList(soap, 0, 0, "ent:EnterpriseList");
	case SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation: return soap_in_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, 0, 0, "vd:BEActivityLocationsModificationOperation-activityLocation");
	case SOAP_TYPE_PointerToent__GLNType: return soap_in_PointerToent__GLNType(soap, 0, 0, "ent:GLNType");
	case SOAP_TYPE_PointerToent__BusinessEntityList: return soap_in_PointerToent__BusinessEntityList(soap, 0, 0, "ent:BusinessEntityList");
	case SOAP_TYPE_PointerToent__ProductItemList: return soap_in_PointerToent__ProductItemList(soap, 0, 0, "ent:ProductItemList");
	case SOAP_TYPE_PointerToPointerTovd__StockEntry: return soap_in_PointerToPointerTovd__StockEntry(soap, 0, 0, "vd:StockEntry");
	case SOAP_TYPE_PointerTobase__RegisterModificationType: return soap_in_PointerTobase__RegisterModificationType(soap, 0, 0, "base:RegisterModificationType");
	case SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure: return soap_in_PointerToPointerTovd__ProcessingProcedure(soap, 0, 0, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerTovd__ProcessingProcedure: return soap_in_PointerTovd__ProcessingProcedure(soap, 0, 0, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerToPointerTovd__ProductiveBatch: return soap_in_PointerToPointerTovd__ProductiveBatch(soap, 0, 0, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerTovd__ProductiveBatch: return soap_in_PointerTovd__ProductiveBatch(soap, 0, 0, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerToPointerTovd__RawBatch: return soap_in_PointerToPointerTovd__RawBatch(soap, 0, 0, "vd:RawBatch");
	case SOAP_TYPE_PointerTovd__RawBatch: return soap_in_PointerTovd__RawBatch(soap, 0, 0, "vd:RawBatch");
	case SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint: return soap_in_PointerToPointerTovd__ShipmentRoutePoint(soap, 0, 0, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__ShipmentRoutePoint: return soap_in_PointerTovd__ShipmentRoutePoint(soap, 0, 0, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__TransportNumber: return soap_in_PointerTovd__TransportNumber(soap, 0, 0, "vd:TransportNumber");
	case SOAP_TYPE_PointerToent__TransportType: return soap_in_PointerToent__TransportType(soap, 0, 0, "ent:TransportType");
	case SOAP_TYPE_PointerTovd__StockEntryList: return soap_in_PointerTovd__StockEntryList(soap, 0, 0, "vd:StockEntryList");
	case SOAP_TYPE_PointerToent__ComplexDate: return soap_in_PointerToent__ComplexDate(soap, 0, 0, "ent:ComplexDate");
	case SOAP_TYPE_PointerToPointerTovd__ReferencedDocument: return soap_in_PointerToPointerTovd__ReferencedDocument(soap, 0, 0, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerTovd__ReferencedDocument: return soap_in_PointerTovd__ReferencedDocument(soap, 0, 0, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerToPointerTovd__VetDocument: return soap_in_PointerToPointerTovd__VetDocument(soap, 0, 0, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__VetDocument: return soap_in_PointerTovd__VetDocument(soap, 0, 0, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__Waybill: return soap_in_PointerTovd__Waybill(soap, 0, 0, "vd:Waybill");
	case SOAP_TYPE_PointerTovd__User: return soap_in_PointerTovd__User(soap, 0, 0, "vd:User");
	case SOAP_TYPE_PointerTovd__DeliveryInspection: return soap_in_PointerTovd__DeliveryInspection(soap, 0, 0, "vd:DeliveryInspection");
	case SOAP_TYPE_PointerTovd__StockEntry: return soap_in_PointerTovd__StockEntry(soap, 0, 0, "vd:StockEntry");
	case SOAP_TYPE_PointerToent__PackageList: return soap_in_PointerToent__PackageList(soap, 0, 0, "ent:PackageList");
	case SOAP_TYPE_PointerTovd__BatchOrigin: return soap_in_PointerTovd__BatchOrigin(soap, 0, 0, "vd:BatchOrigin");
	case SOAP_TYPE_PointerTovd__GoodsDate: return soap_in_PointerTovd__GoodsDate(soap, 0, 0, "vd:GoodsDate");
	case SOAP_TYPE_PointerToent__ProductItem: return soap_in_PointerToent__ProductItem(soap, 0, 0, "ent:ProductItem");
	case SOAP_TYPE_PointerToent__SubProduct: return soap_in_PointerToent__SubProduct(soap, 0, 0, "ent:SubProduct");
	case SOAP_TYPE_PointerToent__Product: return soap_in_PointerToent__Product(soap, 0, 0, "ent:Product");
	case SOAP_TYPE_PointerToent__ProductType: return soap_in_PointerToent__ProductType(soap, 0, 0, "ent:ProductType");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationConditionGroup: return soap_in_PointerToPointerToent__RegionalizationConditionGroup(soap, 0, 0, "ent:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerToent__RegionalizationConditionGroup: return soap_in_PointerToent__RegionalizationConditionGroup(soap, 0, 0, "ent:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerToent__AnimalDisease: return soap_in_PointerToent__AnimalDisease(soap, 0, 0, "ent:AnimalDisease");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationCondition: return soap_in_PointerToPointerToent__RegionalizationCondition(soap, 0, 0, "ent:RegionalizationCondition");
	case SOAP_TYPE_PointerToent__RegionalizationCondition: return soap_in_PointerToent__RegionalizationCondition(soap, 0, 0, "ent:RegionalizationCondition");
	case SOAP_TYPE_PointerToent__BusinessMember: return soap_in_PointerToent__BusinessMember(soap, 0, 0, "ent:BusinessMember");
	case SOAP_TYPE_PointerTobase__Identifier: return soap_in_PointerTobase__Identifier(soap, 0, 0, "base:Identifier");
	case SOAP_TYPE_PointerToent__Address: return soap_in_PointerToent__Address(soap, 0, 0, "ent:Address");
	case SOAP_TYPE_PointerToent__Unit: return soap_in_PointerToent__Unit(soap, 0, 0, "ent:Unit");
	case SOAP_TYPE_PointerTobase__Decimal: return soap_in_PointerTobase__Decimal(soap, 0, 0, "base:Decimal");
	case SOAP_TYPE_PointerToent__Minute: return soap_in_PointerToent__Minute(soap, 0, 0, "ent:Minute");
	case SOAP_TYPE_PointerToent__Hour: return soap_in_PointerToent__Hour(soap, 0, 0, "ent:Hour");
	case SOAP_TYPE_PointerToent__Day: return soap_in_PointerToent__Day(soap, 0, 0, "ent:Day");
	case SOAP_TYPE_PointerToent__Month: return soap_in_PointerToent__Month(soap, 0, 0, "ent:Month");
	case SOAP_TYPE_PointerToent__Year: return soap_in_PointerToent__Year(soap, 0, 0, "ent:Year");
	case SOAP_TYPE_PointerToPointerToent__Package: return soap_in_PointerToPointerToent__Package(soap, 0, 0, "ent:Package");
	case SOAP_TYPE_PointerToent__Package: return soap_in_PointerToent__Package(soap, 0, 0, "ent:Package");
	case SOAP_TYPE_PointerToPointerToent__ProductMarks: return soap_in_PointerToPointerToent__ProductMarks(soap, 0, 0, "ent:ProductMarks");
	case SOAP_TYPE_PointerToent__ProductMarks: return soap_in_PointerToent__ProductMarks(soap, 0, 0, "ent:ProductMarks");
	case SOAP_TYPE_PointerToent__PackingType: return soap_in_PointerToent__PackingType(soap, 0, 0, "ent:PackingType");
	case SOAP_TYPE_PointerToent__BusinessEntity: return soap_in_PointerToent__BusinessEntity(soap, 0, 0, "ent:BusinessEntity");
	case SOAP_TYPE_PointerTobase__String255: return soap_in_PointerTobase__String255(soap, 0, 0, "base:String255");
	case SOAP_TYPE_PointerToPointerToent__Producer: return soap_in_PointerToPointerToent__Producer(soap, 0, 0, "ent:Producer");
	case SOAP_TYPE_PointerToent__Producer: return soap_in_PointerToent__Producer(soap, 0, 0, "ent:Producer");
	case SOAP_TYPE_PointerToent__EnterpriseRole: return soap_in_PointerToent__EnterpriseRole(soap, 0, 0, "ent:EnterpriseRole");
	case SOAP_TYPE_PointerToent__Enterprise: return soap_in_PointerToent__Enterprise(soap, 0, 0, "ent:Enterprise");
	case SOAP_TYPE_PointerTobase__NText: return soap_in_PointerTobase__NText(soap, 0, 0, "base:NText");
	case SOAP_TYPE_PointerToent__Street: return soap_in_PointerToent__Street(soap, 0, 0, "ent:Street");
	case SOAP_TYPE_PointerToent__Locality: return soap_in_PointerToent__Locality(soap, 0, 0, "ent:Locality");
	case SOAP_TYPE_PointerToent__District: return soap_in_PointerToent__District(soap, 0, 0, "ent:District");
	case SOAP_TYPE_PointerToent__Region: return soap_in_PointerToent__Region(soap, 0, 0, "ent:Region");
	case SOAP_TYPE_PointerToent__FederalDistrict: return soap_in_PointerToent__FederalDistrict(soap, 0, 0, "ent:FederalDistrict");
	case SOAP_TYPE_PointerToent__Country: return soap_in_PointerToent__Country(soap, 0, 0, "ent:Country");
	case SOAP_TYPE_PointerToPointerToapp__BusinessError: return soap_in_PointerToPointerToapp__BusinessError(soap, 0, 0, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__BusinessError: return soap_in_PointerToapp__BusinessError(soap, 0, 0, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__ContentEncoding: return soap_in_PointerToapp__ContentEncoding(soap, 0, 0, "app:ContentEncoding");
	case SOAP_TYPE_PointerToapp__BusinessErrorList: return soap_in_PointerToapp__BusinessErrorList(soap, 0, 0, "app:BusinessErrorList");
	case SOAP_TYPE_PointerToapp__ApplicationResultWrapper: return soap_in_PointerToapp__ApplicationResultWrapper(soap, 0, 0, "app:ApplicationResultWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationDataWrapper: return soap_in_PointerToapp__ApplicationDataWrapper(soap, 0, 0, "app:ApplicationDataWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationStatus: return soap_in_PointerToapp__ApplicationStatus(soap, 0, 0, "app:ApplicationStatus");
	case SOAP_TYPE_PointerToPointerTobase__Error: return soap_in_PointerToPointerTobase__Error(soap, 0, 0, "base:Error");
	case SOAP_TYPE_PointerTobase__Error: return soap_in_PointerTobase__Error(soap, 0, 0, "base:Error");
	case SOAP_TYPE_PointerTobool: return soap_in_PointerTobool(soap, 0, 0, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64: return soap_in_PointerToLONG64(soap, 0, 0, "xsd:long");
	case SOAP_TYPE_PointerToint: return soap_in_PointerToint(soap, 0, 0, "xsd:int");
	case SOAP_TYPE_PointerTotime: return soap_in_PointerTotime(soap, 0, 0, "xsd:dateTime");
	case SOAP_TYPE_PointerToapp__Application: return soap_in_PointerToapp__Application(soap, 0, 0, "app:Application");
	case SOAP_TYPE_vd__VetDocumentStatusChangeReason:
	{
		char ** s = soap_in_vd__VetDocumentStatusChangeReason(soap, 0, 0, "vd:VetDocumentStatusChangeReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__GRNType:
	{
		char ** s = soap_in_ent__GRNType(soap, 0, 0, "ent:GRNType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_vd__SNILSType:
	{
		char ** s = soap_in_vd__SNILSType(soap, 0, 0, "vd:SNILSType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_vd__StockEntryNumber:
	{
		char ** s = soap_in_vd__StockEntryNumber(soap, 0, 0, "vd:StockEntryNumber");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__OTPToken:
	{
		char ** s = soap_in_ent__OTPToken(soap, 0, 0, "ent:OTPToken");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__GTINType:
	{
		char ** s = soap_in_ent__GTINType(soap, 0, 0, "ent:GTINType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__GLNType:
	{
		char ** s = soap_in_ent__GLNType(soap, 0, 0, "ent:GLNType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__ENTModificationReason:
	{
		char ** s = soap_in_ent__ENTModificationReason(soap, 0, 0, "ent:ENTModificationReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__BEModificationReason:
	{
		char ** s = soap_in_ent__BEModificationReason(soap, 0, 0, "ent:BEModificationReason");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__EnterpriseType:
	{
		char ** s = soap_in_ent__EnterpriseType(soap, 0, 0, "ent:EnterpriseType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__Code3:
	{
		char ** s = soap_in_ent__Code3(soap, 0, 0, "ent:Code3");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ent__Code:
	{
		char ** s = soap_in_ent__Code(soap, 0, 0, "ent:Code");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_app__APIKey:
	{
		char ** s = soap_in_app__APIKey(soap, 0, 0, "app:APIKey");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__SequenceNumber:
	{
		char ** s = soap_in_base__SequenceNumber(soap, 0, 0, "base:SequenceNumber");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__Identifier:
	{
		char ** s = soap_in_base__Identifier(soap, 0, 0, "base:Identifier");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__VersionStatus:
	{
		char ** s = soap_in_base__VersionStatus(soap, 0, 0, "base:VersionStatus");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__Decimal:
	{
		char ** s = soap_in_base__Decimal(soap, 0, 0, "base:Decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__String32:
	{
		char ** s = soap_in_base__String32(soap, 0, 0, "base:String32");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__String255:
	{
		char ** s = soap_in_base__String255(soap, 0, 0, "base:String255");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__NText:
	{
		char ** s = soap_in_base__NText(soap, 0, 0, "base:NText");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__Text:
	{
		char ** s = soap_in_base__Text(soap, 0, 0, "base:Text");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_base__UUID:
	{
		char ** s = soap_in_base__UUID(soap, 0, 0, "base:UUID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{
		char ** s = soap_in_xsd__token(soap, 0, 0, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__positiveInteger:
	{
		char ** s = soap_in_xsd__positiveInteger(soap, 0, 0, "xsd:positiveInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{
		char ** s = soap_in_xsd__nonNegativeInteger(soap, 0, 0, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{
		char ** s = soap_in_xsd__integer(soap, 0, 0, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{
		char ** s = soap_in_xsd__decimal(soap, 0, 0, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{
		char ** s = soap_in_xsd__date(soap, 0, 0, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte: return soap_in_PointerTounsignedByte(soap, 0, 0, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__Name:
	{
		char ** s = soap_in_xsd__Name(soap, 0, 0, "xsd:Name");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{
		char ** s = soap_in_xsd__NCName(soap, 0, 0, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__IDREF:
	{
		char ** s = soap_in_xsd__IDREF(soap, 0, 0, "xsd:IDREF");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{
		char ** s = soap_in_xsd__ID(soap, 0, 0, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{
		char ** s = soap_in__QName(soap, 0, 0, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{
		char ** s = soap_in_string(soap, 0, 0, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if(!*t)
			t = soap->tag;
		if(!soap_match_tag(soap, t, "app:BinaryContent")) { *type = SOAP_TYPE_app__BinaryContent; return soap_in_app__BinaryContent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:WorkingArea")) { *type = SOAP_TYPE_vd__WorkingArea; return soap_in_vd__WorkingArea(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:UserAuthority")) { *type = SOAP_TYPE_vd__UserAuthority; return soap_in_vd__UserAuthority(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:WorkingAreaList")) { *type = SOAP_TYPE_vd__WorkingAreaList; return soap_in_vd__WorkingAreaList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:AuthorityList")) { *type = SOAP_TYPE_vd__AuthorityList; return soap_in_vd__AuthorityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:UserList")) { *type = SOAP_TYPE_vd__UserList; return soap_in_vd__UserList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:User")) { *type = SOAP_TYPE_vd__User; return soap_in_vd__User(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProcessingProcedure")) { *type = SOAP_TYPE_vd__ProcessingProcedure; return soap_in_vd__ProcessingProcedure(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:RouteSectionR13nRules")) { *type = SOAP_TYPE_vd__RouteSectionR13nRules; return soap_in_vd__RouteSectionR13nRules(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:RegionalizationClause")) { *type = SOAP_TYPE_vd__RegionalizationClause; return soap_in_vd__RegionalizationClause(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentStatusChange")) { *type = SOAP_TYPE_vd__VetDocumentStatusChange; return soap_in_vd__VetDocumentStatusChange(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntryEventList")) { *type = SOAP_TYPE_vd__StockEntryEventList; return soap_in_vd__StockEntryEventList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BatchOrigin")) { *type = SOAP_TYPE_vd__BatchOrigin; return soap_in_vd__BatchOrigin(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VeterinaryAuthentication")) { *type = SOAP_TYPE_vd__VeterinaryAuthentication; return soap_in_vd__VeterinaryAuthentication(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:QuarantineEvent")) { *type = SOAP_TYPE_vd__QuarantineEvent; return soap_in_vd__QuarantineEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:AnimalMedicationEvent")) { *type = SOAP_TYPE_vd__AnimalMedicationEvent; return soap_in_vd__AnimalMedicationEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:LaboratoryResearchEvent")) { *type = SOAP_TYPE_vd__LaboratoryResearchEvent; return soap_in_vd__LaboratoryResearchEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VeterinaryEvent")) { *type = SOAP_TYPE_vd__VeterinaryEvent; return soap_in_vd__VeterinaryEvent(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ReferencedDocument")) { *type = SOAP_TYPE_vd__ReferencedDocument; return soap_in_vd__ReferencedDocument(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:CertifiedConsignment")) { *type = SOAP_TYPE_vd__CertifiedConsignment; return soap_in_vd__CertifiedConsignment(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:CertifiedBatch")) { *type = SOAP_TYPE_vd__CertifiedBatch; return soap_in_vd__CertifiedBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ENTModificationOperation")) { *type = SOAP_TYPE_vd__ENTModificationOperation; return soap_in_vd__ENTModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BEActivityLocationsModificationOperation")) { *type = SOAP_TYPE_vd__BEActivityLocationsModificationOperation; return soap_in_vd__BEActivityLocationsModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BEModificationOperation")) { *type = SOAP_TYPE_vd__BEModificationOperation; return soap_in_vd__BEModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:PSLModificationOperation")) { *type = SOAP_TYPE_vd__PSLModificationOperation; return soap_in_vd__PSLModificationOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:MergeStockEntriesOperation")) { *type = SOAP_TYPE_vd__MergeStockEntriesOperation; return soap_in_vd__MergeStockEntriesOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProductionOperation")) { *type = SOAP_TYPE_vd__ProductionOperation; return soap_in_vd__ProductionOperation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ShipmentRoute")) { *type = SOAP_TYPE_vd__ShipmentRoute; return soap_in_vd__ShipmentRoute(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ShipmentRoutePoint")) { *type = SOAP_TYPE_vd__ShipmentRoutePoint; return soap_in_vd__ShipmentRoutePoint(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:TransportNumber")) { *type = SOAP_TYPE_vd__TransportNumber; return soap_in_vd__TransportNumber(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:TransportInfo")) { *type = SOAP_TYPE_vd__TransportInfo; return soap_in_vd__TransportInfo(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Waybill")) { *type = SOAP_TYPE_vd__Waybill; return soap_in_vd__Waybill(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Document")) { *type = SOAP_TYPE_vd__Document; return soap_in_vd__Document(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntrySearchPattern")) { *type = SOAP_TYPE_vd__StockEntrySearchPattern; return soap_in_vd__StockEntrySearchPattern(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockDiscrepancy")) { *type = SOAP_TYPE_vd__StockDiscrepancy; return soap_in_vd__StockDiscrepancy(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntryList")) { *type = SOAP_TYPE_vd__StockEntryList; return soap_in_vd__StockEntryList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntry")) { *type = SOAP_TYPE_vd__StockEntry; return soap_in_vd__StockEntry(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DiscrepancyReason")) { *type = SOAP_TYPE_vd__DiscrepancyReason; return soap_in_vd__DiscrepancyReason(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DiscrepancyReport")) { *type = SOAP_TYPE_vd__DiscrepancyReport; return soap_in_vd__DiscrepancyReport(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentList")) { *type = SOAP_TYPE_vd__VetDocumentList; return soap_in_vd__VetDocumentList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:GoodsDate")) { *type = SOAP_TYPE_vd__GoodsDate; return soap_in_vd__GoodsDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ConsignmentDocumentList")) { *type = SOAP_TYPE_vd__ConsignmentDocumentList; return soap_in_vd__ConsignmentDocumentList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryInspection")) { *type = SOAP_TYPE_vd__DeliveryInspection; return soap_in_vd__DeliveryInspection(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryFactList")) { *type = SOAP_TYPE_vd__DeliveryFactList; return soap_in_vd__DeliveryFactList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Delivery")) { *type = SOAP_TYPE_vd__Delivery; return soap_in_vd__Delivery(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProductiveBatch")) { *type = SOAP_TYPE_vd__ProductiveBatch; return soap_in_vd__ProductiveBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:RawBatch")) { *type = SOAP_TYPE_vd__RawBatch; return soap_in_vd__RawBatch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Consignment")) { *type = SOAP_TYPE_vd__Consignment; return soap_in_vd__Consignment(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:Batch")) { *type = SOAP_TYPE_vd__Batch; return soap_in_vd__Batch(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocument")) { *type = SOAP_TYPE_vd__VetDocument; return soap_in_vd__VetDocument(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ActivityLocationList")) { *type = SOAP_TYPE_ent__ActivityLocationList; return soap_in_ent__ActivityLocationList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ResearchMethodList")) { *type = SOAP_TYPE_ent__ResearchMethodList; return soap_in_ent__ResearchMethodList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:AnimalDiseaseList")) { *type = SOAP_TYPE_ent__AnimalDiseaseList; return soap_in_ent__AnimalDiseaseList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationShippingRuleList")) { *type = SOAP_TYPE_ent__RegionalizationShippingRuleList; return soap_in_ent__RegionalizationShippingRuleList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationRegionStatusList")) { *type = SOAP_TYPE_ent__RegionalizationRegionStatusList; return soap_in_ent__RegionalizationRegionStatusList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationConditionList")) { *type = SOAP_TYPE_ent__RegionalizationConditionList; return soap_in_ent__RegionalizationConditionList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Area")) { *type = SOAP_TYPE_ent__Area; return soap_in_ent__Area(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationRegionStatus")) { *type = SOAP_TYPE_ent__RegionalizationRegionStatus; return soap_in_ent__RegionalizationRegionStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationStatus")) { *type = SOAP_TYPE_ent__RegionalizationStatus; return soap_in_ent__RegionalizationStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationShippingRule")) { *type = SOAP_TYPE_ent__RegionalizationShippingRule; return soap_in_ent__RegionalizationShippingRule(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationRequirement")) { *type = SOAP_TYPE_ent__RegionalizationRequirement; return soap_in_ent__RegionalizationRequirement(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationConditionGroup")) { *type = SOAP_TYPE_ent__RegionalizationConditionGroup; return soap_in_ent__RegionalizationConditionGroup(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationCondition")) { *type = SOAP_TYPE_ent__RegionalizationCondition; return soap_in_ent__RegionalizationCondition(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:MedicinalDrug")) { *type = SOAP_TYPE_ent__MedicinalDrug; return soap_in_ent__MedicinalDrug(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ResearchMethod")) { *type = SOAP_TYPE_ent__ResearchMethod; return soap_in_ent__ResearchMethod(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:AnimalDisease")) { *type = SOAP_TYPE_ent__AnimalDisease; return soap_in_ent__AnimalDisease(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Indicator")) { *type = SOAP_TYPE_ent__Indicator; return soap_in_ent__Indicator(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Organization")) { *type = SOAP_TYPE_ent__Organization; return soap_in_ent__Organization(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseOfficialRegistration")) { *type = SOAP_TYPE_ent__EnterpriseOfficialRegistration; return soap_in_ent__EnterpriseOfficialRegistration(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Location")) { *type = SOAP_TYPE_ent__Location; return soap_in_ent__Location(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Packaging")) { *type = SOAP_TYPE_ent__Packaging; return soap_in_ent__Packaging(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductItemProducing")) { *type = SOAP_TYPE_ent__ProductItemProducing; return soap_in_ent__ProductItemProducing(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ComplexDate")) { *type = SOAP_TYPE_ent__ComplexDate; return soap_in_ent__ComplexDate(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:PackageList")) { *type = SOAP_TYPE_ent__PackageList; return soap_in_ent__PackageList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Package")) { *type = SOAP_TYPE_ent__Package; return soap_in_ent__Package(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductMarks")) { *type = SOAP_TYPE_ent__ProductMarks; return soap_in_ent__ProductMarks(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductItemList")) { *type = SOAP_TYPE_ent__ProductItemList; return soap_in_ent__ProductItemList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:SubProductList")) { *type = SOAP_TYPE_ent__SubProductList; return soap_in_ent__SubProductList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductList")) { *type = SOAP_TYPE_ent__ProductList; return soap_in_ent__ProductList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:SubProduct")) { *type = SOAP_TYPE_ent__SubProduct; return soap_in_ent__SubProduct(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Product")) { *type = SOAP_TYPE_ent__Product; return soap_in_ent__Product(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductItem")) { *type = SOAP_TYPE_ent__ProductItem; return soap_in_ent__ProductItem(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:BusinessEntityList")) { *type = SOAP_TYPE_ent__BusinessEntityList; return soap_in_ent__BusinessEntityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:IncorporationForm")) { *type = SOAP_TYPE_ent__IncorporationForm; return soap_in_ent__IncorporationForm(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:BusinessEntity")) { *type = SOAP_TYPE_ent__BusinessEntity; return soap_in_ent__BusinessEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:BusinessMember")) { *type = SOAP_TYPE_ent__BusinessMember; return soap_in_ent__BusinessMember(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseList")) { *type = SOAP_TYPE_ent__EnterpriseList; return soap_in_ent__EnterpriseList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseNumberList")) { *type = SOAP_TYPE_ent__EnterpriseNumberList; return soap_in_ent__EnterpriseNumberList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProducerList")) { *type = SOAP_TYPE_ent__ProducerList; return soap_in_ent__ProducerList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Producer")) { *type = SOAP_TYPE_ent__Producer; return soap_in_ent__Producer(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseActivity")) { *type = SOAP_TYPE_ent__EnterpriseActivity; return soap_in_ent__EnterpriseActivity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseActivityList")) { *type = SOAP_TYPE_ent__EnterpriseActivityList; return soap_in_ent__EnterpriseActivityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Enterprise")) { *type = SOAP_TYPE_ent__Enterprise; return soap_in_ent__Enterprise(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:StreetList")) { *type = SOAP_TYPE_ent__StreetList; return soap_in_ent__StreetList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:LocalityList")) { *type = SOAP_TYPE_ent__LocalityList; return soap_in_ent__LocalityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:DistrictList")) { *type = SOAP_TYPE_ent__DistrictList; return soap_in_ent__DistrictList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionList")) { *type = SOAP_TYPE_ent__RegionList; return soap_in_ent__RegionList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:CountryList")) { *type = SOAP_TYPE_ent__CountryList; return soap_in_ent__CountryList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Address")) { *type = SOAP_TYPE_ent__Address; return soap_in_ent__Address(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Street")) { *type = SOAP_TYPE_ent__Street; return soap_in_ent__Street(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Locality")) { *type = SOAP_TYPE_ent__Locality; return soap_in_ent__Locality(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:District")) { *type = SOAP_TYPE_ent__District; return soap_in_ent__District(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Region")) { *type = SOAP_TYPE_ent__Region; return soap_in_ent__Region(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:AddressObjectView")) { *type = SOAP_TYPE_ent__AddressObjectView; return soap_in_ent__AddressObjectView(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:FederalDistrict")) { *type = SOAP_TYPE_ent__FederalDistrict; return soap_in_ent__FederalDistrict(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Country")) { *type = SOAP_TYPE_ent__Country; return soap_in_ent__Country(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:UnitList")) { *type = SOAP_TYPE_ent__UnitList; return soap_in_ent__UnitList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:PurposeList")) { *type = SOAP_TYPE_ent__PurposeList; return soap_in_ent__PurposeList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:PackingType")) { *type = SOAP_TYPE_ent__PackingType; return soap_in_ent__PackingType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Unit")) { *type = SOAP_TYPE_ent__Unit; return soap_in_ent__Unit(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Purpose")) { *type = SOAP_TYPE_ent__Purpose; return soap_in_ent__Purpose(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetAppliedUserAuthorityListResponse")) { *type = SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse; return soap_in_merc__GetAppliedUserAuthorityListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetAppliedUserAuthorityListRequest")) { *type = SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest; return soap_in_merc__GetAppliedUserAuthorityListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UnbindBusinessEntityUserResponse")) { *type = SOAP_TYPE_merc__UnbindBusinessEntityUserResponse; return soap_in_merc__UnbindBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UnbindBusinessEntityUserRequest")) { *type = SOAP_TYPE_merc__UnbindBusinessEntityUserRequest; return soap_in_merc__UnbindBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateUserWorkingAreasResponse")) { *type = SOAP_TYPE_merc__UpdateUserWorkingAreasResponse; return soap_in_merc__UpdateUserWorkingAreasResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateUserWorkingAreasRequest")) { *type = SOAP_TYPE_merc__UpdateUserWorkingAreasRequest; return soap_in_merc__UpdateUserWorkingAreasRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateUserAuthoritiesResponse")) { *type = SOAP_TYPE_merc__UpdateUserAuthoritiesResponse; return soap_in_merc__UpdateUserAuthoritiesResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateUserAuthoritiesRequest")) { *type = SOAP_TYPE_merc__UpdateUserAuthoritiesRequest; return soap_in_merc__UpdateUserAuthoritiesRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetBusinessEntityUserResponse")) { *type = SOAP_TYPE_merc__GetBusinessEntityUserResponse; return soap_in_merc__GetBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetBusinessEntityUserRequest")) { *type = SOAP_TYPE_merc__GetBusinessEntityUserRequest; return soap_in_merc__GetBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetBusinessEntityUserListResponse")) { *type = SOAP_TYPE_merc__GetBusinessEntityUserListResponse; return soap_in_merc__GetBusinessEntityUserListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetBusinessEntityUserListRequest")) { *type = SOAP_TYPE_merc__GetBusinessEntityUserListRequest; return soap_in_merc__GetBusinessEntityUserListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:AddBusinessEntityUserResponse")) { *type = SOAP_TYPE_merc__AddBusinessEntityUserResponse; return soap_in_merc__AddBusinessEntityUserResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:AddBusinessEntityUserRequest")) { *type = SOAP_TYPE_merc__AddBusinessEntityUserRequest; return soap_in_merc__AddBusinessEntityUserRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:CheckShipmentRegionalizationResponse")) { *type = SOAP_TYPE_merc__CheckShipmentRegionalizationResponse; return soap_in_merc__CheckShipmentRegionalizationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:CheckShipmentRegionalizationRequest")) { *type = SOAP_TYPE_merc__CheckShipmentRegionalizationRequest; return soap_in_merc__CheckShipmentRegionalizationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateVeterinaryEventsResponse")) { *type = SOAP_TYPE_merc__UpdateVeterinaryEventsResponse; return soap_in_merc__UpdateVeterinaryEventsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateVeterinaryEventsRequest")) { *type = SOAP_TYPE_merc__UpdateVeterinaryEventsRequest; return soap_in_merc__UpdateVeterinaryEventsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateTransportMovementDetailsResponse")) { *type = SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse; return soap_in_merc__UpdateTransportMovementDetailsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:UpdateTransportMovementDetailsRequest")) { *type = SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest; return soap_in_merc__UpdateTransportMovementDetailsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryVersionListResponse")) { *type = SOAP_TYPE_merc__GetStockEntryVersionListResponse; return soap_in_merc__GetStockEntryVersionListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryVersionListRequest")) { *type = SOAP_TYPE_merc__GetStockEntryVersionListRequest; return soap_in_merc__GetStockEntryVersionListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryListResponse")) { *type = SOAP_TYPE_merc__GetStockEntryListResponse; return soap_in_merc__GetStockEntryListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryListRequest")) { *type = SOAP_TYPE_merc__GetStockEntryListRequest; return soap_in_merc__GetStockEntryListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryChangesListResponse")) { *type = SOAP_TYPE_merc__GetStockEntryChangesListResponse; return soap_in_merc__GetStockEntryChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryChangesListRequest")) { *type = SOAP_TYPE_merc__GetStockEntryChangesListRequest; return soap_in_merc__GetStockEntryChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryByUuidResponse")) { *type = SOAP_TYPE_merc__GetStockEntryByUuidResponse; return soap_in_merc__GetStockEntryByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryByUuidRequest")) { *type = SOAP_TYPE_merc__GetStockEntryByUuidRequest; return soap_in_merc__GetStockEntryByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryByGuidResponse")) { *type = SOAP_TYPE_merc__GetStockEntryByGuidResponse; return soap_in_merc__GetStockEntryByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetStockEntryByGuidRequest")) { *type = SOAP_TYPE_merc__GetStockEntryByGuidRequest; return soap_in_merc__GetStockEntryByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetVetDocumentChangesListResponse")) { *type = SOAP_TYPE_merc__GetVetDocumentChangesListResponse; return soap_in_merc__GetVetDocumentChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetVetDocumentChangesListRequest")) { *type = SOAP_TYPE_merc__GetVetDocumentChangesListRequest; return soap_in_merc__GetVetDocumentChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetVetDocumentListResponse")) { *type = SOAP_TYPE_merc__GetVetDocumentListResponse; return soap_in_merc__GetVetDocumentListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetVetDocumentListRequest")) { *type = SOAP_TYPE_merc__GetVetDocumentListRequest; return soap_in_merc__GetVetDocumentListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetVetDocumentByUuidResponse")) { *type = SOAP_TYPE_merc__GetVetDocumentByUuidResponse; return soap_in_merc__GetVetDocumentByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:GetVetDocumentByUuidRequest")) { *type = SOAP_TYPE_merc__GetVetDocumentByUuidRequest; return soap_in_merc__GetVetDocumentByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyProducerStockListResponse")) { *type = SOAP_TYPE_merc__ModifyProducerStockListResponse; return soap_in_merc__ModifyProducerStockListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyProducerStockListRequest")) { *type = SOAP_TYPE_merc__ModifyProducerStockListRequest; return soap_in_merc__ModifyProducerStockListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ResolveDiscrepancyResponse")) { *type = SOAP_TYPE_merc__ResolveDiscrepancyResponse; return soap_in_merc__ResolveDiscrepancyResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ResolveDiscrepancyRequest")) { *type = SOAP_TYPE_merc__ResolveDiscrepancyRequest; return soap_in_merc__ResolveDiscrepancyRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyActivityLocationsResponse")) { *type = SOAP_TYPE_merc__ModifyActivityLocationsResponse; return soap_in_merc__ModifyActivityLocationsResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyActivityLocationsRequest")) { *type = SOAP_TYPE_merc__ModifyActivityLocationsRequest; return soap_in_merc__ModifyActivityLocationsRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyEnterpriseResponse")) { *type = SOAP_TYPE_merc__ModifyEnterpriseResponse; return soap_in_merc__ModifyEnterpriseResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyEnterpriseRequest")) { *type = SOAP_TYPE_merc__ModifyEnterpriseRequest; return soap_in_merc__ModifyEnterpriseRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyBusinessEntityResponse")) { *type = SOAP_TYPE_merc__ModifyBusinessEntityResponse; return soap_in_merc__ModifyBusinessEntityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ModifyBusinessEntityRequest")) { *type = SOAP_TYPE_merc__ModifyBusinessEntityRequest; return soap_in_merc__ModifyBusinessEntityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:WithdrawVetDocumentResponse")) { *type = SOAP_TYPE_merc__WithdrawVetDocumentResponse; return soap_in_merc__WithdrawVetDocumentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:WithdrawVetDocumentRequest")) { *type = SOAP_TYPE_merc__WithdrawVetDocumentRequest; return soap_in_merc__WithdrawVetDocumentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:MergeStockEntriesResponse")) { *type = SOAP_TYPE_merc__MergeStockEntriesResponse; return soap_in_merc__MergeStockEntriesResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:MergeStockEntriesRequest")) { *type = SOAP_TYPE_merc__MergeStockEntriesRequest; return soap_in_merc__MergeStockEntriesRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:RegisterProductionOperationResponse")) { *type = SOAP_TYPE_merc__RegisterProductionOperationResponse; return soap_in_merc__RegisterProductionOperationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:RegisterProductionOperationRequest")) { *type = SOAP_TYPE_merc__RegisterProductionOperationRequest; return soap_in_merc__RegisterProductionOperationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:PrepareOutgoingConsignmentResponse")) { *type = SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse; return soap_in_merc__PrepareOutgoingConsignmentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:PrepareOutgoingConsignmentRequest")) { *type = SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest; return soap_in_merc__PrepareOutgoingConsignmentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ProcessIncomingConsignmentResponse")) { *type = SOAP_TYPE_merc__ProcessIncomingConsignmentResponse; return soap_in_merc__ProcessIncomingConsignmentResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:ProcessIncomingConsignmentRequest")) { *type = SOAP_TYPE_merc__ProcessIncomingConsignmentRequest; return soap_in_merc__ProcessIncomingConsignmentRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "merc:MercuryApplicationRequest")) { *type = SOAP_TYPE_merc__MercuryApplicationRequest; return soap_in_merc__MercuryApplicationRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:BusinessError")) { *type = SOAP_TYPE_app__BusinessError; return soap_in_app__BusinessError(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:BusinessErrorList")) { *type = SOAP_TYPE_app__BusinessErrorList; return soap_in_app__BusinessErrorList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationResultData")) { *type = SOAP_TYPE_app__ApplicationResultData; return soap_in_app__ApplicationResultData(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationData")) { *type = SOAP_TYPE_app__ApplicationData; return soap_in_app__ApplicationData(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationResultWrapper")) { *type = SOAP_TYPE_app__ApplicationResultWrapper; return soap_in_app__ApplicationResultWrapper(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationDataWrapper")) { *type = SOAP_TYPE_app__ApplicationDataWrapper; return soap_in_app__ApplicationDataWrapper(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:Application")) { *type = SOAP_TYPE_app__Application; return soap_in_app__Application(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:Error")) { *type = SOAP_TYPE_base__Error; return soap_in_base__Error(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:FaultInfo")) { *type = SOAP_TYPE_base__FaultInfo; return soap_in_base__FaultInfo(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:EntityList")) { *type = SOAP_TYPE_base__EntityList; return soap_in_base__EntityList(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:DateInterval")) { *type = SOAP_TYPE_base__DateInterval; return soap_in_base__DateInterval(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:ListOptions")) { *type = SOAP_TYPE_base__ListOptions; return soap_in_base__ListOptions(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:GenericVersioningEntity")) { *type = SOAP_TYPE_base__GenericVersioningEntity; return soap_in_base__GenericVersioningEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:GenericEntity")) { *type = SOAP_TYPE_base__GenericEntity; return soap_in_base__GenericEntity(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:base64Binary")) { *type = SOAP_TYPE_xsd__base64Binary; return soap_in_xsd__base64Binary(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:byte")) { *type = SOAP_TYPE_byte; return soap_in_byte(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Minute")) { *type = SOAP_TYPE_ent__Minute; return soap_in_ent__Minute(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Hour")) { *type = SOAP_TYPE_ent__Hour; return soap_in_ent__Hour(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Day")) { *type = SOAP_TYPE_ent__Day; return soap_in_ent__Day(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Month")) { *type = SOAP_TYPE_ent__Month; return soap_in_ent__Month(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:Year")) { *type = SOAP_TYPE_ent__Year; return soap_in_ent__Year(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:int")) { *type = SOAP_TYPE_int; return soap_in_int(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:long")) { *type = SOAP_TYPE_LONG64; return soap_in_LONG64(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:unsignedByte")) { *type = SOAP_TYPE_unsignedByte; return soap_in_unsignedByte(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:unsignedInt")) { *type = SOAP_TYPE_unsignedInt; return soap_in_unsignedInt(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:dateTime")) { *type = SOAP_TYPE_time; return soap_in_time(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "xsd:boolean")) { *type = SOAP_TYPE_bool; return soap_in_bool(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:AnimalSpentPeriod")) { *type = SOAP_TYPE_vd__AnimalSpentPeriod; return soap_in_vd__AnimalSpentPeriod(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentStatus")) { *type = SOAP_TYPE_vd__VetDocumentStatus; return soap_in_vd__VetDocumentStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentType")) { *type = SOAP_TYPE_vd__VetDocumentType; return soap_in_vd__VetDocumentType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentForm")) { *type = SOAP_TYPE_vd__VetDocumentForm; return soap_in_vd__VetDocumentForm(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryInspectionResult")) { *type = SOAP_TYPE_vd__DeliveryInspectionResult; return soap_in_vd__DeliveryInspectionResult(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:DeliveryDecision")) { *type = SOAP_TYPE_vd__DeliveryDecision; return soap_in_vd__DeliveryDecision(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductMarkingClass")) { *type = SOAP_TYPE_ent__ProductMarkingClass; return soap_in_ent__ProductMarkingClass(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:TransportationStorageType")) { *type = SOAP_TYPE_ent__TransportationStorageType; return soap_in_ent__TransportationStorageType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:DocumentNature")) { *type = SOAP_TYPE_ent__DocumentNature; return soap_in_ent__DocumentNature(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseRole")) { *type = SOAP_TYPE_ent__EnterpriseRole; return soap_in_ent__EnterpriseRole(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:ProcessingProcedureType")) { *type = SOAP_TYPE_vd__ProcessingProcedureType; return soap_in_vd__ProcessingProcedureType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VeterinaryEventType")) { *type = SOAP_TYPE_vd__VeterinaryEventType; return soap_in_vd__VeterinaryEventType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:StockEntryBlankFilter")) { *type = SOAP_TYPE_vd__StockEntryBlankFilter; return soap_in_vd__StockEntryBlankFilter(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:VaccinationType")) { *type = SOAP_TYPE_ent__VaccinationType; return soap_in_ent__VaccinationType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProsperityType")) { *type = SOAP_TYPE_ent__ProsperityType; return soap_in_ent__ProsperityType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:RegionalizationDecision")) { *type = SOAP_TYPE_ent__RegionalizationDecision; return soap_in_ent__RegionalizationDecision(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ResearchResult")) { *type = SOAP_TYPE_ent__ResearchResult; return soap_in_ent__ResearchResult(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:TransportType")) { *type = SOAP_TYPE_ent__TransportType; return soap_in_ent__TransportType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ReferenceType")) { *type = SOAP_TYPE_ent__ReferenceType; return soap_in_ent__ReferenceType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:DocumentType")) { *type = SOAP_TYPE_ent__DocumentType; return soap_in_ent__DocumentType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:ProductType")) { *type = SOAP_TYPE_ent__ProductType; return soap_in_ent__ProductType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:BusinessEntityType")) { *type = SOAP_TYPE_ent__BusinessEntityType; return soap_in_ent__BusinessEntityType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:EnterpriseGroup")) { *type = SOAP_TYPE_ent__EnterpriseGroup; return soap_in_ent__EnterpriseGroup(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:PackingCodeType")) { *type = SOAP_TYPE_ent__PackingCodeType; return soap_in_ent__PackingCodeType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ent:PackageLevelType")) { *type = SOAP_TYPE_ent__PackageLevelType; return soap_in_ent__PackageLevelType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ContentEncoding")) { *type = SOAP_TYPE_app__ContentEncoding; return soap_in_app__ContentEncoding(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "app:ApplicationStatus")) { *type = SOAP_TYPE_app__ApplicationStatus; return soap_in_app__ApplicationStatus(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "base:RegisterModificationType")) { *type = SOAP_TYPE_base__RegisterModificationType; return soap_in_base__RegisterModificationType(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:VetDocumentStatusChangeReason")) {
			*type = SOAP_TYPE_vd__VetDocumentStatusChangeReason;
			char ** s = soap_in_vd__VetDocumentStatusChangeReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:GRNType")) {
			*type = SOAP_TYPE_ent__GRNType;
			char ** s = soap_in_ent__GRNType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "vd:SNILSType")) {
			*type = SOAP_TYPE_vd__SNILSType;
			char ** s = soap_in_vd__SNILSType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "vd:StockEntryNumber")) {
			*type = SOAP_TYPE_vd__StockEntryNumber;
			char ** s = soap_in_vd__StockEntryNumber(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:OTPToken")) {
			*type = SOAP_TYPE_ent__OTPToken;
			char ** s = soap_in_ent__OTPToken(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:GTINType")) {
			*type = SOAP_TYPE_ent__GTINType;
			char ** s = soap_in_ent__GTINType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:GLNType")) {
			*type = SOAP_TYPE_ent__GLNType;
			char ** s = soap_in_ent__GLNType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:ENTModificationReason")) {
			*type = SOAP_TYPE_ent__ENTModificationReason;
			char ** s = soap_in_ent__ENTModificationReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:BEModificationReason")) {
			*type = SOAP_TYPE_ent__BEModificationReason;
			char ** s = soap_in_ent__BEModificationReason(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:EnterpriseType")) {
			*type = SOAP_TYPE_ent__EnterpriseType;
			char ** s = soap_in_ent__EnterpriseType(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:Code3")) {
			*type = SOAP_TYPE_ent__Code3;
			char ** s = soap_in_ent__Code3(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "ent:Code")) {
			*type = SOAP_TYPE_ent__Code;
			char ** s = soap_in_ent__Code(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "app:APIKey")) {
			*type = SOAP_TYPE_app__APIKey;
			char ** s = soap_in_app__APIKey(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:SequenceNumber")) {
			*type = SOAP_TYPE_base__SequenceNumber;
			char ** s = soap_in_base__SequenceNumber(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:Identifier")) {
			*type = SOAP_TYPE_base__Identifier;
			char ** s = soap_in_base__Identifier(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:VersionStatus")) {
			*type = SOAP_TYPE_base__VersionStatus;
			char ** s = soap_in_base__VersionStatus(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:Decimal")) {
			*type = SOAP_TYPE_base__Decimal;
			char ** s = soap_in_base__Decimal(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:String32")) {
			*type = SOAP_TYPE_base__String32;
			char ** s = soap_in_base__String32(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:String255")) {
			*type = SOAP_TYPE_base__String255;
			char ** s = soap_in_base__String255(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:NText")) {
			*type = SOAP_TYPE_base__NText;
			char ** s = soap_in_base__NText(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:Text")) {
			*type = SOAP_TYPE_base__Text;
			char ** s = soap_in_base__Text(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "base:UUID")) {
			*type = SOAP_TYPE_base__UUID;
			char ** s = soap_in_base__UUID(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:token")) {
			*type = SOAP_TYPE_xsd__token;
			char ** s = soap_in_xsd__token(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:positiveInteger")) {
			*type = SOAP_TYPE_xsd__positiveInteger;
			char ** s = soap_in_xsd__positiveInteger(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:nonNegativeInteger")) {
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			char ** s = soap_in_xsd__nonNegativeInteger(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:integer")) {
			*type = SOAP_TYPE_xsd__integer;
			char ** s = soap_in_xsd__integer(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:decimal")) {
			*type = SOAP_TYPE_xsd__decimal;
			char ** s = soap_in_xsd__decimal(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:date")) {
			*type = SOAP_TYPE_xsd__date;
			char ** s = soap_in_xsd__date(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:Name")) {
			*type = SOAP_TYPE_xsd__Name;
			char ** s = soap_in_xsd__Name(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:NCName")) {
			*type = SOAP_TYPE_xsd__NCName;
			char ** s = soap_in_xsd__NCName(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:IDREF")) {
			*type = SOAP_TYPE_xsd__IDREF;
			char ** s = soap_in_xsd__IDREF(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:ID")) {
			*type = SOAP_TYPE_xsd__ID;
			char ** s = soap_in_xsd__ID(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:QName")) {
			*type = SOAP_TYPE__QName;
			char ** s = soap_in__QName(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		if(!soap_match_tag(soap, t, "xsd:string")) {
			*type = SOAP_TYPE_string;
			char ** s = soap_in_string(soap, 0, 0, 0);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if(!soap_match_tag(soap, t, "ent:BusinessEntity-activityLocation")) { *type = SOAP_TYPE__ent__BusinessEntity_activityLocation; return soap_in__ent__BusinessEntity_activityLocation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "vd:BEActivityLocationsModificationOperation-activityLocation")) { *type = SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation; return soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodChangesListResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodChangesListResponse; return soap_in__ns8__getResearchMethodChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodChangesListRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodChangesListRequest; return soap_in__ns8__getResearchMethodChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodListResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodListResponse; return soap_in__ns8__getResearchMethodListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodListRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodListRequest; return soap_in__ns8__getResearchMethodListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByUuidResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodByUuidResponse; return soap_in__ns8__getResearchMethodByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByUuidRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodByUuidRequest; return soap_in__ns8__getResearchMethodByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByGuidResponse")) { *type = SOAP_TYPE__ns8__getResearchMethodByGuidResponse; return soap_in__ns8__getResearchMethodByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getResearchMethodByGuidRequest")) { *type = SOAP_TYPE__ns8__getResearchMethodByGuidRequest; return soap_in__ns8__getResearchMethodByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseChangesListResponse")) { *type = SOAP_TYPE__ns8__getDiseaseChangesListResponse; return soap_in__ns8__getDiseaseChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseChangesListRequest")) { *type = SOAP_TYPE__ns8__getDiseaseChangesListRequest; return soap_in__ns8__getDiseaseChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseListResponse")) { *type = SOAP_TYPE__ns8__getDiseaseListResponse; return soap_in__ns8__getDiseaseListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseListRequest")) { *type = SOAP_TYPE__ns8__getDiseaseListRequest; return soap_in__ns8__getDiseaseListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByUuidResponse")) { *type = SOAP_TYPE__ns8__getDiseaseByUuidResponse; return soap_in__ns8__getDiseaseByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByUuidRequest")) { *type = SOAP_TYPE__ns8__getDiseaseByUuidRequest; return soap_in__ns8__getDiseaseByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByGuidResponse")) { *type = SOAP_TYPE__ns8__getDiseaseByGuidResponse; return soap_in__ns8__getDiseaseByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDiseaseByGuidRequest")) { *type = SOAP_TYPE__ns8__getDiseaseByGuidRequest; return soap_in__ns8__getDiseaseByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nShippingRuleListResponse")) { *type = SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse; return soap_in__ns8__getActualR13nShippingRuleListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nShippingRuleListRequest")) { *type = SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest; return soap_in__ns8__getActualR13nShippingRuleListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nRegionStatusListResponse")) { *type = SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse; return soap_in__ns8__getActualR13nRegionStatusListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActualR13nRegionStatusListRequest")) { *type = SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest; return soap_in__ns8__getActualR13nRegionStatusListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getR13nConditionListResponse")) { *type = SOAP_TYPE__ns8__getR13nConditionListResponse; return soap_in__ns8__getR13nConditionListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getR13nConditionListRequest")) { *type = SOAP_TYPE__ns8__getR13nConditionListRequest; return soap_in__ns8__getR13nConditionListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActivityLocationListResponse")) { *type = SOAP_TYPE__ns8__getActivityLocationListResponse; return soap_in__ns8__getActivityLocationListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getActivityLocationListRequest")) { *type = SOAP_TYPE__ns8__getActivityLocationListRequest; return soap_in__ns8__getActivityLocationListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessMemberByGLNResponse")) { *type = SOAP_TYPE__ns8__getBusinessMemberByGLNResponse; return soap_in__ns8__getBusinessMemberByGLNResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessMemberByGLNRequest")) { *type = SOAP_TYPE__ns8__getBusinessMemberByGLNRequest; return soap_in__ns8__getBusinessMemberByGLNRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityChangesListResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityChangesListResponse; return soap_in__ns8__getBusinessEntityChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityChangesListRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityChangesListRequest; return soap_in__ns8__getBusinessEntityChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityListResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityListResponse; return soap_in__ns8__getBusinessEntityListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityListRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityListRequest; return soap_in__ns8__getBusinessEntityListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByUuidResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityByUuidResponse; return soap_in__ns8__getBusinessEntityByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByUuidRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityByUuidRequest; return soap_in__ns8__getBusinessEntityByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByGuidResponse")) { *type = SOAP_TYPE__ns8__getBusinessEntityByGuidResponse; return soap_in__ns8__getBusinessEntityByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getBusinessEntityByGuidRequest")) { *type = SOAP_TYPE__ns8__getBusinessEntityByGuidRequest; return soap_in__ns8__getBusinessEntityByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseChangesListResponse")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse; return soap_in__ns8__getRussianEnterpriseChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseChangesListRequest")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest; return soap_in__ns8__getRussianEnterpriseChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseChangesListResponse")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse; return soap_in__ns8__getForeignEnterpriseChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseChangesListRequest")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest; return soap_in__ns8__getForeignEnterpriseChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseListResponse")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseListResponse; return soap_in__ns8__getRussianEnterpriseListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRussianEnterpriseListRequest")) { *type = SOAP_TYPE__ns8__getRussianEnterpriseListRequest; return soap_in__ns8__getRussianEnterpriseListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseListResponse")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseListResponse; return soap_in__ns8__getForeignEnterpriseListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getForeignEnterpriseListRequest")) { *type = SOAP_TYPE__ns8__getForeignEnterpriseListRequest; return soap_in__ns8__getForeignEnterpriseListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByUuidResponse")) { *type = SOAP_TYPE__ns8__getEnterpriseByUuidResponse; return soap_in__ns8__getEnterpriseByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByUuidRequest")) { *type = SOAP_TYPE__ns8__getEnterpriseByUuidRequest; return soap_in__ns8__getEnterpriseByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByGuidResponse")) { *type = SOAP_TYPE__ns8__getEnterpriseByGuidResponse; return soap_in__ns8__getEnterpriseByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getEnterpriseByGuidRequest")) { *type = SOAP_TYPE__ns8__getEnterpriseByGuidRequest; return soap_in__ns8__getEnterpriseByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findStreetListByNameResponse")) { *type = SOAP_TYPE__ns8__findStreetListByNameResponse; return soap_in__ns8__findStreetListByNameResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findStreetListByNameRequest")) { *type = SOAP_TYPE__ns8__findStreetListByNameRequest; return soap_in__ns8__findStreetListByNameRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findLocalityListByNameResponse")) { *type = SOAP_TYPE__ns8__findLocalityListByNameResponse; return soap_in__ns8__findLocalityListByNameResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:findLocalityListByNameRequest")) { *type = SOAP_TYPE__ns8__findLocalityListByNameRequest; return soap_in__ns8__findLocalityListByNameRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getStreetListByLocalityResponse")) { *type = SOAP_TYPE__ns8__getStreetListByLocalityResponse; return soap_in__ns8__getStreetListByLocalityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getStreetListByLocalityRequest")) { *type = SOAP_TYPE__ns8__getStreetListByLocalityRequest; return soap_in__ns8__getStreetListByLocalityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByLocalityResponse")) { *type = SOAP_TYPE__ns8__getLocalityListByLocalityResponse; return soap_in__ns8__getLocalityListByLocalityResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByLocalityRequest")) { *type = SOAP_TYPE__ns8__getLocalityListByLocalityRequest; return soap_in__ns8__getLocalityListByLocalityRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByDistrictResponse")) { *type = SOAP_TYPE__ns8__getLocalityListByDistrictResponse; return soap_in__ns8__getLocalityListByDistrictResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByDistrictRequest")) { *type = SOAP_TYPE__ns8__getLocalityListByDistrictRequest; return soap_in__ns8__getLocalityListByDistrictRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByRegionResponse")) { *type = SOAP_TYPE__ns8__getLocalityListByRegionResponse; return soap_in__ns8__getLocalityListByRegionResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getLocalityListByRegionRequest")) { *type = SOAP_TYPE__ns8__getLocalityListByRegionRequest; return soap_in__ns8__getLocalityListByRegionRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictChangesListResponse")) { *type = SOAP_TYPE__ns8__getDistrictChangesListResponse; return soap_in__ns8__getDistrictChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictChangesListRequest")) { *type = SOAP_TYPE__ns8__getDistrictChangesListRequest; return soap_in__ns8__getDistrictChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByUuidResponse")) { *type = SOAP_TYPE__ns8__getDistrictByUuidResponse; return soap_in__ns8__getDistrictByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByUuidRequest")) { *type = SOAP_TYPE__ns8__getDistrictByUuidRequest; return soap_in__ns8__getDistrictByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByGuidResponse")) { *type = SOAP_TYPE__ns8__getDistrictByGuidResponse; return soap_in__ns8__getDistrictByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictByGuidRequest")) { *type = SOAP_TYPE__ns8__getDistrictByGuidRequest; return soap_in__ns8__getDistrictByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictListByRegionResponse")) { *type = SOAP_TYPE__ns8__getDistrictListByRegionResponse; return soap_in__ns8__getDistrictListByRegionResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getDistrictListByRegionRequest")) { *type = SOAP_TYPE__ns8__getDistrictListByRegionRequest; return soap_in__ns8__getDistrictListByRegionRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionChangesListResponse")) { *type = SOAP_TYPE__ns8__getRegionChangesListResponse; return soap_in__ns8__getRegionChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionChangesListRequest")) { *type = SOAP_TYPE__ns8__getRegionChangesListRequest; return soap_in__ns8__getRegionChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByUuidResponse")) { *type = SOAP_TYPE__ns8__getRegionByUuidResponse; return soap_in__ns8__getRegionByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByUuidRequest")) { *type = SOAP_TYPE__ns8__getRegionByUuidRequest; return soap_in__ns8__getRegionByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByGuidResponse")) { *type = SOAP_TYPE__ns8__getRegionByGuidResponse; return soap_in__ns8__getRegionByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionByGuidRequest")) { *type = SOAP_TYPE__ns8__getRegionByGuidRequest; return soap_in__ns8__getRegionByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionListByCountryResponse")) { *type = SOAP_TYPE__ns8__getRegionListByCountryResponse; return soap_in__ns8__getRegionListByCountryResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getRegionListByCountryRequest")) { *type = SOAP_TYPE__ns8__getRegionListByCountryRequest; return soap_in__ns8__getRegionListByCountryRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryChangesListResponse")) { *type = SOAP_TYPE__ns8__getCountryChangesListResponse; return soap_in__ns8__getCountryChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryChangesListRequest")) { *type = SOAP_TYPE__ns8__getCountryChangesListRequest; return soap_in__ns8__getCountryChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByUuidResponse")) { *type = SOAP_TYPE__ns8__getCountryByUuidResponse; return soap_in__ns8__getCountryByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByUuidRequest")) { *type = SOAP_TYPE__ns8__getCountryByUuidRequest; return soap_in__ns8__getCountryByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByGuidResponse")) { *type = SOAP_TYPE__ns8__getCountryByGuidResponse; return soap_in__ns8__getCountryByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getCountryByGuidRequest")) { *type = SOAP_TYPE__ns8__getCountryByGuidRequest; return soap_in__ns8__getCountryByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getAllCountryListResponse")) { *type = SOAP_TYPE__ns8__getAllCountryListResponse; return soap_in__ns8__getAllCountryListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getAllCountryListRequest")) { *type = SOAP_TYPE__ns8__getAllCountryListRequest; return soap_in__ns8__getAllCountryListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemChangesListResponse")) { *type = SOAP_TYPE__ns8__getProductItemChangesListResponse; return soap_in__ns8__getProductItemChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemChangesListRequest")) { *type = SOAP_TYPE__ns8__getProductItemChangesListRequest; return soap_in__ns8__getProductItemChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemListResponse")) { *type = SOAP_TYPE__ns8__getProductItemListResponse; return soap_in__ns8__getProductItemListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemListRequest")) { *type = SOAP_TYPE__ns8__getProductItemListRequest; return soap_in__ns8__getProductItemListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByUuidResponse")) { *type = SOAP_TYPE__ns8__getProductItemByUuidResponse; return soap_in__ns8__getProductItemByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByUuidRequest")) { *type = SOAP_TYPE__ns8__getProductItemByUuidRequest; return soap_in__ns8__getProductItemByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByGuidResponse")) { *type = SOAP_TYPE__ns8__getProductItemByGuidResponse; return soap_in__ns8__getProductItemByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductItemByGuidRequest")) { *type = SOAP_TYPE__ns8__getProductItemByGuidRequest; return soap_in__ns8__getProductItemByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductChangesListResponse")) { *type = SOAP_TYPE__ns8__getSubProductChangesListResponse; return soap_in__ns8__getSubProductChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductChangesListRequest")) { *type = SOAP_TYPE__ns8__getSubProductChangesListRequest; return soap_in__ns8__getSubProductChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByProductListResponse")) { *type = SOAP_TYPE__ns8__getSubProductByProductListResponse; return soap_in__ns8__getSubProductByProductListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByProductListRequest")) { *type = SOAP_TYPE__ns8__getSubProductByProductListRequest; return soap_in__ns8__getSubProductByProductListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByUuidResponse")) { *type = SOAP_TYPE__ns8__getSubProductByUuidResponse; return soap_in__ns8__getSubProductByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByUuidRequest")) { *type = SOAP_TYPE__ns8__getSubProductByUuidRequest; return soap_in__ns8__getSubProductByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByGuidResponse")) { *type = SOAP_TYPE__ns8__getSubProductByGuidResponse; return soap_in__ns8__getSubProductByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getSubProductByGuidRequest")) { *type = SOAP_TYPE__ns8__getSubProductByGuidRequest; return soap_in__ns8__getSubProductByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductChangesListResponse")) { *type = SOAP_TYPE__ns8__getProductChangesListResponse; return soap_in__ns8__getProductChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductChangesListRequest")) { *type = SOAP_TYPE__ns8__getProductChangesListRequest; return soap_in__ns8__getProductChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByTypeListResponse")) { *type = SOAP_TYPE__ns8__getProductByTypeListResponse; return soap_in__ns8__getProductByTypeListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByTypeListRequest")) { *type = SOAP_TYPE__ns8__getProductByTypeListRequest; return soap_in__ns8__getProductByTypeListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByUuidResponse")) { *type = SOAP_TYPE__ns8__getProductByUuidResponse; return soap_in__ns8__getProductByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByUuidRequest")) { *type = SOAP_TYPE__ns8__getProductByUuidRequest; return soap_in__ns8__getProductByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByGuidResponse")) { *type = SOAP_TYPE__ns8__getProductByGuidResponse; return soap_in__ns8__getProductByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getProductByGuidRequest")) { *type = SOAP_TYPE__ns8__getProductByGuidRequest; return soap_in__ns8__getProductByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitChangesListResponse")) { *type = SOAP_TYPE__ns8__getUnitChangesListResponse; return soap_in__ns8__getUnitChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitChangesListRequest")) { *type = SOAP_TYPE__ns8__getUnitChangesListRequest; return soap_in__ns8__getUnitChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitListResponse")) { *type = SOAP_TYPE__ns8__getUnitListResponse; return soap_in__ns8__getUnitListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitListRequest")) { *type = SOAP_TYPE__ns8__getUnitListRequest; return soap_in__ns8__getUnitListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByUuidResponse")) { *type = SOAP_TYPE__ns8__getUnitByUuidResponse; return soap_in__ns8__getUnitByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByUuidRequest")) { *type = SOAP_TYPE__ns8__getUnitByUuidRequest; return soap_in__ns8__getUnitByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByGuidResponse")) { *type = SOAP_TYPE__ns8__getUnitByGuidResponse; return soap_in__ns8__getUnitByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getUnitByGuidRequest")) { *type = SOAP_TYPE__ns8__getUnitByGuidRequest; return soap_in__ns8__getUnitByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeChangesListResponse")) { *type = SOAP_TYPE__ns8__getPurposeChangesListResponse; return soap_in__ns8__getPurposeChangesListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeChangesListRequest")) { *type = SOAP_TYPE__ns8__getPurposeChangesListRequest; return soap_in__ns8__getPurposeChangesListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeListResponse")) { *type = SOAP_TYPE__ns8__getPurposeListResponse; return soap_in__ns8__getPurposeListResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeListRequest")) { *type = SOAP_TYPE__ns8__getPurposeListRequest; return soap_in__ns8__getPurposeListRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByUuidResponse")) { *type = SOAP_TYPE__ns8__getPurposeByUuidResponse; return soap_in__ns8__getPurposeByUuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByUuidRequest")) { *type = SOAP_TYPE__ns8__getPurposeByUuidRequest; return soap_in__ns8__getPurposeByUuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByGuidResponse")) { *type = SOAP_TYPE__ns8__getPurposeByGuidResponse; return soap_in__ns8__getPurposeByGuidResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ns8:getPurposeByGuidRequest")) { *type = SOAP_TYPE__ns8__getPurposeByGuidRequest; return soap_in__ns8__getPurposeByGuidRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:receiveApplicationResultResponse")) { *type = SOAP_TYPE__ws__receiveApplicationResultResponse; return soap_in__ws__receiveApplicationResultResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:receiveApplicationResultRequest")) { *type = SOAP_TYPE__ws__receiveApplicationResultRequest; return soap_in__ws__receiveApplicationResultRequest(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:submitApplicationResponse")) { *type = SOAP_TYPE__ws__submitApplicationResponse; return soap_in__ws__submitApplicationResponse(soap, 0, 0, 0); }
		if(!soap_match_tag(soap, t, "ws:submitApplicationRequest")) { *type = SOAP_TYPE__ws__submitApplicationRequest; return soap_in__ws__submitApplicationRequest(soap, 0, 0, 0); }
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if(!soap_peek_element(soap)) {
		int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if(soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if(((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if(!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			soap->error = soap->fignore ? soap->fignore(soap, soap->tag) : SOAP_OK;
			DBGLOG(TEST, if(!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if(!soap->error && soap->body)
			{	soap->level++;
				while(!soap_ignore_element(soap))
					;
				if(soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int FASTCALL soap_putindependent(struct soap *soap)
{
	if(soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for(int i = 0; i < SOAP_PTRHASH; i++)
			for(struct soap_plist * pp = soap->pht[i]; pp; pp = pp->next)
				if(pp->mark1 == 2 || pp->mark2 == 2)
					if(soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	(void)tag;
	switch(type) {
	case SOAP_TYPE_byte: return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ent__Minute: return soap_out_ent__Minute(soap, tag, id, (const int *)ptr, "ent:Minute");
	case SOAP_TYPE_ent__Hour: return soap_out_ent__Hour(soap, tag, id, (const int *)ptr, "ent:Hour");
	case SOAP_TYPE_ent__Day: return soap_out_ent__Day(soap, tag, id, (const int *)ptr, "ent:Day");
	case SOAP_TYPE_ent__Month: return soap_out_ent__Month(soap, tag, id, (const int *)ptr, "ent:Month");
	case SOAP_TYPE_ent__Year: return soap_out_ent__Year(soap, tag, id, (const int *)ptr, "ent:Year");
	case SOAP_TYPE_int: return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64: return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte: return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt: return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time: return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool: return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_vd__AnimalSpentPeriod: return soap_out_vd__AnimalSpentPeriod(soap, tag, id, (const enum vd__AnimalSpentPeriod *)ptr, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_vd__VetDocumentStatus: return soap_out_vd__VetDocumentStatus(soap, tag, id, (const enum vd__VetDocumentStatus *)ptr, "vd:VetDocumentStatus");
	case SOAP_TYPE_vd__VetDocumentType: return soap_out_vd__VetDocumentType(soap, tag, id, (const enum vd__VetDocumentType *)ptr, "vd:VetDocumentType");
	case SOAP_TYPE_vd__VetDocumentForm: return soap_out_vd__VetDocumentForm(soap, tag, id, (const enum vd__VetDocumentForm *)ptr, "vd:VetDocumentForm");
	case SOAP_TYPE_vd__DeliveryInspectionResult: return soap_out_vd__DeliveryInspectionResult(soap, tag, id, (const enum vd__DeliveryInspectionResult *)ptr, "vd:DeliveryInspectionResult");
	case SOAP_TYPE_vd__DeliveryDecision: return soap_out_vd__DeliveryDecision(soap, tag, id, (const enum vd__DeliveryDecision *)ptr, "vd:DeliveryDecision");
	case SOAP_TYPE_ent__ProductMarkingClass: return soap_out_ent__ProductMarkingClass(soap, tag, id, (const enum ent__ProductMarkingClass *)ptr, "ent:ProductMarkingClass");
	case SOAP_TYPE_ent__TransportationStorageType: return soap_out_ent__TransportationStorageType(soap, tag, id, (const enum ent__TransportationStorageType *)ptr, "ent:TransportationStorageType");
	case SOAP_TYPE_ent__DocumentNature: return soap_out_ent__DocumentNature(soap, tag, id, (const enum ent__DocumentNature *)ptr, "ent:DocumentNature");
	case SOAP_TYPE_ent__EnterpriseRole: return soap_out_ent__EnterpriseRole(soap, tag, id, (const enum ent__EnterpriseRole *)ptr, "ent:EnterpriseRole");
	case SOAP_TYPE_vd__ProcessingProcedureType: return soap_out_vd__ProcessingProcedureType(soap, tag, id, (const enum vd__ProcessingProcedureType *)ptr, "vd:ProcessingProcedureType");
	case SOAP_TYPE_vd__VeterinaryEventType: return soap_out_vd__VeterinaryEventType(soap, tag, id, (const enum vd__VeterinaryEventType *)ptr, "vd:VeterinaryEventType");
	case SOAP_TYPE_vd__StockEntryBlankFilter: return soap_out_vd__StockEntryBlankFilter(soap, tag, id, (const enum vd__StockEntryBlankFilter *)ptr, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_ent__VaccinationType: return soap_out_ent__VaccinationType(soap, tag, id, (const enum ent__VaccinationType *)ptr, "ent:VaccinationType");
	case SOAP_TYPE_ent__ProsperityType: return soap_out_ent__ProsperityType(soap, tag, id, (const enum ent__ProsperityType *)ptr, "ent:ProsperityType");
	case SOAP_TYPE_ent__RegionalizationDecision: return soap_out_ent__RegionalizationDecision(soap, tag, id, (const enum ent__RegionalizationDecision *)ptr, "ent:RegionalizationDecision");
	case SOAP_TYPE_ent__ResearchResult: return soap_out_ent__ResearchResult(soap, tag, id, (const enum ent__ResearchResult *)ptr, "ent:ResearchResult");
	case SOAP_TYPE_ent__TransportType: return soap_out_ent__TransportType(soap, tag, id, (const enum ent__TransportType *)ptr, "ent:TransportType");
	case SOAP_TYPE_ent__ReferenceType: return soap_out_ent__ReferenceType(soap, tag, id, (const enum ent__ReferenceType *)ptr, "ent:ReferenceType");
	case SOAP_TYPE_ent__DocumentType: return soap_out_ent__DocumentType(soap, tag, id, (const enum ent__DocumentType *)ptr, "ent:DocumentType");
	case SOAP_TYPE_ent__ProductType: return soap_out_ent__ProductType(soap, tag, id, (const enum ent__ProductType *)ptr, "ent:ProductType");
	case SOAP_TYPE_ent__BusinessEntityType: return soap_out_ent__BusinessEntityType(soap, tag, id, (const enum ent__BusinessEntityType *)ptr, "ent:BusinessEntityType");
	case SOAP_TYPE_ent__EnterpriseGroup: return soap_out_ent__EnterpriseGroup(soap, tag, id, (const enum ent__EnterpriseGroup *)ptr, "ent:EnterpriseGroup");
	case SOAP_TYPE_ent__PackingCodeType: return soap_out_ent__PackingCodeType(soap, tag, id, (const enum ent__PackingCodeType *)ptr, "ent:PackingCodeType");
	case SOAP_TYPE_ent__PackageLevelType: return soap_out_ent__PackageLevelType(soap, tag, id, (const enum ent__PackageLevelType *)ptr, "ent:PackageLevelType");
	case SOAP_TYPE_app__ContentEncoding: return soap_out_app__ContentEncoding(soap, tag, id, (const enum app__ContentEncoding *)ptr, "app:ContentEncoding");
	case SOAP_TYPE_app__ApplicationStatus: return soap_out_app__ApplicationStatus(soap, tag, id, (const enum app__ApplicationStatus *)ptr, "app:ApplicationStatus");
	case SOAP_TYPE_base__RegisterModificationType: return soap_out_base__RegisterModificationType(soap, tag, id, (const enum base__RegisterModificationType *)ptr, "base:RegisterModificationType");
	case SOAP_TYPE__ent__BusinessEntity_activityLocation: return ((_ent__BusinessEntity_activityLocation *)ptr)->soap_out(soap, "ent:BusinessEntity-activityLocation", id, NULL);
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation: return ((_vd__BEActivityLocationsModificationOperation_activityLocation *)ptr)->soap_out(soap, "vd:BEActivityLocationsModificationOperation-activityLocation", id, NULL);
	case SOAP_TYPE_app__BinaryContent: return soap_out_app__BinaryContent(soap, tag, id, (const xsd__base64Binary *)ptr, "app:BinaryContent");
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse: return ((_ns8__getResearchMethodChangesListResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest: return ((_ns8__getResearchMethodChangesListRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodListResponse: return ((_ns8__getResearchMethodListResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodListResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodListRequest: return ((_ns8__getResearchMethodListRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodListRequest", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse: return ((_ns8__getResearchMethodByUuidResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest: return ((_ns8__getResearchMethodByUuidRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse: return ((_ns8__getResearchMethodByGuidResponse *)ptr)->soap_out(soap, "ns8:getResearchMethodByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest: return ((_ns8__getResearchMethodByGuidRequest *)ptr)->soap_out(soap, "ns8:getResearchMethodByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse: return ((_ns8__getDiseaseChangesListResponse *)ptr)->soap_out(soap, "ns8:getDiseaseChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest: return ((_ns8__getDiseaseChangesListRequest *)ptr)->soap_out(soap, "ns8:getDiseaseChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseListResponse: return ((_ns8__getDiseaseListResponse *)ptr)->soap_out(soap, "ns8:getDiseaseListResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseListRequest: return ((_ns8__getDiseaseListRequest *)ptr)->soap_out(soap, "ns8:getDiseaseListRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse: return ((_ns8__getDiseaseByUuidResponse *)ptr)->soap_out(soap, "ns8:getDiseaseByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest: return ((_ns8__getDiseaseByUuidRequest *)ptr)->soap_out(soap, "ns8:getDiseaseByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse: return ((_ns8__getDiseaseByGuidResponse *)ptr)->soap_out(soap, "ns8:getDiseaseByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest: return ((_ns8__getDiseaseByGuidRequest *)ptr)->soap_out(soap, "ns8:getDiseaseByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse: return ((_ns8__getActualR13nShippingRuleListResponse *)ptr)->soap_out(soap, "ns8:getActualR13nShippingRuleListResponse", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest: return ((_ns8__getActualR13nShippingRuleListRequest *)ptr)->soap_out(soap, "ns8:getActualR13nShippingRuleListRequest", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse: return ((_ns8__getActualR13nRegionStatusListResponse *)ptr)->soap_out(soap, "ns8:getActualR13nRegionStatusListResponse", id, NULL);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest: return ((_ns8__getActualR13nRegionStatusListRequest *)ptr)->soap_out(soap, "ns8:getActualR13nRegionStatusListRequest", id, NULL);
	case SOAP_TYPE__ns8__getR13nConditionListResponse: return ((_ns8__getR13nConditionListResponse *)ptr)->soap_out(soap, "ns8:getR13nConditionListResponse", id, NULL);
	case SOAP_TYPE__ns8__getR13nConditionListRequest: return ((_ns8__getR13nConditionListRequest *)ptr)->soap_out(soap, "ns8:getR13nConditionListRequest", id, NULL);
	case SOAP_TYPE__ns8__getActivityLocationListResponse: return ((_ns8__getActivityLocationListResponse *)ptr)->soap_out(soap, "ns8:getActivityLocationListResponse", id, NULL);
	case SOAP_TYPE__ns8__getActivityLocationListRequest: return ((_ns8__getActivityLocationListRequest *)ptr)->soap_out(soap, "ns8:getActivityLocationListRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse: return ((_ns8__getBusinessMemberByGLNResponse *)ptr)->soap_out(soap, "ns8:getBusinessMemberByGLNResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest: return ((_ns8__getBusinessMemberByGLNRequest *)ptr)->soap_out(soap, "ns8:getBusinessMemberByGLNRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse: return ((_ns8__getBusinessEntityChangesListResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest: return ((_ns8__getBusinessEntityChangesListRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityListResponse: return ((_ns8__getBusinessEntityListResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityListResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityListRequest: return ((_ns8__getBusinessEntityListRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityListRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse: return ((_ns8__getBusinessEntityByUuidResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest: return ((_ns8__getBusinessEntityByUuidRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse: return ((_ns8__getBusinessEntityByGuidResponse *)ptr)->soap_out(soap, "ns8:getBusinessEntityByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest: return ((_ns8__getBusinessEntityByGuidRequest *)ptr)->soap_out(soap, "ns8:getBusinessEntityByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse: return ((_ns8__getRussianEnterpriseChangesListResponse *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest: return ((_ns8__getRussianEnterpriseChangesListRequest *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse: return ((_ns8__getForeignEnterpriseChangesListResponse *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest: return ((_ns8__getForeignEnterpriseChangesListRequest *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse: return ((_ns8__getRussianEnterpriseListResponse *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseListResponse", id, NULL);
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest: return ((_ns8__getRussianEnterpriseListRequest *)ptr)->soap_out(soap, "ns8:getRussianEnterpriseListRequest", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse: return ((_ns8__getForeignEnterpriseListResponse *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseListResponse", id, NULL);
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest: return ((_ns8__getForeignEnterpriseListRequest *)ptr)->soap_out(soap, "ns8:getForeignEnterpriseListRequest", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse: return ((_ns8__getEnterpriseByUuidResponse *)ptr)->soap_out(soap, "ns8:getEnterpriseByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest: return ((_ns8__getEnterpriseByUuidRequest *)ptr)->soap_out(soap, "ns8:getEnterpriseByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse: return ((_ns8__getEnterpriseByGuidResponse *)ptr)->soap_out(soap, "ns8:getEnterpriseByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest: return ((_ns8__getEnterpriseByGuidRequest *)ptr)->soap_out(soap, "ns8:getEnterpriseByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__findStreetListByNameResponse: return ((_ns8__findStreetListByNameResponse *)ptr)->soap_out(soap, "ns8:findStreetListByNameResponse", id, NULL);
	case SOAP_TYPE__ns8__findStreetListByNameRequest: return ((_ns8__findStreetListByNameRequest *)ptr)->soap_out(soap, "ns8:findStreetListByNameRequest", id, NULL);
	case SOAP_TYPE__ns8__findLocalityListByNameResponse: return ((_ns8__findLocalityListByNameResponse *)ptr)->soap_out(soap, "ns8:findLocalityListByNameResponse", id, NULL);
	case SOAP_TYPE__ns8__findLocalityListByNameRequest: return ((_ns8__findLocalityListByNameRequest *)ptr)->soap_out(soap, "ns8:findLocalityListByNameRequest", id, NULL);
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse: return ((_ns8__getStreetListByLocalityResponse *)ptr)->soap_out(soap, "ns8:getStreetListByLocalityResponse", id, NULL);
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest: return ((_ns8__getStreetListByLocalityRequest *)ptr)->soap_out(soap, "ns8:getStreetListByLocalityRequest", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse: return ((_ns8__getLocalityListByLocalityResponse *)ptr)->soap_out(soap, "ns8:getLocalityListByLocalityResponse", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest: return ((_ns8__getLocalityListByLocalityRequest *)ptr)->soap_out(soap, "ns8:getLocalityListByLocalityRequest", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse: return ((_ns8__getLocalityListByDistrictResponse *)ptr)->soap_out(soap, "ns8:getLocalityListByDistrictResponse", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest: return ((_ns8__getLocalityListByDistrictRequest *)ptr)->soap_out(soap, "ns8:getLocalityListByDistrictRequest", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse: return ((_ns8__getLocalityListByRegionResponse *)ptr)->soap_out(soap, "ns8:getLocalityListByRegionResponse", id, NULL);
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest: return ((_ns8__getLocalityListByRegionRequest *)ptr)->soap_out(soap, "ns8:getLocalityListByRegionRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictChangesListResponse: return ((_ns8__getDistrictChangesListResponse *)ptr)->soap_out(soap, "ns8:getDistrictChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictChangesListRequest: return ((_ns8__getDistrictChangesListRequest *)ptr)->soap_out(soap, "ns8:getDistrictChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByUuidResponse: return ((_ns8__getDistrictByUuidResponse *)ptr)->soap_out(soap, "ns8:getDistrictByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByUuidRequest: return ((_ns8__getDistrictByUuidRequest *)ptr)->soap_out(soap, "ns8:getDistrictByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByGuidResponse: return ((_ns8__getDistrictByGuidResponse *)ptr)->soap_out(soap, "ns8:getDistrictByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictByGuidRequest: return ((_ns8__getDistrictByGuidRequest *)ptr)->soap_out(soap, "ns8:getDistrictByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse: return ((_ns8__getDistrictListByRegionResponse *)ptr)->soap_out(soap, "ns8:getDistrictListByRegionResponse", id, NULL);
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest: return ((_ns8__getDistrictListByRegionRequest *)ptr)->soap_out(soap, "ns8:getDistrictListByRegionRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionChangesListResponse: return ((_ns8__getRegionChangesListResponse *)ptr)->soap_out(soap, "ns8:getRegionChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionChangesListRequest: return ((_ns8__getRegionChangesListRequest *)ptr)->soap_out(soap, "ns8:getRegionChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionByUuidResponse: return ((_ns8__getRegionByUuidResponse *)ptr)->soap_out(soap, "ns8:getRegionByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionByUuidRequest: return ((_ns8__getRegionByUuidRequest *)ptr)->soap_out(soap, "ns8:getRegionByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionByGuidResponse: return ((_ns8__getRegionByGuidResponse *)ptr)->soap_out(soap, "ns8:getRegionByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionByGuidRequest: return ((_ns8__getRegionByGuidRequest *)ptr)->soap_out(soap, "ns8:getRegionByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getRegionListByCountryResponse: return ((_ns8__getRegionListByCountryResponse *)ptr)->soap_out(soap, "ns8:getRegionListByCountryResponse", id, NULL);
	case SOAP_TYPE__ns8__getRegionListByCountryRequest: return ((_ns8__getRegionListByCountryRequest *)ptr)->soap_out(soap, "ns8:getRegionListByCountryRequest", id, NULL);
	case SOAP_TYPE__ns8__getCountryChangesListResponse: return ((_ns8__getCountryChangesListResponse *)ptr)->soap_out(soap, "ns8:getCountryChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getCountryChangesListRequest: return ((_ns8__getCountryChangesListRequest *)ptr)->soap_out(soap, "ns8:getCountryChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getCountryByUuidResponse: return ((_ns8__getCountryByUuidResponse *)ptr)->soap_out(soap, "ns8:getCountryByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getCountryByUuidRequest: return ((_ns8__getCountryByUuidRequest *)ptr)->soap_out(soap, "ns8:getCountryByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getCountryByGuidResponse: return ((_ns8__getCountryByGuidResponse *)ptr)->soap_out(soap, "ns8:getCountryByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getCountryByGuidRequest: return ((_ns8__getCountryByGuidRequest *)ptr)->soap_out(soap, "ns8:getCountryByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getAllCountryListResponse: return ((_ns8__getAllCountryListResponse *)ptr)->soap_out(soap, "ns8:getAllCountryListResponse", id, NULL);
	case SOAP_TYPE__ns8__getAllCountryListRequest: return ((_ns8__getAllCountryListRequest *)ptr)->soap_out(soap, "ns8:getAllCountryListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemChangesListResponse: return ((_ns8__getProductItemChangesListResponse *)ptr)->soap_out(soap, "ns8:getProductItemChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemChangesListRequest: return ((_ns8__getProductItemChangesListRequest *)ptr)->soap_out(soap, "ns8:getProductItemChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemListResponse: return ((_ns8__getProductItemListResponse *)ptr)->soap_out(soap, "ns8:getProductItemListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemListRequest: return ((_ns8__getProductItemListRequest *)ptr)->soap_out(soap, "ns8:getProductItemListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByUuidResponse: return ((_ns8__getProductItemByUuidResponse *)ptr)->soap_out(soap, "ns8:getProductItemByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByUuidRequest: return ((_ns8__getProductItemByUuidRequest *)ptr)->soap_out(soap, "ns8:getProductItemByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByGuidResponse: return ((_ns8__getProductItemByGuidResponse *)ptr)->soap_out(soap, "ns8:getProductItemByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductItemByGuidRequest: return ((_ns8__getProductItemByGuidRequest *)ptr)->soap_out(soap, "ns8:getProductItemByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductChangesListResponse: return ((_ns8__getSubProductChangesListResponse *)ptr)->soap_out(soap, "ns8:getSubProductChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductChangesListRequest: return ((_ns8__getSubProductChangesListRequest *)ptr)->soap_out(soap, "ns8:getSubProductChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByProductListResponse: return ((_ns8__getSubProductByProductListResponse *)ptr)->soap_out(soap, "ns8:getSubProductByProductListResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByProductListRequest: return ((_ns8__getSubProductByProductListRequest *)ptr)->soap_out(soap, "ns8:getSubProductByProductListRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByUuidResponse: return ((_ns8__getSubProductByUuidResponse *)ptr)->soap_out(soap, "ns8:getSubProductByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByUuidRequest: return ((_ns8__getSubProductByUuidRequest *)ptr)->soap_out(soap, "ns8:getSubProductByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByGuidResponse: return ((_ns8__getSubProductByGuidResponse *)ptr)->soap_out(soap, "ns8:getSubProductByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getSubProductByGuidRequest: return ((_ns8__getSubProductByGuidRequest *)ptr)->soap_out(soap, "ns8:getSubProductByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductChangesListResponse: return ((_ns8__getProductChangesListResponse *)ptr)->soap_out(soap, "ns8:getProductChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductChangesListRequest: return ((_ns8__getProductChangesListRequest *)ptr)->soap_out(soap, "ns8:getProductChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductByTypeListResponse: return ((_ns8__getProductByTypeListResponse *)ptr)->soap_out(soap, "ns8:getProductByTypeListResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductByTypeListRequest: return ((_ns8__getProductByTypeListRequest *)ptr)->soap_out(soap, "ns8:getProductByTypeListRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductByUuidResponse: return ((_ns8__getProductByUuidResponse *)ptr)->soap_out(soap, "ns8:getProductByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductByUuidRequest: return ((_ns8__getProductByUuidRequest *)ptr)->soap_out(soap, "ns8:getProductByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getProductByGuidResponse: return ((_ns8__getProductByGuidResponse *)ptr)->soap_out(soap, "ns8:getProductByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getProductByGuidRequest: return ((_ns8__getProductByGuidRequest *)ptr)->soap_out(soap, "ns8:getProductByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitChangesListResponse: return ((_ns8__getUnitChangesListResponse *)ptr)->soap_out(soap, "ns8:getUnitChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitChangesListRequest: return ((_ns8__getUnitChangesListRequest *)ptr)->soap_out(soap, "ns8:getUnitChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitListResponse: return ((_ns8__getUnitListResponse *)ptr)->soap_out(soap, "ns8:getUnitListResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitListRequest: return ((_ns8__getUnitListRequest *)ptr)->soap_out(soap, "ns8:getUnitListRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitByUuidResponse: return ((_ns8__getUnitByUuidResponse *)ptr)->soap_out(soap, "ns8:getUnitByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitByUuidRequest: return ((_ns8__getUnitByUuidRequest *)ptr)->soap_out(soap, "ns8:getUnitByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getUnitByGuidResponse: return ((_ns8__getUnitByGuidResponse *)ptr)->soap_out(soap, "ns8:getUnitByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getUnitByGuidRequest: return ((_ns8__getUnitByGuidRequest *)ptr)->soap_out(soap, "ns8:getUnitByGuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeChangesListResponse: return ((_ns8__getPurposeChangesListResponse *)ptr)->soap_out(soap, "ns8:getPurposeChangesListResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeChangesListRequest: return ((_ns8__getPurposeChangesListRequest *)ptr)->soap_out(soap, "ns8:getPurposeChangesListRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeListResponse: return ((_ns8__getPurposeListResponse *)ptr)->soap_out(soap, "ns8:getPurposeListResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeListRequest: return ((_ns8__getPurposeListRequest *)ptr)->soap_out(soap, "ns8:getPurposeListRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByUuidResponse: return ((_ns8__getPurposeByUuidResponse *)ptr)->soap_out(soap, "ns8:getPurposeByUuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByUuidRequest: return ((_ns8__getPurposeByUuidRequest *)ptr)->soap_out(soap, "ns8:getPurposeByUuidRequest", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByGuidResponse: return ((_ns8__getPurposeByGuidResponse *)ptr)->soap_out(soap, "ns8:getPurposeByGuidResponse", id, NULL);
	case SOAP_TYPE__ns8__getPurposeByGuidRequest: return ((_ns8__getPurposeByGuidRequest *)ptr)->soap_out(soap, "ns8:getPurposeByGuidRequest", id, NULL);
	case SOAP_TYPE_vd__WorkingArea: return ((vd__WorkingArea *)ptr)->soap_out(soap, tag, id, "vd:WorkingArea");
	case SOAP_TYPE_vd__UserAuthority: return ((vd__UserAuthority *)ptr)->soap_out(soap, tag, id, "vd:UserAuthority");
	case SOAP_TYPE_vd__WorkingAreaList: return ((vd__WorkingAreaList *)ptr)->soap_out(soap, tag, id, "vd:WorkingAreaList");
	case SOAP_TYPE_vd__AuthorityList: return ((vd__AuthorityList *)ptr)->soap_out(soap, tag, id, "vd:AuthorityList");
	case SOAP_TYPE_vd__UserList: return ((vd__UserList *)ptr)->soap_out(soap, tag, id, "vd:UserList");
	case SOAP_TYPE_vd__User: return ((vd__User *)ptr)->soap_out(soap, tag, id, "vd:User");
	case SOAP_TYPE_vd__ProcessingProcedure: return ((vd__ProcessingProcedure *)ptr)->soap_out(soap, tag, id, "vd:ProcessingProcedure");
	case SOAP_TYPE_vd__RouteSectionR13nRules: return ((vd__RouteSectionR13nRules *)ptr)->soap_out(soap, tag, id, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_vd__RegionalizationClause: return ((vd__RegionalizationClause *)ptr)->soap_out(soap, tag, id, "vd:RegionalizationClause");
	case SOAP_TYPE_vd__VetDocumentStatusChange: return ((vd__VetDocumentStatusChange *)ptr)->soap_out(soap, tag, id, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_vd__StockEntryEventList: return ((vd__StockEntryEventList *)ptr)->soap_out(soap, tag, id, "vd:StockEntryEventList");
	case SOAP_TYPE_vd__BatchOrigin: return ((vd__BatchOrigin *)ptr)->soap_out(soap, tag, id, "vd:BatchOrigin");
	case SOAP_TYPE_vd__VeterinaryAuthentication: return ((vd__VeterinaryAuthentication *)ptr)->soap_out(soap, tag, id, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_vd__QuarantineEvent: return ((vd__QuarantineEvent *)ptr)->soap_out(soap, tag, id, "vd:QuarantineEvent");
	case SOAP_TYPE_vd__AnimalMedicationEvent: return ((vd__AnimalMedicationEvent *)ptr)->soap_out(soap, tag, id, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_vd__LaboratoryResearchEvent: return ((vd__LaboratoryResearchEvent *)ptr)->soap_out(soap, tag, id, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_vd__VeterinaryEvent: return ((vd__VeterinaryEvent *)ptr)->soap_out(soap, tag, id, "vd:VeterinaryEvent");
	case SOAP_TYPE_vd__ReferencedDocument: return ((vd__ReferencedDocument *)ptr)->soap_out(soap, tag, id, "vd:ReferencedDocument");
	case SOAP_TYPE_vd__CertifiedConsignment: return ((vd__CertifiedConsignment *)ptr)->soap_out(soap, tag, id, "vd:CertifiedConsignment");
	case SOAP_TYPE_vd__CertifiedBatch: return ((vd__CertifiedBatch *)ptr)->soap_out(soap, tag, id, "vd:CertifiedBatch");
	case SOAP_TYPE_vd__ENTModificationOperation: return ((vd__ENTModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:ENTModificationOperation");
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: return ((vd__BEActivityLocationsModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_vd__BEModificationOperation: return ((vd__BEModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:BEModificationOperation");
	case SOAP_TYPE_vd__PSLModificationOperation: return ((vd__PSLModificationOperation *)ptr)->soap_out(soap, tag, id, "vd:PSLModificationOperation");
	case SOAP_TYPE_vd__MergeStockEntriesOperation: return ((vd__MergeStockEntriesOperation *)ptr)->soap_out(soap, tag, id, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_vd__ProductionOperation: return ((vd__ProductionOperation *)ptr)->soap_out(soap, tag, id, "vd:ProductionOperation");
	case SOAP_TYPE_vd__ShipmentRoute: return ((vd__ShipmentRoute *)ptr)->soap_out(soap, tag, id, "vd:ShipmentRoute");
	case SOAP_TYPE_vd__ShipmentRoutePoint: return ((vd__ShipmentRoutePoint *)ptr)->soap_out(soap, tag, id, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_vd__TransportNumber: return ((vd__TransportNumber *)ptr)->soap_out(soap, tag, id, "vd:TransportNumber");
	case SOAP_TYPE_vd__TransportInfo: return ((vd__TransportInfo *)ptr)->soap_out(soap, tag, id, "vd:TransportInfo");
	case SOAP_TYPE_vd__Waybill: return ((vd__Waybill *)ptr)->soap_out(soap, tag, id, "vd:Waybill");
	case SOAP_TYPE_vd__Document: return ((vd__Document *)ptr)->soap_out(soap, tag, id, "vd:Document");
	case SOAP_TYPE_vd__StockEntrySearchPattern: return ((vd__StockEntrySearchPattern *)ptr)->soap_out(soap, tag, id, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_vd__StockDiscrepancy: return ((vd__StockDiscrepancy *)ptr)->soap_out(soap, tag, id, "vd:StockDiscrepancy");
	case SOAP_TYPE_vd__StockEntryList: return ((vd__StockEntryList *)ptr)->soap_out(soap, tag, id, "vd:StockEntryList");
	case SOAP_TYPE_vd__StockEntry: return ((vd__StockEntry *)ptr)->soap_out(soap, tag, id, "vd:StockEntry");
	case SOAP_TYPE_vd__DiscrepancyReason: return ((vd__DiscrepancyReason *)ptr)->soap_out(soap, tag, id, "vd:DiscrepancyReason");
	case SOAP_TYPE_vd__DiscrepancyReport: return ((vd__DiscrepancyReport *)ptr)->soap_out(soap, tag, id, "vd:DiscrepancyReport");
	case SOAP_TYPE_vd__VetDocumentList: return ((vd__VetDocumentList *)ptr)->soap_out(soap, tag, id, "vd:VetDocumentList");
	case SOAP_TYPE_vd__GoodsDate: return ((vd__GoodsDate *)ptr)->soap_out(soap, tag, id, "vd:GoodsDate");
	case SOAP_TYPE_vd__ConsignmentDocumentList: return ((vd__ConsignmentDocumentList *)ptr)->soap_out(soap, tag, id, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_vd__DeliveryInspection: return ((vd__DeliveryInspection *)ptr)->soap_out(soap, tag, id, "vd:DeliveryInspection");
	case SOAP_TYPE_vd__DeliveryFactList: return ((vd__DeliveryFactList *)ptr)->soap_out(soap, tag, id, "vd:DeliveryFactList");
	case SOAP_TYPE_vd__Delivery: return ((vd__Delivery *)ptr)->soap_out(soap, tag, id, "vd:Delivery");
	case SOAP_TYPE_vd__ProductiveBatch: return ((vd__ProductiveBatch *)ptr)->soap_out(soap, tag, id, "vd:ProductiveBatch");
	case SOAP_TYPE_vd__RawBatch: return ((vd__RawBatch *)ptr)->soap_out(soap, tag, id, "vd:RawBatch");
	case SOAP_TYPE_vd__Consignment: return ((vd__Consignment *)ptr)->soap_out(soap, tag, id, "vd:Consignment");
	case SOAP_TYPE_vd__Batch: return ((vd__Batch *)ptr)->soap_out(soap, tag, id, "vd:Batch");
	case SOAP_TYPE_vd__VetDocument: return ((vd__VetDocument *)ptr)->soap_out(soap, tag, id, "vd:VetDocument");
	case SOAP_TYPE_ent__ActivityLocationList: return ((ent__ActivityLocationList *)ptr)->soap_out(soap, tag, id, "ent:ActivityLocationList");
	case SOAP_TYPE_ent__ResearchMethodList: return ((ent__ResearchMethodList *)ptr)->soap_out(soap, tag, id, "ent:ResearchMethodList");
	case SOAP_TYPE_ent__AnimalDiseaseList: return ((ent__AnimalDiseaseList *)ptr)->soap_out(soap, tag, id, "ent:AnimalDiseaseList");
	case SOAP_TYPE_ent__RegionalizationShippingRuleList: return ((ent__RegionalizationShippingRuleList *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationShippingRuleList");
	case SOAP_TYPE_ent__RegionalizationRegionStatusList: return ((ent__RegionalizationRegionStatusList *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationRegionStatusList");
	case SOAP_TYPE_ent__RegionalizationConditionList: return ((ent__RegionalizationConditionList *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationConditionList");
	case SOAP_TYPE_ent__Area: return ((ent__Area *)ptr)->soap_out(soap, tag, id, "ent:Area");
	case SOAP_TYPE_ent__RegionalizationRegionStatus: return ((ent__RegionalizationRegionStatus *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationRegionStatus");
	case SOAP_TYPE_ent__RegionalizationStatus: return ((ent__RegionalizationStatus *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationStatus");
	case SOAP_TYPE_ent__RegionalizationShippingRule: return ((ent__RegionalizationShippingRule *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationShippingRule");
	case SOAP_TYPE_ent__RegionalizationRequirement: return ((ent__RegionalizationRequirement *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationRequirement");
	case SOAP_TYPE_ent__RegionalizationConditionGroup: return ((ent__RegionalizationConditionGroup *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationConditionGroup");
	case SOAP_TYPE_ent__RegionalizationCondition: return ((ent__RegionalizationCondition *)ptr)->soap_out(soap, tag, id, "ent:RegionalizationCondition");
	case SOAP_TYPE_ent__MedicinalDrug: return ((ent__MedicinalDrug *)ptr)->soap_out(soap, tag, id, "ent:MedicinalDrug");
	case SOAP_TYPE_ent__ResearchMethod: return ((ent__ResearchMethod *)ptr)->soap_out(soap, tag, id, "ent:ResearchMethod");
	case SOAP_TYPE_ent__AnimalDisease: return ((ent__AnimalDisease *)ptr)->soap_out(soap, tag, id, "ent:AnimalDisease");
	case SOAP_TYPE_ent__Indicator: return ((ent__Indicator *)ptr)->soap_out(soap, tag, id, "ent:Indicator");
	case SOAP_TYPE_ent__Organization: return ((ent__Organization *)ptr)->soap_out(soap, tag, id, "ent:Organization");
	case SOAP_TYPE_ent__EnterpriseOfficialRegistration: return ((ent__EnterpriseOfficialRegistration *)ptr)->soap_out(soap, tag, id, "ent:EnterpriseOfficialRegistration");
	case SOAP_TYPE_ent__Location: return ((ent__Location *)ptr)->soap_out(soap, tag, id, "ent:Location");
	case SOAP_TYPE_ent__Packaging: return ((ent__Packaging *)ptr)->soap_out(soap, tag, id, "ent:Packaging");
	case SOAP_TYPE_ent__ProductItemProducing: return ((ent__ProductItemProducing *)ptr)->soap_out(soap, tag, id, "ent:ProductItemProducing");
	case SOAP_TYPE_ent__ComplexDate: return ((ent__ComplexDate *)ptr)->soap_out(soap, tag, id, "ent:ComplexDate");
	case SOAP_TYPE_ent__PackageList: return ((ent__PackageList *)ptr)->soap_out(soap, tag, id, "ent:PackageList");
	case SOAP_TYPE_ent__Package: return ((ent__Package *)ptr)->soap_out(soap, tag, id, "ent:Package");
	case SOAP_TYPE_ent__ProductMarks: return ((ent__ProductMarks *)ptr)->soap_out(soap, tag, id, "ent:ProductMarks");
	case SOAP_TYPE_ent__ProductItemList: return ((ent__ProductItemList *)ptr)->soap_out(soap, tag, id, "ent:ProductItemList");
	case SOAP_TYPE_ent__SubProductList: return ((ent__SubProductList *)ptr)->soap_out(soap, tag, id, "ent:SubProductList");
	case SOAP_TYPE_ent__ProductList: return ((ent__ProductList *)ptr)->soap_out(soap, tag, id, "ent:ProductList");
	case SOAP_TYPE_ent__SubProduct: return ((ent__SubProduct *)ptr)->soap_out(soap, tag, id, "ent:SubProduct");
	case SOAP_TYPE_ent__Product: return ((ent__Product *)ptr)->soap_out(soap, tag, id, "ent:Product");
	case SOAP_TYPE_ent__ProductItem: return ((ent__ProductItem *)ptr)->soap_out(soap, tag, id, "ent:ProductItem");
	case SOAP_TYPE_ent__BusinessEntityList: return ((ent__BusinessEntityList *)ptr)->soap_out(soap, tag, id, "ent:BusinessEntityList");
	case SOAP_TYPE_ent__IncorporationForm: return ((ent__IncorporationForm *)ptr)->soap_out(soap, tag, id, "ent:IncorporationForm");
	case SOAP_TYPE_ent__BusinessEntity: return ((ent__BusinessEntity *)ptr)->soap_out(soap, tag, id, "ent:BusinessEntity");
	case SOAP_TYPE_ent__BusinessMember: return ((ent__BusinessMember *)ptr)->soap_out(soap, tag, id, "ent:BusinessMember");
	case SOAP_TYPE_ent__EnterpriseList: return ((ent__EnterpriseList *)ptr)->soap_out(soap, tag, id, "ent:EnterpriseList");
	case SOAP_TYPE_ent__EnterpriseNumberList: return ((ent__EnterpriseNumberList *)ptr)->soap_out(soap, tag, id, "ent:EnterpriseNumberList");
	case SOAP_TYPE_ent__ProducerList: return ((ent__ProducerList *)ptr)->soap_out(soap, tag, id, "ent:ProducerList");
	case SOAP_TYPE_ent__Producer: return ((ent__Producer *)ptr)->soap_out(soap, tag, id, "ent:Producer");
	case SOAP_TYPE_ent__EnterpriseActivity: return ((ent__EnterpriseActivity *)ptr)->soap_out(soap, tag, id, "ent:EnterpriseActivity");
	case SOAP_TYPE_ent__EnterpriseActivityList: return ((ent__EnterpriseActivityList *)ptr)->soap_out(soap, tag, id, "ent:EnterpriseActivityList");
	case SOAP_TYPE_ent__Enterprise: return ((ent__Enterprise *)ptr)->soap_out(soap, tag, id, "ent:Enterprise");
	case SOAP_TYPE_ent__StreetList: return ((ent__StreetList *)ptr)->soap_out(soap, tag, id, "ent:StreetList");
	case SOAP_TYPE_ent__LocalityList: return ((ent__LocalityList *)ptr)->soap_out(soap, tag, id, "ent:LocalityList");
	case SOAP_TYPE_ent__DistrictList: return ((ent__DistrictList *)ptr)->soap_out(soap, tag, id, "ent:DistrictList");
	case SOAP_TYPE_ent__RegionList: return ((ent__RegionList *)ptr)->soap_out(soap, tag, id, "ent:RegionList");
	case SOAP_TYPE_ent__CountryList: return ((ent__CountryList *)ptr)->soap_out(soap, tag, id, "ent:CountryList");
	case SOAP_TYPE_ent__Address: return ((ent__Address *)ptr)->soap_out(soap, tag, id, "ent:Address");
	case SOAP_TYPE_ent__Street: return ((ent__Street *)ptr)->soap_out(soap, tag, id, "ent:Street");
	case SOAP_TYPE_ent__Locality: return ((ent__Locality *)ptr)->soap_out(soap, tag, id, "ent:Locality");
	case SOAP_TYPE_ent__District: return ((ent__District *)ptr)->soap_out(soap, tag, id, "ent:District");
	case SOAP_TYPE_ent__Region: return ((ent__Region *)ptr)->soap_out(soap, tag, id, "ent:Region");
	case SOAP_TYPE_ent__AddressObjectView: return ((ent__AddressObjectView *)ptr)->soap_out(soap, tag, id, "ent:AddressObjectView");
	case SOAP_TYPE_ent__FederalDistrict: return ((ent__FederalDistrict *)ptr)->soap_out(soap, tag, id, "ent:FederalDistrict");
	case SOAP_TYPE_ent__Country: return ((ent__Country *)ptr)->soap_out(soap, tag, id, "ent:Country");
	case SOAP_TYPE_ent__UnitList: return ((ent__UnitList *)ptr)->soap_out(soap, tag, id, "ent:UnitList");
	case SOAP_TYPE_ent__PurposeList: return ((ent__PurposeList *)ptr)->soap_out(soap, tag, id, "ent:PurposeList");
	case SOAP_TYPE_ent__PackingType: return ((ent__PackingType *)ptr)->soap_out(soap, tag, id, "ent:PackingType");
	case SOAP_TYPE_ent__Unit: return ((ent__Unit *)ptr)->soap_out(soap, tag, id, "ent:Unit");
	case SOAP_TYPE_ent__Purpose: return ((ent__Purpose *)ptr)->soap_out(soap, tag, id, "ent:Purpose");
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse: return ((merc__GetAppliedUserAuthorityListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest: return ((merc__GetAppliedUserAuthorityListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_merc__UnbindBusinessEntityUserResponse: return ((merc__UnbindBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "merc:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_merc__UnbindBusinessEntityUserRequest: return ((merc__UnbindBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "merc:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_merc__UpdateUserWorkingAreasResponse: return ((merc__UpdateUserWorkingAreasResponse *)ptr)->soap_out(soap, tag, id, "merc:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_merc__UpdateUserWorkingAreasRequest: return ((merc__UpdateUserWorkingAreasRequest *)ptr)->soap_out(soap, tag, id, "merc:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_merc__UpdateUserAuthoritiesResponse: return ((merc__UpdateUserAuthoritiesResponse *)ptr)->soap_out(soap, tag, id, "merc:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_merc__UpdateUserAuthoritiesRequest: return ((merc__UpdateUserAuthoritiesRequest *)ptr)->soap_out(soap, tag, id, "merc:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_merc__GetBusinessEntityUserResponse: return ((merc__GetBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "merc:GetBusinessEntityUserResponse");
	case SOAP_TYPE_merc__GetBusinessEntityUserRequest: return ((merc__GetBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "merc:GetBusinessEntityUserRequest");
	case SOAP_TYPE_merc__GetBusinessEntityUserListResponse: return ((merc__GetBusinessEntityUserListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_merc__GetBusinessEntityUserListRequest: return ((merc__GetBusinessEntityUserListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_merc__AddBusinessEntityUserResponse: return ((merc__AddBusinessEntityUserResponse *)ptr)->soap_out(soap, tag, id, "merc:AddBusinessEntityUserResponse");
	case SOAP_TYPE_merc__AddBusinessEntityUserRequest: return ((merc__AddBusinessEntityUserRequest *)ptr)->soap_out(soap, tag, id, "merc:AddBusinessEntityUserRequest");
	case SOAP_TYPE_merc__CheckShipmentRegionalizationResponse: return ((merc__CheckShipmentRegionalizationResponse *)ptr)->soap_out(soap, tag, id, "merc:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_merc__CheckShipmentRegionalizationRequest: return ((merc__CheckShipmentRegionalizationRequest *)ptr)->soap_out(soap, tag, id, "merc:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_merc__UpdateVeterinaryEventsResponse: return ((merc__UpdateVeterinaryEventsResponse *)ptr)->soap_out(soap, tag, id, "merc:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_merc__UpdateVeterinaryEventsRequest: return ((merc__UpdateVeterinaryEventsRequest *)ptr)->soap_out(soap, tag, id, "merc:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse: return ((merc__UpdateTransportMovementDetailsResponse *)ptr)->soap_out(soap, tag, id, "merc:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest: return ((merc__UpdateTransportMovementDetailsRequest *)ptr)->soap_out(soap, tag, id, "merc:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_merc__GetStockEntryVersionListResponse: return ((merc__GetStockEntryVersionListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryVersionListResponse");
	case SOAP_TYPE_merc__GetStockEntryVersionListRequest: return ((merc__GetStockEntryVersionListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryVersionListRequest");
	case SOAP_TYPE_merc__GetStockEntryListResponse: return ((merc__GetStockEntryListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryListResponse");
	case SOAP_TYPE_merc__GetStockEntryListRequest: return ((merc__GetStockEntryListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryListRequest");
	case SOAP_TYPE_merc__GetStockEntryChangesListResponse: return ((merc__GetStockEntryChangesListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryChangesListResponse");
	case SOAP_TYPE_merc__GetStockEntryChangesListRequest: return ((merc__GetStockEntryChangesListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryChangesListRequest");
	case SOAP_TYPE_merc__GetStockEntryByUuidResponse: return ((merc__GetStockEntryByUuidResponse *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryByUuidResponse");
	case SOAP_TYPE_merc__GetStockEntryByUuidRequest: return ((merc__GetStockEntryByUuidRequest *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryByUuidRequest");
	case SOAP_TYPE_merc__GetStockEntryByGuidResponse: return ((merc__GetStockEntryByGuidResponse *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryByGuidResponse");
	case SOAP_TYPE_merc__GetStockEntryByGuidRequest: return ((merc__GetStockEntryByGuidRequest *)ptr)->soap_out(soap, tag, id, "merc:GetStockEntryByGuidRequest");
	case SOAP_TYPE_merc__GetVetDocumentChangesListResponse: return ((merc__GetVetDocumentChangesListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_merc__GetVetDocumentChangesListRequest: return ((merc__GetVetDocumentChangesListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_merc__GetVetDocumentListResponse: return ((merc__GetVetDocumentListResponse *)ptr)->soap_out(soap, tag, id, "merc:GetVetDocumentListResponse");
	case SOAP_TYPE_merc__GetVetDocumentListRequest: return ((merc__GetVetDocumentListRequest *)ptr)->soap_out(soap, tag, id, "merc:GetVetDocumentListRequest");
	case SOAP_TYPE_merc__GetVetDocumentByUuidResponse: return ((merc__GetVetDocumentByUuidResponse *)ptr)->soap_out(soap, tag, id, "merc:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_merc__GetVetDocumentByUuidRequest: return ((merc__GetVetDocumentByUuidRequest *)ptr)->soap_out(soap, tag, id, "merc:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_merc__ModifyProducerStockListResponse: return ((merc__ModifyProducerStockListResponse *)ptr)->soap_out(soap, tag, id, "merc:ModifyProducerStockListResponse");
	case SOAP_TYPE_merc__ModifyProducerStockListRequest: return ((merc__ModifyProducerStockListRequest *)ptr)->soap_out(soap, tag, id, "merc:ModifyProducerStockListRequest");
	case SOAP_TYPE_merc__ResolveDiscrepancyResponse: return ((merc__ResolveDiscrepancyResponse *)ptr)->soap_out(soap, tag, id, "merc:ResolveDiscrepancyResponse");
	case SOAP_TYPE_merc__ResolveDiscrepancyRequest: return ((merc__ResolveDiscrepancyRequest *)ptr)->soap_out(soap, tag, id, "merc:ResolveDiscrepancyRequest");
	case SOAP_TYPE_merc__ModifyActivityLocationsResponse: return ((merc__ModifyActivityLocationsResponse *)ptr)->soap_out(soap, tag, id, "merc:ModifyActivityLocationsResponse");
	case SOAP_TYPE_merc__ModifyActivityLocationsRequest: return ((merc__ModifyActivityLocationsRequest *)ptr)->soap_out(soap, tag, id, "merc:ModifyActivityLocationsRequest");
	case SOAP_TYPE_merc__ModifyEnterpriseResponse: return ((merc__ModifyEnterpriseResponse *)ptr)->soap_out(soap, tag, id, "merc:ModifyEnterpriseResponse");
	case SOAP_TYPE_merc__ModifyEnterpriseRequest: return ((merc__ModifyEnterpriseRequest *)ptr)->soap_out(soap, tag, id, "merc:ModifyEnterpriseRequest");
	case SOAP_TYPE_merc__ModifyBusinessEntityResponse: return ((merc__ModifyBusinessEntityResponse *)ptr)->soap_out(soap, tag, id, "merc:ModifyBusinessEntityResponse");
	case SOAP_TYPE_merc__ModifyBusinessEntityRequest: return ((merc__ModifyBusinessEntityRequest *)ptr)->soap_out(soap, tag, id, "merc:ModifyBusinessEntityRequest");
	case SOAP_TYPE_merc__WithdrawVetDocumentResponse: return ((merc__WithdrawVetDocumentResponse *)ptr)->soap_out(soap, tag, id, "merc:WithdrawVetDocumentResponse");
	case SOAP_TYPE_merc__WithdrawVetDocumentRequest: return ((merc__WithdrawVetDocumentRequest *)ptr)->soap_out(soap, tag, id, "merc:WithdrawVetDocumentRequest");
	case SOAP_TYPE_merc__MergeStockEntriesResponse: return ((merc__MergeStockEntriesResponse *)ptr)->soap_out(soap, tag, id, "merc:MergeStockEntriesResponse");
	case SOAP_TYPE_merc__MergeStockEntriesRequest: return ((merc__MergeStockEntriesRequest *)ptr)->soap_out(soap, tag, id, "merc:MergeStockEntriesRequest");
	case SOAP_TYPE_merc__RegisterProductionOperationResponse: return ((merc__RegisterProductionOperationResponse *)ptr)->soap_out(soap, tag, id, "merc:RegisterProductionOperationResponse");
	case SOAP_TYPE_merc__RegisterProductionOperationRequest: return ((merc__RegisterProductionOperationRequest *)ptr)->soap_out(soap, tag, id, "merc:RegisterProductionOperationRequest");
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse: return ((merc__PrepareOutgoingConsignmentResponse *)ptr)->soap_out(soap, tag, id, "merc:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest: return ((merc__PrepareOutgoingConsignmentRequest *)ptr)->soap_out(soap, tag, id, "merc:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_merc__ProcessIncomingConsignmentResponse: return ((merc__ProcessIncomingConsignmentResponse *)ptr)->soap_out(soap, tag, id, "merc:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_merc__ProcessIncomingConsignmentRequest: return ((merc__ProcessIncomingConsignmentRequest *)ptr)->soap_out(soap, tag, id, "merc:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_merc__MercuryApplicationRequest: return ((merc__MercuryApplicationRequest *)ptr)->soap_out(soap, tag, id, "merc:MercuryApplicationRequest");
	case SOAP_TYPE_app__BusinessError: return ((app__BusinessError *)ptr)->soap_out(soap, tag, id, "app:BusinessError");
	case SOAP_TYPE_app__BusinessErrorList: return ((app__BusinessErrorList *)ptr)->soap_out(soap, tag, id, "app:BusinessErrorList");
	case SOAP_TYPE_app__ApplicationResultData: return ((app__ApplicationResultData *)ptr)->soap_out(soap, tag, id, "app:ApplicationResultData");
	case SOAP_TYPE_app__ApplicationData: return ((app__ApplicationData *)ptr)->soap_out(soap, tag, id, "app:ApplicationData");
	case SOAP_TYPE_app__ApplicationResultWrapper: return ((app__ApplicationResultWrapper *)ptr)->soap_out(soap, tag, id, "app:ApplicationResultWrapper");
	case SOAP_TYPE_app__ApplicationDataWrapper: return ((app__ApplicationDataWrapper *)ptr)->soap_out(soap, tag, id, "app:ApplicationDataWrapper");
	case SOAP_TYPE_app__Application: return ((app__Application *)ptr)->soap_out(soap, tag, id, "app:Application");
	case SOAP_TYPE_base__Error: return ((base__Error *)ptr)->soap_out(soap, tag, id, "base:Error");
	case SOAP_TYPE_base__FaultInfo: return ((base__FaultInfo *)ptr)->soap_out(soap, tag, id, "base:FaultInfo");
	case SOAP_TYPE_base__EntityList: return ((base__EntityList *)ptr)->soap_out(soap, tag, id, "base:EntityList");
	case SOAP_TYPE_base__DateInterval: return ((base__DateInterval *)ptr)->soap_out(soap, tag, id, "base:DateInterval");
	case SOAP_TYPE_base__ListOptions: return ((base__ListOptions *)ptr)->soap_out(soap, tag, id, "base:ListOptions");
	case SOAP_TYPE_base__GenericVersioningEntity: return ((base__GenericVersioningEntity *)ptr)->soap_out(soap, tag, id, "base:GenericVersioningEntity");
	case SOAP_TYPE_base__GenericEntity: return ((base__GenericEntity *)ptr)->soap_out(soap, tag, id, "base:GenericEntity");
	case SOAP_TYPE__ws__receiveApplicationResultResponse: return ((_ws__receiveApplicationResultResponse *)ptr)->soap_out(soap, "ws:receiveApplicationResultResponse", id, NULL);
	case SOAP_TYPE__ws__receiveApplicationResultRequest: return ((_ws__receiveApplicationResultRequest *)ptr)->soap_out(soap, "ws:receiveApplicationResultRequest", id, NULL);
	case SOAP_TYPE__ws__submitApplicationResponse: return ((_ws__submitApplicationResponse *)ptr)->soap_out(soap, "ws:submitApplicationResponse", id, NULL);
	case SOAP_TYPE__ws__submitApplicationRequest: return ((_ws__submitApplicationRequest *)ptr)->soap_out(soap, "ws:submitApplicationRequest", id, NULL);
	case SOAP_TYPE_xsd__base64Binary: return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListResponse: return soap_out_PointerTomerc__GetAppliedUserAuthorityListResponse(soap, tag, id, (merc__GetAppliedUserAuthorityListResponse *const*)ptr, "merc:GetAppliedUserAuthorityListResponse");
	case SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListRequest: return soap_out_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, tag, id, (merc__GetAppliedUserAuthorityListRequest *const*)ptr, "merc:GetAppliedUserAuthorityListRequest");
	case SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserResponse: return soap_out_PointerTomerc__UnbindBusinessEntityUserResponse(soap, tag, id, (merc__UnbindBusinessEntityUserResponse *const*)ptr, "merc:UnbindBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserRequest: return soap_out_PointerTomerc__UnbindBusinessEntityUserRequest(soap, tag, id, (merc__UnbindBusinessEntityUserRequest *const*)ptr, "merc:UnbindBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasResponse: return soap_out_PointerTomerc__UpdateUserWorkingAreasResponse(soap, tag, id, (merc__UpdateUserWorkingAreasResponse *const*)ptr, "merc:UpdateUserWorkingAreasResponse");
	case SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasRequest: return soap_out_PointerTomerc__UpdateUserWorkingAreasRequest(soap, tag, id, (merc__UpdateUserWorkingAreasRequest *const*)ptr, "merc:UpdateUserWorkingAreasRequest");
	case SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesResponse: return soap_out_PointerTomerc__UpdateUserAuthoritiesResponse(soap, tag, id, (merc__UpdateUserAuthoritiesResponse *const*)ptr, "merc:UpdateUserAuthoritiesResponse");
	case SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesRequest: return soap_out_PointerTomerc__UpdateUserAuthoritiesRequest(soap, tag, id, (merc__UpdateUserAuthoritiesRequest *const*)ptr, "merc:UpdateUserAuthoritiesRequest");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserResponse: return soap_out_PointerTomerc__GetBusinessEntityUserResponse(soap, tag, id, (merc__GetBusinessEntityUserResponse *const*)ptr, "merc:GetBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserRequest: return soap_out_PointerTomerc__GetBusinessEntityUserRequest(soap, tag, id, (merc__GetBusinessEntityUserRequest *const*)ptr, "merc:GetBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListResponse: return soap_out_PointerTomerc__GetBusinessEntityUserListResponse(soap, tag, id, (merc__GetBusinessEntityUserListResponse *const*)ptr, "merc:GetBusinessEntityUserListResponse");
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListRequest: return soap_out_PointerTomerc__GetBusinessEntityUserListRequest(soap, tag, id, (merc__GetBusinessEntityUserListRequest *const*)ptr, "merc:GetBusinessEntityUserListRequest");
	case SOAP_TYPE_PointerTomerc__AddBusinessEntityUserResponse: return soap_out_PointerTomerc__AddBusinessEntityUserResponse(soap, tag, id, (merc__AddBusinessEntityUserResponse *const*)ptr, "merc:AddBusinessEntityUserResponse");
	case SOAP_TYPE_PointerTomerc__AddBusinessEntityUserRequest: return soap_out_PointerTomerc__AddBusinessEntityUserRequest(soap, tag, id, (merc__AddBusinessEntityUserRequest *const*)ptr, "merc:AddBusinessEntityUserRequest");
	case SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationResponse: return soap_out_PointerTomerc__CheckShipmentRegionalizationResponse(soap, tag, id, (merc__CheckShipmentRegionalizationResponse *const*)ptr, "merc:CheckShipmentRegionalizationResponse");
	case SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationRequest: return soap_out_PointerTomerc__CheckShipmentRegionalizationRequest(soap, tag, id, (merc__CheckShipmentRegionalizationRequest *const*)ptr, "merc:CheckShipmentRegionalizationRequest");
	case SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsResponse: return soap_out_PointerTomerc__UpdateVeterinaryEventsResponse(soap, tag, id, (merc__UpdateVeterinaryEventsResponse *const*)ptr, "merc:UpdateVeterinaryEventsResponse");
	case SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsRequest: return soap_out_PointerTomerc__UpdateVeterinaryEventsRequest(soap, tag, id, (merc__UpdateVeterinaryEventsRequest *const*)ptr, "merc:UpdateVeterinaryEventsRequest");
	case SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsResponse: return soap_out_PointerTomerc__UpdateTransportMovementDetailsResponse(soap, tag, id, (merc__UpdateTransportMovementDetailsResponse *const*)ptr, "merc:UpdateTransportMovementDetailsResponse");
	case SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsRequest: return soap_out_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, tag, id, (merc__UpdateTransportMovementDetailsRequest *const*)ptr, "merc:UpdateTransportMovementDetailsRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryVersionListResponse: return soap_out_PointerTomerc__GetStockEntryVersionListResponse(soap, tag, id, (merc__GetStockEntryVersionListResponse *const*)ptr, "merc:GetStockEntryVersionListResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryVersionListRequest: return soap_out_PointerTomerc__GetStockEntryVersionListRequest(soap, tag, id, (merc__GetStockEntryVersionListRequest *const*)ptr, "merc:GetStockEntryVersionListRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryChangesListResponse: return soap_out_PointerTomerc__GetStockEntryChangesListResponse(soap, tag, id, (merc__GetStockEntryChangesListResponse *const*)ptr, "merc:GetStockEntryChangesListResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryChangesListRequest: return soap_out_PointerTomerc__GetStockEntryChangesListRequest(soap, tag, id, (merc__GetStockEntryChangesListRequest *const*)ptr, "merc:GetStockEntryChangesListRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryListResponse: return soap_out_PointerTomerc__GetStockEntryListResponse(soap, tag, id, (merc__GetStockEntryListResponse *const*)ptr, "merc:GetStockEntryListResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryListRequest: return soap_out_PointerTomerc__GetStockEntryListRequest(soap, tag, id, (merc__GetStockEntryListRequest *const*)ptr, "merc:GetStockEntryListRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByUuidResponse: return soap_out_PointerTomerc__GetStockEntryByUuidResponse(soap, tag, id, (merc__GetStockEntryByUuidResponse *const*)ptr, "merc:GetStockEntryByUuidResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByUuidRequest: return soap_out_PointerTomerc__GetStockEntryByUuidRequest(soap, tag, id, (merc__GetStockEntryByUuidRequest *const*)ptr, "merc:GetStockEntryByUuidRequest");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByGuidResponse: return soap_out_PointerTomerc__GetStockEntryByGuidResponse(soap, tag, id, (merc__GetStockEntryByGuidResponse *const*)ptr, "merc:GetStockEntryByGuidResponse");
	case SOAP_TYPE_PointerTomerc__GetStockEntryByGuidRequest: return soap_out_PointerTomerc__GetStockEntryByGuidRequest(soap, tag, id, (merc__GetStockEntryByGuidRequest *const*)ptr, "merc:GetStockEntryByGuidRequest");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListResponse: return soap_out_PointerTomerc__GetVetDocumentChangesListResponse(soap, tag, id, (merc__GetVetDocumentChangesListResponse *const*)ptr, "merc:GetVetDocumentChangesListResponse");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListRequest: return soap_out_PointerTomerc__GetVetDocumentChangesListRequest(soap, tag, id, (merc__GetVetDocumentChangesListRequest *const*)ptr, "merc:GetVetDocumentChangesListRequest");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentListResponse: return soap_out_PointerTomerc__GetVetDocumentListResponse(soap, tag, id, (merc__GetVetDocumentListResponse *const*)ptr, "merc:GetVetDocumentListResponse");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentListRequest: return soap_out_PointerTomerc__GetVetDocumentListRequest(soap, tag, id, (merc__GetVetDocumentListRequest *const*)ptr, "merc:GetVetDocumentListRequest");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidResponse: return soap_out_PointerTomerc__GetVetDocumentByUuidResponse(soap, tag, id, (merc__GetVetDocumentByUuidResponse *const*)ptr, "merc:GetVetDocumentByUuidResponse");
	case SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidRequest: return soap_out_PointerTomerc__GetVetDocumentByUuidRequest(soap, tag, id, (merc__GetVetDocumentByUuidRequest *const*)ptr, "merc:GetVetDocumentByUuidRequest");
	case SOAP_TYPE_PointerTomerc__ModifyProducerStockListResponse: return soap_out_PointerTomerc__ModifyProducerStockListResponse(soap, tag, id, (merc__ModifyProducerStockListResponse *const*)ptr, "merc:ModifyProducerStockListResponse");
	case SOAP_TYPE_PointerTomerc__ModifyProducerStockListRequest: return soap_out_PointerTomerc__ModifyProducerStockListRequest(soap, tag, id, (merc__ModifyProducerStockListRequest *const*)ptr, "merc:ModifyProducerStockListRequest");
	case SOAP_TYPE_PointerTomerc__ResolveDiscrepancyResponse: return soap_out_PointerTomerc__ResolveDiscrepancyResponse(soap, tag, id, (merc__ResolveDiscrepancyResponse *const*)ptr, "merc:ResolveDiscrepancyResponse");
	case SOAP_TYPE_PointerTomerc__ResolveDiscrepancyRequest: return soap_out_PointerTomerc__ResolveDiscrepancyRequest(soap, tag, id, (merc__ResolveDiscrepancyRequest *const*)ptr, "merc:ResolveDiscrepancyRequest");
	case SOAP_TYPE_PointerTomerc__ModifyActivityLocationsResponse: return soap_out_PointerTomerc__ModifyActivityLocationsResponse(soap, tag, id, (merc__ModifyActivityLocationsResponse *const*)ptr, "merc:ModifyActivityLocationsResponse");
	case SOAP_TYPE_PointerTomerc__ModifyActivityLocationsRequest: return soap_out_PointerTomerc__ModifyActivityLocationsRequest(soap, tag, id, (merc__ModifyActivityLocationsRequest *const*)ptr, "merc:ModifyActivityLocationsRequest");
	case SOAP_TYPE_PointerTomerc__ModifyEnterpriseResponse: return soap_out_PointerTomerc__ModifyEnterpriseResponse(soap, tag, id, (merc__ModifyEnterpriseResponse *const*)ptr, "merc:ModifyEnterpriseResponse");
	case SOAP_TYPE_PointerTomerc__ModifyEnterpriseRequest: return soap_out_PointerTomerc__ModifyEnterpriseRequest(soap, tag, id, (merc__ModifyEnterpriseRequest *const*)ptr, "merc:ModifyEnterpriseRequest");
	case SOAP_TYPE_PointerTomerc__ModifyBusinessEntityResponse: return soap_out_PointerTomerc__ModifyBusinessEntityResponse(soap, tag, id, (merc__ModifyBusinessEntityResponse *const*)ptr, "merc:ModifyBusinessEntityResponse");
	case SOAP_TYPE_PointerTomerc__ModifyBusinessEntityRequest: return soap_out_PointerTomerc__ModifyBusinessEntityRequest(soap, tag, id, (merc__ModifyBusinessEntityRequest *const*)ptr, "merc:ModifyBusinessEntityRequest");
	case SOAP_TYPE_PointerTomerc__WithdrawVetDocumentResponse: return soap_out_PointerTomerc__WithdrawVetDocumentResponse(soap, tag, id, (merc__WithdrawVetDocumentResponse *const*)ptr, "merc:WithdrawVetDocumentResponse");
	case SOAP_TYPE_PointerTomerc__WithdrawVetDocumentRequest: return soap_out_PointerTomerc__WithdrawVetDocumentRequest(soap, tag, id, (merc__WithdrawVetDocumentRequest *const*)ptr, "merc:WithdrawVetDocumentRequest");
	case SOAP_TYPE_PointerTomerc__MergeStockEntriesResponse: return soap_out_PointerTomerc__MergeStockEntriesResponse(soap, tag, id, (merc__MergeStockEntriesResponse *const*)ptr, "merc:MergeStockEntriesResponse");
	case SOAP_TYPE_PointerTomerc__MergeStockEntriesRequest: return soap_out_PointerTomerc__MergeStockEntriesRequest(soap, tag, id, (merc__MergeStockEntriesRequest *const*)ptr, "merc:MergeStockEntriesRequest");
	case SOAP_TYPE_PointerTomerc__RegisterProductionOperationResponse: return soap_out_PointerTomerc__RegisterProductionOperationResponse(soap, tag, id, (merc__RegisterProductionOperationResponse *const*)ptr, "merc:RegisterProductionOperationResponse");
	case SOAP_TYPE_PointerTomerc__RegisterProductionOperationRequest: return soap_out_PointerTomerc__RegisterProductionOperationRequest(soap, tag, id, (merc__RegisterProductionOperationRequest *const*)ptr, "merc:RegisterProductionOperationRequest");
	case SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentResponse: return soap_out_PointerTomerc__PrepareOutgoingConsignmentResponse(soap, tag, id, (merc__PrepareOutgoingConsignmentResponse *const*)ptr, "merc:PrepareOutgoingConsignmentResponse");
	case SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentRequest: return soap_out_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, tag, id, (merc__PrepareOutgoingConsignmentRequest *const*)ptr, "merc:PrepareOutgoingConsignmentRequest");
	case SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentResponse: return soap_out_PointerTomerc__ProcessIncomingConsignmentResponse(soap, tag, id, (merc__ProcessIncomingConsignmentResponse *const*)ptr, "merc:ProcessIncomingConsignmentResponse");
	case SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentRequest: return soap_out_PointerTomerc__ProcessIncomingConsignmentRequest(soap, tag, id, (merc__ProcessIncomingConsignmentRequest *const*)ptr, "merc:ProcessIncomingConsignmentRequest");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse: return soap_out_PointerTo_ws__receiveApplicationResultResponse(soap, tag, id, (_ws__receiveApplicationResultResponse *const*)ptr, "ws:receiveApplicationResultResponse");
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest: return soap_out_PointerTo_ws__receiveApplicationResultRequest(soap, tag, id, (_ws__receiveApplicationResultRequest *const*)ptr, "ws:receiveApplicationResultRequest");
	case SOAP_TYPE_PointerTo_ws__submitApplicationResponse: return soap_out_PointerTo_ws__submitApplicationResponse(soap, tag, id, (_ws__submitApplicationResponse *const*)ptr, "ws:submitApplicationResponse");
	case SOAP_TYPE_PointerTo_ws__submitApplicationRequest: return soap_out_PointerTo_ws__submitApplicationRequest(soap, tag, id, (_ws__submitApplicationRequest *const*)ptr, "ws:submitApplicationRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemChangesListResponse: return soap_out_PointerTo_ns8__getProductItemChangesListResponse(soap, tag, id, (_ns8__getProductItemChangesListResponse *const*)ptr, "ns8:getProductItemChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemChangesListRequest: return soap_out_PointerTo_ns8__getProductItemChangesListRequest(soap, tag, id, (_ns8__getProductItemChangesListRequest *const*)ptr, "ns8:getProductItemChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemListResponse: return soap_out_PointerTo_ns8__getProductItemListResponse(soap, tag, id, (_ns8__getProductItemListResponse *const*)ptr, "ns8:getProductItemListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemListRequest: return soap_out_PointerTo_ns8__getProductItemListRequest(soap, tag, id, (_ns8__getProductItemListRequest *const*)ptr, "ns8:getProductItemListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByUuidResponse: return soap_out_PointerTo_ns8__getProductItemByUuidResponse(soap, tag, id, (_ns8__getProductItemByUuidResponse *const*)ptr, "ns8:getProductItemByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByUuidRequest: return soap_out_PointerTo_ns8__getProductItemByUuidRequest(soap, tag, id, (_ns8__getProductItemByUuidRequest *const*)ptr, "ns8:getProductItemByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByGuidResponse: return soap_out_PointerTo_ns8__getProductItemByGuidResponse(soap, tag, id, (_ns8__getProductItemByGuidResponse *const*)ptr, "ns8:getProductItemByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductItemByGuidRequest: return soap_out_PointerTo_ns8__getProductItemByGuidRequest(soap, tag, id, (_ns8__getProductItemByGuidRequest *const*)ptr, "ns8:getProductItemByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductChangesListResponse: return soap_out_PointerTo_ns8__getSubProductChangesListResponse(soap, tag, id, (_ns8__getSubProductChangesListResponse *const*)ptr, "ns8:getSubProductChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductChangesListRequest: return soap_out_PointerTo_ns8__getSubProductChangesListRequest(soap, tag, id, (_ns8__getSubProductChangesListRequest *const*)ptr, "ns8:getSubProductChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByProductListResponse: return soap_out_PointerTo_ns8__getSubProductByProductListResponse(soap, tag, id, (_ns8__getSubProductByProductListResponse *const*)ptr, "ns8:getSubProductByProductListResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByProductListRequest: return soap_out_PointerTo_ns8__getSubProductByProductListRequest(soap, tag, id, (_ns8__getSubProductByProductListRequest *const*)ptr, "ns8:getSubProductByProductListRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByUuidResponse: return soap_out_PointerTo_ns8__getSubProductByUuidResponse(soap, tag, id, (_ns8__getSubProductByUuidResponse *const*)ptr, "ns8:getSubProductByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByUuidRequest: return soap_out_PointerTo_ns8__getSubProductByUuidRequest(soap, tag, id, (_ns8__getSubProductByUuidRequest *const*)ptr, "ns8:getSubProductByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByGuidResponse: return soap_out_PointerTo_ns8__getSubProductByGuidResponse(soap, tag, id, (_ns8__getSubProductByGuidResponse *const*)ptr, "ns8:getSubProductByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getSubProductByGuidRequest: return soap_out_PointerTo_ns8__getSubProductByGuidRequest(soap, tag, id, (_ns8__getSubProductByGuidRequest *const*)ptr, "ns8:getSubProductByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductChangesListResponse: return soap_out_PointerTo_ns8__getProductChangesListResponse(soap, tag, id, (_ns8__getProductChangesListResponse *const*)ptr, "ns8:getProductChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductChangesListRequest: return soap_out_PointerTo_ns8__getProductChangesListRequest(soap, tag, id, (_ns8__getProductChangesListRequest *const*)ptr, "ns8:getProductChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductByTypeListResponse: return soap_out_PointerTo_ns8__getProductByTypeListResponse(soap, tag, id, (_ns8__getProductByTypeListResponse *const*)ptr, "ns8:getProductByTypeListResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductByTypeListRequest: return soap_out_PointerTo_ns8__getProductByTypeListRequest(soap, tag, id, (_ns8__getProductByTypeListRequest *const*)ptr, "ns8:getProductByTypeListRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductByUuidResponse: return soap_out_PointerTo_ns8__getProductByUuidResponse(soap, tag, id, (_ns8__getProductByUuidResponse *const*)ptr, "ns8:getProductByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductByUuidRequest: return soap_out_PointerTo_ns8__getProductByUuidRequest(soap, tag, id, (_ns8__getProductByUuidRequest *const*)ptr, "ns8:getProductByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getProductByGuidResponse: return soap_out_PointerTo_ns8__getProductByGuidResponse(soap, tag, id, (_ns8__getProductByGuidResponse *const*)ptr, "ns8:getProductByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getProductByGuidRequest: return soap_out_PointerTo_ns8__getProductByGuidRequest(soap, tag, id, (_ns8__getProductByGuidRequest *const*)ptr, "ns8:getProductByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse: return soap_out_PointerTo_ns8__getActivityLocationListResponse(soap, tag, id, (_ns8__getActivityLocationListResponse *const*)ptr, "ns8:getActivityLocationListResponse");
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest: return soap_out_PointerTo_ns8__getActivityLocationListRequest(soap, tag, id, (_ns8__getActivityLocationListRequest *const*)ptr, "ns8:getActivityLocationListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse: return soap_out_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, tag, id, (_ns8__getBusinessMemberByGLNResponse *const*)ptr, "ns8:getBusinessMemberByGLNResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest: return soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, tag, id, (_ns8__getBusinessMemberByGLNRequest *const*)ptr, "ns8:getBusinessMemberByGLNRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse: return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, tag, id, (_ns8__getRussianEnterpriseChangesListResponse *const*)ptr, "ns8:getRussianEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest: return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, tag, id, (_ns8__getRussianEnterpriseChangesListRequest *const*)ptr, "ns8:getRussianEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse: return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, tag, id, (_ns8__getForeignEnterpriseChangesListResponse *const*)ptr, "ns8:getForeignEnterpriseChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest: return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, tag, id, (_ns8__getForeignEnterpriseChangesListRequest *const*)ptr, "ns8:getForeignEnterpriseChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse: return soap_out_PointerTo_ns8__getRussianEnterpriseListResponse(soap, tag, id, (_ns8__getRussianEnterpriseListResponse *const*)ptr, "ns8:getRussianEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest: return soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(soap, tag, id, (_ns8__getRussianEnterpriseListRequest *const*)ptr, "ns8:getRussianEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse: return soap_out_PointerTo_ns8__getForeignEnterpriseListResponse(soap, tag, id, (_ns8__getForeignEnterpriseListResponse *const*)ptr, "ns8:getForeignEnterpriseListResponse");
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest: return soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(soap, tag, id, (_ns8__getForeignEnterpriseListRequest *const*)ptr, "ns8:getForeignEnterpriseListRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse: return soap_out_PointerTo_ns8__getEnterpriseByUuidResponse(soap, tag, id, (_ns8__getEnterpriseByUuidResponse *const*)ptr, "ns8:getEnterpriseByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest: return soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(soap, tag, id, (_ns8__getEnterpriseByUuidRequest *const*)ptr, "ns8:getEnterpriseByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse: return soap_out_PointerTo_ns8__getEnterpriseByGuidResponse(soap, tag, id, (_ns8__getEnterpriseByGuidResponse *const*)ptr, "ns8:getEnterpriseByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest: return soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(soap, tag, id, (_ns8__getEnterpriseByGuidRequest *const*)ptr, "ns8:getEnterpriseByGuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse: return soap_out_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, tag, id, (_ns8__getBusinessEntityChangesListResponse *const*)ptr, "ns8:getBusinessEntityChangesListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest: return soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, tag, id, (_ns8__getBusinessEntityChangesListRequest *const*)ptr, "ns8:getBusinessEntityChangesListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse: return soap_out_PointerTo_ns8__getBusinessEntityListResponse(soap, tag, id, (_ns8__getBusinessEntityListResponse *const*)ptr, "ns8:getBusinessEntityListResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest: return soap_out_PointerTo_ns8__getBusinessEntityListRequest(soap, tag, id, (_ns8__getBusinessEntityListRequest *const*)ptr, "ns8:getBusinessEntityListRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse: return soap_out_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, tag, id, (_ns8__getBusinessEntityByUuidResponse *const*)ptr, "ns8:getBusinessEntityByUuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest: return soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, tag, id, (_ns8__getBusinessEntityByUuidRequest *const*)ptr, "ns8:getBusinessEntityByUuidRequest");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse: return soap_out_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, tag, id, (_ns8__getBusinessEntityByGuidResponse *const*)ptr, "ns8:getBusinessEntityByGuidResponse");
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest: return soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, tag, id, (_ns8__getBusinessEntityByGuidRequest *const*)ptr, "ns8:getBusinessEntityByGuidRequest");
	case SOAP_TYPE_PointerTobase__FaultInfo: return soap_out_PointerTobase__FaultInfo(soap, tag, id, (base__FaultInfo *const*)ptr, "base:FaultInfo");
	case SOAP_TYPE_PointerTovd__StockEntryBlankFilter: return soap_out_PointerTovd__StockEntryBlankFilter(soap, tag, id, (enum vd__StockEntryBlankFilter *const*)ptr, "vd:StockEntryBlankFilter");
	case SOAP_TYPE_PointerTovd__StockEntryEventList: return soap_out_PointerTovd__StockEntryEventList(soap, tag, id, (vd__StockEntryEventList *const*)ptr, "vd:StockEntryEventList");
	case SOAP_TYPE_PointerTovd__DiscrepancyReason: return soap_out_PointerTovd__DiscrepancyReason(soap, tag, id, (vd__DiscrepancyReason *const*)ptr, "vd:DiscrepancyReason");
	case SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange: return soap_out_PointerToPointerTovd__VetDocumentStatusChange(soap, tag, id, (vd__VetDocumentStatusChange **const*)ptr, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VetDocumentStatusChange: return soap_out_PointerTovd__VetDocumentStatusChange(soap, tag, id, (vd__VetDocumentStatusChange *const*)ptr, "vd:VetDocumentStatusChange");
	case SOAP_TYPE_PointerTovd__VeterinaryAuthentication: return soap_out_PointerTovd__VeterinaryAuthentication(soap, tag, id, (vd__VeterinaryAuthentication *const*)ptr, "vd:VeterinaryAuthentication");
	case SOAP_TYPE_PointerTovd__CertifiedConsignment: return soap_out_PointerTovd__CertifiedConsignment(soap, tag, id, (vd__CertifiedConsignment *const*)ptr, "vd:CertifiedConsignment");
	case SOAP_TYPE_PointerTovd__CertifiedBatch: return soap_out_PointerTovd__CertifiedBatch(soap, tag, id, (vd__CertifiedBatch *const*)ptr, "vd:CertifiedBatch");
	case SOAP_TYPE_PointerTovd__VetDocumentForm: return soap_out_PointerTovd__VetDocumentForm(soap, tag, id, (enum vd__VetDocumentForm *const*)ptr, "vd:VetDocumentForm");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationStatus: return soap_out_PointerToPointerToent__RegionalizationStatus(soap, tag, id, (ent__RegionalizationStatus **const*)ptr, "ent:RegionalizationStatus");
	case SOAP_TYPE_PointerToPointerToent__Area: return soap_out_PointerToPointerToent__Area(soap, tag, id, (ent__Area **const*)ptr, "ent:Area");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationRequirement: return soap_out_PointerToPointerToent__RegionalizationRequirement(soap, tag, id, (ent__RegionalizationRequirement **const*)ptr, "ent:RegionalizationRequirement");
	case SOAP_TYPE_PointerToent__RegionalizationRequirement: return soap_out_PointerToent__RegionalizationRequirement(soap, tag, id, (ent__RegionalizationRequirement *const*)ptr, "ent:RegionalizationRequirement");
	case SOAP_TYPE_PointerToent__RegionalizationDecision: return soap_out_PointerToent__RegionalizationDecision(soap, tag, id, (enum ent__RegionalizationDecision *const*)ptr, "ent:RegionalizationDecision");
	case SOAP_TYPE_PointerToent__RegionalizationStatus: return soap_out_PointerToent__RegionalizationStatus(soap, tag, id, (ent__RegionalizationStatus *const*)ptr, "ent:RegionalizationStatus");
	case SOAP_TYPE_PointerToent__Packaging: return soap_out_PointerToent__Packaging(soap, tag, id, (ent__Packaging *const*)ptr, "ent:Packaging");
	case SOAP_TYPE_PointerToPointerToent__ProductItemProducing: return soap_out_PointerToPointerToent__ProductItemProducing(soap, tag, id, (ent__ProductItemProducing **const*)ptr, "ent:ProductItemProducing");
	case SOAP_TYPE_PointerToent__ProductItemProducing: return soap_out_PointerToent__ProductItemProducing(soap, tag, id, (ent__ProductItemProducing *const*)ptr, "ent:ProductItemProducing");
	case SOAP_TYPE_PointerTo_ent__BusinessEntity_activityLocation: return soap_out_PointerTo_ent__BusinessEntity_activityLocation(soap, tag, id, (_ent__BusinessEntity_activityLocation *const*)ptr, "ent:BusinessEntity-activityLocation");
	case SOAP_TYPE_PointerToent__IncorporationForm: return soap_out_PointerToent__IncorporationForm(soap, tag, id, (ent__IncorporationForm *const*)ptr, "ent:IncorporationForm");
	case SOAP_TYPE_PointerToent__BusinessEntityType: return soap_out_PointerToent__BusinessEntityType(soap, tag, id, (enum ent__BusinessEntityType *const*)ptr, "ent:BusinessEntityType");
	case SOAP_TYPE_PointerToPointerToent__EnterpriseOfficialRegistration: return soap_out_PointerToPointerToent__EnterpriseOfficialRegistration(soap, tag, id, (ent__EnterpriseOfficialRegistration **const*)ptr, "ent:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration: return soap_out_PointerToent__EnterpriseOfficialRegistration(soap, tag, id, (ent__EnterpriseOfficialRegistration *const*)ptr, "ent:EnterpriseOfficialRegistration");
	case SOAP_TYPE_PointerToent__EnterpriseActivityList: return soap_out_PointerToent__EnterpriseActivityList(soap, tag, id, (ent__EnterpriseActivityList *const*)ptr, "ent:EnterpriseActivityList");
	case SOAP_TYPE_PointerToent__EnterpriseNumberList: return soap_out_PointerToent__EnterpriseNumberList(soap, tag, id, (ent__EnterpriseNumberList *const*)ptr, "ent:EnterpriseNumberList");
	case SOAP_TYPE_PointerToent__EnterpriseType: return soap_out_PointerToent__EnterpriseType(soap, tag, id, (char **const*)ptr, "ent:EnterpriseType");
	case SOAP_TYPE_PointerToent__PackingCodeType: return soap_out_PointerToent__PackingCodeType(soap, tag, id, (enum ent__PackingCodeType *const*)ptr, "ent:PackingCodeType");
	case SOAP_TYPE_PointerTobase__UUID: return soap_out_PointerTobase__UUID(soap, tag, id, (char **const*)ptr, "base:UUID");
	case SOAP_TYPE_PointerTovd__StockEntrySearchPattern: return soap_out_PointerTovd__StockEntrySearchPattern(soap, tag, id, (vd__StockEntrySearchPattern *const*)ptr, "vd:StockEntrySearchPattern");
	case SOAP_TYPE_PointerTovd__VetDocumentStatus: return soap_out_PointerTovd__VetDocumentStatus(soap, tag, id, (enum vd__VetDocumentStatus *const*)ptr, "vd:VetDocumentStatus");
	case SOAP_TYPE_PointerTovd__VetDocumentType: return soap_out_PointerTovd__VetDocumentType(soap, tag, id, (enum vd__VetDocumentType *const*)ptr, "vd:VetDocumentType");
	case SOAP_TYPE_PointerTovd__PSLModificationOperation: return soap_out_PointerTovd__PSLModificationOperation(soap, tag, id, (vd__PSLModificationOperation *const*)ptr, "vd:PSLModificationOperation");
	case SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy: return soap_out_PointerToPointerTovd__StockDiscrepancy(soap, tag, id, (vd__StockDiscrepancy **const*)ptr, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__StockDiscrepancy: return soap_out_PointerTovd__StockDiscrepancy(soap, tag, id, (vd__StockDiscrepancy *const*)ptr, "vd:StockDiscrepancy");
	case SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation: return soap_out_PointerTovd__BEActivityLocationsModificationOperation(soap, tag, id, (vd__BEActivityLocationsModificationOperation *const*)ptr, "vd:BEActivityLocationsModificationOperation");
	case SOAP_TYPE_PointerTovd__ENTModificationOperation: return soap_out_PointerTovd__ENTModificationOperation(soap, tag, id, (vd__ENTModificationOperation *const*)ptr, "vd:ENTModificationOperation");
	case SOAP_TYPE_PointerTovd__BEModificationOperation: return soap_out_PointerTovd__BEModificationOperation(soap, tag, id, (vd__BEModificationOperation *const*)ptr, "vd:BEModificationOperation");
	case SOAP_TYPE_PointerTovd__MergeStockEntriesOperation: return soap_out_PointerTovd__MergeStockEntriesOperation(soap, tag, id, (vd__MergeStockEntriesOperation *const*)ptr, "vd:MergeStockEntriesOperation");
	case SOAP_TYPE_PointerTovd__ProductionOperation: return soap_out_PointerTovd__ProductionOperation(soap, tag, id, (vd__ProductionOperation *const*)ptr, "vd:ProductionOperation");
	case SOAP_TYPE_PointerToPointerTovd__Delivery: return soap_out_PointerToPointerTovd__Delivery(soap, tag, id, (vd__Delivery **const*)ptr, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport: return soap_out_PointerToPointerTovd__DiscrepancyReport(soap, tag, id, (vd__DiscrepancyReport **const*)ptr, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DiscrepancyReport: return soap_out_PointerTovd__DiscrepancyReport(soap, tag, id, (vd__DiscrepancyReport *const*)ptr, "vd:DiscrepancyReport");
	case SOAP_TYPE_PointerTovd__DeliveryFactList: return soap_out_PointerTovd__DeliveryFactList(soap, tag, id, (vd__DeliveryFactList *const*)ptr, "vd:DeliveryFactList");
	case SOAP_TYPE_PointerTovd__Delivery: return soap_out_PointerTovd__Delivery(soap, tag, id, (vd__Delivery *const*)ptr, "vd:Delivery");
	case SOAP_TYPE_PointerToPointerTovd__WorkingArea: return soap_out_PointerToPointerTovd__WorkingArea(soap, tag, id, (vd__WorkingArea **const*)ptr, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingArea: return soap_out_PointerTovd__WorkingArea(soap, tag, id, (vd__WorkingArea *const*)ptr, "vd:WorkingArea");
	case SOAP_TYPE_PointerTovd__WorkingAreaList: return soap_out_PointerTovd__WorkingAreaList(soap, tag, id, (vd__WorkingAreaList *const*)ptr, "vd:WorkingAreaList");
	case SOAP_TYPE_PointerTovd__SNILSType: return soap_out_PointerTovd__SNILSType(soap, tag, id, (char **const*)ptr, "vd:SNILSType");
	case SOAP_TYPE_PointerToent__MedicinalDrug: return soap_out_PointerToent__MedicinalDrug(soap, tag, id, (ent__MedicinalDrug *const*)ptr, "ent:MedicinalDrug");
	case SOAP_TYPE_PointerToent__Indicator: return soap_out_PointerToent__Indicator(soap, tag, id, (ent__Indicator *const*)ptr, "ent:Indicator");
	case SOAP_TYPE_PointerToent__DocumentType: return soap_out_PointerToent__DocumentType(soap, tag, id, (enum ent__DocumentType *const*)ptr, "ent:DocumentType");
	case SOAP_TYPE_PointerTovd__ConsignmentDocumentList: return soap_out_PointerTovd__ConsignmentDocumentList(soap, tag, id, (vd__ConsignmentDocumentList *const*)ptr, "vd:ConsignmentDocumentList");
	case SOAP_TYPE_PointerToPointerTovd__Consignment: return soap_out_PointerToPointerTovd__Consignment(soap, tag, id, (vd__Consignment **const*)ptr, "vd:Consignment");
	case SOAP_TYPE_PointerTovd__Consignment: return soap_out_PointerTovd__Consignment(soap, tag, id, (vd__Consignment *const*)ptr, "vd:Consignment");
	case SOAP_TYPE_PointerToPointerToent__BusinessMember: return soap_out_PointerToPointerToent__BusinessMember(soap, tag, id, (ent__BusinessMember **const*)ptr, "ent:BusinessMember");
	case SOAP_TYPE_PointerToPointerToent__ResearchMethod: return soap_out_PointerToPointerToent__ResearchMethod(soap, tag, id, (ent__ResearchMethod **const*)ptr, "ent:ResearchMethod");
	case SOAP_TYPE_PointerToPointerToent__AnimalDisease: return soap_out_PointerToPointerToent__AnimalDisease(soap, tag, id, (ent__AnimalDisease **const*)ptr, "ent:AnimalDisease");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationRegionStatus: return soap_out_PointerToPointerToent__RegionalizationRegionStatus(soap, tag, id, (ent__RegionalizationRegionStatus **const*)ptr, "ent:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToent__RegionalizationRegionStatus: return soap_out_PointerToent__RegionalizationRegionStatus(soap, tag, id, (ent__RegionalizationRegionStatus *const*)ptr, "ent:RegionalizationRegionStatus");
	case SOAP_TYPE_PointerToPointerToent__ProductItem: return soap_out_PointerToPointerToent__ProductItem(soap, tag, id, (ent__ProductItem **const*)ptr, "ent:ProductItem");
	case SOAP_TYPE_PointerToPointerToent__SubProduct: return soap_out_PointerToPointerToent__SubProduct(soap, tag, id, (ent__SubProduct **const*)ptr, "ent:SubProduct");
	case SOAP_TYPE_PointerToPointerToent__Product: return soap_out_PointerToPointerToent__Product(soap, tag, id, (ent__Product **const*)ptr, "ent:Product");
	case SOAP_TYPE_PointerToPointerToent__EnterpriseActivity: return soap_out_PointerToPointerToent__EnterpriseActivity(soap, tag, id, (ent__EnterpriseActivity **const*)ptr, "ent:EnterpriseActivity");
	case SOAP_TYPE_PointerToent__EnterpriseActivity: return soap_out_PointerToent__EnterpriseActivity(soap, tag, id, (ent__EnterpriseActivity *const*)ptr, "ent:EnterpriseActivity");
	case SOAP_TYPE_PointerToPointerToent__Street: return soap_out_PointerToPointerToent__Street(soap, tag, id, (ent__Street **const*)ptr, "ent:Street");
	case SOAP_TYPE_PointerToPointerToent__Locality: return soap_out_PointerToPointerToent__Locality(soap, tag, id, (ent__Locality **const*)ptr, "ent:Locality");
	case SOAP_TYPE_PointerToPointerToent__District: return soap_out_PointerToPointerToent__District(soap, tag, id, (ent__District **const*)ptr, "ent:District");
	case SOAP_TYPE_PointerToPointerToent__Region: return soap_out_PointerToPointerToent__Region(soap, tag, id, (ent__Region **const*)ptr, "ent:Region");
	case SOAP_TYPE_PointerToPointerToent__Country: return soap_out_PointerToPointerToent__Country(soap, tag, id, (ent__Country **const*)ptr, "ent:Country");
	case SOAP_TYPE_PointerToPointerToent__Unit: return soap_out_PointerToPointerToent__Unit(soap, tag, id, (ent__Unit **const*)ptr, "ent:Unit");
	case SOAP_TYPE_PointerToPointerToent__Purpose: return soap_out_PointerToPointerToent__Purpose(soap, tag, id, (ent__Purpose **const*)ptr, "ent:Purpose");
	case SOAP_TYPE_PointerTovd__AuthorityList: return soap_out_PointerTovd__AuthorityList(soap, tag, id, (vd__AuthorityList *const*)ptr, "vd:AuthorityList");
	case SOAP_TYPE_PointerTovd__UserList: return soap_out_PointerTovd__UserList(soap, tag, id, (vd__UserList *const*)ptr, "vd:UserList");
	case SOAP_TYPE_PointerToPointerTovd__User: return soap_out_PointerToPointerTovd__User(soap, tag, id, (vd__User **const*)ptr, "vd:User");
	case SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules: return soap_out_PointerToPointerTovd__RouteSectionR13nRules(soap, tag, id, (vd__RouteSectionR13nRules **const*)ptr, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__RouteSectionR13nRules: return soap_out_PointerTovd__RouteSectionR13nRules(soap, tag, id, (vd__RouteSectionR13nRules *const*)ptr, "vd:RouteSectionR13nRules");
	case SOAP_TYPE_PointerTovd__VetDocumentList: return soap_out_PointerTovd__VetDocumentList(soap, tag, id, (vd__VetDocumentList *const*)ptr, "vd:VetDocumentList");
	case SOAP_TYPE_PointerToPointerToent__Enterprise: return soap_out_PointerToPointerToent__Enterprise(soap, tag, id, (ent__Enterprise **const*)ptr, "ent:Enterprise");
	case SOAP_TYPE_PointerToPointerToent__BusinessEntity: return soap_out_PointerToPointerToent__BusinessEntity(soap, tag, id, (ent__BusinessEntity **const*)ptr, "ent:BusinessEntity");
	case SOAP_TYPE_PointerToent__OTPToken: return soap_out_PointerToent__OTPToken(soap, tag, id, (char **const*)ptr, "ent:OTPToken");
	case SOAP_TYPE_PointerTobase__VersionStatus: return soap_out_PointerTobase__VersionStatus(soap, tag, id, (char **const*)ptr, "base:VersionStatus");
	case SOAP_TYPE_PointerToent__ResearchMethodList: return soap_out_PointerToent__ResearchMethodList(soap, tag, id, (ent__ResearchMethodList *const*)ptr, "ent:ResearchMethodList");
	case SOAP_TYPE_PointerToent__ResearchMethod: return soap_out_PointerToent__ResearchMethod(soap, tag, id, (ent__ResearchMethod *const*)ptr, "ent:ResearchMethod");
	case SOAP_TYPE_PointerToent__AnimalDiseaseList: return soap_out_PointerToent__AnimalDiseaseList(soap, tag, id, (ent__AnimalDiseaseList *const*)ptr, "ent:AnimalDiseaseList");
	case SOAP_TYPE_PointerToent__RegionalizationShippingRuleList: return soap_out_PointerToent__RegionalizationShippingRuleList(soap, tag, id, (ent__RegionalizationShippingRuleList *const*)ptr, "ent:RegionalizationShippingRuleList");
	case SOAP_TYPE_PointerToent__RegionalizationRegionStatusList: return soap_out_PointerToent__RegionalizationRegionStatusList(soap, tag, id, (ent__RegionalizationRegionStatusList *const*)ptr, "ent:RegionalizationRegionStatusList");
	case SOAP_TYPE_PointerToent__RegionalizationConditionList: return soap_out_PointerToent__RegionalizationConditionList(soap, tag, id, (ent__RegionalizationConditionList *const*)ptr, "ent:RegionalizationConditionList");
	case SOAP_TYPE_PointerToent__ActivityLocationList: return soap_out_PointerToent__ActivityLocationList(soap, tag, id, (ent__ActivityLocationList *const*)ptr, "ent:ActivityLocationList");
	case SOAP_TYPE_PointerToent__EnterpriseGroup: return soap_out_PointerToent__EnterpriseGroup(soap, tag, id, (enum ent__EnterpriseGroup *const*)ptr, "ent:EnterpriseGroup");
	case SOAP_TYPE_PointerToent__StreetList: return soap_out_PointerToent__StreetList(soap, tag, id, (ent__StreetList *const*)ptr, "ent:StreetList");
	case SOAP_TYPE_PointerToent__LocalityList: return soap_out_PointerToent__LocalityList(soap, tag, id, (ent__LocalityList *const*)ptr, "ent:LocalityList");
	case SOAP_TYPE_PointerToent__DistrictList: return soap_out_PointerToent__DistrictList(soap, tag, id, (ent__DistrictList *const*)ptr, "ent:DistrictList");
	case SOAP_TYPE_PointerToent__RegionList: return soap_out_PointerToent__RegionList(soap, tag, id, (ent__RegionList *const*)ptr, "ent:RegionList");
	case SOAP_TYPE_PointerToent__CountryList: return soap_out_PointerToent__CountryList(soap, tag, id, (ent__CountryList *const*)ptr, "ent:CountryList");
	case SOAP_TYPE_PointerToent__SubProductList: return soap_out_PointerToent__SubProductList(soap, tag, id, (ent__SubProductList *const*)ptr, "ent:SubProductList");
	case SOAP_TYPE_PointerToent__ProductList: return soap_out_PointerToent__ProductList(soap, tag, id, (ent__ProductList *const*)ptr, "ent:ProductList");
	case SOAP_TYPE_PointerToent__UnitList: return soap_out_PointerToent__UnitList(soap, tag, id, (ent__UnitList *const*)ptr, "ent:UnitList");
	case SOAP_TYPE_PointerTobase__DateInterval: return soap_out_PointerTobase__DateInterval(soap, tag, id, (base__DateInterval *const*)ptr, "base:DateInterval");
	case SOAP_TYPE_PointerToent__PurposeList: return soap_out_PointerToent__PurposeList(soap, tag, id, (ent__PurposeList *const*)ptr, "ent:PurposeList");
	case SOAP_TYPE_PointerTobase__ListOptions: return soap_out_PointerTobase__ListOptions(soap, tag, id, (base__ListOptions *const*)ptr, "base:ListOptions");
	case SOAP_TYPE_PointerToent__Area: return soap_out_PointerToent__Area(soap, tag, id, (ent__Area *const*)ptr, "ent:Area");
	case SOAP_TYPE_PointerToPointerTovd__UserAuthority: return soap_out_PointerToPointerTovd__UserAuthority(soap, tag, id, (vd__UserAuthority **const*)ptr, "vd:UserAuthority");
	case SOAP_TYPE_PointerTovd__UserAuthority: return soap_out_PointerTovd__UserAuthority(soap, tag, id, (vd__UserAuthority *const*)ptr, "vd:UserAuthority");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationShippingRule: return soap_out_PointerToPointerToent__RegionalizationShippingRule(soap, tag, id, (ent__RegionalizationShippingRule **const*)ptr, "ent:RegionalizationShippingRule");
	case SOAP_TYPE_PointerToent__RegionalizationShippingRule: return soap_out_PointerToent__RegionalizationShippingRule(soap, tag, id, (ent__RegionalizationShippingRule *const*)ptr, "ent:RegionalizationShippingRule");
	case SOAP_TYPE_PointerTobase__SequenceNumber: return soap_out_PointerTobase__SequenceNumber(soap, tag, id, (char **const*)ptr, "base:SequenceNumber");
	case SOAP_TYPE_PointerToPointerTovd__QuarantineEvent: return soap_out_PointerToPointerTovd__QuarantineEvent(soap, tag, id, (vd__QuarantineEvent **const*)ptr, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__RegionalizationClause: return soap_out_PointerToPointerTovd__RegionalizationClause(soap, tag, id, (vd__RegionalizationClause **const*)ptr, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerTovd__RegionalizationClause: return soap_out_PointerTovd__RegionalizationClause(soap, tag, id, (vd__RegionalizationClause *const*)ptr, "vd:RegionalizationClause");
	case SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent: return soap_out_PointerToPointerTovd__VeterinaryEvent(soap, tag, id, (vd__VeterinaryEvent **const*)ptr, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerTovd__VeterinaryEvent: return soap_out_PointerTovd__VeterinaryEvent(soap, tag, id, (vd__VeterinaryEvent *const*)ptr, "vd:VeterinaryEvent");
	case SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent: return soap_out_PointerToPointerTovd__AnimalMedicationEvent(soap, tag, id, (vd__AnimalMedicationEvent **const*)ptr, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__AnimalMedicationEvent: return soap_out_PointerTovd__AnimalMedicationEvent(soap, tag, id, (vd__AnimalMedicationEvent *const*)ptr, "vd:AnimalMedicationEvent");
	case SOAP_TYPE_PointerTovd__QuarantineEvent: return soap_out_PointerTovd__QuarantineEvent(soap, tag, id, (vd__QuarantineEvent *const*)ptr, "vd:QuarantineEvent");
	case SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent: return soap_out_PointerToPointerTovd__LaboratoryResearchEvent(soap, tag, id, (vd__LaboratoryResearchEvent **const*)ptr, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__LaboratoryResearchEvent: return soap_out_PointerTovd__LaboratoryResearchEvent(soap, tag, id, (vd__LaboratoryResearchEvent *const*)ptr, "vd:LaboratoryResearchEvent");
	case SOAP_TYPE_PointerTovd__AnimalSpentPeriod: return soap_out_PointerTovd__AnimalSpentPeriod(soap, tag, id, (enum vd__AnimalSpentPeriod *const*)ptr, "vd:AnimalSpentPeriod");
	case SOAP_TYPE_PointerToent__ResearchResult: return soap_out_PointerToent__ResearchResult(soap, tag, id, (enum ent__ResearchResult *const*)ptr, "ent:ResearchResult");
	case SOAP_TYPE_PointerToent__Purpose: return soap_out_PointerToent__Purpose(soap, tag, id, (ent__Purpose *const*)ptr, "ent:Purpose");
	case SOAP_TYPE_PointerToPointerTovd__Document: return soap_out_PointerToPointerTovd__Document(soap, tag, id, (vd__Document **const*)ptr, "vd:Document");
	case SOAP_TYPE_PointerTovd__Document: return soap_out_PointerTovd__Document(soap, tag, id, (vd__Document *const*)ptr, "vd:Document");
	case SOAP_TYPE_PointerToent__Organization: return soap_out_PointerToent__Organization(soap, tag, id, (ent__Organization *const*)ptr, "ent:Organization");
	case SOAP_TYPE_PointerToent__Location: return soap_out_PointerToent__Location(soap, tag, id, (ent__Location *const*)ptr, "ent:Location");
	case SOAP_TYPE_PointerTovd__VeterinaryEventType: return soap_out_PointerTovd__VeterinaryEventType(soap, tag, id, (enum vd__VeterinaryEventType *const*)ptr, "vd:VeterinaryEventType");
	case SOAP_TYPE_PointerTovd__ShipmentRoute: return soap_out_PointerTovd__ShipmentRoute(soap, tag, id, (vd__ShipmentRoute *const*)ptr, "vd:ShipmentRoute");
	case SOAP_TYPE_PointerToent__TransportationStorageType: return soap_out_PointerToent__TransportationStorageType(soap, tag, id, (enum ent__TransportationStorageType *const*)ptr, "ent:TransportationStorageType");
	case SOAP_TYPE_PointerTovd__TransportInfo: return soap_out_PointerTovd__TransportInfo(soap, tag, id, (vd__TransportInfo *const*)ptr, "vd:TransportInfo");
	case SOAP_TYPE_PointerTovd__Batch: return soap_out_PointerTovd__Batch(soap, tag, id, (vd__Batch *const*)ptr, "vd:Batch");
	case SOAP_TYPE_PointerToent__EnterpriseList: return soap_out_PointerToent__EnterpriseList(soap, tag, id, (ent__EnterpriseList *const*)ptr, "ent:EnterpriseList");
	case SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation: return soap_out_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, id, (_vd__BEActivityLocationsModificationOperation_activityLocation *const*)ptr, "vd:BEActivityLocationsModificationOperation-activityLocation");
	case SOAP_TYPE_PointerToent__GLNType: return soap_out_PointerToent__GLNType(soap, tag, id, (char **const*)ptr, "ent:GLNType");
	case SOAP_TYPE_PointerToent__BusinessEntityList: return soap_out_PointerToent__BusinessEntityList(soap, tag, id, (ent__BusinessEntityList *const*)ptr, "ent:BusinessEntityList");
	case SOAP_TYPE_PointerToent__ProductItemList: return soap_out_PointerToent__ProductItemList(soap, tag, id, (ent__ProductItemList *const*)ptr, "ent:ProductItemList");
	case SOAP_TYPE_PointerToPointerTovd__StockEntry: return soap_out_PointerToPointerTovd__StockEntry(soap, tag, id, (vd__StockEntry **const*)ptr, "vd:StockEntry");
	case SOAP_TYPE_PointerTobase__RegisterModificationType: return soap_out_PointerTobase__RegisterModificationType(soap, tag, id, (enum base__RegisterModificationType *const*)ptr, "base:RegisterModificationType");
	case SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure: return soap_out_PointerToPointerTovd__ProcessingProcedure(soap, tag, id, (vd__ProcessingProcedure **const*)ptr, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerTovd__ProcessingProcedure: return soap_out_PointerTovd__ProcessingProcedure(soap, tag, id, (vd__ProcessingProcedure *const*)ptr, "vd:ProcessingProcedure");
	case SOAP_TYPE_PointerToPointerTovd__ProductiveBatch: return soap_out_PointerToPointerTovd__ProductiveBatch(soap, tag, id, (vd__ProductiveBatch **const*)ptr, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerTovd__ProductiveBatch: return soap_out_PointerTovd__ProductiveBatch(soap, tag, id, (vd__ProductiveBatch *const*)ptr, "vd:ProductiveBatch");
	case SOAP_TYPE_PointerToPointerTovd__RawBatch: return soap_out_PointerToPointerTovd__RawBatch(soap, tag, id, (vd__RawBatch **const*)ptr, "vd:RawBatch");
	case SOAP_TYPE_PointerTovd__RawBatch: return soap_out_PointerTovd__RawBatch(soap, tag, id, (vd__RawBatch *const*)ptr, "vd:RawBatch");
	case SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint: return soap_out_PointerToPointerTovd__ShipmentRoutePoint(soap, tag, id, (vd__ShipmentRoutePoint **const*)ptr, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__ShipmentRoutePoint: return soap_out_PointerTovd__ShipmentRoutePoint(soap, tag, id, (vd__ShipmentRoutePoint *const*)ptr, "vd:ShipmentRoutePoint");
	case SOAP_TYPE_PointerTovd__TransportNumber: return soap_out_PointerTovd__TransportNumber(soap, tag, id, (vd__TransportNumber *const*)ptr, "vd:TransportNumber");
	case SOAP_TYPE_PointerToent__TransportType: return soap_out_PointerToent__TransportType(soap, tag, id, (enum ent__TransportType *const*)ptr, "ent:TransportType");
	case SOAP_TYPE_PointerTovd__StockEntryList: return soap_out_PointerTovd__StockEntryList(soap, tag, id, (vd__StockEntryList *const*)ptr, "vd:StockEntryList");
	case SOAP_TYPE_PointerToent__ComplexDate: return soap_out_PointerToent__ComplexDate(soap, tag, id, (ent__ComplexDate *const*)ptr, "ent:ComplexDate");
	case SOAP_TYPE_PointerToPointerTovd__ReferencedDocument: return soap_out_PointerToPointerTovd__ReferencedDocument(soap, tag, id, (vd__ReferencedDocument **const*)ptr, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerTovd__ReferencedDocument: return soap_out_PointerTovd__ReferencedDocument(soap, tag, id, (vd__ReferencedDocument *const*)ptr, "vd:ReferencedDocument");
	case SOAP_TYPE_PointerToPointerTovd__VetDocument: return soap_out_PointerToPointerTovd__VetDocument(soap, tag, id, (vd__VetDocument **const*)ptr, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__VetDocument: return soap_out_PointerTovd__VetDocument(soap, tag, id, (vd__VetDocument *const*)ptr, "vd:VetDocument");
	case SOAP_TYPE_PointerTovd__Waybill: return soap_out_PointerTovd__Waybill(soap, tag, id, (vd__Waybill *const*)ptr, "vd:Waybill");
	case SOAP_TYPE_PointerTovd__User: return soap_out_PointerTovd__User(soap, tag, id, (vd__User *const*)ptr, "vd:User");
	case SOAP_TYPE_PointerTovd__DeliveryInspection: return soap_out_PointerTovd__DeliveryInspection(soap, tag, id, (vd__DeliveryInspection *const*)ptr, "vd:DeliveryInspection");
	case SOAP_TYPE_PointerTovd__StockEntry: return soap_out_PointerTovd__StockEntry(soap, tag, id, (vd__StockEntry *const*)ptr, "vd:StockEntry");
	case SOAP_TYPE_PointerToent__PackageList: return soap_out_PointerToent__PackageList(soap, tag, id, (ent__PackageList *const*)ptr, "ent:PackageList");
	case SOAP_TYPE_PointerTovd__BatchOrigin: return soap_out_PointerTovd__BatchOrigin(soap, tag, id, (vd__BatchOrigin *const*)ptr, "vd:BatchOrigin");
	case SOAP_TYPE_PointerTovd__GoodsDate: return soap_out_PointerTovd__GoodsDate(soap, tag, id, (vd__GoodsDate *const*)ptr, "vd:GoodsDate");
	case SOAP_TYPE_PointerToent__ProductItem: return soap_out_PointerToent__ProductItem(soap, tag, id, (ent__ProductItem *const*)ptr, "ent:ProductItem");
	case SOAP_TYPE_PointerToent__SubProduct: return soap_out_PointerToent__SubProduct(soap, tag, id, (ent__SubProduct *const*)ptr, "ent:SubProduct");
	case SOAP_TYPE_PointerToent__Product: return soap_out_PointerToent__Product(soap, tag, id, (ent__Product *const*)ptr, "ent:Product");
	case SOAP_TYPE_PointerToent__ProductType: return soap_out_PointerToent__ProductType(soap, tag, id, (enum ent__ProductType *const*)ptr, "ent:ProductType");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationConditionGroup: return soap_out_PointerToPointerToent__RegionalizationConditionGroup(soap, tag, id, (ent__RegionalizationConditionGroup **const*)ptr, "ent:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerToent__RegionalizationConditionGroup: return soap_out_PointerToent__RegionalizationConditionGroup(soap, tag, id, (ent__RegionalizationConditionGroup *const*)ptr, "ent:RegionalizationConditionGroup");
	case SOAP_TYPE_PointerToent__AnimalDisease: return soap_out_PointerToent__AnimalDisease(soap, tag, id, (ent__AnimalDisease *const*)ptr, "ent:AnimalDisease");
	case SOAP_TYPE_PointerToPointerToent__RegionalizationCondition: return soap_out_PointerToPointerToent__RegionalizationCondition(soap, tag, id, (ent__RegionalizationCondition **const*)ptr, "ent:RegionalizationCondition");
	case SOAP_TYPE_PointerToent__RegionalizationCondition: return soap_out_PointerToent__RegionalizationCondition(soap, tag, id, (ent__RegionalizationCondition *const*)ptr, "ent:RegionalizationCondition");
	case SOAP_TYPE_PointerToent__BusinessMember: return soap_out_PointerToent__BusinessMember(soap, tag, id, (ent__BusinessMember *const*)ptr, "ent:BusinessMember");
	case SOAP_TYPE_PointerTobase__Identifier: return soap_out_PointerTobase__Identifier(soap, tag, id, (char **const*)ptr, "base:Identifier");
	case SOAP_TYPE_PointerToent__Address: return soap_out_PointerToent__Address(soap, tag, id, (ent__Address *const*)ptr, "ent:Address");
	case SOAP_TYPE_PointerToent__Unit: return soap_out_PointerToent__Unit(soap, tag, id, (ent__Unit *const*)ptr, "ent:Unit");
	case SOAP_TYPE_PointerTobase__Decimal: return soap_out_PointerTobase__Decimal(soap, tag, id, (char **const*)ptr, "base:Decimal");
	case SOAP_TYPE_PointerToent__Minute: return soap_out_PointerToent__Minute(soap, tag, id, (int *const*)ptr, "ent:Minute");
	case SOAP_TYPE_PointerToent__Hour: return soap_out_PointerToent__Hour(soap, tag, id, (int *const*)ptr, "ent:Hour");
	case SOAP_TYPE_PointerToent__Day: return soap_out_PointerToent__Day(soap, tag, id, (int *const*)ptr, "ent:Day");
	case SOAP_TYPE_PointerToent__Month: return soap_out_PointerToent__Month(soap, tag, id, (int *const*)ptr, "ent:Month");
	case SOAP_TYPE_PointerToent__Year: return soap_out_PointerToent__Year(soap, tag, id, (int *const*)ptr, "ent:Year");
	case SOAP_TYPE_PointerToPointerToent__Package: return soap_out_PointerToPointerToent__Package(soap, tag, id, (ent__Package **const*)ptr, "ent:Package");
	case SOAP_TYPE_PointerToent__Package: return soap_out_PointerToent__Package(soap, tag, id, (ent__Package *const*)ptr, "ent:Package");
	case SOAP_TYPE_PointerToPointerToent__ProductMarks: return soap_out_PointerToPointerToent__ProductMarks(soap, tag, id, (ent__ProductMarks **const*)ptr, "ent:ProductMarks");
	case SOAP_TYPE_PointerToent__ProductMarks: return soap_out_PointerToent__ProductMarks(soap, tag, id, (ent__ProductMarks *const*)ptr, "ent:ProductMarks");
	case SOAP_TYPE_PointerToent__PackingType: return soap_out_PointerToent__PackingType(soap, tag, id, (ent__PackingType *const*)ptr, "ent:PackingType");
	case SOAP_TYPE_PointerToent__BusinessEntity: return soap_out_PointerToent__BusinessEntity(soap, tag, id, (ent__BusinessEntity *const*)ptr, "ent:BusinessEntity");
	case SOAP_TYPE_PointerTobase__String255: return soap_out_PointerTobase__String255(soap, tag, id, (char **const*)ptr, "base:String255");
	case SOAP_TYPE_PointerToPointerToent__Producer: return soap_out_PointerToPointerToent__Producer(soap, tag, id, (ent__Producer **const*)ptr, "ent:Producer");
	case SOAP_TYPE_PointerToent__Producer: return soap_out_PointerToent__Producer(soap, tag, id, (ent__Producer *const*)ptr, "ent:Producer");
	case SOAP_TYPE_PointerToent__EnterpriseRole: return soap_out_PointerToent__EnterpriseRole(soap, tag, id, (enum ent__EnterpriseRole *const*)ptr, "ent:EnterpriseRole");
	case SOAP_TYPE_PointerToent__Enterprise: return soap_out_PointerToent__Enterprise(soap, tag, id, (ent__Enterprise *const*)ptr, "ent:Enterprise");
	case SOAP_TYPE_PointerTobase__NText: return soap_out_PointerTobase__NText(soap, tag, id, (char **const*)ptr, "base:NText");
	case SOAP_TYPE_PointerToent__Street: return soap_out_PointerToent__Street(soap, tag, id, (ent__Street *const*)ptr, "ent:Street");
	case SOAP_TYPE_PointerToent__Locality: return soap_out_PointerToent__Locality(soap, tag, id, (ent__Locality *const*)ptr, "ent:Locality");
	case SOAP_TYPE_PointerToent__District: return soap_out_PointerToent__District(soap, tag, id, (ent__District *const*)ptr, "ent:District");
	case SOAP_TYPE_PointerToent__Region: return soap_out_PointerToent__Region(soap, tag, id, (ent__Region *const*)ptr, "ent:Region");
	case SOAP_TYPE_PointerToent__FederalDistrict: return soap_out_PointerToent__FederalDistrict(soap, tag, id, (ent__FederalDistrict *const*)ptr, "ent:FederalDistrict");
	case SOAP_TYPE_PointerToent__Country: return soap_out_PointerToent__Country(soap, tag, id, (ent__Country *const*)ptr, "ent:Country");
	case SOAP_TYPE_PointerToPointerToapp__BusinessError: return soap_out_PointerToPointerToapp__BusinessError(soap, tag, id, (app__BusinessError **const*)ptr, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__BusinessError: return soap_out_PointerToapp__BusinessError(soap, tag, id, (app__BusinessError *const*)ptr, "app:BusinessError");
	case SOAP_TYPE_PointerToapp__ContentEncoding: return soap_out_PointerToapp__ContentEncoding(soap, tag, id, (enum app__ContentEncoding *const*)ptr, "app:ContentEncoding");
	case SOAP_TYPE_PointerToapp__BusinessErrorList: return soap_out_PointerToapp__BusinessErrorList(soap, tag, id, (app__BusinessErrorList *const*)ptr, "app:BusinessErrorList");
	case SOAP_TYPE_PointerToapp__ApplicationResultWrapper: return soap_out_PointerToapp__ApplicationResultWrapper(soap, tag, id, (app__ApplicationResultWrapper *const*)ptr, "app:ApplicationResultWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationDataWrapper: return soap_out_PointerToapp__ApplicationDataWrapper(soap, tag, id, (app__ApplicationDataWrapper *const*)ptr, "app:ApplicationDataWrapper");
	case SOAP_TYPE_PointerToapp__ApplicationStatus: return soap_out_PointerToapp__ApplicationStatus(soap, tag, id, (enum app__ApplicationStatus *const*)ptr, "app:ApplicationStatus");
	case SOAP_TYPE_PointerToPointerTobase__Error: return soap_out_PointerToPointerTobase__Error(soap, tag, id, (base__Error **const*)ptr, "base:Error");
	case SOAP_TYPE_PointerTobase__Error: return soap_out_PointerTobase__Error(soap, tag, id, (base__Error *const*)ptr, "base:Error");
	case SOAP_TYPE_PointerTobool: return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64: return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToint: return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTotime: return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToapp__Application: return soap_out_PointerToapp__Application(soap, tag, id, (app__Application *const*)ptr, "app:Application");
	case SOAP_TYPE_vd__VetDocumentStatusChangeReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "vd:VetDocumentStatusChangeReason");
	case SOAP_TYPE_ent__GRNType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:GRNType");
	case SOAP_TYPE_vd__SNILSType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "vd:SNILSType");
	case SOAP_TYPE_vd__StockEntryNumber: return soap_out_string(soap, tag, id, (char*const*)&ptr, "vd:StockEntryNumber");
	case SOAP_TYPE_ent__OTPToken: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:OTPToken");
	case SOAP_TYPE_ent__GTINType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:GTINType");
	case SOAP_TYPE_ent__GLNType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:GLNType");
	case SOAP_TYPE_ent__ENTModificationReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:ENTModificationReason");
	case SOAP_TYPE_ent__BEModificationReason: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:BEModificationReason");
	case SOAP_TYPE_ent__EnterpriseType: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:EnterpriseType");
	case SOAP_TYPE_ent__Code3: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:Code3");
	case SOAP_TYPE_ent__Code: return soap_out_string(soap, tag, id, (char*const*)&ptr, "ent:Code");
	case SOAP_TYPE_app__APIKey: return soap_out_string(soap, tag, id, (char*const*)&ptr, "app:APIKey");
	case SOAP_TYPE_base__SequenceNumber: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:SequenceNumber");
	case SOAP_TYPE_base__Identifier: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:Identifier");
	case SOAP_TYPE_base__VersionStatus: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:VersionStatus");
	case SOAP_TYPE_base__Decimal: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:Decimal");
	case SOAP_TYPE_base__String32: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:String32");
	case SOAP_TYPE_base__String255: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:String255");
	case SOAP_TYPE_base__NText: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:NText");
	case SOAP_TYPE_base__Text: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:Text");
	case SOAP_TYPE_base__UUID: return soap_out_string(soap, tag, id, (char*const*)&ptr, "base:UUID");
	case SOAP_TYPE_xsd__token: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__positiveInteger: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE_PointerTounsignedByte: return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__Name: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:Name");
	case SOAP_TYPE_xsd__NCName: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__IDREF: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:ID");
	case SOAP_TYPE__QName: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string: return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	switch(type) {
	case SOAP_TYPE__ent__BusinessEntity_activityLocation: ((_ent__BusinessEntity_activityLocation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation: ((_vd__BEActivityLocationsModificationOperation_activityLocation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__BinaryContent: soap_serialize_app__BinaryContent(soap, (const xsd__base64Binary *)ptr); break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse: ((_ns8__getResearchMethodChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest: ((_ns8__getResearchMethodChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodListResponse: ((_ns8__getResearchMethodListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodListRequest: ((_ns8__getResearchMethodListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse: ((_ns8__getResearchMethodByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest: ((_ns8__getResearchMethodByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse: ((_ns8__getResearchMethodByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest: ((_ns8__getResearchMethodByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse: ((_ns8__getDiseaseChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest: ((_ns8__getDiseaseChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseListResponse: ((_ns8__getDiseaseListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseListRequest: ((_ns8__getDiseaseListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse: ((_ns8__getDiseaseByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest: ((_ns8__getDiseaseByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse: ((_ns8__getDiseaseByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest: ((_ns8__getDiseaseByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse: ((_ns8__getActualR13nShippingRuleListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest: ((_ns8__getActualR13nShippingRuleListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse: ((_ns8__getActualR13nRegionStatusListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest: ((_ns8__getActualR13nRegionStatusListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getR13nConditionListResponse: ((_ns8__getR13nConditionListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getR13nConditionListRequest: ((_ns8__getR13nConditionListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActivityLocationListResponse: ((_ns8__getActivityLocationListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getActivityLocationListRequest: ((_ns8__getActivityLocationListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse: ((_ns8__getBusinessMemberByGLNResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest: ((_ns8__getBusinessMemberByGLNRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse: ((_ns8__getBusinessEntityChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest: ((_ns8__getBusinessEntityChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityListResponse: ((_ns8__getBusinessEntityListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityListRequest: ((_ns8__getBusinessEntityListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse: ((_ns8__getBusinessEntityByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest: ((_ns8__getBusinessEntityByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse: ((_ns8__getBusinessEntityByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest: ((_ns8__getBusinessEntityByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse: ((_ns8__getRussianEnterpriseChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest: ((_ns8__getRussianEnterpriseChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse: ((_ns8__getForeignEnterpriseChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest: ((_ns8__getForeignEnterpriseChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse: ((_ns8__getRussianEnterpriseListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest: ((_ns8__getRussianEnterpriseListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse: ((_ns8__getForeignEnterpriseListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest: ((_ns8__getForeignEnterpriseListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse: ((_ns8__getEnterpriseByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest: ((_ns8__getEnterpriseByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse: ((_ns8__getEnterpriseByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest: ((_ns8__getEnterpriseByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findStreetListByNameResponse: ((_ns8__findStreetListByNameResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findStreetListByNameRequest: ((_ns8__findStreetListByNameRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findLocalityListByNameResponse: ((_ns8__findLocalityListByNameResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__findLocalityListByNameRequest: ((_ns8__findLocalityListByNameRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse: ((_ns8__getStreetListByLocalityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest: ((_ns8__getStreetListByLocalityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse: ((_ns8__getLocalityListByLocalityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest: ((_ns8__getLocalityListByLocalityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse: ((_ns8__getLocalityListByDistrictResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest: ((_ns8__getLocalityListByDistrictRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse: ((_ns8__getLocalityListByRegionResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest: ((_ns8__getLocalityListByRegionRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictChangesListResponse: ((_ns8__getDistrictChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictChangesListRequest: ((_ns8__getDistrictChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByUuidResponse: ((_ns8__getDistrictByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByUuidRequest: ((_ns8__getDistrictByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByGuidResponse: ((_ns8__getDistrictByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictByGuidRequest: ((_ns8__getDistrictByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse: ((_ns8__getDistrictListByRegionResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest: ((_ns8__getDistrictListByRegionRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionChangesListResponse: ((_ns8__getRegionChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionChangesListRequest: ((_ns8__getRegionChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByUuidResponse: ((_ns8__getRegionByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByUuidRequest: ((_ns8__getRegionByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByGuidResponse: ((_ns8__getRegionByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionByGuidRequest: ((_ns8__getRegionByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionListByCountryResponse: ((_ns8__getRegionListByCountryResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getRegionListByCountryRequest: ((_ns8__getRegionListByCountryRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryChangesListResponse: ((_ns8__getCountryChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryChangesListRequest: ((_ns8__getCountryChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByUuidResponse: ((_ns8__getCountryByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByUuidRequest: ((_ns8__getCountryByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByGuidResponse: ((_ns8__getCountryByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getCountryByGuidRequest: ((_ns8__getCountryByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getAllCountryListResponse: ((_ns8__getAllCountryListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getAllCountryListRequest: ((_ns8__getAllCountryListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemChangesListResponse: ((_ns8__getProductItemChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemChangesListRequest: ((_ns8__getProductItemChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemListResponse: ((_ns8__getProductItemListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemListRequest: ((_ns8__getProductItemListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByUuidResponse: ((_ns8__getProductItemByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByUuidRequest: ((_ns8__getProductItemByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByGuidResponse: ((_ns8__getProductItemByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductItemByGuidRequest: ((_ns8__getProductItemByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductChangesListResponse: ((_ns8__getSubProductChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductChangesListRequest: ((_ns8__getSubProductChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByProductListResponse: ((_ns8__getSubProductByProductListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByProductListRequest: ((_ns8__getSubProductByProductListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByUuidResponse: ((_ns8__getSubProductByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByUuidRequest: ((_ns8__getSubProductByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByGuidResponse: ((_ns8__getSubProductByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getSubProductByGuidRequest: ((_ns8__getSubProductByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductChangesListResponse: ((_ns8__getProductChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductChangesListRequest: ((_ns8__getProductChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByTypeListResponse: ((_ns8__getProductByTypeListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByTypeListRequest: ((_ns8__getProductByTypeListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByUuidResponse: ((_ns8__getProductByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByUuidRequest: ((_ns8__getProductByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByGuidResponse: ((_ns8__getProductByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getProductByGuidRequest: ((_ns8__getProductByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitChangesListResponse: ((_ns8__getUnitChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitChangesListRequest: ((_ns8__getUnitChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitListResponse: ((_ns8__getUnitListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitListRequest: ((_ns8__getUnitListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByUuidResponse: ((_ns8__getUnitByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByUuidRequest: ((_ns8__getUnitByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByGuidResponse: ((_ns8__getUnitByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getUnitByGuidRequest: ((_ns8__getUnitByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeChangesListResponse: ((_ns8__getPurposeChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeChangesListRequest: ((_ns8__getPurposeChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeListResponse: ((_ns8__getPurposeListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeListRequest: ((_ns8__getPurposeListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByUuidResponse: ((_ns8__getPurposeByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByUuidRequest: ((_ns8__getPurposeByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByGuidResponse: ((_ns8__getPurposeByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ns8__getPurposeByGuidRequest: ((_ns8__getPurposeByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__WorkingArea: ((vd__WorkingArea *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__UserAuthority: ((vd__UserAuthority *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__WorkingAreaList: ((vd__WorkingAreaList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__AuthorityList: ((vd__AuthorityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__UserList: ((vd__UserList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__User: ((vd__User *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ProcessingProcedure: ((vd__ProcessingProcedure *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__RouteSectionR13nRules: ((vd__RouteSectionR13nRules *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__RegionalizationClause: ((vd__RegionalizationClause *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VetDocumentStatusChange: ((vd__VetDocumentStatusChange *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntryEventList: ((vd__StockEntryEventList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__BatchOrigin: ((vd__BatchOrigin *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VeterinaryAuthentication: ((vd__VeterinaryAuthentication *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__QuarantineEvent: ((vd__QuarantineEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__AnimalMedicationEvent: ((vd__AnimalMedicationEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__LaboratoryResearchEvent: ((vd__LaboratoryResearchEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VeterinaryEvent: ((vd__VeterinaryEvent *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ReferencedDocument: ((vd__ReferencedDocument *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__CertifiedConsignment: ((vd__CertifiedConsignment *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__CertifiedBatch: ((vd__CertifiedBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ENTModificationOperation: ((vd__ENTModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: ((vd__BEActivityLocationsModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__BEModificationOperation: ((vd__BEModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__PSLModificationOperation: ((vd__PSLModificationOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__MergeStockEntriesOperation: ((vd__MergeStockEntriesOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ProductionOperation: ((vd__ProductionOperation *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ShipmentRoute: ((vd__ShipmentRoute *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ShipmentRoutePoint: ((vd__ShipmentRoutePoint *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__TransportNumber: ((vd__TransportNumber *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__TransportInfo: ((vd__TransportInfo *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Waybill: ((vd__Waybill *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Document: ((vd__Document *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntrySearchPattern: ((vd__StockEntrySearchPattern *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockDiscrepancy: ((vd__StockDiscrepancy *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntryList: ((vd__StockEntryList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__StockEntry: ((vd__StockEntry *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DiscrepancyReason: ((vd__DiscrepancyReason *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DiscrepancyReport: ((vd__DiscrepancyReport *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VetDocumentList: ((vd__VetDocumentList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__GoodsDate: ((vd__GoodsDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ConsignmentDocumentList: ((vd__ConsignmentDocumentList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DeliveryInspection: ((vd__DeliveryInspection *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__DeliveryFactList: ((vd__DeliveryFactList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Delivery: ((vd__Delivery *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__ProductiveBatch: ((vd__ProductiveBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__RawBatch: ((vd__RawBatch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Consignment: ((vd__Consignment *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__Batch: ((vd__Batch *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_vd__VetDocument: ((vd__VetDocument *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ActivityLocationList: ((ent__ActivityLocationList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ResearchMethodList: ((ent__ResearchMethodList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__AnimalDiseaseList: ((ent__AnimalDiseaseList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationShippingRuleList: ((ent__RegionalizationShippingRuleList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationRegionStatusList: ((ent__RegionalizationRegionStatusList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationConditionList: ((ent__RegionalizationConditionList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Area: ((ent__Area *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationRegionStatus: ((ent__RegionalizationRegionStatus *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationStatus: ((ent__RegionalizationStatus *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationShippingRule: ((ent__RegionalizationShippingRule *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationRequirement: ((ent__RegionalizationRequirement *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationConditionGroup: ((ent__RegionalizationConditionGroup *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionalizationCondition: ((ent__RegionalizationCondition *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__MedicinalDrug: ((ent__MedicinalDrug *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ResearchMethod: ((ent__ResearchMethod *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__AnimalDisease: ((ent__AnimalDisease *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Indicator: ((ent__Indicator *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Organization: ((ent__Organization *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__EnterpriseOfficialRegistration: ((ent__EnterpriseOfficialRegistration *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Location: ((ent__Location *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Packaging: ((ent__Packaging *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ProductItemProducing: ((ent__ProductItemProducing *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ComplexDate: ((ent__ComplexDate *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__PackageList: ((ent__PackageList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Package: ((ent__Package *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ProductMarks: ((ent__ProductMarks *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ProductItemList: ((ent__ProductItemList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__SubProductList: ((ent__SubProductList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ProductList: ((ent__ProductList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__SubProduct: ((ent__SubProduct *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Product: ((ent__Product *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ProductItem: ((ent__ProductItem *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__BusinessEntityList: ((ent__BusinessEntityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__IncorporationForm: ((ent__IncorporationForm *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__BusinessEntity: ((ent__BusinessEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__BusinessMember: ((ent__BusinessMember *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__EnterpriseList: ((ent__EnterpriseList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__EnterpriseNumberList: ((ent__EnterpriseNumberList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__ProducerList: ((ent__ProducerList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Producer: ((ent__Producer *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__EnterpriseActivity: ((ent__EnterpriseActivity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__EnterpriseActivityList: ((ent__EnterpriseActivityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Enterprise: ((ent__Enterprise *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__StreetList: ((ent__StreetList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__LocalityList: ((ent__LocalityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__DistrictList: ((ent__DistrictList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__RegionList: ((ent__RegionList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__CountryList: ((ent__CountryList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Address: ((ent__Address *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Street: ((ent__Street *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Locality: ((ent__Locality *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__District: ((ent__District *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Region: ((ent__Region *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__AddressObjectView: ((ent__AddressObjectView *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__FederalDistrict: ((ent__FederalDistrict *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Country: ((ent__Country *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__UnitList: ((ent__UnitList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__PurposeList: ((ent__PurposeList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__PackingType: ((ent__PackingType *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Unit: ((ent__Unit *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_ent__Purpose: ((ent__Purpose *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse: ((merc__GetAppliedUserAuthorityListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest: ((merc__GetAppliedUserAuthorityListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UnbindBusinessEntityUserResponse: ((merc__UnbindBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UnbindBusinessEntityUserRequest: ((merc__UnbindBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateUserWorkingAreasResponse: ((merc__UpdateUserWorkingAreasResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateUserWorkingAreasRequest: ((merc__UpdateUserWorkingAreasRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateUserAuthoritiesResponse: ((merc__UpdateUserAuthoritiesResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateUserAuthoritiesRequest: ((merc__UpdateUserAuthoritiesRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetBusinessEntityUserResponse: ((merc__GetBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetBusinessEntityUserRequest: ((merc__GetBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetBusinessEntityUserListResponse: ((merc__GetBusinessEntityUserListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetBusinessEntityUserListRequest: ((merc__GetBusinessEntityUserListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__AddBusinessEntityUserResponse: ((merc__AddBusinessEntityUserResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__AddBusinessEntityUserRequest: ((merc__AddBusinessEntityUserRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__CheckShipmentRegionalizationResponse: ((merc__CheckShipmentRegionalizationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__CheckShipmentRegionalizationRequest: ((merc__CheckShipmentRegionalizationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateVeterinaryEventsResponse: ((merc__UpdateVeterinaryEventsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateVeterinaryEventsRequest: ((merc__UpdateVeterinaryEventsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse: ((merc__UpdateTransportMovementDetailsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest: ((merc__UpdateTransportMovementDetailsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryVersionListResponse: ((merc__GetStockEntryVersionListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryVersionListRequest: ((merc__GetStockEntryVersionListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryListResponse: ((merc__GetStockEntryListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryListRequest: ((merc__GetStockEntryListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryChangesListResponse: ((merc__GetStockEntryChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryChangesListRequest: ((merc__GetStockEntryChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryByUuidResponse: ((merc__GetStockEntryByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryByUuidRequest: ((merc__GetStockEntryByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryByGuidResponse: ((merc__GetStockEntryByGuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetStockEntryByGuidRequest: ((merc__GetStockEntryByGuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetVetDocumentChangesListResponse: ((merc__GetVetDocumentChangesListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetVetDocumentChangesListRequest: ((merc__GetVetDocumentChangesListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetVetDocumentListResponse: ((merc__GetVetDocumentListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetVetDocumentListRequest: ((merc__GetVetDocumentListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetVetDocumentByUuidResponse: ((merc__GetVetDocumentByUuidResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__GetVetDocumentByUuidRequest: ((merc__GetVetDocumentByUuidRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyProducerStockListResponse: ((merc__ModifyProducerStockListResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyProducerStockListRequest: ((merc__ModifyProducerStockListRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ResolveDiscrepancyResponse: ((merc__ResolveDiscrepancyResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ResolveDiscrepancyRequest: ((merc__ResolveDiscrepancyRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyActivityLocationsResponse: ((merc__ModifyActivityLocationsResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyActivityLocationsRequest: ((merc__ModifyActivityLocationsRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyEnterpriseResponse: ((merc__ModifyEnterpriseResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyEnterpriseRequest: ((merc__ModifyEnterpriseRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyBusinessEntityResponse: ((merc__ModifyBusinessEntityResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ModifyBusinessEntityRequest: ((merc__ModifyBusinessEntityRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__WithdrawVetDocumentResponse: ((merc__WithdrawVetDocumentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__WithdrawVetDocumentRequest: ((merc__WithdrawVetDocumentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__MergeStockEntriesResponse: ((merc__MergeStockEntriesResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__MergeStockEntriesRequest: ((merc__MergeStockEntriesRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__RegisterProductionOperationResponse: ((merc__RegisterProductionOperationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__RegisterProductionOperationRequest: ((merc__RegisterProductionOperationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse: ((merc__PrepareOutgoingConsignmentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest: ((merc__PrepareOutgoingConsignmentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ProcessIncomingConsignmentResponse: ((merc__ProcessIncomingConsignmentResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__ProcessIncomingConsignmentRequest: ((merc__ProcessIncomingConsignmentRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_merc__MercuryApplicationRequest: ((merc__MercuryApplicationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__BusinessError: ((app__BusinessError *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__BusinessErrorList: ((app__BusinessErrorList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationResultData: ((app__ApplicationResultData *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationData: ((app__ApplicationData *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationResultWrapper: ((app__ApplicationResultWrapper *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__ApplicationDataWrapper: ((app__ApplicationDataWrapper *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_app__Application: ((app__Application *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__Error: ((base__Error *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__FaultInfo: ((base__FaultInfo *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__EntityList: ((base__EntityList *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__DateInterval: ((base__DateInterval *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__ListOptions: ((base__ListOptions *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__GenericVersioningEntity: ((base__GenericVersioningEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_base__GenericEntity: ((base__GenericEntity *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__receiveApplicationResultResponse: ((_ws__receiveApplicationResultResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__receiveApplicationResultRequest: ((_ws__receiveApplicationResultRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__submitApplicationResponse: ((_ws__submitApplicationResponse *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE__ws__submitApplicationRequest: ((_ws__submitApplicationRequest *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE_xsd__base64Binary: ((xsd__base64Binary *)ptr)->soap_serialize(soap); break;
	case SOAP_TYPE___ns4__getAppliedUserAuthorityListRequest: soap_serialize___ns4__getAppliedUserAuthorityListRequest(soap, (const struct __ns4__getAppliedUserAuthorityListRequest *)ptr); break;
	case SOAP_TYPE___ns4__unbindBusinessEntityUserRequest: soap_serialize___ns4__unbindBusinessEntityUserRequest(soap, (const struct __ns4__unbindBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___ns4__updateUserWorkingAreasRequest: soap_serialize___ns4__updateUserWorkingAreasRequest(soap, (const struct __ns4__updateUserWorkingAreasRequest *)ptr); break;
	case SOAP_TYPE___ns4__updateUserAuthoritiesRequest: soap_serialize___ns4__updateUserAuthoritiesRequest(soap, (const struct __ns4__updateUserAuthoritiesRequest *)ptr); break;
	case SOAP_TYPE___ns4__getBusinessEntityUserRequest: soap_serialize___ns4__getBusinessEntityUserRequest(soap, (const struct __ns4__getBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___ns4__getBusinessEntityUserListRequest: soap_serialize___ns4__getBusinessEntityUserListRequest(soap, (const struct __ns4__getBusinessEntityUserListRequest *)ptr); break;
	case SOAP_TYPE___ns4__addBusinessEntityUserRequest: soap_serialize___ns4__addBusinessEntityUserRequest(soap, (const struct __ns4__addBusinessEntityUserRequest *)ptr); break;
	case SOAP_TYPE___ns4__checkShipmentRegionalizationRequest: soap_serialize___ns4__checkShipmentRegionalizationRequest(soap, (const struct __ns4__checkShipmentRegionalizationRequest *)ptr); break;
	case SOAP_TYPE___ns4__updateVeterinaryEventsRequest: soap_serialize___ns4__updateVeterinaryEventsRequest(soap, (const struct __ns4__updateVeterinaryEventsRequest *)ptr); break;
	case SOAP_TYPE___ns4__updateTransportMovementDetailsRequest: soap_serialize___ns4__updateTransportMovementDetailsRequest(soap, (const struct __ns4__updateTransportMovementDetailsRequest *)ptr); break;
	case SOAP_TYPE___ns4__getStockEntryVersionListRequest: soap_serialize___ns4__getStockEntryVersionListRequest(soap, (const struct __ns4__getStockEntryVersionListRequest *)ptr); break;
	case SOAP_TYPE___ns4__getStockEntryChangesListRequest: soap_serialize___ns4__getStockEntryChangesListRequest(soap, (const struct __ns4__getStockEntryChangesListRequest *)ptr); break;
	case SOAP_TYPE___ns4__getStockEntryListRequest: soap_serialize___ns4__getStockEntryListRequest(soap, (const struct __ns4__getStockEntryListRequest *)ptr); break;
	case SOAP_TYPE___ns4__getStockEntryByUuidRequest: soap_serialize___ns4__getStockEntryByUuidRequest(soap, (const struct __ns4__getStockEntryByUuidRequest *)ptr); break;
	case SOAP_TYPE___ns4__getStockEntryByGuidRequest: soap_serialize___ns4__getStockEntryByGuidRequest(soap, (const struct __ns4__getStockEntryByGuidRequest *)ptr); break;
	case SOAP_TYPE___ns4__getVetDocumentChangesListRequest: soap_serialize___ns4__getVetDocumentChangesListRequest(soap, (const struct __ns4__getVetDocumentChangesListRequest *)ptr); break;
	case SOAP_TYPE___ns4__getVetDocumentListRequest: soap_serialize___ns4__getVetDocumentListRequest(soap, (const struct __ns4__getVetDocumentListRequest *)ptr); break;
	case SOAP_TYPE___ns4__getVetDocumentByUuidRequest: soap_serialize___ns4__getVetDocumentByUuidRequest(soap, (const struct __ns4__getVetDocumentByUuidRequest *)ptr); break;
	case SOAP_TYPE___ns4__modifyProducerStockListRequest: soap_serialize___ns4__modifyProducerStockListRequest(soap, (const struct __ns4__modifyProducerStockListRequest *)ptr); break;
	case SOAP_TYPE___ns4__resolveDiscrepancyRequest: soap_serialize___ns4__resolveDiscrepancyRequest(soap, (const struct __ns4__resolveDiscrepancyRequest *)ptr); break;
	case SOAP_TYPE___ns4__modifyActivityLocationsRequest: soap_serialize___ns4__modifyActivityLocationsRequest(soap, (const struct __ns4__modifyActivityLocationsRequest *)ptr); break;
	case SOAP_TYPE___ns4__modifyEnterpriseRequest: soap_serialize___ns4__modifyEnterpriseRequest(soap, (const struct __ns4__modifyEnterpriseRequest *)ptr); break;
	case SOAP_TYPE___ns4__modifyBusinessEntityRequest: soap_serialize___ns4__modifyBusinessEntityRequest(soap, (const struct __ns4__modifyBusinessEntityRequest *)ptr); break;
	case SOAP_TYPE___ns4__withdrawVetDocumentRequest: soap_serialize___ns4__withdrawVetDocumentRequest(soap, (const struct __ns4__withdrawVetDocumentRequest *)ptr); break;
	case SOAP_TYPE___ns4__mergeStockEntriesRequest: soap_serialize___ns4__mergeStockEntriesRequest(soap, (const struct __ns4__mergeStockEntriesRequest *)ptr); break;
	case SOAP_TYPE___ns4__registerProductionOperationRequest: soap_serialize___ns4__registerProductionOperationRequest(soap, (const struct __ns4__registerProductionOperationRequest *)ptr); break;
	case SOAP_TYPE___ns4__prepareOutgoingConsignmentRequest: soap_serialize___ns4__prepareOutgoingConsignmentRequest(soap, (const struct __ns4__prepareOutgoingConsignmentRequest *)ptr); break;
	case SOAP_TYPE___ns4__processIncomingConsignmentRequest: soap_serialize___ns4__processIncomingConsignmentRequest(soap, (const struct __ns4__processIncomingConsignmentRequest *)ptr); break;
	case SOAP_TYPE___ns3__receiveApplicationResult: soap_serialize___ns3__receiveApplicationResult(soap, (const struct __ns3__receiveApplicationResult *)ptr); break;
	case SOAP_TYPE___ns3__submitApplicationRequest: soap_serialize___ns3__submitApplicationRequest(soap, (const struct __ns3__submitApplicationRequest *)ptr); break;
	case SOAP_TYPE___ns2__GetProductItemChangesList: soap_serialize___ns2__GetProductItemChangesList(soap, (const struct __ns2__GetProductItemChangesList *)ptr); break;
	case SOAP_TYPE___ns2__GetProductItemList: soap_serialize___ns2__GetProductItemList(soap, (const struct __ns2__GetProductItemList *)ptr); break;
	case SOAP_TYPE___ns2__GetProductItemByUuid: soap_serialize___ns2__GetProductItemByUuid(soap, (const struct __ns2__GetProductItemByUuid *)ptr); break;
	case SOAP_TYPE___ns2__GetProductItemByGuid: soap_serialize___ns2__GetProductItemByGuid(soap, (const struct __ns2__GetProductItemByGuid *)ptr); break;
	case SOAP_TYPE___ns2__GetSubProductChangesList: soap_serialize___ns2__GetSubProductChangesList(soap, (const struct __ns2__GetSubProductChangesList *)ptr); break;
	case SOAP_TYPE___ns2__GetSubProductByProductList: soap_serialize___ns2__GetSubProductByProductList(soap, (const struct __ns2__GetSubProductByProductList *)ptr); break;
	case SOAP_TYPE___ns2__GetSubProductByUuid: soap_serialize___ns2__GetSubProductByUuid(soap, (const struct __ns2__GetSubProductByUuid *)ptr); break;
	case SOAP_TYPE___ns2__GetSubProductByGuid: soap_serialize___ns2__GetSubProductByGuid(soap, (const struct __ns2__GetSubProductByGuid *)ptr); break;
	case SOAP_TYPE___ns2__GetProductChangesList: soap_serialize___ns2__GetProductChangesList(soap, (const struct __ns2__GetProductChangesList *)ptr); break;
	case SOAP_TYPE___ns2__GetProductByTypeList: soap_serialize___ns2__GetProductByTypeList(soap, (const struct __ns2__GetProductByTypeList *)ptr); break;
	case SOAP_TYPE___ns2__GetProductByUuid: soap_serialize___ns2__GetProductByUuid(soap, (const struct __ns2__GetProductByUuid *)ptr); break;
	case SOAP_TYPE___ns2__GetProductByGuid: soap_serialize___ns2__GetProductByGuid(soap, (const struct __ns2__GetProductByGuid *)ptr); break;
	case SOAP_TYPE___ns1__GetActivityLocationList: soap_serialize___ns1__GetActivityLocationList(soap, (const struct __ns1__GetActivityLocationList *)ptr); break;
	case SOAP_TYPE___ns1__GetBusinessMemberByGLN: soap_serialize___ns1__GetBusinessMemberByGLN(soap, (const struct __ns1__GetBusinessMemberByGLN *)ptr); break;
	case SOAP_TYPE___ns1__GetRussianEnterpriseChangesList: soap_serialize___ns1__GetRussianEnterpriseChangesList(soap, (const struct __ns1__GetRussianEnterpriseChangesList *)ptr); break;
	case SOAP_TYPE___ns1__GetForeignEnterpriseChangesList: soap_serialize___ns1__GetForeignEnterpriseChangesList(soap, (const struct __ns1__GetForeignEnterpriseChangesList *)ptr); break;
	case SOAP_TYPE___ns1__GetRussianEnterpriseList: soap_serialize___ns1__GetRussianEnterpriseList(soap, (const struct __ns1__GetRussianEnterpriseList *)ptr); break;
	case SOAP_TYPE___ns1__GetForeignEnterpriseList: soap_serialize___ns1__GetForeignEnterpriseList(soap, (const struct __ns1__GetForeignEnterpriseList *)ptr); break;
	case SOAP_TYPE___ns1__GetEnterpriseByUuid: soap_serialize___ns1__GetEnterpriseByUuid(soap, (const struct __ns1__GetEnterpriseByUuid *)ptr); break;
	case SOAP_TYPE___ns1__GetEnterpriseByGuid: soap_serialize___ns1__GetEnterpriseByGuid(soap, (const struct __ns1__GetEnterpriseByGuid *)ptr); break;
	case SOAP_TYPE___ns1__GetBusinessEntityChangesList: soap_serialize___ns1__GetBusinessEntityChangesList(soap, (const struct __ns1__GetBusinessEntityChangesList *)ptr); break;
	case SOAP_TYPE___ns1__GetBusinessEntityList: soap_serialize___ns1__GetBusinessEntityList(soap, (const struct __ns1__GetBusinessEntityList *)ptr); break;
	case SOAP_TYPE___ns1__GetBusinessEntityByUuid: soap_serialize___ns1__GetBusinessEntityByUuid(soap, (const struct __ns1__GetBusinessEntityByUuid *)ptr); break;
	case SOAP_TYPE___ns1__GetBusinessEntityByGuid: soap_serialize___ns1__GetBusinessEntityByGuid(soap, (const struct __ns1__GetBusinessEntityByGuid *)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListResponse: soap_serialize_PointerTomerc__GetAppliedUserAuthorityListResponse(soap, (merc__GetAppliedUserAuthorityListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListRequest: soap_serialize_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, (merc__GetAppliedUserAuthorityListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserResponse: soap_serialize_PointerTomerc__UnbindBusinessEntityUserResponse(soap, (merc__UnbindBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserRequest: soap_serialize_PointerTomerc__UnbindBusinessEntityUserRequest(soap, (merc__UnbindBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasResponse: soap_serialize_PointerTomerc__UpdateUserWorkingAreasResponse(soap, (merc__UpdateUserWorkingAreasResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasRequest: soap_serialize_PointerTomerc__UpdateUserWorkingAreasRequest(soap, (merc__UpdateUserWorkingAreasRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesResponse: soap_serialize_PointerTomerc__UpdateUserAuthoritiesResponse(soap, (merc__UpdateUserAuthoritiesResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesRequest: soap_serialize_PointerTomerc__UpdateUserAuthoritiesRequest(soap, (merc__UpdateUserAuthoritiesRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserResponse: soap_serialize_PointerTomerc__GetBusinessEntityUserResponse(soap, (merc__GetBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserRequest: soap_serialize_PointerTomerc__GetBusinessEntityUserRequest(soap, (merc__GetBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListResponse: soap_serialize_PointerTomerc__GetBusinessEntityUserListResponse(soap, (merc__GetBusinessEntityUserListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListRequest: soap_serialize_PointerTomerc__GetBusinessEntityUserListRequest(soap, (merc__GetBusinessEntityUserListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__AddBusinessEntityUserResponse: soap_serialize_PointerTomerc__AddBusinessEntityUserResponse(soap, (merc__AddBusinessEntityUserResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__AddBusinessEntityUserRequest: soap_serialize_PointerTomerc__AddBusinessEntityUserRequest(soap, (merc__AddBusinessEntityUserRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationResponse: soap_serialize_PointerTomerc__CheckShipmentRegionalizationResponse(soap, (merc__CheckShipmentRegionalizationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationRequest: soap_serialize_PointerTomerc__CheckShipmentRegionalizationRequest(soap, (merc__CheckShipmentRegionalizationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsResponse: soap_serialize_PointerTomerc__UpdateVeterinaryEventsResponse(soap, (merc__UpdateVeterinaryEventsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsRequest: soap_serialize_PointerTomerc__UpdateVeterinaryEventsRequest(soap, (merc__UpdateVeterinaryEventsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsResponse: soap_serialize_PointerTomerc__UpdateTransportMovementDetailsResponse(soap, (merc__UpdateTransportMovementDetailsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsRequest: soap_serialize_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, (merc__UpdateTransportMovementDetailsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryVersionListResponse: soap_serialize_PointerTomerc__GetStockEntryVersionListResponse(soap, (merc__GetStockEntryVersionListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryVersionListRequest: soap_serialize_PointerTomerc__GetStockEntryVersionListRequest(soap, (merc__GetStockEntryVersionListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryChangesListResponse: soap_serialize_PointerTomerc__GetStockEntryChangesListResponse(soap, (merc__GetStockEntryChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryChangesListRequest: soap_serialize_PointerTomerc__GetStockEntryChangesListRequest(soap, (merc__GetStockEntryChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryListResponse: soap_serialize_PointerTomerc__GetStockEntryListResponse(soap, (merc__GetStockEntryListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryListRequest: soap_serialize_PointerTomerc__GetStockEntryListRequest(soap, (merc__GetStockEntryListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryByUuidResponse: soap_serialize_PointerTomerc__GetStockEntryByUuidResponse(soap, (merc__GetStockEntryByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryByUuidRequest: soap_serialize_PointerTomerc__GetStockEntryByUuidRequest(soap, (merc__GetStockEntryByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryByGuidResponse: soap_serialize_PointerTomerc__GetStockEntryByGuidResponse(soap, (merc__GetStockEntryByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetStockEntryByGuidRequest: soap_serialize_PointerTomerc__GetStockEntryByGuidRequest(soap, (merc__GetStockEntryByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListResponse: soap_serialize_PointerTomerc__GetVetDocumentChangesListResponse(soap, (merc__GetVetDocumentChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListRequest: soap_serialize_PointerTomerc__GetVetDocumentChangesListRequest(soap, (merc__GetVetDocumentChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetVetDocumentListResponse: soap_serialize_PointerTomerc__GetVetDocumentListResponse(soap, (merc__GetVetDocumentListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetVetDocumentListRequest: soap_serialize_PointerTomerc__GetVetDocumentListRequest(soap, (merc__GetVetDocumentListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidResponse: soap_serialize_PointerTomerc__GetVetDocumentByUuidResponse(soap, (merc__GetVetDocumentByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidRequest: soap_serialize_PointerTomerc__GetVetDocumentByUuidRequest(soap, (merc__GetVetDocumentByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyProducerStockListResponse: soap_serialize_PointerTomerc__ModifyProducerStockListResponse(soap, (merc__ModifyProducerStockListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyProducerStockListRequest: soap_serialize_PointerTomerc__ModifyProducerStockListRequest(soap, (merc__ModifyProducerStockListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ResolveDiscrepancyResponse: soap_serialize_PointerTomerc__ResolveDiscrepancyResponse(soap, (merc__ResolveDiscrepancyResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ResolveDiscrepancyRequest: soap_serialize_PointerTomerc__ResolveDiscrepancyRequest(soap, (merc__ResolveDiscrepancyRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyActivityLocationsResponse: soap_serialize_PointerTomerc__ModifyActivityLocationsResponse(soap, (merc__ModifyActivityLocationsResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyActivityLocationsRequest: soap_serialize_PointerTomerc__ModifyActivityLocationsRequest(soap, (merc__ModifyActivityLocationsRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyEnterpriseResponse: soap_serialize_PointerTomerc__ModifyEnterpriseResponse(soap, (merc__ModifyEnterpriseResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyEnterpriseRequest: soap_serialize_PointerTomerc__ModifyEnterpriseRequest(soap, (merc__ModifyEnterpriseRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyBusinessEntityResponse: soap_serialize_PointerTomerc__ModifyBusinessEntityResponse(soap, (merc__ModifyBusinessEntityResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ModifyBusinessEntityRequest: soap_serialize_PointerTomerc__ModifyBusinessEntityRequest(soap, (merc__ModifyBusinessEntityRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__WithdrawVetDocumentResponse: soap_serialize_PointerTomerc__WithdrawVetDocumentResponse(soap, (merc__WithdrawVetDocumentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__WithdrawVetDocumentRequest: soap_serialize_PointerTomerc__WithdrawVetDocumentRequest(soap, (merc__WithdrawVetDocumentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__MergeStockEntriesResponse: soap_serialize_PointerTomerc__MergeStockEntriesResponse(soap, (merc__MergeStockEntriesResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__MergeStockEntriesRequest: soap_serialize_PointerTomerc__MergeStockEntriesRequest(soap, (merc__MergeStockEntriesRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__RegisterProductionOperationResponse: soap_serialize_PointerTomerc__RegisterProductionOperationResponse(soap, (merc__RegisterProductionOperationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__RegisterProductionOperationRequest: soap_serialize_PointerTomerc__RegisterProductionOperationRequest(soap, (merc__RegisterProductionOperationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentResponse: soap_serialize_PointerTomerc__PrepareOutgoingConsignmentResponse(soap, (merc__PrepareOutgoingConsignmentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentRequest: soap_serialize_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, (merc__PrepareOutgoingConsignmentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentResponse: soap_serialize_PointerTomerc__ProcessIncomingConsignmentResponse(soap, (merc__ProcessIncomingConsignmentResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentRequest: soap_serialize_PointerTomerc__ProcessIncomingConsignmentRequest(soap, (merc__ProcessIncomingConsignmentRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse: soap_serialize_PointerTo_ws__receiveApplicationResultResponse(soap, (_ws__receiveApplicationResultResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest: soap_serialize_PointerTo_ws__receiveApplicationResultRequest(soap, (_ws__receiveApplicationResultRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__submitApplicationResponse: soap_serialize_PointerTo_ws__submitApplicationResponse(soap, (_ws__submitApplicationResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ws__submitApplicationRequest: soap_serialize_PointerTo_ws__submitApplicationRequest(soap, (_ws__submitApplicationRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemChangesListResponse: soap_serialize_PointerTo_ns8__getProductItemChangesListResponse(soap, (_ns8__getProductItemChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemChangesListRequest: soap_serialize_PointerTo_ns8__getProductItemChangesListRequest(soap, (_ns8__getProductItemChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemListResponse: soap_serialize_PointerTo_ns8__getProductItemListResponse(soap, (_ns8__getProductItemListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemListRequest: soap_serialize_PointerTo_ns8__getProductItemListRequest(soap, (_ns8__getProductItemListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemByUuidResponse: soap_serialize_PointerTo_ns8__getProductItemByUuidResponse(soap, (_ns8__getProductItemByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemByUuidRequest: soap_serialize_PointerTo_ns8__getProductItemByUuidRequest(soap, (_ns8__getProductItemByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemByGuidResponse: soap_serialize_PointerTo_ns8__getProductItemByGuidResponse(soap, (_ns8__getProductItemByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductItemByGuidRequest: soap_serialize_PointerTo_ns8__getProductItemByGuidRequest(soap, (_ns8__getProductItemByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductChangesListResponse: soap_serialize_PointerTo_ns8__getSubProductChangesListResponse(soap, (_ns8__getSubProductChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductChangesListRequest: soap_serialize_PointerTo_ns8__getSubProductChangesListRequest(soap, (_ns8__getSubProductChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductByProductListResponse: soap_serialize_PointerTo_ns8__getSubProductByProductListResponse(soap, (_ns8__getSubProductByProductListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductByProductListRequest: soap_serialize_PointerTo_ns8__getSubProductByProductListRequest(soap, (_ns8__getSubProductByProductListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductByUuidResponse: soap_serialize_PointerTo_ns8__getSubProductByUuidResponse(soap, (_ns8__getSubProductByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductByUuidRequest: soap_serialize_PointerTo_ns8__getSubProductByUuidRequest(soap, (_ns8__getSubProductByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductByGuidResponse: soap_serialize_PointerTo_ns8__getSubProductByGuidResponse(soap, (_ns8__getSubProductByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getSubProductByGuidRequest: soap_serialize_PointerTo_ns8__getSubProductByGuidRequest(soap, (_ns8__getSubProductByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductChangesListResponse: soap_serialize_PointerTo_ns8__getProductChangesListResponse(soap, (_ns8__getProductChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductChangesListRequest: soap_serialize_PointerTo_ns8__getProductChangesListRequest(soap, (_ns8__getProductChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductByTypeListResponse: soap_serialize_PointerTo_ns8__getProductByTypeListResponse(soap, (_ns8__getProductByTypeListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductByTypeListRequest: soap_serialize_PointerTo_ns8__getProductByTypeListRequest(soap, (_ns8__getProductByTypeListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductByUuidResponse: soap_serialize_PointerTo_ns8__getProductByUuidResponse(soap, (_ns8__getProductByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductByUuidRequest: soap_serialize_PointerTo_ns8__getProductByUuidRequest(soap, (_ns8__getProductByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductByGuidResponse: soap_serialize_PointerTo_ns8__getProductByGuidResponse(soap, (_ns8__getProductByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getProductByGuidRequest: soap_serialize_PointerTo_ns8__getProductByGuidRequest(soap, (_ns8__getProductByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse: soap_serialize_PointerTo_ns8__getActivityLocationListResponse(soap, (_ns8__getActivityLocationListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest: soap_serialize_PointerTo_ns8__getActivityLocationListRequest(soap, (_ns8__getActivityLocationListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse: soap_serialize_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, (_ns8__getBusinessMemberByGLNResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest: soap_serialize_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, (_ns8__getBusinessMemberByGLNRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse: soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, (_ns8__getRussianEnterpriseChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest: soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, (_ns8__getRussianEnterpriseChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse: soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, (_ns8__getForeignEnterpriseChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest: soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, (_ns8__getForeignEnterpriseChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse: soap_serialize_PointerTo_ns8__getRussianEnterpriseListResponse(soap, (_ns8__getRussianEnterpriseListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest: soap_serialize_PointerTo_ns8__getRussianEnterpriseListRequest(soap, (_ns8__getRussianEnterpriseListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse: soap_serialize_PointerTo_ns8__getForeignEnterpriseListResponse(soap, (_ns8__getForeignEnterpriseListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest: soap_serialize_PointerTo_ns8__getForeignEnterpriseListRequest(soap, (_ns8__getForeignEnterpriseListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse: soap_serialize_PointerTo_ns8__getEnterpriseByUuidResponse(soap, (_ns8__getEnterpriseByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest: soap_serialize_PointerTo_ns8__getEnterpriseByUuidRequest(soap, (_ns8__getEnterpriseByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse: soap_serialize_PointerTo_ns8__getEnterpriseByGuidResponse(soap, (_ns8__getEnterpriseByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest: soap_serialize_PointerTo_ns8__getEnterpriseByGuidRequest(soap, (_ns8__getEnterpriseByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse: soap_serialize_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, (_ns8__getBusinessEntityChangesListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest: soap_serialize_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, (_ns8__getBusinessEntityChangesListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse: soap_serialize_PointerTo_ns8__getBusinessEntityListResponse(soap, (_ns8__getBusinessEntityListResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest: soap_serialize_PointerTo_ns8__getBusinessEntityListRequest(soap, (_ns8__getBusinessEntityListRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse: soap_serialize_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, (_ns8__getBusinessEntityByUuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest: soap_serialize_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, (_ns8__getBusinessEntityByUuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse: soap_serialize_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, (_ns8__getBusinessEntityByGuidResponse *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest: soap_serialize_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, (_ns8__getBusinessEntityByGuidRequest *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__FaultInfo: soap_serialize_PointerTobase__FaultInfo(soap, (base__FaultInfo *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntryBlankFilter: soap_serialize_PointerTovd__StockEntryBlankFilter(soap, (enum vd__StockEntryBlankFilter *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntryEventList: soap_serialize_PointerTovd__StockEntryEventList(soap, (vd__StockEntryEventList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DiscrepancyReason: soap_serialize_PointerTovd__DiscrepancyReason(soap, (vd__DiscrepancyReason *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange: soap_serialize_PointerToPointerTovd__VetDocumentStatusChange(soap, (vd__VetDocumentStatusChange **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentStatusChange: soap_serialize_PointerTovd__VetDocumentStatusChange(soap, (vd__VetDocumentStatusChange *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VeterinaryAuthentication: soap_serialize_PointerTovd__VeterinaryAuthentication(soap, (vd__VeterinaryAuthentication *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__CertifiedConsignment: soap_serialize_PointerTovd__CertifiedConsignment(soap, (vd__CertifiedConsignment *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__CertifiedBatch: soap_serialize_PointerTovd__CertifiedBatch(soap, (vd__CertifiedBatch *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentForm: soap_serialize_PointerTovd__VetDocumentForm(soap, (enum vd__VetDocumentForm *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__RegionalizationStatus: soap_serialize_PointerToPointerToent__RegionalizationStatus(soap, (ent__RegionalizationStatus **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Area: soap_serialize_PointerToPointerToent__Area(soap, (ent__Area **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__RegionalizationRequirement: soap_serialize_PointerToPointerToent__RegionalizationRequirement(soap, (ent__RegionalizationRequirement **const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationRequirement: soap_serialize_PointerToent__RegionalizationRequirement(soap, (ent__RegionalizationRequirement *const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationDecision: soap_serialize_PointerToent__RegionalizationDecision(soap, (enum ent__RegionalizationDecision *const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationStatus: soap_serialize_PointerToent__RegionalizationStatus(soap, (ent__RegionalizationStatus *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Packaging: soap_serialize_PointerToent__Packaging(soap, (ent__Packaging *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__ProductItemProducing: soap_serialize_PointerToPointerToent__ProductItemProducing(soap, (ent__ProductItemProducing **const*)ptr); break;
	case SOAP_TYPE_PointerToent__ProductItemProducing: soap_serialize_PointerToent__ProductItemProducing(soap, (ent__ProductItemProducing *const*)ptr); break;
	case SOAP_TYPE_PointerTo_ent__BusinessEntity_activityLocation: soap_serialize_PointerTo_ent__BusinessEntity_activityLocation(soap, (_ent__BusinessEntity_activityLocation *const*)ptr); break;
	case SOAP_TYPE_PointerToent__IncorporationForm: soap_serialize_PointerToent__IncorporationForm(soap, (ent__IncorporationForm *const*)ptr); break;
	case SOAP_TYPE_PointerToent__BusinessEntityType: soap_serialize_PointerToent__BusinessEntityType(soap, (enum ent__BusinessEntityType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__EnterpriseOfficialRegistration: soap_serialize_PointerToPointerToent__EnterpriseOfficialRegistration(soap, (ent__EnterpriseOfficialRegistration **const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration: soap_serialize_PointerToent__EnterpriseOfficialRegistration(soap, (ent__EnterpriseOfficialRegistration *const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseActivityList: soap_serialize_PointerToent__EnterpriseActivityList(soap, (ent__EnterpriseActivityList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseNumberList: soap_serialize_PointerToent__EnterpriseNumberList(soap, (ent__EnterpriseNumberList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseType: soap_serialize_PointerToent__EnterpriseType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__PackingCodeType: soap_serialize_PointerToent__PackingCodeType(soap, (enum ent__PackingCodeType *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__UUID: soap_serialize_PointerTobase__UUID(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntrySearchPattern: soap_serialize_PointerTovd__StockEntrySearchPattern(soap, (vd__StockEntrySearchPattern *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentStatus: soap_serialize_PointerTovd__VetDocumentStatus(soap, (enum vd__VetDocumentStatus *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentType: soap_serialize_PointerTovd__VetDocumentType(soap, (enum vd__VetDocumentType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__PSLModificationOperation: soap_serialize_PointerTovd__PSLModificationOperation(soap, (vd__PSLModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy: soap_serialize_PointerToPointerTovd__StockDiscrepancy(soap, (vd__StockDiscrepancy **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockDiscrepancy: soap_serialize_PointerTovd__StockDiscrepancy(soap, (vd__StockDiscrepancy *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation: soap_serialize_PointerTovd__BEActivityLocationsModificationOperation(soap, (vd__BEActivityLocationsModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ENTModificationOperation: soap_serialize_PointerTovd__ENTModificationOperation(soap, (vd__ENTModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__BEModificationOperation: soap_serialize_PointerTovd__BEModificationOperation(soap, (vd__BEModificationOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__MergeStockEntriesOperation: soap_serialize_PointerTovd__MergeStockEntriesOperation(soap, (vd__MergeStockEntriesOperation *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ProductionOperation: soap_serialize_PointerTovd__ProductionOperation(soap, (vd__ProductionOperation *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__Delivery: soap_serialize_PointerToPointerTovd__Delivery(soap, (vd__Delivery **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport: soap_serialize_PointerToPointerTovd__DiscrepancyReport(soap, (vd__DiscrepancyReport **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DiscrepancyReport: soap_serialize_PointerTovd__DiscrepancyReport(soap, (vd__DiscrepancyReport *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DeliveryFactList: soap_serialize_PointerTovd__DeliveryFactList(soap, (vd__DeliveryFactList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Delivery: soap_serialize_PointerTovd__Delivery(soap, (vd__Delivery *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__WorkingArea: soap_serialize_PointerToPointerTovd__WorkingArea(soap, (vd__WorkingArea **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__WorkingArea: soap_serialize_PointerTovd__WorkingArea(soap, (vd__WorkingArea *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__WorkingAreaList: soap_serialize_PointerTovd__WorkingAreaList(soap, (vd__WorkingAreaList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__SNILSType: soap_serialize_PointerTovd__SNILSType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__MedicinalDrug: soap_serialize_PointerToent__MedicinalDrug(soap, (ent__MedicinalDrug *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Indicator: soap_serialize_PointerToent__Indicator(soap, (ent__Indicator *const*)ptr); break;
	case SOAP_TYPE_PointerToent__DocumentType: soap_serialize_PointerToent__DocumentType(soap, (enum ent__DocumentType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ConsignmentDocumentList: soap_serialize_PointerTovd__ConsignmentDocumentList(soap, (vd__ConsignmentDocumentList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__Consignment: soap_serialize_PointerToPointerTovd__Consignment(soap, (vd__Consignment **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Consignment: soap_serialize_PointerTovd__Consignment(soap, (vd__Consignment *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__BusinessMember: soap_serialize_PointerToPointerToent__BusinessMember(soap, (ent__BusinessMember **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__ResearchMethod: soap_serialize_PointerToPointerToent__ResearchMethod(soap, (ent__ResearchMethod **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__AnimalDisease: soap_serialize_PointerToPointerToent__AnimalDisease(soap, (ent__AnimalDisease **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__RegionalizationRegionStatus: soap_serialize_PointerToPointerToent__RegionalizationRegionStatus(soap, (ent__RegionalizationRegionStatus **const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationRegionStatus: soap_serialize_PointerToent__RegionalizationRegionStatus(soap, (ent__RegionalizationRegionStatus *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__ProductItem: soap_serialize_PointerToPointerToent__ProductItem(soap, (ent__ProductItem **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__SubProduct: soap_serialize_PointerToPointerToent__SubProduct(soap, (ent__SubProduct **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Product: soap_serialize_PointerToPointerToent__Product(soap, (ent__Product **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__EnterpriseActivity: soap_serialize_PointerToPointerToent__EnterpriseActivity(soap, (ent__EnterpriseActivity **const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseActivity: soap_serialize_PointerToent__EnterpriseActivity(soap, (ent__EnterpriseActivity *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Street: soap_serialize_PointerToPointerToent__Street(soap, (ent__Street **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Locality: soap_serialize_PointerToPointerToent__Locality(soap, (ent__Locality **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__District: soap_serialize_PointerToPointerToent__District(soap, (ent__District **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Region: soap_serialize_PointerToPointerToent__Region(soap, (ent__Region **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Country: soap_serialize_PointerToPointerToent__Country(soap, (ent__Country **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Unit: soap_serialize_PointerToPointerToent__Unit(soap, (ent__Unit **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Purpose: soap_serialize_PointerToPointerToent__Purpose(soap, (ent__Purpose **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__AuthorityList: soap_serialize_PointerTovd__AuthorityList(soap, (vd__AuthorityList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__UserList: soap_serialize_PointerTovd__UserList(soap, (vd__UserList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__User: soap_serialize_PointerToPointerTovd__User(soap, (vd__User **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules: soap_serialize_PointerToPointerTovd__RouteSectionR13nRules(soap, (vd__RouteSectionR13nRules **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__RouteSectionR13nRules: soap_serialize_PointerTovd__RouteSectionR13nRules(soap, (vd__RouteSectionR13nRules *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocumentList: soap_serialize_PointerTovd__VetDocumentList(soap, (vd__VetDocumentList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Enterprise: soap_serialize_PointerToPointerToent__Enterprise(soap, (ent__Enterprise **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__BusinessEntity: soap_serialize_PointerToPointerToent__BusinessEntity(soap, (ent__BusinessEntity **const*)ptr); break;
	case SOAP_TYPE_PointerToent__OTPToken: soap_serialize_PointerToent__OTPToken(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerTobase__VersionStatus: soap_serialize_PointerTobase__VersionStatus(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__ResearchMethodList: soap_serialize_PointerToent__ResearchMethodList(soap, (ent__ResearchMethodList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ResearchMethod: soap_serialize_PointerToent__ResearchMethod(soap, (ent__ResearchMethod *const*)ptr); break;
	case SOAP_TYPE_PointerToent__AnimalDiseaseList: soap_serialize_PointerToent__AnimalDiseaseList(soap, (ent__AnimalDiseaseList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationShippingRuleList: soap_serialize_PointerToent__RegionalizationShippingRuleList(soap, (ent__RegionalizationShippingRuleList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationRegionStatusList: soap_serialize_PointerToent__RegionalizationRegionStatusList(soap, (ent__RegionalizationRegionStatusList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationConditionList: soap_serialize_PointerToent__RegionalizationConditionList(soap, (ent__RegionalizationConditionList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ActivityLocationList: soap_serialize_PointerToent__ActivityLocationList(soap, (ent__ActivityLocationList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseGroup: soap_serialize_PointerToent__EnterpriseGroup(soap, (enum ent__EnterpriseGroup *const*)ptr); break;
	case SOAP_TYPE_PointerToent__StreetList: soap_serialize_PointerToent__StreetList(soap, (ent__StreetList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__LocalityList: soap_serialize_PointerToent__LocalityList(soap, (ent__LocalityList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__DistrictList: soap_serialize_PointerToent__DistrictList(soap, (ent__DistrictList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionList: soap_serialize_PointerToent__RegionList(soap, (ent__RegionList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__CountryList: soap_serialize_PointerToent__CountryList(soap, (ent__CountryList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__SubProductList: soap_serialize_PointerToent__SubProductList(soap, (ent__SubProductList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ProductList: soap_serialize_PointerToent__ProductList(soap, (ent__ProductList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__UnitList: soap_serialize_PointerToent__UnitList(soap, (ent__UnitList *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__DateInterval: soap_serialize_PointerTobase__DateInterval(soap, (base__DateInterval *const*)ptr); break;
	case SOAP_TYPE_PointerToent__PurposeList: soap_serialize_PointerToent__PurposeList(soap, (ent__PurposeList *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__ListOptions: soap_serialize_PointerTobase__ListOptions(soap, (base__ListOptions *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Area: soap_serialize_PointerToent__Area(soap, (ent__Area *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__UserAuthority: soap_serialize_PointerToPointerTovd__UserAuthority(soap, (vd__UserAuthority **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__UserAuthority: soap_serialize_PointerTovd__UserAuthority(soap, (vd__UserAuthority *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__RegionalizationShippingRule: soap_serialize_PointerToPointerToent__RegionalizationShippingRule(soap, (ent__RegionalizationShippingRule **const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationShippingRule: soap_serialize_PointerToent__RegionalizationShippingRule(soap, (ent__RegionalizationShippingRule *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__SequenceNumber: soap_serialize_PointerTobase__SequenceNumber(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__QuarantineEvent: soap_serialize_PointerToPointerTovd__QuarantineEvent(soap, (vd__QuarantineEvent **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__RegionalizationClause: soap_serialize_PointerToPointerTovd__RegionalizationClause(soap, (vd__RegionalizationClause **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__RegionalizationClause: soap_serialize_PointerTovd__RegionalizationClause(soap, (vd__RegionalizationClause *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent: soap_serialize_PointerToPointerTovd__VeterinaryEvent(soap, (vd__VeterinaryEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VeterinaryEvent: soap_serialize_PointerTovd__VeterinaryEvent(soap, (vd__VeterinaryEvent *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent: soap_serialize_PointerToPointerTovd__AnimalMedicationEvent(soap, (vd__AnimalMedicationEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__AnimalMedicationEvent: soap_serialize_PointerTovd__AnimalMedicationEvent(soap, (vd__AnimalMedicationEvent *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__QuarantineEvent: soap_serialize_PointerTovd__QuarantineEvent(soap, (vd__QuarantineEvent *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent: soap_serialize_PointerToPointerTovd__LaboratoryResearchEvent(soap, (vd__LaboratoryResearchEvent **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__LaboratoryResearchEvent: soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, (vd__LaboratoryResearchEvent *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__AnimalSpentPeriod: soap_serialize_PointerTovd__AnimalSpentPeriod(soap, (enum vd__AnimalSpentPeriod *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ResearchResult: soap_serialize_PointerToent__ResearchResult(soap, (enum ent__ResearchResult *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Purpose: soap_serialize_PointerToent__Purpose(soap, (ent__Purpose *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__Document: soap_serialize_PointerToPointerTovd__Document(soap, (vd__Document **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Document: soap_serialize_PointerTovd__Document(soap, (vd__Document *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Organization: soap_serialize_PointerToent__Organization(soap, (ent__Organization *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Location: soap_serialize_PointerToent__Location(soap, (ent__Location *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VeterinaryEventType: soap_serialize_PointerTovd__VeterinaryEventType(soap, (enum vd__VeterinaryEventType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ShipmentRoute: soap_serialize_PointerTovd__ShipmentRoute(soap, (vd__ShipmentRoute *const*)ptr); break;
	case SOAP_TYPE_PointerToent__TransportationStorageType: soap_serialize_PointerToent__TransportationStorageType(soap, (enum ent__TransportationStorageType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__TransportInfo: soap_serialize_PointerTovd__TransportInfo(soap, (vd__TransportInfo *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Batch: soap_serialize_PointerTovd__Batch(soap, (vd__Batch *const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseList: soap_serialize_PointerToent__EnterpriseList(soap, (ent__EnterpriseList *const*)ptr); break;
	case SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation: soap_serialize_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, (_vd__BEActivityLocationsModificationOperation_activityLocation *const*)ptr); break;
	case SOAP_TYPE_PointerToent__GLNType: soap_serialize_PointerToent__GLNType(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__BusinessEntityList: soap_serialize_PointerToent__BusinessEntityList(soap, (ent__BusinessEntityList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ProductItemList: soap_serialize_PointerToent__ProductItemList(soap, (ent__ProductItemList *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__StockEntry: soap_serialize_PointerToPointerTovd__StockEntry(soap, (vd__StockEntry **const*)ptr); break;
	case SOAP_TYPE_PointerTobase__RegisterModificationType: soap_serialize_PointerTobase__RegisterModificationType(soap, (enum base__RegisterModificationType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure: soap_serialize_PointerToPointerTovd__ProcessingProcedure(soap, (vd__ProcessingProcedure **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ProcessingProcedure: soap_serialize_PointerTovd__ProcessingProcedure(soap, (vd__ProcessingProcedure *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ProductiveBatch: soap_serialize_PointerToPointerTovd__ProductiveBatch(soap, (vd__ProductiveBatch **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ProductiveBatch: soap_serialize_PointerTovd__ProductiveBatch(soap, (vd__ProductiveBatch *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__RawBatch: soap_serialize_PointerToPointerTovd__RawBatch(soap, (vd__RawBatch **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__RawBatch: soap_serialize_PointerTovd__RawBatch(soap, (vd__RawBatch *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint: soap_serialize_PointerToPointerTovd__ShipmentRoutePoint(soap, (vd__ShipmentRoutePoint **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ShipmentRoutePoint: soap_serialize_PointerTovd__ShipmentRoutePoint(soap, (vd__ShipmentRoutePoint *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__TransportNumber: soap_serialize_PointerTovd__TransportNumber(soap, (vd__TransportNumber *const*)ptr); break;
	case SOAP_TYPE_PointerToent__TransportType: soap_serialize_PointerToent__TransportType(soap, (enum ent__TransportType *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntryList: soap_serialize_PointerTovd__StockEntryList(soap, (vd__StockEntryList *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ComplexDate: soap_serialize_PointerToent__ComplexDate(soap, (ent__ComplexDate *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__ReferencedDocument: soap_serialize_PointerToPointerTovd__ReferencedDocument(soap, (vd__ReferencedDocument **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__ReferencedDocument: soap_serialize_PointerTovd__ReferencedDocument(soap, (vd__ReferencedDocument *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTovd__VetDocument: soap_serialize_PointerToPointerTovd__VetDocument(soap, (vd__VetDocument **const*)ptr); break;
	case SOAP_TYPE_PointerTovd__VetDocument: soap_serialize_PointerTovd__VetDocument(soap, (vd__VetDocument *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__Waybill: soap_serialize_PointerTovd__Waybill(soap, (vd__Waybill *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__User: soap_serialize_PointerTovd__User(soap, (vd__User *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__DeliveryInspection: soap_serialize_PointerTovd__DeliveryInspection(soap, (vd__DeliveryInspection *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__StockEntry: soap_serialize_PointerTovd__StockEntry(soap, (vd__StockEntry *const*)ptr); break;
	case SOAP_TYPE_PointerToent__PackageList: soap_serialize_PointerToent__PackageList(soap, (ent__PackageList *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__BatchOrigin: soap_serialize_PointerTovd__BatchOrigin(soap, (vd__BatchOrigin *const*)ptr); break;
	case SOAP_TYPE_PointerTovd__GoodsDate: soap_serialize_PointerTovd__GoodsDate(soap, (vd__GoodsDate *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ProductItem: soap_serialize_PointerToent__ProductItem(soap, (ent__ProductItem *const*)ptr); break;
	case SOAP_TYPE_PointerToent__SubProduct: soap_serialize_PointerToent__SubProduct(soap, (ent__SubProduct *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Product: soap_serialize_PointerToent__Product(soap, (ent__Product *const*)ptr); break;
	case SOAP_TYPE_PointerToent__ProductType: soap_serialize_PointerToent__ProductType(soap, (enum ent__ProductType *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__RegionalizationConditionGroup: soap_serialize_PointerToPointerToent__RegionalizationConditionGroup(soap, (ent__RegionalizationConditionGroup **const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationConditionGroup: soap_serialize_PointerToent__RegionalizationConditionGroup(soap, (ent__RegionalizationConditionGroup *const*)ptr); break;
	case SOAP_TYPE_PointerToent__AnimalDisease: soap_serialize_PointerToent__AnimalDisease(soap, (ent__AnimalDisease *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__RegionalizationCondition: soap_serialize_PointerToPointerToent__RegionalizationCondition(soap, (ent__RegionalizationCondition **const*)ptr); break;
	case SOAP_TYPE_PointerToent__RegionalizationCondition: soap_serialize_PointerToent__RegionalizationCondition(soap, (ent__RegionalizationCondition *const*)ptr); break;
	case SOAP_TYPE_PointerToent__BusinessMember: soap_serialize_PointerToent__BusinessMember(soap, (ent__BusinessMember *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Identifier: soap_serialize_PointerTobase__Identifier(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__Address: soap_serialize_PointerToent__Address(soap, (ent__Address *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Unit: soap_serialize_PointerToent__Unit(soap, (ent__Unit *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Decimal: soap_serialize_PointerTobase__Decimal(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__Minute: soap_serialize_PointerToent__Minute(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Hour: soap_serialize_PointerToent__Hour(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Day: soap_serialize_PointerToent__Day(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Month: soap_serialize_PointerToent__Month(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Year: soap_serialize_PointerToent__Year(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Package: soap_serialize_PointerToPointerToent__Package(soap, (ent__Package **const*)ptr); break;
	case SOAP_TYPE_PointerToent__Package: soap_serialize_PointerToent__Package(soap, (ent__Package *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__ProductMarks: soap_serialize_PointerToPointerToent__ProductMarks(soap, (ent__ProductMarks **const*)ptr); break;
	case SOAP_TYPE_PointerToent__ProductMarks: soap_serialize_PointerToent__ProductMarks(soap, (ent__ProductMarks *const*)ptr); break;
	case SOAP_TYPE_PointerToent__PackingType: soap_serialize_PointerToent__PackingType(soap, (ent__PackingType *const*)ptr); break;
	case SOAP_TYPE_PointerToent__BusinessEntity: soap_serialize_PointerToent__BusinessEntity(soap, (ent__BusinessEntity *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__String255: soap_serialize_PointerTobase__String255(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToent__Producer: soap_serialize_PointerToPointerToent__Producer(soap, (ent__Producer **const*)ptr); break;
	case SOAP_TYPE_PointerToent__Producer: soap_serialize_PointerToent__Producer(soap, (ent__Producer *const*)ptr); break;
	case SOAP_TYPE_PointerToent__EnterpriseRole: soap_serialize_PointerToent__EnterpriseRole(soap, (enum ent__EnterpriseRole *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Enterprise: soap_serialize_PointerToent__Enterprise(soap, (ent__Enterprise *const*)ptr); break;
	case SOAP_TYPE_PointerTobase__NText: soap_serialize_PointerTobase__NText(soap, (char **const*)ptr); break;
	case SOAP_TYPE_PointerToent__Street: soap_serialize_PointerToent__Street(soap, (ent__Street *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Locality: soap_serialize_PointerToent__Locality(soap, (ent__Locality *const*)ptr); break;
	case SOAP_TYPE_PointerToent__District: soap_serialize_PointerToent__District(soap, (ent__District *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Region: soap_serialize_PointerToent__Region(soap, (ent__Region *const*)ptr); break;
	case SOAP_TYPE_PointerToent__FederalDistrict: soap_serialize_PointerToent__FederalDistrict(soap, (ent__FederalDistrict *const*)ptr); break;
	case SOAP_TYPE_PointerToent__Country: soap_serialize_PointerToent__Country(soap, (ent__Country *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerToapp__BusinessError: soap_serialize_PointerToPointerToapp__BusinessError(soap, (app__BusinessError **const*)ptr); break;
	case SOAP_TYPE_PointerToapp__BusinessError: soap_serialize_PointerToapp__BusinessError(soap, (app__BusinessError *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ContentEncoding: soap_serialize_PointerToapp__ContentEncoding(soap, (enum app__ContentEncoding *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__BusinessErrorList: soap_serialize_PointerToapp__BusinessErrorList(soap, (app__BusinessErrorList *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ApplicationResultWrapper: soap_serialize_PointerToapp__ApplicationResultWrapper(soap, (app__ApplicationResultWrapper *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ApplicationDataWrapper: soap_serialize_PointerToapp__ApplicationDataWrapper(soap, (app__ApplicationDataWrapper *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__ApplicationStatus: soap_serialize_PointerToapp__ApplicationStatus(soap, (enum app__ApplicationStatus *const*)ptr); break;
	case SOAP_TYPE_PointerToPointerTobase__Error: soap_serialize_PointerToPointerTobase__Error(soap, (base__Error **const*)ptr); break;
	case SOAP_TYPE_PointerTobase__Error: soap_serialize_PointerTobase__Error(soap, (base__Error *const*)ptr); break;
	case SOAP_TYPE_PointerTobool: soap_serialize_PointerTobool(soap, (bool *const*)ptr); break;
	case SOAP_TYPE_PointerToLONG64: soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr); break;
	case SOAP_TYPE_PointerToint: soap_serialize_PointerToint(soap, (int *const*)ptr); break;
	case SOAP_TYPE_PointerTotime: soap_serialize_PointerTotime(soap, (time_t *const*)ptr); break;
	case SOAP_TYPE_PointerToapp__Application: soap_serialize_PointerToapp__Application(soap, (app__Application *const*)ptr); break;
	case SOAP_TYPE_vd__VetDocumentStatusChangeReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__GRNType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_vd__SNILSType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_vd__StockEntryNumber: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__OTPToken: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__GTINType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__GLNType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__ENTModificationReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__BEModificationReason: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__EnterpriseType: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__Code3: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_ent__Code: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_app__APIKey: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__SequenceNumber: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__Identifier: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__VersionStatus: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__Decimal: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__String32: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__String255: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__NText: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__Text: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_base__UUID: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__token: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__positiveInteger: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__nonNegativeInteger: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__integer: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__decimal: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__date: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_PointerTounsignedByte: soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr); break;
	case SOAP_TYPE_xsd__Name: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__NCName: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__IDREF: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_xsd__ID: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE__QName: soap_serialize_string(soap, (char*const*)&ptr); break;
	case SOAP_TYPE_string: soap_serialize_string(soap, (char*const*)&ptr); break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 vetisams_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	(void)type;
	switch(t) {
	case SOAP_TYPE_xsd__base64Binary: return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__submitApplicationRequest: return (void*)soap_instantiate__ws__submitApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__submitApplicationResponse: return (void*)soap_instantiate__ws__submitApplicationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__receiveApplicationResultRequest: return (void*)soap_instantiate__ws__receiveApplicationResultRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ws__receiveApplicationResultResponse: return (void*)soap_instantiate__ws__receiveApplicationResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__GenericEntity: return (void*)soap_instantiate_base__GenericEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__ListOptions: return (void*)soap_instantiate_base__ListOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__DateInterval: return (void*)soap_instantiate_base__DateInterval(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__EntityList: return (void*)soap_instantiate_base__EntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__FaultInfo: return (void*)soap_instantiate_base__FaultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__Application: return (void*)soap_instantiate_app__Application(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationDataWrapper: return (void*)soap_instantiate_app__ApplicationDataWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationResultWrapper: return (void*)soap_instantiate_app__ApplicationResultWrapper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationData: return (void*)soap_instantiate_app__ApplicationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__ApplicationResultData: return (void*)soap_instantiate_app__ApplicationResultData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__BusinessErrorList: return (void*)soap_instantiate_app__BusinessErrorList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Address: return (void*)soap_instantiate_ent__Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Producer: return (void*)soap_instantiate_ent__Producer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ProducerList: return (void*)soap_instantiate_ent__ProducerList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__EnterpriseNumberList: return (void*)soap_instantiate_ent__EnterpriseNumberList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__BusinessMember: return (void*)soap_instantiate_ent__BusinessMember(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Package: return (void*)soap_instantiate_ent__Package(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__PackageList: return (void*)soap_instantiate_ent__PackageList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ComplexDate: return (void*)soap_instantiate_ent__ComplexDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ProductItemProducing: return (void*)soap_instantiate_ent__ProductItemProducing(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Packaging: return (void*)soap_instantiate_ent__Packaging(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Location: return (void*)soap_instantiate_ent__Location(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__EnterpriseOfficialRegistration: return (void*)soap_instantiate_ent__EnterpriseOfficialRegistration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Organization: return (void*)soap_instantiate_ent__Organization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__MedicinalDrug: return (void*)soap_instantiate_ent__MedicinalDrug(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationConditionGroup: return (void*)soap_instantiate_ent__RegionalizationConditionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationRequirement: return (void*)soap_instantiate_ent__RegionalizationRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationStatus: return (void*)soap_instantiate_ent__RegionalizationStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Batch: return (void*)soap_instantiate_vd__Batch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__RawBatch: return (void*)soap_instantiate_vd__RawBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DeliveryFactList: return (void*)soap_instantiate_vd__DeliveryFactList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DeliveryInspection: return (void*)soap_instantiate_vd__DeliveryInspection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ConsignmentDocumentList: return (void*)soap_instantiate_vd__ConsignmentDocumentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__GoodsDate: return (void*)soap_instantiate_vd__GoodsDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockDiscrepancy: return (void*)soap_instantiate_vd__StockDiscrepancy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__TransportInfo: return (void*)soap_instantiate_vd__TransportInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__TransportNumber: return (void*)soap_instantiate_vd__TransportNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ShipmentRoute: return (void*)soap_instantiate_vd__ShipmentRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ProductionOperation: return (void*)soap_instantiate_vd__ProductionOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__MergeStockEntriesOperation: return (void*)soap_instantiate_vd__MergeStockEntriesOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__PSLModificationOperation: return (void*)soap_instantiate_vd__PSLModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__BEModificationOperation: return (void*)soap_instantiate_vd__BEModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation: return (void*)soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation: return (void*)soap_instantiate_vd__BEActivityLocationsModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ENTModificationOperation: return (void*)soap_instantiate_vd__ENTModificationOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__CertifiedBatch: return (void*)soap_instantiate_vd__CertifiedBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__CertifiedConsignment: return (void*)soap_instantiate_vd__CertifiedConsignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VeterinaryEvent: return (void*)soap_instantiate_vd__VeterinaryEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VeterinaryAuthentication: return (void*)soap_instantiate_vd__VeterinaryAuthentication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__BatchOrigin: return (void*)soap_instantiate_vd__BatchOrigin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntryEventList: return (void*)soap_instantiate_vd__StockEntryEventList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VetDocumentStatusChange: return (void*)soap_instantiate_vd__VetDocumentStatusChange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__RegionalizationClause: return (void*)soap_instantiate_vd__RegionalizationClause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__RouteSectionR13nRules: return (void*)soap_instantiate_vd__RouteSectionR13nRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ProcessingProcedure: return (void*)soap_instantiate_vd__ProcessingProcedure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__AuthorityList: return (void*)soap_instantiate_vd__AuthorityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__UserAuthority: return (void*)soap_instantiate_vd__UserAuthority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__WorkingArea: return (void*)soap_instantiate_vd__WorkingArea(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByGuidRequest: return (void*)soap_instantiate__ns8__getPurposeByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByGuidResponse: return (void*)soap_instantiate__ns8__getPurposeByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByUuidRequest: return (void*)soap_instantiate__ns8__getPurposeByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeByUuidResponse: return (void*)soap_instantiate__ns8__getPurposeByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeListRequest: return (void*)soap_instantiate__ns8__getPurposeListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeListResponse: return (void*)soap_instantiate__ns8__getPurposeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeChangesListRequest: return (void*)soap_instantiate__ns8__getPurposeChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getPurposeChangesListResponse: return (void*)soap_instantiate__ns8__getPurposeChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByGuidRequest: return (void*)soap_instantiate__ns8__getUnitByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByGuidResponse: return (void*)soap_instantiate__ns8__getUnitByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByUuidRequest: return (void*)soap_instantiate__ns8__getUnitByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitByUuidResponse: return (void*)soap_instantiate__ns8__getUnitByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitListRequest: return (void*)soap_instantiate__ns8__getUnitListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitListResponse: return (void*)soap_instantiate__ns8__getUnitListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitChangesListRequest: return (void*)soap_instantiate__ns8__getUnitChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getUnitChangesListResponse: return (void*)soap_instantiate__ns8__getUnitChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByGuidRequest: return (void*)soap_instantiate__ns8__getProductByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByGuidResponse: return (void*)soap_instantiate__ns8__getProductByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByUuidRequest: return (void*)soap_instantiate__ns8__getProductByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByUuidResponse: return (void*)soap_instantiate__ns8__getProductByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByTypeListRequest: return (void*)soap_instantiate__ns8__getProductByTypeListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductByTypeListResponse: return (void*)soap_instantiate__ns8__getProductByTypeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductChangesListRequest: return (void*)soap_instantiate__ns8__getProductChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductChangesListResponse: return (void*)soap_instantiate__ns8__getProductChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByGuidRequest: return (void*)soap_instantiate__ns8__getSubProductByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByGuidResponse: return (void*)soap_instantiate__ns8__getSubProductByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByUuidRequest: return (void*)soap_instantiate__ns8__getSubProductByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByUuidResponse: return (void*)soap_instantiate__ns8__getSubProductByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByProductListRequest: return (void*)soap_instantiate__ns8__getSubProductByProductListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductByProductListResponse: return (void*)soap_instantiate__ns8__getSubProductByProductListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductChangesListRequest: return (void*)soap_instantiate__ns8__getSubProductChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getSubProductChangesListResponse: return (void*)soap_instantiate__ns8__getSubProductChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByGuidRequest: return (void*)soap_instantiate__ns8__getProductItemByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByGuidResponse: return (void*)soap_instantiate__ns8__getProductItemByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByUuidRequest: return (void*)soap_instantiate__ns8__getProductItemByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemByUuidResponse: return (void*)soap_instantiate__ns8__getProductItemByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemListRequest: return (void*)soap_instantiate__ns8__getProductItemListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemListResponse: return (void*)soap_instantiate__ns8__getProductItemListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemChangesListRequest: return (void*)soap_instantiate__ns8__getProductItemChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getProductItemChangesListResponse: return (void*)soap_instantiate__ns8__getProductItemChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getAllCountryListRequest: return (void*)soap_instantiate__ns8__getAllCountryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getAllCountryListResponse: return (void*)soap_instantiate__ns8__getAllCountryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByGuidRequest: return (void*)soap_instantiate__ns8__getCountryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByGuidResponse: return (void*)soap_instantiate__ns8__getCountryByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByUuidRequest: return (void*)soap_instantiate__ns8__getCountryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryByUuidResponse: return (void*)soap_instantiate__ns8__getCountryByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryChangesListRequest: return (void*)soap_instantiate__ns8__getCountryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getCountryChangesListResponse: return (void*)soap_instantiate__ns8__getCountryChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionListByCountryRequest: return (void*)soap_instantiate__ns8__getRegionListByCountryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionListByCountryResponse: return (void*)soap_instantiate__ns8__getRegionListByCountryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByGuidRequest: return (void*)soap_instantiate__ns8__getRegionByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByGuidResponse: return (void*)soap_instantiate__ns8__getRegionByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByUuidRequest: return (void*)soap_instantiate__ns8__getRegionByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionByUuidResponse: return (void*)soap_instantiate__ns8__getRegionByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionChangesListRequest: return (void*)soap_instantiate__ns8__getRegionChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRegionChangesListResponse: return (void*)soap_instantiate__ns8__getRegionChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest: return (void*)soap_instantiate__ns8__getDistrictListByRegionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse: return (void*)soap_instantiate__ns8__getDistrictListByRegionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByGuidRequest: return (void*)soap_instantiate__ns8__getDistrictByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByGuidResponse: return (void*)soap_instantiate__ns8__getDistrictByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByUuidRequest: return (void*)soap_instantiate__ns8__getDistrictByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictByUuidResponse: return (void*)soap_instantiate__ns8__getDistrictByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictChangesListRequest: return (void*)soap_instantiate__ns8__getDistrictChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDistrictChangesListResponse: return (void*)soap_instantiate__ns8__getDistrictChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest: return (void*)soap_instantiate__ns8__getLocalityListByRegionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse: return (void*)soap_instantiate__ns8__getLocalityListByRegionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest: return (void*)soap_instantiate__ns8__getLocalityListByDistrictRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse: return (void*)soap_instantiate__ns8__getLocalityListByDistrictResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest: return (void*)soap_instantiate__ns8__getLocalityListByLocalityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse: return (void*)soap_instantiate__ns8__getLocalityListByLocalityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest: return (void*)soap_instantiate__ns8__getStreetListByLocalityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse: return (void*)soap_instantiate__ns8__getStreetListByLocalityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findLocalityListByNameRequest: return (void*)soap_instantiate__ns8__findLocalityListByNameRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findLocalityListByNameResponse: return (void*)soap_instantiate__ns8__findLocalityListByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findStreetListByNameRequest: return (void*)soap_instantiate__ns8__findStreetListByNameRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__findStreetListByNameResponse: return (void*)soap_instantiate__ns8__findStreetListByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest: return (void*)soap_instantiate__ns8__getEnterpriseByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse: return (void*)soap_instantiate__ns8__getEnterpriseByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest: return (void*)soap_instantiate__ns8__getEnterpriseByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse: return (void*)soap_instantiate__ns8__getEnterpriseByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest: return (void*)soap_instantiate__ns8__getForeignEnterpriseListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse: return (void*)soap_instantiate__ns8__getForeignEnterpriseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest: return (void*)soap_instantiate__ns8__getRussianEnterpriseListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse: return (void*)soap_instantiate__ns8__getRussianEnterpriseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest: return (void*)soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse: return (void*)soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest: return (void*)soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse: return (void*)soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest: return (void*)soap_instantiate__ns8__getBusinessEntityByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse: return (void*)soap_instantiate__ns8__getBusinessEntityByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest: return (void*)soap_instantiate__ns8__getBusinessEntityByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse: return (void*)soap_instantiate__ns8__getBusinessEntityByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityListRequest: return (void*)soap_instantiate__ns8__getBusinessEntityListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityListResponse: return (void*)soap_instantiate__ns8__getBusinessEntityListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest: return (void*)soap_instantiate__ns8__getBusinessEntityChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse: return (void*)soap_instantiate__ns8__getBusinessEntityChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest: return (void*)soap_instantiate__ns8__getBusinessMemberByGLNRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse: return (void*)soap_instantiate__ns8__getBusinessMemberByGLNResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActivityLocationListRequest: return (void*)soap_instantiate__ns8__getActivityLocationListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActivityLocationListResponse: return (void*)soap_instantiate__ns8__getActivityLocationListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getR13nConditionListRequest: return (void*)soap_instantiate__ns8__getR13nConditionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getR13nConditionListResponse: return (void*)soap_instantiate__ns8__getR13nConditionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest: return (void*)soap_instantiate__ns8__getActualR13nRegionStatusListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse: return (void*)soap_instantiate__ns8__getActualR13nRegionStatusListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest: return (void*)soap_instantiate__ns8__getActualR13nShippingRuleListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse: return (void*)soap_instantiate__ns8__getActualR13nShippingRuleListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest: return (void*)soap_instantiate__ns8__getDiseaseByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse: return (void*)soap_instantiate__ns8__getDiseaseByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest: return (void*)soap_instantiate__ns8__getDiseaseByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse: return (void*)soap_instantiate__ns8__getDiseaseByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseListRequest: return (void*)soap_instantiate__ns8__getDiseaseListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseListResponse: return (void*)soap_instantiate__ns8__getDiseaseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest: return (void*)soap_instantiate__ns8__getDiseaseChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse: return (void*)soap_instantiate__ns8__getDiseaseChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest: return (void*)soap_instantiate__ns8__getResearchMethodByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse: return (void*)soap_instantiate__ns8__getResearchMethodByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest: return (void*)soap_instantiate__ns8__getResearchMethodByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse: return (void*)soap_instantiate__ns8__getResearchMethodByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodListRequest: return (void*)soap_instantiate__ns8__getResearchMethodListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodListResponse: return (void*)soap_instantiate__ns8__getResearchMethodListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest: return (void*)soap_instantiate__ns8__getResearchMethodChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse: return (void*)soap_instantiate__ns8__getResearchMethodChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__GenericVersioningEntity: return (void*)soap_instantiate_base__GenericVersioningEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_base__Error: return (void*)soap_instantiate_base__Error(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__MercuryApplicationRequest: return (void*)soap_instantiate_merc__MercuryApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ProcessIncomingConsignmentResponse: return (void*)soap_instantiate_merc__ProcessIncomingConsignmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse: return (void*)soap_instantiate_merc__PrepareOutgoingConsignmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__RegisterProductionOperationResponse: return (void*)soap_instantiate_merc__RegisterProductionOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__MergeStockEntriesResponse: return (void*)soap_instantiate_merc__MergeStockEntriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__WithdrawVetDocumentResponse: return (void*)soap_instantiate_merc__WithdrawVetDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyBusinessEntityResponse: return (void*)soap_instantiate_merc__ModifyBusinessEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyEnterpriseResponse: return (void*)soap_instantiate_merc__ModifyEnterpriseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyActivityLocationsResponse: return (void*)soap_instantiate_merc__ModifyActivityLocationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ResolveDiscrepancyResponse: return (void*)soap_instantiate_merc__ResolveDiscrepancyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyProducerStockListResponse: return (void*)soap_instantiate_merc__ModifyProducerStockListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetVetDocumentByUuidResponse: return (void*)soap_instantiate_merc__GetVetDocumentByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetVetDocumentListResponse: return (void*)soap_instantiate_merc__GetVetDocumentListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetVetDocumentChangesListResponse: return (void*)soap_instantiate_merc__GetVetDocumentChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryByGuidResponse: return (void*)soap_instantiate_merc__GetStockEntryByGuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryByUuidResponse: return (void*)soap_instantiate_merc__GetStockEntryByUuidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryChangesListResponse: return (void*)soap_instantiate_merc__GetStockEntryChangesListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryListResponse: return (void*)soap_instantiate_merc__GetStockEntryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryVersionListResponse: return (void*)soap_instantiate_merc__GetStockEntryVersionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse: return (void*)soap_instantiate_merc__UpdateTransportMovementDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateVeterinaryEventsResponse: return (void*)soap_instantiate_merc__UpdateVeterinaryEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__CheckShipmentRegionalizationResponse: return (void*)soap_instantiate_merc__CheckShipmentRegionalizationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__AddBusinessEntityUserResponse: return (void*)soap_instantiate_merc__AddBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetBusinessEntityUserListResponse: return (void*)soap_instantiate_merc__GetBusinessEntityUserListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetBusinessEntityUserResponse: return (void*)soap_instantiate_merc__GetBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateUserAuthoritiesResponse: return (void*)soap_instantiate_merc__UpdateUserAuthoritiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateUserWorkingAreasResponse: return (void*)soap_instantiate_merc__UpdateUserWorkingAreasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UnbindBusinessEntityUserResponse: return (void*)soap_instantiate_merc__UnbindBusinessEntityUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse: return (void*)soap_instantiate_merc__GetAppliedUserAuthorityListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__PurposeList: return (void*)soap_instantiate_ent__PurposeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__UnitList: return (void*)soap_instantiate_ent__UnitList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__CountryList: return (void*)soap_instantiate_ent__CountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionList: return (void*)soap_instantiate_ent__RegionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__DistrictList: return (void*)soap_instantiate_ent__DistrictList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__LocalityList: return (void*)soap_instantiate_ent__LocalityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__StreetList: return (void*)soap_instantiate_ent__StreetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__EnterpriseActivityList: return (void*)soap_instantiate_ent__EnterpriseActivityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__EnterpriseActivity: return (void*)soap_instantiate_ent__EnterpriseActivity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__EnterpriseList: return (void*)soap_instantiate_ent__EnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__IncorporationForm: return (void*)soap_instantiate_ent__IncorporationForm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__BusinessEntityList: return (void*)soap_instantiate_ent__BusinessEntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ProductList: return (void*)soap_instantiate_ent__ProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__SubProductList: return (void*)soap_instantiate_ent__SubProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ProductItemList: return (void*)soap_instantiate_ent__ProductItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Area: return (void*)soap_instantiate_ent__Area(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationConditionList: return (void*)soap_instantiate_ent__RegionalizationConditionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationRegionStatusList: return (void*)soap_instantiate_ent__RegionalizationRegionStatusList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationShippingRuleList: return (void*)soap_instantiate_ent__RegionalizationShippingRuleList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__AnimalDiseaseList: return (void*)soap_instantiate_ent__AnimalDiseaseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ResearchMethodList: return (void*)soap_instantiate_ent__ResearchMethodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ActivityLocationList: return (void*)soap_instantiate_ent__ActivityLocationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Consignment: return (void*)soap_instantiate_vd__Consignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ProductiveBatch: return (void*)soap_instantiate_vd__ProductiveBatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Delivery: return (void*)soap_instantiate_vd__Delivery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VetDocumentList: return (void*)soap_instantiate_vd__VetDocumentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DiscrepancyReason: return (void*)soap_instantiate_vd__DiscrepancyReason(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntryList: return (void*)soap_instantiate_vd__StockEntryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Document: return (void*)soap_instantiate_vd__Document(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ShipmentRoutePoint: return (void*)soap_instantiate_vd__ShipmentRoutePoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__LaboratoryResearchEvent: return (void*)soap_instantiate_vd__LaboratoryResearchEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__AnimalMedicationEvent: return (void*)soap_instantiate_vd__AnimalMedicationEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__QuarantineEvent: return (void*)soap_instantiate_vd__QuarantineEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__User: return (void*)soap_instantiate_vd__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__UserList: return (void*)soap_instantiate_vd__UserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__WorkingAreaList: return (void*)soap_instantiate_vd__WorkingAreaList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_app__BusinessError: return (void*)soap_instantiate_app__BusinessError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ProcessIncomingConsignmentRequest: return (void*)soap_instantiate_merc__ProcessIncomingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest: return (void*)soap_instantiate_merc__PrepareOutgoingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__RegisterProductionOperationRequest: return (void*)soap_instantiate_merc__RegisterProductionOperationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__MergeStockEntriesRequest: return (void*)soap_instantiate_merc__MergeStockEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__WithdrawVetDocumentRequest: return (void*)soap_instantiate_merc__WithdrawVetDocumentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyBusinessEntityRequest: return (void*)soap_instantiate_merc__ModifyBusinessEntityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyEnterpriseRequest: return (void*)soap_instantiate_merc__ModifyEnterpriseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyActivityLocationsRequest: return (void*)soap_instantiate_merc__ModifyActivityLocationsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ResolveDiscrepancyRequest: return (void*)soap_instantiate_merc__ResolveDiscrepancyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__ModifyProducerStockListRequest: return (void*)soap_instantiate_merc__ModifyProducerStockListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetVetDocumentByUuidRequest: return (void*)soap_instantiate_merc__GetVetDocumentByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetVetDocumentListRequest: return (void*)soap_instantiate_merc__GetVetDocumentListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetVetDocumentChangesListRequest: return (void*)soap_instantiate_merc__GetVetDocumentChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryByGuidRequest: return (void*)soap_instantiate_merc__GetStockEntryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryByUuidRequest: return (void*)soap_instantiate_merc__GetStockEntryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryChangesListRequest: return (void*)soap_instantiate_merc__GetStockEntryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryListRequest: return (void*)soap_instantiate_merc__GetStockEntryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetStockEntryVersionListRequest: return (void*)soap_instantiate_merc__GetStockEntryVersionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest: return (void*)soap_instantiate_merc__UpdateTransportMovementDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateVeterinaryEventsRequest: return (void*)soap_instantiate_merc__UpdateVeterinaryEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__CheckShipmentRegionalizationRequest: return (void*)soap_instantiate_merc__CheckShipmentRegionalizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__AddBusinessEntityUserRequest: return (void*)soap_instantiate_merc__AddBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetBusinessEntityUserListRequest: return (void*)soap_instantiate_merc__GetBusinessEntityUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetBusinessEntityUserRequest: return (void*)soap_instantiate_merc__GetBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateUserAuthoritiesRequest: return (void*)soap_instantiate_merc__UpdateUserAuthoritiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UpdateUserWorkingAreasRequest: return (void*)soap_instantiate_merc__UpdateUserWorkingAreasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__UnbindBusinessEntityUserRequest: return (void*)soap_instantiate_merc__UnbindBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest: return (void*)soap_instantiate_merc__GetAppliedUserAuthorityListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Purpose: return (void*)soap_instantiate_ent__Purpose(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Unit: return (void*)soap_instantiate_ent__Unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__PackingType: return (void*)soap_instantiate_ent__PackingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Country: return (void*)soap_instantiate_ent__Country(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__FederalDistrict: return (void*)soap_instantiate_ent__FederalDistrict(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__AddressObjectView: return (void*)soap_instantiate_ent__AddressObjectView(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Enterprise: return (void*)soap_instantiate_ent__Enterprise(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ent__BusinessEntity_activityLocation: return (void*)soap_instantiate__ent__BusinessEntity_activityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__BusinessEntity: return (void*)soap_instantiate_ent__BusinessEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ProductItem: return (void*)soap_instantiate_ent__ProductItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Product: return (void*)soap_instantiate_ent__Product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__SubProduct: return (void*)soap_instantiate_ent__SubProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ProductMarks: return (void*)soap_instantiate_ent__ProductMarks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Indicator: return (void*)soap_instantiate_ent__Indicator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__AnimalDisease: return (void*)soap_instantiate_ent__AnimalDisease(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__ResearchMethod: return (void*)soap_instantiate_ent__ResearchMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationCondition: return (void*)soap_instantiate_ent__RegionalizationCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationShippingRule: return (void*)soap_instantiate_ent__RegionalizationShippingRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__RegionalizationRegionStatus: return (void*)soap_instantiate_ent__RegionalizationRegionStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__VetDocument: return (void*)soap_instantiate_vd__VetDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__DiscrepancyReport: return (void*)soap_instantiate_vd__DiscrepancyReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntry: return (void*)soap_instantiate_vd__StockEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__Waybill: return (void*)soap_instantiate_vd__Waybill(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__ReferencedDocument: return (void*)soap_instantiate_vd__ReferencedDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Region: return (void*)soap_instantiate_ent__Region(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__District: return (void*)soap_instantiate_ent__District(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Locality: return (void*)soap_instantiate_ent__Locality(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ent__Street: return (void*)soap_instantiate_ent__Street(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vd__StockEntrySearchPattern: return (void*)soap_instantiate_vd__StockEntrySearchPattern(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail: return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__GetBusinessEntityByGuid: return (void*)soap_instantiate___ns1__GetBusinessEntityByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBusinessEntityByUuid: return (void*)soap_instantiate___ns1__GetBusinessEntityByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBusinessEntityList: return (void*)soap_instantiate___ns1__GetBusinessEntityList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBusinessEntityChangesList: return (void*)soap_instantiate___ns1__GetBusinessEntityChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEnterpriseByGuid: return (void*)soap_instantiate___ns1__GetEnterpriseByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEnterpriseByUuid: return (void*)soap_instantiate___ns1__GetEnterpriseByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetForeignEnterpriseList: return (void*)soap_instantiate___ns1__GetForeignEnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRussianEnterpriseList: return (void*)soap_instantiate___ns1__GetRussianEnterpriseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetForeignEnterpriseChangesList: return (void*)soap_instantiate___ns1__GetForeignEnterpriseChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRussianEnterpriseChangesList: return (void*)soap_instantiate___ns1__GetRussianEnterpriseChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBusinessMemberByGLN: return (void*)soap_instantiate___ns1__GetBusinessMemberByGLN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetActivityLocationList: return (void*)soap_instantiate___ns1__GetActivityLocationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductByGuid: return (void*)soap_instantiate___ns2__GetProductByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductByUuid: return (void*)soap_instantiate___ns2__GetProductByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductByTypeList: return (void*)soap_instantiate___ns2__GetProductByTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductChangesList: return (void*)soap_instantiate___ns2__GetProductChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetSubProductByGuid: return (void*)soap_instantiate___ns2__GetSubProductByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetSubProductByUuid: return (void*)soap_instantiate___ns2__GetSubProductByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetSubProductByProductList: return (void*)soap_instantiate___ns2__GetSubProductByProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetSubProductChangesList: return (void*)soap_instantiate___ns2__GetSubProductChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductItemByGuid: return (void*)soap_instantiate___ns2__GetProductItemByGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductItemByUuid: return (void*)soap_instantiate___ns2__GetProductItemByUuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductItemList: return (void*)soap_instantiate___ns2__GetProductItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetProductItemChangesList: return (void*)soap_instantiate___ns2__GetProductItemChangesList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__submitApplicationRequest: return (void*)soap_instantiate___ns3__submitApplicationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__receiveApplicationResult: return (void*)soap_instantiate___ns3__receiveApplicationResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__processIncomingConsignmentRequest: return (void*)soap_instantiate___ns4__processIncomingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__prepareOutgoingConsignmentRequest: return (void*)soap_instantiate___ns4__prepareOutgoingConsignmentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__registerProductionOperationRequest: return (void*)soap_instantiate___ns4__registerProductionOperationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__mergeStockEntriesRequest: return (void*)soap_instantiate___ns4__mergeStockEntriesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__withdrawVetDocumentRequest: return (void*)soap_instantiate___ns4__withdrawVetDocumentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__modifyBusinessEntityRequest: return (void*)soap_instantiate___ns4__modifyBusinessEntityRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__modifyEnterpriseRequest: return (void*)soap_instantiate___ns4__modifyEnterpriseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__modifyActivityLocationsRequest: return (void*)soap_instantiate___ns4__modifyActivityLocationsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__resolveDiscrepancyRequest: return (void*)soap_instantiate___ns4__resolveDiscrepancyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__modifyProducerStockListRequest: return (void*)soap_instantiate___ns4__modifyProducerStockListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getVetDocumentByUuidRequest: return (void*)soap_instantiate___ns4__getVetDocumentByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getVetDocumentListRequest: return (void*)soap_instantiate___ns4__getVetDocumentListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getVetDocumentChangesListRequest: return (void*)soap_instantiate___ns4__getVetDocumentChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getStockEntryByGuidRequest: return (void*)soap_instantiate___ns4__getStockEntryByGuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getStockEntryByUuidRequest: return (void*)soap_instantiate___ns4__getStockEntryByUuidRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getStockEntryListRequest: return (void*)soap_instantiate___ns4__getStockEntryListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getStockEntryChangesListRequest: return (void*)soap_instantiate___ns4__getStockEntryChangesListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getStockEntryVersionListRequest: return (void*)soap_instantiate___ns4__getStockEntryVersionListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__updateTransportMovementDetailsRequest: return (void*)soap_instantiate___ns4__updateTransportMovementDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__updateVeterinaryEventsRequest: return (void*)soap_instantiate___ns4__updateVeterinaryEventsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__checkShipmentRegionalizationRequest: return (void*)soap_instantiate___ns4__checkShipmentRegionalizationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__addBusinessEntityUserRequest: return (void*)soap_instantiate___ns4__addBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getBusinessEntityUserListRequest: return (void*)soap_instantiate___ns4__getBusinessEntityUserListRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getBusinessEntityUserRequest: return (void*)soap_instantiate___ns4__getBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__updateUserAuthoritiesRequest: return (void*)soap_instantiate___ns4__updateUserAuthoritiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__updateUserWorkingAreasRequest: return (void*)soap_instantiate___ns4__updateUserWorkingAreasRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__unbindBusinessEntityUserRequest: return (void*)soap_instantiate___ns4__unbindBusinessEntityUserRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__getAppliedUserAuthorityListRequest: return (void*)soap_instantiate___ns4__getAppliedUserAuthorityListRequest(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header: return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code: return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason: return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault: return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_app__BinaryContent: return (void*)soap_instantiate_app__BinaryContent(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 vetisams_fdelete(struct soap_clist *p)
{
	switch(p->type) {
	case SOAP_TYPE_xsd__base64Binary:
		if(p->size < 0) SOAP_DELETE((xsd__base64Binary*)p->ptr); else SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE__ws__submitApplicationRequest:
		if(p->size < 0) SOAP_DELETE((_ws__submitApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ws__submitApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE__ws__submitApplicationResponse:
		if(p->size < 0) SOAP_DELETE((_ws__submitApplicationResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ws__submitApplicationResponse*)p->ptr);
		break;
	case SOAP_TYPE__ws__receiveApplicationResultRequest:
		if(p->size < 0) SOAP_DELETE((_ws__receiveApplicationResultRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ws__receiveApplicationResultRequest*)p->ptr);
		break;
	case SOAP_TYPE__ws__receiveApplicationResultResponse:
		if(p->size < 0) SOAP_DELETE((_ws__receiveApplicationResultResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ws__receiveApplicationResultResponse*)p->ptr);
		break;
	case SOAP_TYPE_base__GenericEntity:
		if(p->size < 0) SOAP_DELETE((base__GenericEntity*)p->ptr); else SOAP_DELETE_ARRAY((base__GenericEntity*)p->ptr);
		break;
	case SOAP_TYPE_base__ListOptions:
		if(p->size < 0) SOAP_DELETE((base__ListOptions*)p->ptr); else SOAP_DELETE_ARRAY((base__ListOptions*)p->ptr);
		break;
	case SOAP_TYPE_base__DateInterval:
		if(p->size < 0) SOAP_DELETE((base__DateInterval*)p->ptr); else SOAP_DELETE_ARRAY((base__DateInterval*)p->ptr);
		break;
	case SOAP_TYPE_base__EntityList:
		if(p->size < 0) SOAP_DELETE((base__EntityList*)p->ptr); else SOAP_DELETE_ARRAY((base__EntityList*)p->ptr);
		break;
	case SOAP_TYPE_base__FaultInfo:
		if(p->size < 0) SOAP_DELETE((base__FaultInfo*)p->ptr); else SOAP_DELETE_ARRAY((base__FaultInfo*)p->ptr);
		break;
	case SOAP_TYPE_app__Application:
		if(p->size < 0) SOAP_DELETE((app__Application*)p->ptr); else SOAP_DELETE_ARRAY((app__Application*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationDataWrapper:
		if(p->size < 0) SOAP_DELETE((app__ApplicationDataWrapper*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationDataWrapper*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationResultWrapper:
		if(p->size < 0) SOAP_DELETE((app__ApplicationResultWrapper*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationResultWrapper*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationData:
		if(p->size < 0) SOAP_DELETE((app__ApplicationData*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationData*)p->ptr);
		break;
	case SOAP_TYPE_app__ApplicationResultData:
		if(p->size < 0) SOAP_DELETE((app__ApplicationResultData*)p->ptr); else SOAP_DELETE_ARRAY((app__ApplicationResultData*)p->ptr);
		break;
	case SOAP_TYPE_app__BusinessErrorList:
		if(p->size < 0) SOAP_DELETE((app__BusinessErrorList*)p->ptr); else SOAP_DELETE_ARRAY((app__BusinessErrorList*)p->ptr);
		break;
	case SOAP_TYPE_ent__Address:
		if(p->size < 0) SOAP_DELETE((ent__Address*)p->ptr); else SOAP_DELETE_ARRAY((ent__Address*)p->ptr);
		break;
	case SOAP_TYPE_ent__Producer:
		if(p->size < 0) SOAP_DELETE((ent__Producer*)p->ptr); else SOAP_DELETE_ARRAY((ent__Producer*)p->ptr);
		break;
	case SOAP_TYPE_ent__ProducerList:
		if(p->size < 0) SOAP_DELETE((ent__ProducerList*)p->ptr); else SOAP_DELETE_ARRAY((ent__ProducerList*)p->ptr);
		break;
	case SOAP_TYPE_ent__EnterpriseNumberList:
		if(p->size < 0) SOAP_DELETE((ent__EnterpriseNumberList*)p->ptr); else SOAP_DELETE_ARRAY((ent__EnterpriseNumberList*)p->ptr);
		break;
	case SOAP_TYPE_ent__BusinessMember:
		if(p->size < 0) SOAP_DELETE((ent__BusinessMember*)p->ptr); else SOAP_DELETE_ARRAY((ent__BusinessMember*)p->ptr);
		break;
	case SOAP_TYPE_ent__Package:
		if(p->size < 0) SOAP_DELETE((ent__Package*)p->ptr); else SOAP_DELETE_ARRAY((ent__Package*)p->ptr);
		break;
	case SOAP_TYPE_ent__PackageList:
		if(p->size < 0) SOAP_DELETE((ent__PackageList*)p->ptr); else SOAP_DELETE_ARRAY((ent__PackageList*)p->ptr);
		break;
	case SOAP_TYPE_ent__ComplexDate:
		if(p->size < 0) SOAP_DELETE((ent__ComplexDate*)p->ptr); else SOAP_DELETE_ARRAY((ent__ComplexDate*)p->ptr);
		break;
	case SOAP_TYPE_ent__ProductItemProducing:
		if(p->size < 0) SOAP_DELETE((ent__ProductItemProducing*)p->ptr); else SOAP_DELETE_ARRAY((ent__ProductItemProducing*)p->ptr);
		break;
	case SOAP_TYPE_ent__Packaging:
		if(p->size < 0) SOAP_DELETE((ent__Packaging*)p->ptr); else SOAP_DELETE_ARRAY((ent__Packaging*)p->ptr);
		break;
	case SOAP_TYPE_ent__Location:
		if(p->size < 0) SOAP_DELETE((ent__Location*)p->ptr); else SOAP_DELETE_ARRAY((ent__Location*)p->ptr);
		break;
	case SOAP_TYPE_ent__EnterpriseOfficialRegistration:
		if(p->size < 0) SOAP_DELETE((ent__EnterpriseOfficialRegistration*)p->ptr); else SOAP_DELETE_ARRAY((ent__EnterpriseOfficialRegistration*)p->ptr);
		break;
	case SOAP_TYPE_ent__Organization:
		if(p->size < 0) SOAP_DELETE((ent__Organization*)p->ptr); else SOAP_DELETE_ARRAY((ent__Organization*)p->ptr);
		break;
	case SOAP_TYPE_ent__MedicinalDrug:
		if(p->size < 0) SOAP_DELETE((ent__MedicinalDrug*)p->ptr); else SOAP_DELETE_ARRAY((ent__MedicinalDrug*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationConditionGroup:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationConditionGroup*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationConditionGroup*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationRequirement:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationRequirement*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationStatus:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationStatus*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationStatus*)p->ptr);
		break;
	case SOAP_TYPE_vd__Batch:
		if(p->size < 0) SOAP_DELETE((vd__Batch*)p->ptr); else SOAP_DELETE_ARRAY((vd__Batch*)p->ptr);
		break;
	case SOAP_TYPE_vd__RawBatch:
		if(p->size < 0) SOAP_DELETE((vd__RawBatch*)p->ptr); else SOAP_DELETE_ARRAY((vd__RawBatch*)p->ptr);
		break;
	case SOAP_TYPE_vd__DeliveryFactList:
		if(p->size < 0) SOAP_DELETE((vd__DeliveryFactList*)p->ptr); else SOAP_DELETE_ARRAY((vd__DeliveryFactList*)p->ptr);
		break;
	case SOAP_TYPE_vd__DeliveryInspection:
		if(p->size < 0) SOAP_DELETE((vd__DeliveryInspection*)p->ptr); else SOAP_DELETE_ARRAY((vd__DeliveryInspection*)p->ptr);
		break;
	case SOAP_TYPE_vd__ConsignmentDocumentList:
		if(p->size < 0) SOAP_DELETE((vd__ConsignmentDocumentList*)p->ptr); else SOAP_DELETE_ARRAY((vd__ConsignmentDocumentList*)p->ptr);
		break;
	case SOAP_TYPE_vd__GoodsDate:
		if(p->size < 0) SOAP_DELETE((vd__GoodsDate*)p->ptr); else SOAP_DELETE_ARRAY((vd__GoodsDate*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockDiscrepancy:
		if(p->size < 0) SOAP_DELETE((vd__StockDiscrepancy*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockDiscrepancy*)p->ptr);
		break;
	case SOAP_TYPE_vd__TransportInfo:
		if(p->size < 0) SOAP_DELETE((vd__TransportInfo*)p->ptr); else SOAP_DELETE_ARRAY((vd__TransportInfo*)p->ptr);
		break;
	case SOAP_TYPE_vd__TransportNumber:
		if(p->size < 0) SOAP_DELETE((vd__TransportNumber*)p->ptr); else SOAP_DELETE_ARRAY((vd__TransportNumber*)p->ptr);
		break;
	case SOAP_TYPE_vd__ShipmentRoute:
		if(p->size < 0) SOAP_DELETE((vd__ShipmentRoute*)p->ptr); else SOAP_DELETE_ARRAY((vd__ShipmentRoute*)p->ptr);
		break;
	case SOAP_TYPE_vd__ProductionOperation:
		if(p->size < 0) SOAP_DELETE((vd__ProductionOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__ProductionOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__MergeStockEntriesOperation:
		if(p->size < 0) SOAP_DELETE((vd__MergeStockEntriesOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__MergeStockEntriesOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__PSLModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__PSLModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__PSLModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__BEModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__BEModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__BEModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation:
		if(p->size < 0) SOAP_DELETE((_vd__BEActivityLocationsModificationOperation_activityLocation*)p->ptr); else SOAP_DELETE_ARRAY((_vd__BEActivityLocationsModificationOperation_activityLocation*)p->ptr);
		break;
	case SOAP_TYPE_vd__BEActivityLocationsModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__BEActivityLocationsModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__BEActivityLocationsModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__ENTModificationOperation:
		if(p->size < 0) SOAP_DELETE((vd__ENTModificationOperation*)p->ptr); else SOAP_DELETE_ARRAY((vd__ENTModificationOperation*)p->ptr);
		break;
	case SOAP_TYPE_vd__CertifiedBatch:
		if(p->size < 0) SOAP_DELETE((vd__CertifiedBatch*)p->ptr); else SOAP_DELETE_ARRAY((vd__CertifiedBatch*)p->ptr);
		break;
	case SOAP_TYPE_vd__CertifiedConsignment:
		if(p->size < 0) SOAP_DELETE((vd__CertifiedConsignment*)p->ptr); else SOAP_DELETE_ARRAY((vd__CertifiedConsignment*)p->ptr);
		break;
	case SOAP_TYPE_vd__VeterinaryEvent:
		if(p->size < 0) SOAP_DELETE((vd__VeterinaryEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__VeterinaryEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__VeterinaryAuthentication:
		if(p->size < 0) SOAP_DELETE((vd__VeterinaryAuthentication*)p->ptr); else SOAP_DELETE_ARRAY((vd__VeterinaryAuthentication*)p->ptr);
		break;
	case SOAP_TYPE_vd__BatchOrigin:
		if(p->size < 0) SOAP_DELETE((vd__BatchOrigin*)p->ptr); else SOAP_DELETE_ARRAY((vd__BatchOrigin*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntryEventList:
		if(p->size < 0) SOAP_DELETE((vd__StockEntryEventList*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntryEventList*)p->ptr);
		break;
	case SOAP_TYPE_vd__VetDocumentStatusChange:
		if(p->size < 0) SOAP_DELETE((vd__VetDocumentStatusChange*)p->ptr); else SOAP_DELETE_ARRAY((vd__VetDocumentStatusChange*)p->ptr);
		break;
	case SOAP_TYPE_vd__RegionalizationClause:
		if(p->size < 0) SOAP_DELETE((vd__RegionalizationClause*)p->ptr); else SOAP_DELETE_ARRAY((vd__RegionalizationClause*)p->ptr);
		break;
	case SOAP_TYPE_vd__RouteSectionR13nRules:
		if(p->size < 0) SOAP_DELETE((vd__RouteSectionR13nRules*)p->ptr); else SOAP_DELETE_ARRAY((vd__RouteSectionR13nRules*)p->ptr);
		break;
	case SOAP_TYPE_vd__ProcessingProcedure:
		if(p->size < 0) SOAP_DELETE((vd__ProcessingProcedure*)p->ptr); else SOAP_DELETE_ARRAY((vd__ProcessingProcedure*)p->ptr);
		break;
	case SOAP_TYPE_vd__AuthorityList:
		if(p->size < 0) SOAP_DELETE((vd__AuthorityList*)p->ptr); else SOAP_DELETE_ARRAY((vd__AuthorityList*)p->ptr);
		break;
	case SOAP_TYPE_vd__UserAuthority:
		if(p->size < 0) SOAP_DELETE((vd__UserAuthority*)p->ptr); else SOAP_DELETE_ARRAY((vd__UserAuthority*)p->ptr);
		break;
	case SOAP_TYPE_vd__WorkingArea:
		if(p->size < 0) SOAP_DELETE((vd__WorkingArea*)p->ptr); else SOAP_DELETE_ARRAY((vd__WorkingArea*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getPurposeChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getPurposeChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getPurposeChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getUnitChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getUnitChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getUnitChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByTypeListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByTypeListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByTypeListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductByTypeListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductByTypeListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductByTypeListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByProductListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByProductListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByProductListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductByProductListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductByProductListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductByProductListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getSubProductChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getSubProductChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getSubProductChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getProductItemChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getProductItemChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getProductItemChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getAllCountryListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getAllCountryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getAllCountryListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getAllCountryListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getAllCountryListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getAllCountryListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getCountryChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getCountryChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getCountryChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionListByCountryRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionListByCountryRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionListByCountryRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionListByCountryResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionListByCountryResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionListByCountryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRegionChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRegionChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRegionChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictListByRegionRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictListByRegionRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictListByRegionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictListByRegionResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictListByRegionResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictListByRegionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDistrictChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDistrictChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDistrictChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByRegionRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByRegionRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByRegionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByRegionResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByRegionResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByRegionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByDistrictRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByDistrictRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByDistrictResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByDistrictResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByDistrictResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByLocalityRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByLocalityRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getLocalityListByLocalityResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getLocalityListByLocalityResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getLocalityListByLocalityResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getStreetListByLocalityRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getStreetListByLocalityRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getStreetListByLocalityRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getStreetListByLocalityResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getStreetListByLocalityResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getStreetListByLocalityResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findLocalityListByNameRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__findLocalityListByNameRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findLocalityListByNameRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findLocalityListByNameResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__findLocalityListByNameResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findLocalityListByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findStreetListByNameRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__findStreetListByNameRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findStreetListByNameRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__findStreetListByNameResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__findStreetListByNameResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__findStreetListByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getEnterpriseByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getEnterpriseByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getEnterpriseByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getForeignEnterpriseChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getForeignEnterpriseChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getRussianEnterpriseChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getRussianEnterpriseChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessEntityChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessEntityChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessEntityChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessMemberByGLNRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessMemberByGLNRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getBusinessMemberByGLNResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getBusinessMemberByGLNResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getBusinessMemberByGLNResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActivityLocationListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getActivityLocationListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActivityLocationListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActivityLocationListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getActivityLocationListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActivityLocationListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getR13nConditionListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getR13nConditionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getR13nConditionListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getR13nConditionListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getR13nConditionListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getR13nConditionListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nRegionStatusListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nRegionStatusListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nRegionStatusListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nRegionStatusListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nShippingRuleListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nShippingRuleListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getActualR13nShippingRuleListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getActualR13nShippingRuleListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getDiseaseChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getDiseaseChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getDiseaseChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByGuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodByUuidResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodListResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListRequest:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns8__getResearchMethodChangesListResponse:
		if(p->size < 0) SOAP_DELETE((_ns8__getResearchMethodChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((_ns8__getResearchMethodChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_base__GenericVersioningEntity:
		if(p->size < 0) SOAP_DELETE((base__GenericVersioningEntity*)p->ptr); else SOAP_DELETE_ARRAY((base__GenericVersioningEntity*)p->ptr);
		break;
	case SOAP_TYPE_base__Error:
		if(p->size < 0) SOAP_DELETE((base__Error*)p->ptr); else SOAP_DELETE_ARRAY((base__Error*)p->ptr);
		break;
	case SOAP_TYPE_merc__MercuryApplicationRequest:
		if(p->size < 0) SOAP_DELETE((merc__MercuryApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__MercuryApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__ProcessIncomingConsignmentResponse:
		if(p->size < 0) SOAP_DELETE((merc__ProcessIncomingConsignmentResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__ProcessIncomingConsignmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse:
		if(p->size < 0) SOAP_DELETE((merc__PrepareOutgoingConsignmentResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__PrepareOutgoingConsignmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__RegisterProductionOperationResponse:
		if(p->size < 0) SOAP_DELETE((merc__RegisterProductionOperationResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__RegisterProductionOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__MergeStockEntriesResponse:
		if(p->size < 0) SOAP_DELETE((merc__MergeStockEntriesResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__MergeStockEntriesResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__WithdrawVetDocumentResponse:
		if(p->size < 0) SOAP_DELETE((merc__WithdrawVetDocumentResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__WithdrawVetDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyBusinessEntityResponse:
		if(p->size < 0) SOAP_DELETE((merc__ModifyBusinessEntityResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyBusinessEntityResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyEnterpriseResponse:
		if(p->size < 0) SOAP_DELETE((merc__ModifyEnterpriseResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyEnterpriseResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyActivityLocationsResponse:
		if(p->size < 0) SOAP_DELETE((merc__ModifyActivityLocationsResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyActivityLocationsResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__ResolveDiscrepancyResponse:
		if(p->size < 0) SOAP_DELETE((merc__ResolveDiscrepancyResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__ResolveDiscrepancyResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyProducerStockListResponse:
		if(p->size < 0) SOAP_DELETE((merc__ModifyProducerStockListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyProducerStockListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetVetDocumentByUuidResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetVetDocumentByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetVetDocumentByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetVetDocumentListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetVetDocumentListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetVetDocumentListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetVetDocumentChangesListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetVetDocumentChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetVetDocumentChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryByGuidResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryByGuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryByGuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryByUuidResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryByUuidResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryByUuidResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryChangesListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryChangesListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryChangesListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryVersionListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryVersionListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryVersionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse:
		if(p->size < 0) SOAP_DELETE((merc__UpdateTransportMovementDetailsResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateTransportMovementDetailsResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateVeterinaryEventsResponse:
		if(p->size < 0) SOAP_DELETE((merc__UpdateVeterinaryEventsResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateVeterinaryEventsResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__CheckShipmentRegionalizationResponse:
		if(p->size < 0) SOAP_DELETE((merc__CheckShipmentRegionalizationResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__CheckShipmentRegionalizationResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__AddBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((merc__AddBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__AddBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetBusinessEntityUserListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetBusinessEntityUserListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetBusinessEntityUserListResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateUserAuthoritiesResponse:
		if(p->size < 0) SOAP_DELETE((merc__UpdateUserAuthoritiesResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateUserAuthoritiesResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateUserWorkingAreasResponse:
		if(p->size < 0) SOAP_DELETE((merc__UpdateUserWorkingAreasResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateUserWorkingAreasResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__UnbindBusinessEntityUserResponse:
		if(p->size < 0) SOAP_DELETE((merc__UnbindBusinessEntityUserResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__UnbindBusinessEntityUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse:
		if(p->size < 0) SOAP_DELETE((merc__GetAppliedUserAuthorityListResponse*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetAppliedUserAuthorityListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ent__PurposeList:
		if(p->size < 0) SOAP_DELETE((ent__PurposeList*)p->ptr); else SOAP_DELETE_ARRAY((ent__PurposeList*)p->ptr);
		break;
	case SOAP_TYPE_ent__UnitList:
		if(p->size < 0) SOAP_DELETE((ent__UnitList*)p->ptr); else SOAP_DELETE_ARRAY((ent__UnitList*)p->ptr);
		break;
	case SOAP_TYPE_ent__CountryList:
		if(p->size < 0) SOAP_DELETE((ent__CountryList*)p->ptr); else SOAP_DELETE_ARRAY((ent__CountryList*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionList:
		if(p->size < 0) SOAP_DELETE((ent__RegionList*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionList*)p->ptr);
		break;
	case SOAP_TYPE_ent__DistrictList:
		if(p->size < 0) SOAP_DELETE((ent__DistrictList*)p->ptr); else SOAP_DELETE_ARRAY((ent__DistrictList*)p->ptr);
		break;
	case SOAP_TYPE_ent__LocalityList:
		if(p->size < 0) SOAP_DELETE((ent__LocalityList*)p->ptr); else SOAP_DELETE_ARRAY((ent__LocalityList*)p->ptr);
		break;
	case SOAP_TYPE_ent__StreetList:
		if(p->size < 0) SOAP_DELETE((ent__StreetList*)p->ptr); else SOAP_DELETE_ARRAY((ent__StreetList*)p->ptr);
		break;
	case SOAP_TYPE_ent__EnterpriseActivityList:
		if(p->size < 0) SOAP_DELETE((ent__EnterpriseActivityList*)p->ptr); else SOAP_DELETE_ARRAY((ent__EnterpriseActivityList*)p->ptr);
		break;
	case SOAP_TYPE_ent__EnterpriseActivity:
		if(p->size < 0) SOAP_DELETE((ent__EnterpriseActivity*)p->ptr); else SOAP_DELETE_ARRAY((ent__EnterpriseActivity*)p->ptr);
		break;
	case SOAP_TYPE_ent__EnterpriseList:
		if(p->size < 0) SOAP_DELETE((ent__EnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((ent__EnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE_ent__IncorporationForm:
		if(p->size < 0) SOAP_DELETE((ent__IncorporationForm*)p->ptr); else SOAP_DELETE_ARRAY((ent__IncorporationForm*)p->ptr);
		break;
	case SOAP_TYPE_ent__BusinessEntityList:
		if(p->size < 0) SOAP_DELETE((ent__BusinessEntityList*)p->ptr); else SOAP_DELETE_ARRAY((ent__BusinessEntityList*)p->ptr);
		break;
	case SOAP_TYPE_ent__ProductList:
		if(p->size < 0) SOAP_DELETE((ent__ProductList*)p->ptr); else SOAP_DELETE_ARRAY((ent__ProductList*)p->ptr);
		break;
	case SOAP_TYPE_ent__SubProductList:
		if(p->size < 0) SOAP_DELETE((ent__SubProductList*)p->ptr); else SOAP_DELETE_ARRAY((ent__SubProductList*)p->ptr);
		break;
	case SOAP_TYPE_ent__ProductItemList:
		if(p->size < 0) SOAP_DELETE((ent__ProductItemList*)p->ptr); else SOAP_DELETE_ARRAY((ent__ProductItemList*)p->ptr);
		break;
	case SOAP_TYPE_ent__Area:
		if(p->size < 0) SOAP_DELETE((ent__Area*)p->ptr); else SOAP_DELETE_ARRAY((ent__Area*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationConditionList:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationConditionList*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationConditionList*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationRegionStatusList:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationRegionStatusList*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationRegionStatusList*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationShippingRuleList:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationShippingRuleList*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationShippingRuleList*)p->ptr);
		break;
	case SOAP_TYPE_ent__AnimalDiseaseList:
		if(p->size < 0) SOAP_DELETE((ent__AnimalDiseaseList*)p->ptr); else SOAP_DELETE_ARRAY((ent__AnimalDiseaseList*)p->ptr);
		break;
	case SOAP_TYPE_ent__ResearchMethodList:
		if(p->size < 0) SOAP_DELETE((ent__ResearchMethodList*)p->ptr); else SOAP_DELETE_ARRAY((ent__ResearchMethodList*)p->ptr);
		break;
	case SOAP_TYPE_ent__ActivityLocationList:
		if(p->size < 0) SOAP_DELETE((ent__ActivityLocationList*)p->ptr); else SOAP_DELETE_ARRAY((ent__ActivityLocationList*)p->ptr);
		break;
	case SOAP_TYPE_vd__Consignment:
		if(p->size < 0) SOAP_DELETE((vd__Consignment*)p->ptr); else SOAP_DELETE_ARRAY((vd__Consignment*)p->ptr);
		break;
	case SOAP_TYPE_vd__ProductiveBatch:
		if(p->size < 0) SOAP_DELETE((vd__ProductiveBatch*)p->ptr); else SOAP_DELETE_ARRAY((vd__ProductiveBatch*)p->ptr);
		break;
	case SOAP_TYPE_vd__Delivery:
		if(p->size < 0) SOAP_DELETE((vd__Delivery*)p->ptr); else SOAP_DELETE_ARRAY((vd__Delivery*)p->ptr);
		break;
	case SOAP_TYPE_vd__VetDocumentList:
		if(p->size < 0) SOAP_DELETE((vd__VetDocumentList*)p->ptr); else SOAP_DELETE_ARRAY((vd__VetDocumentList*)p->ptr);
		break;
	case SOAP_TYPE_vd__DiscrepancyReason:
		if(p->size < 0) SOAP_DELETE((vd__DiscrepancyReason*)p->ptr); else SOAP_DELETE_ARRAY((vd__DiscrepancyReason*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntryList:
		if(p->size < 0) SOAP_DELETE((vd__StockEntryList*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntryList*)p->ptr);
		break;
	case SOAP_TYPE_vd__Document:
		if(p->size < 0) SOAP_DELETE((vd__Document*)p->ptr); else SOAP_DELETE_ARRAY((vd__Document*)p->ptr);
		break;
	case SOAP_TYPE_vd__ShipmentRoutePoint:
		if(p->size < 0) SOAP_DELETE((vd__ShipmentRoutePoint*)p->ptr); else SOAP_DELETE_ARRAY((vd__ShipmentRoutePoint*)p->ptr);
		break;
	case SOAP_TYPE_vd__LaboratoryResearchEvent:
		if(p->size < 0) SOAP_DELETE((vd__LaboratoryResearchEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__LaboratoryResearchEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__AnimalMedicationEvent:
		if(p->size < 0) SOAP_DELETE((vd__AnimalMedicationEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__AnimalMedicationEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__QuarantineEvent:
		if(p->size < 0) SOAP_DELETE((vd__QuarantineEvent*)p->ptr); else SOAP_DELETE_ARRAY((vd__QuarantineEvent*)p->ptr);
		break;
	case SOAP_TYPE_vd__User:
		if(p->size < 0) SOAP_DELETE((vd__User*)p->ptr); else SOAP_DELETE_ARRAY((vd__User*)p->ptr);
		break;
	case SOAP_TYPE_vd__UserList:
		if(p->size < 0) SOAP_DELETE((vd__UserList*)p->ptr); else SOAP_DELETE_ARRAY((vd__UserList*)p->ptr);
		break;
	case SOAP_TYPE_vd__WorkingAreaList:
		if(p->size < 0) SOAP_DELETE((vd__WorkingAreaList*)p->ptr); else SOAP_DELETE_ARRAY((vd__WorkingAreaList*)p->ptr);
		break;
	case SOAP_TYPE_app__BusinessError:
		if(p->size < 0) SOAP_DELETE((app__BusinessError*)p->ptr); else SOAP_DELETE_ARRAY((app__BusinessError*)p->ptr);
		break;
	case SOAP_TYPE_merc__ProcessIncomingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((merc__ProcessIncomingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__ProcessIncomingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((merc__PrepareOutgoingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__PrepareOutgoingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__RegisterProductionOperationRequest:
		if(p->size < 0) SOAP_DELETE((merc__RegisterProductionOperationRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__RegisterProductionOperationRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__MergeStockEntriesRequest:
		if(p->size < 0) SOAP_DELETE((merc__MergeStockEntriesRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__MergeStockEntriesRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__WithdrawVetDocumentRequest:
		if(p->size < 0) SOAP_DELETE((merc__WithdrawVetDocumentRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__WithdrawVetDocumentRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyBusinessEntityRequest:
		if(p->size < 0) SOAP_DELETE((merc__ModifyBusinessEntityRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyBusinessEntityRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyEnterpriseRequest:
		if(p->size < 0) SOAP_DELETE((merc__ModifyEnterpriseRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyEnterpriseRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyActivityLocationsRequest:
		if(p->size < 0) SOAP_DELETE((merc__ModifyActivityLocationsRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyActivityLocationsRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__ResolveDiscrepancyRequest:
		if(p->size < 0) SOAP_DELETE((merc__ResolveDiscrepancyRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__ResolveDiscrepancyRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__ModifyProducerStockListRequest:
		if(p->size < 0) SOAP_DELETE((merc__ModifyProducerStockListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__ModifyProducerStockListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetVetDocumentByUuidRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetVetDocumentByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetVetDocumentByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetVetDocumentListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetVetDocumentListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetVetDocumentListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetVetDocumentChangesListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetVetDocumentChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetVetDocumentChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetStockEntryVersionListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetStockEntryVersionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetStockEntryVersionListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest:
		if(p->size < 0) SOAP_DELETE((merc__UpdateTransportMovementDetailsRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateTransportMovementDetailsRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateVeterinaryEventsRequest:
		if(p->size < 0) SOAP_DELETE((merc__UpdateVeterinaryEventsRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateVeterinaryEventsRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__CheckShipmentRegionalizationRequest:
		if(p->size < 0) SOAP_DELETE((merc__CheckShipmentRegionalizationRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__CheckShipmentRegionalizationRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__AddBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((merc__AddBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__AddBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetBusinessEntityUserListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetBusinessEntityUserListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetBusinessEntityUserListRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateUserAuthoritiesRequest:
		if(p->size < 0) SOAP_DELETE((merc__UpdateUserAuthoritiesRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateUserAuthoritiesRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__UpdateUserWorkingAreasRequest:
		if(p->size < 0) SOAP_DELETE((merc__UpdateUserWorkingAreasRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__UpdateUserWorkingAreasRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__UnbindBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((merc__UnbindBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__UnbindBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest:
		if(p->size < 0) SOAP_DELETE((merc__GetAppliedUserAuthorityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((merc__GetAppliedUserAuthorityListRequest*)p->ptr);
		break;
	case SOAP_TYPE_ent__Purpose:
		if(p->size < 0) SOAP_DELETE((ent__Purpose*)p->ptr); else SOAP_DELETE_ARRAY((ent__Purpose*)p->ptr);
		break;
	case SOAP_TYPE_ent__Unit:
		if(p->size < 0) SOAP_DELETE((ent__Unit*)p->ptr); else SOAP_DELETE_ARRAY((ent__Unit*)p->ptr);
		break;
	case SOAP_TYPE_ent__PackingType:
		if(p->size < 0) SOAP_DELETE((ent__PackingType*)p->ptr); else SOAP_DELETE_ARRAY((ent__PackingType*)p->ptr);
		break;
	case SOAP_TYPE_ent__Country:
		if(p->size < 0) SOAP_DELETE((ent__Country*)p->ptr); else SOAP_DELETE_ARRAY((ent__Country*)p->ptr);
		break;
	case SOAP_TYPE_ent__FederalDistrict:
		if(p->size < 0) SOAP_DELETE((ent__FederalDistrict*)p->ptr); else SOAP_DELETE_ARRAY((ent__FederalDistrict*)p->ptr);
		break;
	case SOAP_TYPE_ent__AddressObjectView:
		if(p->size < 0) SOAP_DELETE((ent__AddressObjectView*)p->ptr); else SOAP_DELETE_ARRAY((ent__AddressObjectView*)p->ptr);
		break;
	case SOAP_TYPE_ent__Enterprise:
		if(p->size < 0) SOAP_DELETE((ent__Enterprise*)p->ptr); else SOAP_DELETE_ARRAY((ent__Enterprise*)p->ptr);
		break;
	case SOAP_TYPE__ent__BusinessEntity_activityLocation:
		if(p->size < 0) SOAP_DELETE((_ent__BusinessEntity_activityLocation*)p->ptr); else SOAP_DELETE_ARRAY((_ent__BusinessEntity_activityLocation*)p->ptr);
		break;
	case SOAP_TYPE_ent__BusinessEntity:
		if(p->size < 0) SOAP_DELETE((ent__BusinessEntity*)p->ptr); else SOAP_DELETE_ARRAY((ent__BusinessEntity*)p->ptr);
		break;
	case SOAP_TYPE_ent__ProductItem:
		if(p->size < 0) SOAP_DELETE((ent__ProductItem*)p->ptr); else SOAP_DELETE_ARRAY((ent__ProductItem*)p->ptr);
		break;
	case SOAP_TYPE_ent__Product:
		if(p->size < 0) SOAP_DELETE((ent__Product*)p->ptr); else SOAP_DELETE_ARRAY((ent__Product*)p->ptr);
		break;
	case SOAP_TYPE_ent__SubProduct:
		if(p->size < 0) SOAP_DELETE((ent__SubProduct*)p->ptr); else SOAP_DELETE_ARRAY((ent__SubProduct*)p->ptr);
		break;
	case SOAP_TYPE_ent__ProductMarks:
		if(p->size < 0) SOAP_DELETE((ent__ProductMarks*)p->ptr); else SOAP_DELETE_ARRAY((ent__ProductMarks*)p->ptr);
		break;
	case SOAP_TYPE_ent__Indicator:
		if(p->size < 0) SOAP_DELETE((ent__Indicator*)p->ptr); else SOAP_DELETE_ARRAY((ent__Indicator*)p->ptr);
		break;
	case SOAP_TYPE_ent__AnimalDisease:
		if(p->size < 0) SOAP_DELETE((ent__AnimalDisease*)p->ptr); else SOAP_DELETE_ARRAY((ent__AnimalDisease*)p->ptr);
		break;
	case SOAP_TYPE_ent__ResearchMethod:
		if(p->size < 0) SOAP_DELETE((ent__ResearchMethod*)p->ptr); else SOAP_DELETE_ARRAY((ent__ResearchMethod*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationCondition:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationCondition*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationCondition*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationShippingRule:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationShippingRule*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationShippingRule*)p->ptr);
		break;
	case SOAP_TYPE_ent__RegionalizationRegionStatus:
		if(p->size < 0) SOAP_DELETE((ent__RegionalizationRegionStatus*)p->ptr); else SOAP_DELETE_ARRAY((ent__RegionalizationRegionStatus*)p->ptr);
		break;
	case SOAP_TYPE_vd__VetDocument:
		if(p->size < 0) SOAP_DELETE((vd__VetDocument*)p->ptr); else SOAP_DELETE_ARRAY((vd__VetDocument*)p->ptr);
		break;
	case SOAP_TYPE_vd__DiscrepancyReport:
		if(p->size < 0) SOAP_DELETE((vd__DiscrepancyReport*)p->ptr); else SOAP_DELETE_ARRAY((vd__DiscrepancyReport*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntry:
		if(p->size < 0) SOAP_DELETE((vd__StockEntry*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntry*)p->ptr);
		break;
	case SOAP_TYPE_vd__Waybill:
		if(p->size < 0) SOAP_DELETE((vd__Waybill*)p->ptr); else SOAP_DELETE_ARRAY((vd__Waybill*)p->ptr);
		break;
	case SOAP_TYPE_vd__ReferencedDocument:
		if(p->size < 0) SOAP_DELETE((vd__ReferencedDocument*)p->ptr); else SOAP_DELETE_ARRAY((vd__ReferencedDocument*)p->ptr);
		break;
	case SOAP_TYPE_ent__Region:
		if(p->size < 0) SOAP_DELETE((ent__Region*)p->ptr); else SOAP_DELETE_ARRAY((ent__Region*)p->ptr);
		break;
	case SOAP_TYPE_ent__District:
		if(p->size < 0) SOAP_DELETE((ent__District*)p->ptr); else SOAP_DELETE_ARRAY((ent__District*)p->ptr);
		break;
	case SOAP_TYPE_ent__Locality:
		if(p->size < 0) SOAP_DELETE((ent__Locality*)p->ptr); else SOAP_DELETE_ARRAY((ent__Locality*)p->ptr);
		break;
	case SOAP_TYPE_ent__Street:
		if(p->size < 0) SOAP_DELETE((ent__Street*)p->ptr); else SOAP_DELETE_ARRAY((ent__Street*)p->ptr);
		break;
	case SOAP_TYPE_vd__StockEntrySearchPattern:
		if(p->size < 0) SOAP_DELETE((vd__StockEntrySearchPattern*)p->ptr); else SOAP_DELETE_ARRAY((vd__StockEntrySearchPattern*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns1__GetBusinessEntityByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetBusinessEntityByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetBusinessEntityByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBusinessEntityByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetBusinessEntityByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetBusinessEntityByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBusinessEntityList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetBusinessEntityList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetBusinessEntityList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBusinessEntityChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetBusinessEntityChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetBusinessEntityChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetEnterpriseByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetEnterpriseByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetEnterpriseByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetEnterpriseByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetEnterpriseByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetEnterpriseByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetForeignEnterpriseList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetForeignEnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetForeignEnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetRussianEnterpriseList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetRussianEnterpriseList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetRussianEnterpriseList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetForeignEnterpriseChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetForeignEnterpriseChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetForeignEnterpriseChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetRussianEnterpriseChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetRussianEnterpriseChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetRussianEnterpriseChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBusinessMemberByGLN:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetBusinessMemberByGLN*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetBusinessMemberByGLN*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetActivityLocationList:
		if(p->size < 0) SOAP_DELETE((struct __ns1__GetActivityLocationList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns1__GetActivityLocationList*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductByTypeList:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductByTypeList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductByTypeList*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetSubProductByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetSubProductByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetSubProductByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetSubProductByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetSubProductByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetSubProductByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetSubProductByProductList:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetSubProductByProductList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetSubProductByProductList*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetSubProductChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetSubProductChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetSubProductChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductItemByGuid:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductItemByGuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductItemByGuid*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductItemByUuid:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductItemByUuid*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductItemByUuid*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductItemList:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductItemList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductItemList*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetProductItemChangesList:
		if(p->size < 0) SOAP_DELETE((struct __ns2__GetProductItemChangesList*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns2__GetProductItemChangesList*)p->ptr);
		break;
	case SOAP_TYPE___ns3__submitApplicationRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns3__submitApplicationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns3__submitApplicationRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns3__receiveApplicationResult:
		if(p->size < 0) SOAP_DELETE((struct __ns3__receiveApplicationResult*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns3__receiveApplicationResult*)p->ptr);
		break;
	case SOAP_TYPE___ns4__processIncomingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__processIncomingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__processIncomingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__prepareOutgoingConsignmentRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__prepareOutgoingConsignmentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__prepareOutgoingConsignmentRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__registerProductionOperationRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__registerProductionOperationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__registerProductionOperationRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__mergeStockEntriesRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__mergeStockEntriesRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__mergeStockEntriesRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__withdrawVetDocumentRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__withdrawVetDocumentRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__withdrawVetDocumentRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__modifyBusinessEntityRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__modifyBusinessEntityRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__modifyBusinessEntityRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__modifyEnterpriseRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__modifyEnterpriseRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__modifyEnterpriseRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__modifyActivityLocationsRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__modifyActivityLocationsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__modifyActivityLocationsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__resolveDiscrepancyRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__resolveDiscrepancyRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__resolveDiscrepancyRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__modifyProducerStockListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__modifyProducerStockListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__modifyProducerStockListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getVetDocumentByUuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getVetDocumentByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getVetDocumentByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getVetDocumentListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getVetDocumentListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getVetDocumentListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getVetDocumentChangesListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getVetDocumentChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getVetDocumentChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getStockEntryByGuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getStockEntryByGuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getStockEntryByGuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getStockEntryByUuidRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getStockEntryByUuidRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getStockEntryByUuidRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getStockEntryListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getStockEntryListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getStockEntryListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getStockEntryChangesListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getStockEntryChangesListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getStockEntryChangesListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getStockEntryVersionListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getStockEntryVersionListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getStockEntryVersionListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__updateTransportMovementDetailsRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__updateTransportMovementDetailsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__updateTransportMovementDetailsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__updateVeterinaryEventsRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__updateVeterinaryEventsRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__updateVeterinaryEventsRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__checkShipmentRegionalizationRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__checkShipmentRegionalizationRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__checkShipmentRegionalizationRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__addBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__addBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__addBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getBusinessEntityUserListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getBusinessEntityUserListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getBusinessEntityUserListRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__updateUserAuthoritiesRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__updateUserAuthoritiesRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__updateUserAuthoritiesRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__updateUserWorkingAreasRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__updateUserWorkingAreasRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__updateUserWorkingAreasRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__unbindBusinessEntityUserRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__unbindBusinessEntityUserRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__unbindBusinessEntityUserRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns4__getAppliedUserAuthorityListRequest:
		if(p->size < 0) SOAP_DELETE((struct __ns4__getAppliedUserAuthorityListRequest*)p->ptr); else SOAP_DELETE_ARRAY((struct __ns4__getAppliedUserAuthorityListRequest*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if(p->size < 0) SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr); else SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_app__BinaryContent:
		if(p->size < 0) SOAP_DELETE((xsd__base64Binary*)p->ptr); else SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{
	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, vetisams_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * FASTCALL soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{;
	char * p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	return soap_out_byte(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if((p = soap_in_byte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Minute(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ent__Minute);
}

SOAP_FMAC3 int * FASTCALL soap_in_ent__Minute(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ent__Minute);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 59) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Minute(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Minute);
	return soap_out_ent__Minute(soap, tag?tag:"ent:Minute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ent__Minute(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Minute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Hour(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ent__Hour);
}

SOAP_FMAC3 int * FASTCALL soap_in_ent__Hour(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ent__Hour);
	if(p && *p < 0) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 23) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Hour(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Hour);
	return soap_out_ent__Hour(soap, tag?tag:"ent:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ent__Hour(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Day(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ent__Day);
}

SOAP_FMAC3 int * FASTCALL soap_in_ent__Day(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ent__Day);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 31) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Day(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Day);
	return soap_out_ent__Day(soap, tag?tag:"ent:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ent__Day(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Month(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ent__Month);
}

SOAP_FMAC3 int * FASTCALL soap_in_ent__Month(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ent__Month);
	if(p && *p < 1) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if(p && *p > 12) {
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Month(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Month);
	return soap_out_ent__Month(soap, tag?tag:"ent:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ent__Month(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Year(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ent__Year);
}

SOAP_FMAC3 int * FASTCALL soap_in_ent__Year(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_ent__Year);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Year(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Year);
	return soap_out_ent__Year(soap, tag?tag:"ent:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ent__Year(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * FASTCALL soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{;
	int * p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	return soap_out_int(soap, tag?tag:"int", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if((p = soap_in_int(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * FASTCALL soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{;
	LONG64 * p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	return soap_out_LONG64(soap, tag?tag:"long", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if((p = soap_in_LONG64(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * FASTCALL soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{;
	unsigned char * p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	return soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if((p = soap_in_unsignedByte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * FASTCALL soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{;
	unsigned int * p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	return soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if((p = soap_in_unsignedInt(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int FASTCALL soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * FASTCALL soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{;
	time_t * p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	return soap_out_time(soap, tag?tag:"dateTime", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if((p = soap_in_time(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int FASTCALL soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if(map)
		*a = (bool)(map->code != 0);
	else {
		long n;
		if(soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * FASTCALL soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	return soap_out_bool(soap, tag?tag:"boolean", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if((p = soap_in_bool(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__AnimalSpentPeriod
	*a = SOAP_DEFAULT_vd__AnimalSpentPeriod;
#else
	*a = (enum vd__AnimalSpentPeriod)0;
#endif
}

static const struct soap_code_map soap_codes_vd__AnimalSpentPeriod[] =
{	{ (long)vd__AnimalSpentPeriod__FROM_USCOREBIRTH, "FROM_BIRTH" },
	{ (long)vd__AnimalSpentPeriod__NOT_USCORELESS_USCORESIX_USCOREMONTHS, "NOT_LESS_SIX_MONTHS" },
	{ (long)vd__AnimalSpentPeriod__IN_USCOREMONTHS, "IN_MONTHS" },
	{ (long)vd__AnimalSpentPeriod__ZERO, "ZERO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__AnimalSpentPeriod2s(struct soap *soap, enum vd__AnimalSpentPeriod n)
{
	const char *s = soap_code_str(soap_codes_vd__AnimalSpentPeriod, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__AnimalSpentPeriod(struct soap *soap, const char *tag, int id, const enum vd__AnimalSpentPeriod *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__AnimalSpentPeriod), type) || soap_send(soap, soap_vd__AnimalSpentPeriod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__AnimalSpentPeriod(struct soap *soap, const char *s, enum vd__AnimalSpentPeriod *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__AnimalSpentPeriod, s);
	if(map)
		*a = (enum vd__AnimalSpentPeriod)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__AnimalSpentPeriod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod * FASTCALL soap_in_vd__AnimalSpentPeriod(struct soap *soap, const char *tag, enum vd__AnimalSpentPeriod *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__AnimalSpentPeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__AnimalSpentPeriod, sizeof(enum vd__AnimalSpentPeriod), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__AnimalSpentPeriod(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__AnimalSpentPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__AnimalSpentPeriod, 0, sizeof(enum vd__AnimalSpentPeriod), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__AnimalSpentPeriod(struct soap *soap, const enum vd__AnimalSpentPeriod *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__AnimalSpentPeriod);
	return soap_out_vd__AnimalSpentPeriod(soap, tag?tag:"vd:AnimalSpentPeriod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod * SOAP_FMAC4 soap_get_vd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__AnimalSpentPeriod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VetDocumentStatus
	*a = SOAP_DEFAULT_vd__VetDocumentStatus;
#else
	*a = (enum vd__VetDocumentStatus)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VetDocumentStatus[] =
{	{ (long)vd__VetDocumentStatus__CREATED, "CREATED" },
	{ (long)vd__VetDocumentStatus__CONFIRMED, "CONFIRMED" },
	{ (long)vd__VetDocumentStatus__WITHDRAWN, "WITHDRAWN" },
	{ (long)vd__VetDocumentStatus__UTILIZED, "UTILIZED" },
	{ (long)vd__VetDocumentStatus__FINALIZED, "FINALIZED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VetDocumentStatus2s(struct soap *soap, enum vd__VetDocumentStatus n)
{
	const char *s = soap_code_str(soap_codes_vd__VetDocumentStatus, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentStatus(struct soap *soap, const char *tag, int id, const enum vd__VetDocumentStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentStatus), type) || soap_send(soap, soap_vd__VetDocumentStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VetDocumentStatus(struct soap *soap, const char *s, enum vd__VetDocumentStatus *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VetDocumentStatus, s);
	if(map)
		*a = (enum vd__VetDocumentStatus)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VetDocumentStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VetDocumentStatus * FASTCALL soap_in_vd__VetDocumentStatus(struct soap *soap, const char *tag, enum vd__VetDocumentStatus *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VetDocumentStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentStatus, sizeof(enum vd__VetDocumentStatus), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VetDocumentStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentStatus, 0, sizeof(enum vd__VetDocumentStatus), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentStatus(struct soap *soap, const enum vd__VetDocumentStatus *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentStatus);
	return soap_out_vd__VetDocumentStatus(soap, tag?tag:"vd:VetDocumentStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentStatus * SOAP_FMAC4 soap_get_vd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VetDocumentType
	*a = SOAP_DEFAULT_vd__VetDocumentType;
#else
	*a = (enum vd__VetDocumentType)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VetDocumentType[] =
{	{ (long)vd__VetDocumentType__TRANSPORT, "TRANSPORT" },
	{ (long)vd__VetDocumentType__PRODUCTIVE, "PRODUCTIVE" },
	{ (long)vd__VetDocumentType__RETURNABLE, "RETURNABLE" },
	{ (long)vd__VetDocumentType__INCOMING, "INCOMING" },
	{ (long)vd__VetDocumentType__OUTGOING, "OUTGOING" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VetDocumentType2s(struct soap *soap, enum vd__VetDocumentType n)
{
	const char *s = soap_code_str(soap_codes_vd__VetDocumentType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentType(struct soap *soap, const char *tag, int id, const enum vd__VetDocumentType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentType), type) || soap_send(soap, soap_vd__VetDocumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VetDocumentType(struct soap *soap, const char *s, enum vd__VetDocumentType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VetDocumentType, s);
	if(map)
		*a = (enum vd__VetDocumentType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VetDocumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VetDocumentType * FASTCALL soap_in_vd__VetDocumentType(struct soap *soap, const char *tag, enum vd__VetDocumentType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VetDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentType, sizeof(enum vd__VetDocumentType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VetDocumentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentType, 0, sizeof(enum vd__VetDocumentType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentType(struct soap *soap, const enum vd__VetDocumentType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentType);
	return soap_out_vd__VetDocumentType(soap, tag?tag:"vd:VetDocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentType * SOAP_FMAC4 soap_get_vd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VetDocumentForm
	*a = SOAP_DEFAULT_vd__VetDocumentForm;
#else
	*a = (enum vd__VetDocumentForm)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VetDocumentForm[] =
{	{ (long)vd__VetDocumentForm__CERTCU1, "CERTCU1" },
	{ (long)vd__VetDocumentForm__LIC1, "LIC1" },
	{ (long)vd__VetDocumentForm__CERTCU2, "CERTCU2" },
	{ (long)vd__VetDocumentForm__LIC2, "LIC2" },
	{ (long)vd__VetDocumentForm__CERTCU3, "CERTCU3" },
	{ (long)vd__VetDocumentForm__LIC3, "LIC3" },
	{ (long)vd__VetDocumentForm__NOTE4, "NOTE4" },
	{ (long)vd__VetDocumentForm__CERT5I, "CERT5I" },
	{ (long)vd__VetDocumentForm__CERT61, "CERT61" },
	{ (long)vd__VetDocumentForm__CERT62, "CERT62" },
	{ (long)vd__VetDocumentForm__CERT63, "CERT63" },
	{ (long)vd__VetDocumentForm__PRODUCTIVE, "PRODUCTIVE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VetDocumentForm2s(struct soap *soap, enum vd__VetDocumentForm n)
{
	const char *s = soap_code_str(soap_codes_vd__VetDocumentForm, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentForm(struct soap *soap, const char *tag, int id, const enum vd__VetDocumentForm *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentForm), type) || soap_send(soap, soap_vd__VetDocumentForm2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VetDocumentForm(struct soap *soap, const char *s, enum vd__VetDocumentForm *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VetDocumentForm, s);
	if(map)
		*a = (enum vd__VetDocumentForm)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VetDocumentForm)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VetDocumentForm * FASTCALL soap_in_vd__VetDocumentForm(struct soap *soap, const char *tag, enum vd__VetDocumentForm *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VetDocumentForm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentForm, sizeof(enum vd__VetDocumentForm), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VetDocumentForm(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentForm, 0, sizeof(enum vd__VetDocumentForm), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentForm(struct soap *soap, const enum vd__VetDocumentForm *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentForm);
	return soap_out_vd__VetDocumentForm(soap, tag?tag:"vd:VetDocumentForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentForm * SOAP_FMAC4 soap_get_vd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__DeliveryInspectionResult(struct soap *soap, enum vd__DeliveryInspectionResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__DeliveryInspectionResult
	*a = SOAP_DEFAULT_vd__DeliveryInspectionResult;
#else
	*a = (enum vd__DeliveryInspectionResult)0;
#endif
}

static const struct soap_code_map soap_codes_vd__DeliveryInspectionResult[] =
{	{ (long)vd__DeliveryInspectionResult__CORRESPONDS, "CORRESPONDS" },
	{ (long)vd__DeliveryInspectionResult__MISMATCH, "MISMATCH" },
	{ (long)vd__DeliveryInspectionResult__UNSUPERVISED, "UNSUPERVISED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__DeliveryInspectionResult2s(struct soap *soap, enum vd__DeliveryInspectionResult n)
{
	const char *s = soap_code_str(soap_codes_vd__DeliveryInspectionResult, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryInspectionResult(struct soap *soap, const char *tag, int id, const enum vd__DeliveryInspectionResult *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryInspectionResult), type) || soap_send(soap, soap_vd__DeliveryInspectionResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__DeliveryInspectionResult(struct soap *soap, const char *s, enum vd__DeliveryInspectionResult *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__DeliveryInspectionResult, s);
	if(map)
		*a = (enum vd__DeliveryInspectionResult)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__DeliveryInspectionResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__DeliveryInspectionResult * FASTCALL soap_in_vd__DeliveryInspectionResult(struct soap *soap, const char *tag, enum vd__DeliveryInspectionResult *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__DeliveryInspectionResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryInspectionResult, sizeof(enum vd__DeliveryInspectionResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__DeliveryInspectionResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__DeliveryInspectionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryInspectionResult, 0, sizeof(enum vd__DeliveryInspectionResult), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__DeliveryInspectionResult(struct soap *soap, const enum vd__DeliveryInspectionResult *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__DeliveryInspectionResult);
	return soap_out_vd__DeliveryInspectionResult(soap, tag?tag:"vd:DeliveryInspectionResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__DeliveryInspectionResult * SOAP_FMAC4 soap_get_vd__DeliveryInspectionResult(struct soap *soap, enum vd__DeliveryInspectionResult *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryInspectionResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__DeliveryDecision(struct soap *soap, enum vd__DeliveryDecision *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__DeliveryDecision
	*a = SOAP_DEFAULT_vd__DeliveryDecision;
#else
	*a = (enum vd__DeliveryDecision)0;
#endif
}

static const struct soap_code_map soap_codes_vd__DeliveryDecision[] =
{	{ (long)vd__DeliveryDecision__ACCEPT_USCOREALL, "ACCEPT_ALL" },
	{ (long)vd__DeliveryDecision__PARTIALLY, "PARTIALLY" },
	{ (long)vd__DeliveryDecision__RETURN_USCOREALL, "RETURN_ALL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__DeliveryDecision2s(struct soap *soap, enum vd__DeliveryDecision n)
{
	const char *s = soap_code_str(soap_codes_vd__DeliveryDecision, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryDecision(struct soap *soap, const char *tag, int id, const enum vd__DeliveryDecision *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryDecision), type) || soap_send(soap, soap_vd__DeliveryDecision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__DeliveryDecision(struct soap *soap, const char *s, enum vd__DeliveryDecision *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__DeliveryDecision, s);
	if(map)
		*a = (enum vd__DeliveryDecision)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__DeliveryDecision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__DeliveryDecision * FASTCALL soap_in_vd__DeliveryDecision(struct soap *soap, const char *tag, enum vd__DeliveryDecision *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__DeliveryDecision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryDecision, sizeof(enum vd__DeliveryDecision), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__DeliveryDecision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__DeliveryDecision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryDecision, 0, sizeof(enum vd__DeliveryDecision), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__DeliveryDecision(struct soap *soap, const enum vd__DeliveryDecision *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__DeliveryDecision);
	return soap_out_vd__DeliveryDecision(soap, tag?tag:"vd:DeliveryDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__DeliveryDecision * SOAP_FMAC4 soap_get_vd__DeliveryDecision(struct soap *soap, enum vd__DeliveryDecision *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__ProductMarkingClass(struct soap *soap, enum ent__ProductMarkingClass *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__ProductMarkingClass
	*a = SOAP_DEFAULT_ent__ProductMarkingClass;
#else
	*a = (enum ent__ProductMarkingClass)0;
#endif
}

static const struct soap_code_map soap_codes_ent__ProductMarkingClass[] =
{	{ (long)ent__ProductMarkingClass__UNDEFINED, "UNDEFINED" },
	{ (long)ent__ProductMarkingClass__BN, "BN" },
	{ (long)ent__ProductMarkingClass__SSCC, "SSCC" },
	{ (long)ent__ProductMarkingClass__EAN8, "EAN8" },
	{ (long)ent__ProductMarkingClass__EAN13, "EAN13" },
	{ (long)ent__ProductMarkingClass__EAN128, "EAN128" },
	{ (long)ent__ProductMarkingClass__BUNDLE, "BUNDLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__ProductMarkingClass2s(struct soap *soap, enum ent__ProductMarkingClass n)
{
	const char *s = soap_code_str(soap_codes_ent__ProductMarkingClass, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductMarkingClass(struct soap *soap, const char *tag, int id, const enum ent__ProductMarkingClass *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProductMarkingClass), type) || soap_send(soap, soap_ent__ProductMarkingClass2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__ProductMarkingClass(struct soap *soap, const char *s, enum ent__ProductMarkingClass *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__ProductMarkingClass, s);
	if(map)
		*a = (enum ent__ProductMarkingClass)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__ProductMarkingClass)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__ProductMarkingClass * FASTCALL soap_in_ent__ProductMarkingClass(struct soap *soap, const char *tag, enum ent__ProductMarkingClass *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__ProductMarkingClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductMarkingClass, sizeof(enum ent__ProductMarkingClass), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__ProductMarkingClass(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__ProductMarkingClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProductMarkingClass, 0, sizeof(enum ent__ProductMarkingClass), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__ProductMarkingClass(struct soap *soap, const enum ent__ProductMarkingClass *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__ProductMarkingClass);
	return soap_out_ent__ProductMarkingClass(soap, tag?tag:"ent:ProductMarkingClass", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ProductMarkingClass * SOAP_FMAC4 soap_get_ent__ProductMarkingClass(struct soap *soap, enum ent__ProductMarkingClass *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductMarkingClass(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__TransportationStorageType(struct soap *soap, enum ent__TransportationStorageType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__TransportationStorageType
	*a = SOAP_DEFAULT_ent__TransportationStorageType;
#else
	*a = (enum ent__TransportationStorageType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__TransportationStorageType[] =
{	{ (long)ent__TransportationStorageType__FROZEN, "FROZEN" },
	{ (long)ent__TransportationStorageType__CHILLED, "CHILLED" },
	{ (long)ent__TransportationStorageType__COOLED, "COOLED" },
	{ (long)ent__TransportationStorageType__VENTILATED, "VENTILATED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__TransportationStorageType2s(struct soap *soap, enum ent__TransportationStorageType n)
{
	const char *s = soap_code_str(soap_codes_ent__TransportationStorageType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__TransportationStorageType(struct soap *soap, const char *tag, int id, const enum ent__TransportationStorageType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__TransportationStorageType), type) || soap_send(soap, soap_ent__TransportationStorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__TransportationStorageType(struct soap *soap, const char *s, enum ent__TransportationStorageType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__TransportationStorageType, s);
	if(map)
		*a = (enum ent__TransportationStorageType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__TransportationStorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__TransportationStorageType * FASTCALL soap_in_ent__TransportationStorageType(struct soap *soap, const char *tag, enum ent__TransportationStorageType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__TransportationStorageType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__TransportationStorageType, sizeof(enum ent__TransportationStorageType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__TransportationStorageType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__TransportationStorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__TransportationStorageType, 0, sizeof(enum ent__TransportationStorageType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__TransportationStorageType(struct soap *soap, const enum ent__TransportationStorageType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__TransportationStorageType);
	return soap_out_ent__TransportationStorageType(soap, tag?tag:"ent:TransportationStorageType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__TransportationStorageType * SOAP_FMAC4 soap_get_ent__TransportationStorageType(struct soap *soap, enum ent__TransportationStorageType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__TransportationStorageType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__DocumentNature(struct soap *soap, enum ent__DocumentNature *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__DocumentNature
	*a = SOAP_DEFAULT_ent__DocumentNature;
#else
	*a = (enum ent__DocumentNature)0;
#endif
}

static const struct soap_code_map soap_codes_ent__DocumentNature[] =
{	{ (long)ent__DocumentNature__ELECTRONIC, "ELECTRONIC" },
	{ (long)ent__DocumentNature__PAPER, "PAPER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__DocumentNature2s(struct soap *soap, enum ent__DocumentNature n)
{
	const char *s = soap_code_str(soap_codes_ent__DocumentNature, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__DocumentNature(struct soap *soap, const char *tag, int id, const enum ent__DocumentNature *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__DocumentNature), type) || soap_send(soap, soap_ent__DocumentNature2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__DocumentNature(struct soap *soap, const char *s, enum ent__DocumentNature *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__DocumentNature, s);
	if(map)
		*a = (enum ent__DocumentNature)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__DocumentNature)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__DocumentNature * FASTCALL soap_in_ent__DocumentNature(struct soap *soap, const char *tag, enum ent__DocumentNature *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__DocumentNature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__DocumentNature, sizeof(enum ent__DocumentNature), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__DocumentNature(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__DocumentNature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__DocumentNature, 0, sizeof(enum ent__DocumentNature), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__DocumentNature(struct soap *soap, const enum ent__DocumentNature *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__DocumentNature);
	return soap_out_ent__DocumentNature(soap, tag?tag:"ent:DocumentNature", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__DocumentNature * SOAP_FMAC4 soap_get_ent__DocumentNature(struct soap *soap, enum ent__DocumentNature *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__DocumentNature(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__EnterpriseRole(struct soap *soap, enum ent__EnterpriseRole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__EnterpriseRole
	*a = SOAP_DEFAULT_ent__EnterpriseRole;
#else
	*a = (enum ent__EnterpriseRole)0;
#endif
}

static const struct soap_code_map soap_codes_ent__EnterpriseRole[] =
{	{ (long)ent__EnterpriseRole__UNKNOWN, "UNKNOWN" },
	{ (long)ent__EnterpriseRole__PRODUCER, "PRODUCER" },
	{ (long)ent__EnterpriseRole__SLAUGHTER_USCOREHOUSE, "SLAUGHTER_HOUSE" },
	{ (long)ent__EnterpriseRole__CUTTING_USCOREPLANT, "CUTTING_PLANT" },
	{ (long)ent__EnterpriseRole__COLD_USCORESTORE, "COLD_STORE" },
	{ (long)ent__EnterpriseRole__PACKAGING_USCOREPLANT, "PACKAGING_PLANT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__EnterpriseRole2s(struct soap *soap, enum ent__EnterpriseRole n)
{
	const char *s = soap_code_str(soap_codes_ent__EnterpriseRole, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseRole(struct soap *soap, const char *tag, int id, const enum ent__EnterpriseRole *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseRole), type) || soap_send(soap, soap_ent__EnterpriseRole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__EnterpriseRole(struct soap *soap, const char *s, enum ent__EnterpriseRole *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__EnterpriseRole, s);
	if(map)
		*a = (enum ent__EnterpriseRole)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__EnterpriseRole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__EnterpriseRole * FASTCALL soap_in_ent__EnterpriseRole(struct soap *soap, const char *tag, enum ent__EnterpriseRole *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__EnterpriseRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseRole, sizeof(enum ent__EnterpriseRole), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__EnterpriseRole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__EnterpriseRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseRole, 0, sizeof(enum ent__EnterpriseRole), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__EnterpriseRole(struct soap *soap, const enum ent__EnterpriseRole *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseRole);
	return soap_out_ent__EnterpriseRole(soap, tag?tag:"ent:EnterpriseRole", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__EnterpriseRole * SOAP_FMAC4 soap_get_ent__EnterpriseRole(struct soap *soap, enum ent__EnterpriseRole *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseRole(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__ProcessingProcedureType(struct soap *soap, enum vd__ProcessingProcedureType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__ProcessingProcedureType
	*a = SOAP_DEFAULT_vd__ProcessingProcedureType;
#else
	*a = (enum vd__ProcessingProcedureType)0;
#endif
}

static const struct soap_code_map soap_codes_vd__ProcessingProcedureType[] =
{	{ (long)vd__ProcessingProcedureType__7, "7" },
	{ (long)vd__ProcessingProcedureType__12, "12" },
	{ (long)vd__ProcessingProcedureType__13, "13" },
	{ (long)vd__ProcessingProcedureType__34, "34" },
	{ (long)vd__ProcessingProcedureType__35, "35" },
	{ (long)vd__ProcessingProcedureType__37, "37" },
	{ (long)vd__ProcessingProcedureType__39, "39" },
	{ (long)vd__ProcessingProcedureType__40, "40" },
	{ (long)vd__ProcessingProcedureType__43, "43" },
	{ (long)vd__ProcessingProcedureType__51, "51" },
	{ (long)vd__ProcessingProcedureType__73, "73" },
	{ (long)vd__ProcessingProcedureType__95, "95" },
	{ (long)vd__ProcessingProcedureType__101, "101" },
	{ (long)vd__ProcessingProcedureType__102, "102" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__ProcessingProcedureType2s(struct soap *soap, enum vd__ProcessingProcedureType n)
{
	const char *s = soap_code_str(soap_codes_vd__ProcessingProcedureType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProcessingProcedureType(struct soap *soap, const char *tag, int id, const enum vd__ProcessingProcedureType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProcessingProcedureType), type) || soap_send(soap, soap_vd__ProcessingProcedureType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__ProcessingProcedureType(struct soap *soap, const char *s, enum vd__ProcessingProcedureType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__ProcessingProcedureType, s);
	if(map)
		*a = (enum vd__ProcessingProcedureType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 102)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__ProcessingProcedureType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__ProcessingProcedureType * FASTCALL soap_in_vd__ProcessingProcedureType(struct soap *soap, const char *tag, enum vd__ProcessingProcedureType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__ProcessingProcedureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProcessingProcedureType, sizeof(enum vd__ProcessingProcedureType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__ProcessingProcedureType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__ProcessingProcedureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProcessingProcedureType, 0, sizeof(enum vd__ProcessingProcedureType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__ProcessingProcedureType(struct soap *soap, const enum vd__ProcessingProcedureType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__ProcessingProcedureType);
	return soap_out_vd__ProcessingProcedureType(soap, tag?tag:"vd:ProcessingProcedureType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__ProcessingProcedureType * SOAP_FMAC4 soap_get_vd__ProcessingProcedureType(struct soap *soap, enum vd__ProcessingProcedureType *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProcessingProcedureType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__VeterinaryEventType
	*a = SOAP_DEFAULT_vd__VeterinaryEventType;
#else
	*a = (enum vd__VeterinaryEventType)0;
#endif
}

static const struct soap_code_map soap_codes_vd__VeterinaryEventType[] =
{	{ (long)vd__VeterinaryEventType__UND, "UND" },
	{ (long)vd__VeterinaryEventType__LBR, "LBR" },
	{ (long)vd__VeterinaryEventType__VSE, "VSE" },
	{ (long)vd__VeterinaryEventType__IMM, "IMM" },
	{ (long)vd__VeterinaryEventType__MED, "MED" },
	{ (long)vd__VeterinaryEventType__QRT, "QRT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__VeterinaryEventType2s(struct soap *soap, enum vd__VeterinaryEventType n)
{
	const char *s = soap_code_str(soap_codes_vd__VeterinaryEventType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VeterinaryEventType(struct soap *soap, const char *tag, int id, const enum vd__VeterinaryEventType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VeterinaryEventType), type) || soap_send(soap, soap_vd__VeterinaryEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__VeterinaryEventType(struct soap *soap, const char *s, enum vd__VeterinaryEventType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__VeterinaryEventType, s);
	if(map)
		*a = (enum vd__VeterinaryEventType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__VeterinaryEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__VeterinaryEventType * FASTCALL soap_in_vd__VeterinaryEventType(struct soap *soap, const char *tag, enum vd__VeterinaryEventType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__VeterinaryEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VeterinaryEventType, sizeof(enum vd__VeterinaryEventType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__VeterinaryEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__VeterinaryEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VeterinaryEventType, 0, sizeof(enum vd__VeterinaryEventType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VeterinaryEventType(struct soap *soap, const enum vd__VeterinaryEventType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VeterinaryEventType);
	return soap_out_vd__VeterinaryEventType(soap, tag?tag:"vd:VeterinaryEventType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VeterinaryEventType * SOAP_FMAC4 soap_get_vd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VeterinaryEventType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vd__StockEntryBlankFilter
	*a = SOAP_DEFAULT_vd__StockEntryBlankFilter;
#else
	*a = (enum vd__StockEntryBlankFilter)0;
#endif
}

static const struct soap_code_map soap_codes_vd__StockEntryBlankFilter[] =
{	{ (long)vd__StockEntryBlankFilter__ALL, "ALL" },
	{ (long)vd__StockEntryBlankFilter__BLANK, "BLANK" },
	{ (long)vd__StockEntryBlankFilter__NOT_USCOREBLANK, "NOT_BLANK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vd__StockEntryBlankFilter2s(struct soap *soap, enum vd__StockEntryBlankFilter n)
{
	const char *s = soap_code_str(soap_codes_vd__StockEntryBlankFilter, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryBlankFilter(struct soap *soap, const char *tag, int id, const enum vd__StockEntryBlankFilter *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntryBlankFilter), type) || soap_send(soap, soap_vd__StockEntryBlankFilter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vd__StockEntryBlankFilter(struct soap *soap, const char *s, enum vd__StockEntryBlankFilter *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_vd__StockEntryBlankFilter, s);
	if(map)
		*a = (enum vd__StockEntryBlankFilter)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vd__StockEntryBlankFilter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter * FASTCALL soap_in_vd__StockEntryBlankFilter(struct soap *soap, const char *tag, enum vd__StockEntryBlankFilter *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vd__StockEntryBlankFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntryBlankFilter, sizeof(enum vd__StockEntryBlankFilter), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2vd__StockEntryBlankFilter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum vd__StockEntryBlankFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntryBlankFilter, 0, sizeof(enum vd__StockEntryBlankFilter), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__StockEntryBlankFilter(struct soap *soap, const enum vd__StockEntryBlankFilter *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__StockEntryBlankFilter);
	return soap_out_vd__StockEntryBlankFilter(soap, tag?tag:"vd:StockEntryBlankFilter", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter * SOAP_FMAC4 soap_get_vd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryBlankFilter(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__VaccinationType(struct soap *soap, enum ent__VaccinationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__VaccinationType
	*a = SOAP_DEFAULT_ent__VaccinationType;
#else
	*a = (enum ent__VaccinationType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__VaccinationType[] =
{	{ (long)ent__VaccinationType__UNDEFINED, "UNDEFINED" },
	{ (long)ent__VaccinationType__APPLIED, "APPLIED" },
	{ (long)ent__VaccinationType__UNVACCINATED, "UNVACCINATED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__VaccinationType2s(struct soap *soap, enum ent__VaccinationType n)
{
	const char *s = soap_code_str(soap_codes_ent__VaccinationType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__VaccinationType(struct soap *soap, const char *tag, int id, const enum ent__VaccinationType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__VaccinationType), type) || soap_send(soap, soap_ent__VaccinationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__VaccinationType(struct soap *soap, const char *s, enum ent__VaccinationType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__VaccinationType, s);
	if(map)
		*a = (enum ent__VaccinationType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__VaccinationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__VaccinationType * FASTCALL soap_in_ent__VaccinationType(struct soap *soap, const char *tag, enum ent__VaccinationType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__VaccinationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__VaccinationType, sizeof(enum ent__VaccinationType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__VaccinationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__VaccinationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__VaccinationType, 0, sizeof(enum ent__VaccinationType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__VaccinationType(struct soap *soap, const enum ent__VaccinationType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__VaccinationType);
	return soap_out_ent__VaccinationType(soap, tag?tag:"ent:VaccinationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__VaccinationType * SOAP_FMAC4 soap_get_ent__VaccinationType(struct soap *soap, enum ent__VaccinationType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__VaccinationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__ProsperityType(struct soap *soap, enum ent__ProsperityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__ProsperityType
	*a = SOAP_DEFAULT_ent__ProsperityType;
#else
	*a = (enum ent__ProsperityType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__ProsperityType[] =
{	{ (long)ent__ProsperityType__UNDEFINED, "UNDEFINED" },
	{ (long)ent__ProsperityType__UNKNOWN, "UNKNOWN" },
	{ (long)ent__ProsperityType__SAFE, "SAFE" },
	{ (long)ent__ProsperityType__UNSAFE, "UNSAFE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__ProsperityType2s(struct soap *soap, enum ent__ProsperityType n)
{
	const char *s = soap_code_str(soap_codes_ent__ProsperityType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProsperityType(struct soap *soap, const char *tag, int id, const enum ent__ProsperityType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProsperityType), type) || soap_send(soap, soap_ent__ProsperityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__ProsperityType(struct soap *soap, const char *s, enum ent__ProsperityType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__ProsperityType, s);
	if(map)
		*a = (enum ent__ProsperityType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__ProsperityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__ProsperityType * FASTCALL soap_in_ent__ProsperityType(struct soap *soap, const char *tag, enum ent__ProsperityType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__ProsperityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProsperityType, sizeof(enum ent__ProsperityType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__ProsperityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__ProsperityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProsperityType, 0, sizeof(enum ent__ProsperityType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__ProsperityType(struct soap *soap, const enum ent__ProsperityType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__ProsperityType);
	return soap_out_ent__ProsperityType(soap, tag?tag:"ent:ProsperityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ProsperityType * SOAP_FMAC4 soap_get_ent__ProsperityType(struct soap *soap, enum ent__ProsperityType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProsperityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__RegionalizationDecision(struct soap *soap, enum ent__RegionalizationDecision *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__RegionalizationDecision
	*a = SOAP_DEFAULT_ent__RegionalizationDecision;
#else
	*a = (enum ent__RegionalizationDecision)0;
#endif
}

static const struct soap_code_map soap_codes_ent__RegionalizationDecision[] =
{	{ (long)ent__RegionalizationDecision__1, "1" },
	{ (long)ent__RegionalizationDecision__2, "2" },
	{ (long)ent__RegionalizationDecision__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__RegionalizationDecision2s(struct soap *soap, enum ent__RegionalizationDecision n)
{
	const char *s = soap_code_str(soap_codes_ent__RegionalizationDecision, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationDecision(struct soap *soap, const char *tag, int id, const enum ent__RegionalizationDecision *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationDecision), type) || soap_send(soap, soap_ent__RegionalizationDecision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__RegionalizationDecision(struct soap *soap, const char *s, enum ent__RegionalizationDecision *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__RegionalizationDecision, s);
	if(map)
		*a = (enum ent__RegionalizationDecision)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__RegionalizationDecision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__RegionalizationDecision * FASTCALL soap_in_ent__RegionalizationDecision(struct soap *soap, const char *tag, enum ent__RegionalizationDecision *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__RegionalizationDecision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationDecision, sizeof(enum ent__RegionalizationDecision), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__RegionalizationDecision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__RegionalizationDecision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationDecision, 0, sizeof(enum ent__RegionalizationDecision), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__RegionalizationDecision(struct soap *soap, const enum ent__RegionalizationDecision *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationDecision);
	return soap_out_ent__RegionalizationDecision(soap, tag?tag:"ent:RegionalizationDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__RegionalizationDecision * SOAP_FMAC4 soap_get_ent__RegionalizationDecision(struct soap *soap, enum ent__RegionalizationDecision *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__ResearchResult(struct soap *soap, enum ent__ResearchResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__ResearchResult
	*a = SOAP_DEFAULT_ent__ResearchResult;
#else
	*a = (enum ent__ResearchResult)0;
#endif
}

static const struct soap_code_map soap_codes_ent__ResearchResult[] =
{	{ (long)ent__ResearchResult__UNKNOWN, "UNKNOWN" },
	{ (long)ent__ResearchResult__UNDEFINED, "UNDEFINED" },
	{ (long)ent__ResearchResult__POSITIVE, "POSITIVE" },
	{ (long)ent__ResearchResult__NEGATIVE, "NEGATIVE" },
	{ (long)ent__ResearchResult__UNFULFILLED, "UNFULFILLED" },
	{ (long)ent__ResearchResult__VSERAW, "VSERAW" },
	{ (long)ent__ResearchResult__VSEFULL, "VSEFULL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__ResearchResult2s(struct soap *soap, enum ent__ResearchResult n)
{
	const char *s = soap_code_str(soap_codes_ent__ResearchResult, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ResearchResult(struct soap *soap, const char *tag, int id, const enum ent__ResearchResult *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ResearchResult), type) || soap_send(soap, soap_ent__ResearchResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__ResearchResult(struct soap *soap, const char *s, enum ent__ResearchResult *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__ResearchResult, s);
	if(map)
		*a = (enum ent__ResearchResult)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__ResearchResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__ResearchResult * FASTCALL soap_in_ent__ResearchResult(struct soap *soap, const char *tag, enum ent__ResearchResult *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__ResearchResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ResearchResult, sizeof(enum ent__ResearchResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__ResearchResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__ResearchResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ResearchResult, 0, sizeof(enum ent__ResearchResult), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__ResearchResult(struct soap *soap, const enum ent__ResearchResult *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__ResearchResult);
	return soap_out_ent__ResearchResult(soap, tag?tag:"ent:ResearchResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ResearchResult * SOAP_FMAC4 soap_get_ent__ResearchResult(struct soap *soap, enum ent__ResearchResult *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ResearchResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__TransportType(struct soap *soap, enum ent__TransportType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__TransportType
	*a = SOAP_DEFAULT_ent__TransportType;
#else
	*a = (enum ent__TransportType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__TransportType[] =
{	{ (long)ent__TransportType__1, "1" },
	{ (long)ent__TransportType__2, "2" },
	{ (long)ent__TransportType__3, "3" },
	{ (long)ent__TransportType__4, "4" },
	{ (long)ent__TransportType__5, "5" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__TransportType2s(struct soap *soap, enum ent__TransportType n)
{
	const char *s = soap_code_str(soap_codes_ent__TransportType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__TransportType(struct soap *soap, const char *tag, int id, const enum ent__TransportType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__TransportType), type) || soap_send(soap, soap_ent__TransportType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__TransportType(struct soap *soap, const char *s, enum ent__TransportType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__TransportType, s);
	if(map)
		*a = (enum ent__TransportType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__TransportType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__TransportType * FASTCALL soap_in_ent__TransportType(struct soap *soap, const char *tag, enum ent__TransportType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__TransportType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__TransportType, sizeof(enum ent__TransportType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__TransportType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__TransportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__TransportType, 0, sizeof(enum ent__TransportType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__TransportType(struct soap *soap, const enum ent__TransportType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__TransportType);
	return soap_out_ent__TransportType(soap, tag?tag:"ent:TransportType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__TransportType * SOAP_FMAC4 soap_get_ent__TransportType(struct soap *soap, enum ent__TransportType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__TransportType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__ReferenceType(struct soap *soap, enum ent__ReferenceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__ReferenceType
	*a = SOAP_DEFAULT_ent__ReferenceType;
#else
	*a = (enum ent__ReferenceType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__ReferenceType[] =
{	{ (long)ent__ReferenceType__1, "1" },
	{ (long)ent__ReferenceType__2, "2" },
	{ (long)ent__ReferenceType__3, "3" },
	{ (long)ent__ReferenceType__4, "4" },
	{ (long)ent__ReferenceType__5, "5" },
	{ (long)ent__ReferenceType__6, "6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__ReferenceType2s(struct soap *soap, enum ent__ReferenceType n)
{
	const char *s = soap_code_str(soap_codes_ent__ReferenceType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ReferenceType(struct soap *soap, const char *tag, int id, const enum ent__ReferenceType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ReferenceType), type) || soap_send(soap, soap_ent__ReferenceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__ReferenceType(struct soap *soap, const char *s, enum ent__ReferenceType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__ReferenceType, s);
	if(map)
		*a = (enum ent__ReferenceType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__ReferenceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__ReferenceType * FASTCALL soap_in_ent__ReferenceType(struct soap *soap, const char *tag, enum ent__ReferenceType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ReferenceType, sizeof(enum ent__ReferenceType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__ReferenceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ReferenceType, 0, sizeof(enum ent__ReferenceType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__ReferenceType(struct soap *soap, const enum ent__ReferenceType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__ReferenceType);
	return soap_out_ent__ReferenceType(soap, tag?tag:"ent:ReferenceType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ReferenceType * SOAP_FMAC4 soap_get_ent__ReferenceType(struct soap *soap, enum ent__ReferenceType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ReferenceType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__DocumentType(struct soap *soap, enum ent__DocumentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__DocumentType
	*a = SOAP_DEFAULT_ent__DocumentType;
#else
	*a = (enum ent__DocumentType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__DocumentType[] =
{	{ (long)ent__DocumentType__1, "1" },
	{ (long)ent__DocumentType__2, "2" },
	{ (long)ent__DocumentType__3, "3" },
	{ (long)ent__DocumentType__4, "4" },
	{ (long)ent__DocumentType__5, "5" },
	{ (long)ent__DocumentType__6, "6" },
	{ (long)ent__DocumentType__7, "7" },
	{ (long)ent__DocumentType__8, "8" },
	{ (long)ent__DocumentType__9, "9" },
	{ (long)ent__DocumentType__10, "10" },
	{ (long)ent__DocumentType__11, "11" },
	{ (long)ent__DocumentType__12, "12" },
	{ (long)ent__DocumentType__13, "13" },
	{ (long)ent__DocumentType__14, "14" },
	{ (long)ent__DocumentType__15, "15" },
	{ (long)ent__DocumentType__16, "16" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__DocumentType2s(struct soap *soap, enum ent__DocumentType n)
{
	const char *s = soap_code_str(soap_codes_ent__DocumentType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__DocumentType(struct soap *soap, const char *tag, int id, const enum ent__DocumentType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__DocumentType), type) || soap_send(soap, soap_ent__DocumentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__DocumentType(struct soap *soap, const char *s, enum ent__DocumentType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__DocumentType, s);
	if(map)
		*a = (enum ent__DocumentType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__DocumentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__DocumentType * FASTCALL soap_in_ent__DocumentType(struct soap *soap, const char *tag, enum ent__DocumentType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__DocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__DocumentType, sizeof(enum ent__DocumentType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__DocumentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__DocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__DocumentType, 0, sizeof(enum ent__DocumentType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__DocumentType(struct soap *soap, const enum ent__DocumentType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__DocumentType);
	return soap_out_ent__DocumentType(soap, tag?tag:"ent:DocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__DocumentType * SOAP_FMAC4 soap_get_ent__DocumentType(struct soap *soap, enum ent__DocumentType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__DocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__ProductType(struct soap *soap, enum ent__ProductType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__ProductType
	*a = SOAP_DEFAULT_ent__ProductType;
#else
	*a = (enum ent__ProductType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__ProductType[] =
{	{ (long)ent__ProductType__1, "1" },
	{ (long)ent__ProductType__2, "2" },
	{ (long)ent__ProductType__3, "3" },
	{ (long)ent__ProductType__4, "4" },
	{ (long)ent__ProductType__5, "5" },
	{ (long)ent__ProductType__6, "6" },
	{ (long)ent__ProductType__7, "7" },
	{ (long)ent__ProductType__8, "8" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__ProductType2s(struct soap *soap, enum ent__ProductType n)
{
	const char *s = soap_code_str(soap_codes_ent__ProductType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductType(struct soap *soap, const char *tag, int id, const enum ent__ProductType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProductType), type) || soap_send(soap, soap_ent__ProductType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__ProductType(struct soap *soap, const char *s, enum ent__ProductType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__ProductType, s);
	if(map)
		*a = (enum ent__ProductType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__ProductType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__ProductType * FASTCALL soap_in_ent__ProductType(struct soap *soap, const char *tag, enum ent__ProductType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__ProductType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductType, sizeof(enum ent__ProductType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__ProductType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__ProductType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProductType, 0, sizeof(enum ent__ProductType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__ProductType(struct soap *soap, const enum ent__ProductType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__ProductType);
	return soap_out_ent__ProductType(soap, tag?tag:"ent:ProductType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ProductType * SOAP_FMAC4 soap_get_ent__ProductType(struct soap *soap, enum ent__ProductType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__BusinessEntityType(struct soap *soap, enum ent__BusinessEntityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__BusinessEntityType
	*a = SOAP_DEFAULT_ent__BusinessEntityType;
#else
	*a = (enum ent__BusinessEntityType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__BusinessEntityType[] =
{	{ (long)ent__BusinessEntityType__1, "1" },
	{ (long)ent__BusinessEntityType__2, "2" },
	{ (long)ent__BusinessEntityType__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__BusinessEntityType2s(struct soap *soap, enum ent__BusinessEntityType n)
{
	const char *s = soap_code_str(soap_codes_ent__BusinessEntityType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__BusinessEntityType(struct soap *soap, const char *tag, int id, const enum ent__BusinessEntityType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__BusinessEntityType), type) || soap_send(soap, soap_ent__BusinessEntityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__BusinessEntityType(struct soap *soap, const char *s, enum ent__BusinessEntityType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__BusinessEntityType, s);
	if(map)
		*a = (enum ent__BusinessEntityType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__BusinessEntityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__BusinessEntityType * FASTCALL soap_in_ent__BusinessEntityType(struct soap *soap, const char *tag, enum ent__BusinessEntityType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__BusinessEntityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__BusinessEntityType, sizeof(enum ent__BusinessEntityType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__BusinessEntityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__BusinessEntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__BusinessEntityType, 0, sizeof(enum ent__BusinessEntityType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__BusinessEntityType(struct soap *soap, const enum ent__BusinessEntityType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__BusinessEntityType);
	return soap_out_ent__BusinessEntityType(soap, tag?tag:"ent:BusinessEntityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__BusinessEntityType * SOAP_FMAC4 soap_get_ent__BusinessEntityType(struct soap *soap, enum ent__BusinessEntityType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__BusinessEntityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__EnterpriseGroup(struct soap *soap, enum ent__EnterpriseGroup *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__EnterpriseGroup
	*a = SOAP_DEFAULT_ent__EnterpriseGroup;
#else
	*a = (enum ent__EnterpriseGroup)0;
#endif
}

static const struct soap_code_map soap_codes_ent__EnterpriseGroup[] =
{	{ (long)ent__EnterpriseGroup__0, "0" },
	{ (long)ent__EnterpriseGroup__1, "1" },
	{ (long)ent__EnterpriseGroup__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__EnterpriseGroup2s(struct soap *soap, enum ent__EnterpriseGroup n)
{
	const char *s = soap_code_str(soap_codes_ent__EnterpriseGroup, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseGroup(struct soap *soap, const char *tag, int id, const enum ent__EnterpriseGroup *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseGroup), type) || soap_send(soap, soap_ent__EnterpriseGroup2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__EnterpriseGroup(struct soap *soap, const char *s, enum ent__EnterpriseGroup *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__EnterpriseGroup, s);
	if(map)
		*a = (enum ent__EnterpriseGroup)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__EnterpriseGroup)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__EnterpriseGroup * FASTCALL soap_in_ent__EnterpriseGroup(struct soap *soap, const char *tag, enum ent__EnterpriseGroup *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__EnterpriseGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseGroup, sizeof(enum ent__EnterpriseGroup), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__EnterpriseGroup(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__EnterpriseGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseGroup, 0, sizeof(enum ent__EnterpriseGroup), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__EnterpriseGroup(struct soap *soap, const enum ent__EnterpriseGroup *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseGroup);
	return soap_out_ent__EnterpriseGroup(soap, tag?tag:"ent:EnterpriseGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__EnterpriseGroup * SOAP_FMAC4 soap_get_ent__EnterpriseGroup(struct soap *soap, enum ent__EnterpriseGroup *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__PackingCodeType(struct soap *soap, enum ent__PackingCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__PackingCodeType
	*a = SOAP_DEFAULT_ent__PackingCodeType;
#else
	*a = (enum ent__PackingCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__PackingCodeType[] =
{	{ (long)ent__PackingCodeType__1A, "1A" },
	{ (long)ent__PackingCodeType__1B, "1B" },
	{ (long)ent__PackingCodeType__1D, "1D" },
	{ (long)ent__PackingCodeType__1F, "1F" },
	{ (long)ent__PackingCodeType__1G, "1G" },
	{ (long)ent__PackingCodeType__1W, "1W" },
	{ (long)ent__PackingCodeType__2C, "2C" },
	{ (long)ent__PackingCodeType__3A, "3A" },
	{ (long)ent__PackingCodeType__3H, "3H" },
	{ (long)ent__PackingCodeType__43, "43" },
	{ (long)ent__PackingCodeType__44, "44" },
	{ (long)ent__PackingCodeType__4A, "4A" },
	{ (long)ent__PackingCodeType__4B, "4B" },
	{ (long)ent__PackingCodeType__4C, "4C" },
	{ (long)ent__PackingCodeType__4D, "4D" },
	{ (long)ent__PackingCodeType__4F, "4F" },
	{ (long)ent__PackingCodeType__4G, "4G" },
	{ (long)ent__PackingCodeType__4H, "4H" },
	{ (long)ent__PackingCodeType__5H, "5H" },
	{ (long)ent__PackingCodeType__5L, "5L" },
	{ (long)ent__PackingCodeType__5M, "5M" },
	{ (long)ent__PackingCodeType__6H, "6H" },
	{ (long)ent__PackingCodeType__6P, "6P" },
	{ (long)ent__PackingCodeType__7A, "7A" },
	{ (long)ent__PackingCodeType__7B, "7B" },
	{ (long)ent__PackingCodeType__8A, "8A" },
	{ (long)ent__PackingCodeType__8B, "8B" },
	{ (long)ent__PackingCodeType__8C, "8C" },
	{ (long)ent__PackingCodeType__AA, "AA" },
	{ (long)ent__PackingCodeType__AB, "AB" },
	{ (long)ent__PackingCodeType__AC, "AC" },
	{ (long)ent__PackingCodeType__AD, "AD" },
	{ (long)ent__PackingCodeType__AE, "AE" },
	{ (long)ent__PackingCodeType__AF, "AF" },
	{ (long)ent__PackingCodeType__AG, "AG" },
	{ (long)ent__PackingCodeType__AH, "AH" },
	{ (long)ent__PackingCodeType__AI, "AI" },
	{ (long)ent__PackingCodeType__AJ, "AJ" },
	{ (long)ent__PackingCodeType__AL, "AL" },
	{ (long)ent__PackingCodeType__AM, "AM" },
	{ (long)ent__PackingCodeType__AP, "AP" },
	{ (long)ent__PackingCodeType__AT, "AT" },
	{ (long)ent__PackingCodeType__AV, "AV" },
	{ (long)ent__PackingCodeType__B4, "B4" },
	{ (long)ent__PackingCodeType__BA, "BA" },
	{ (long)ent__PackingCodeType__BB, "BB" },
	{ (long)ent__PackingCodeType__BC, "BC" },
	{ (long)ent__PackingCodeType__BD, "BD" },
	{ (long)ent__PackingCodeType__BE, "BE" },
	{ (long)ent__PackingCodeType__BF, "BF" },
	{ (long)ent__PackingCodeType__BG, "BG" },
	{ (long)ent__PackingCodeType__BH, "BH" },
	{ (long)ent__PackingCodeType__BI, "BI" },
	{ (long)ent__PackingCodeType__BJ, "BJ" },
	{ (long)ent__PackingCodeType__BK, "BK" },
	{ (long)ent__PackingCodeType__BL, "BL" },
	{ (long)ent__PackingCodeType__BM, "BM" },
	{ (long)ent__PackingCodeType__BN, "BN" },
	{ (long)ent__PackingCodeType__BO, "BO" },
	{ (long)ent__PackingCodeType__BP, "BP" },
	{ (long)ent__PackingCodeType__BQ, "BQ" },
	{ (long)ent__PackingCodeType__BR, "BR" },
	{ (long)ent__PackingCodeType__BS, "BS" },
	{ (long)ent__PackingCodeType__BT, "BT" },
	{ (long)ent__PackingCodeType__BU, "BU" },
	{ (long)ent__PackingCodeType__BV, "BV" },
	{ (long)ent__PackingCodeType__BW, "BW" },
	{ (long)ent__PackingCodeType__BX, "BX" },
	{ (long)ent__PackingCodeType__BY, "BY" },
	{ (long)ent__PackingCodeType__BZ, "BZ" },
	{ (long)ent__PackingCodeType__CA, "CA" },
	{ (long)ent__PackingCodeType__CB, "CB" },
	{ (long)ent__PackingCodeType__CC, "CC" },
	{ (long)ent__PackingCodeType__CD, "CD" },
	{ (long)ent__PackingCodeType__CE, "CE" },
	{ (long)ent__PackingCodeType__CF, "CF" },
	{ (long)ent__PackingCodeType__CG, "CG" },
	{ (long)ent__PackingCodeType__CH, "CH" },
	{ (long)ent__PackingCodeType__CI, "CI" },
	{ (long)ent__PackingCodeType__CJ, "CJ" },
	{ (long)ent__PackingCodeType__CK, "CK" },
	{ (long)ent__PackingCodeType__CL, "CL" },
	{ (long)ent__PackingCodeType__CM, "CM" },
	{ (long)ent__PackingCodeType__CN, "CN" },
	{ (long)ent__PackingCodeType__CO, "CO" },
	{ (long)ent__PackingCodeType__CP, "CP" },
	{ (long)ent__PackingCodeType__CQ, "CQ" },
	{ (long)ent__PackingCodeType__CR, "CR" },
	{ (long)ent__PackingCodeType__CS, "CS" },
	{ (long)ent__PackingCodeType__CT, "CT" },
	{ (long)ent__PackingCodeType__CU, "CU" },
	{ (long)ent__PackingCodeType__CV, "CV" },
	{ (long)ent__PackingCodeType__CW, "CW" },
	{ (long)ent__PackingCodeType__CX, "CX" },
	{ (long)ent__PackingCodeType__CY, "CY" },
	{ (long)ent__PackingCodeType__CZ, "CZ" },
	{ (long)ent__PackingCodeType__DA, "DA" },
	{ (long)ent__PackingCodeType__DB, "DB" },
	{ (long)ent__PackingCodeType__DC, "DC" },
	{ (long)ent__PackingCodeType__DG, "DG" },
	{ (long)ent__PackingCodeType__DH, "DH" },
	{ (long)ent__PackingCodeType__DI, "DI" },
	{ (long)ent__PackingCodeType__DJ, "DJ" },
	{ (long)ent__PackingCodeType__DK, "DK" },
	{ (long)ent__PackingCodeType__DL, "DL" },
	{ (long)ent__PackingCodeType__DM, "DM" },
	{ (long)ent__PackingCodeType__DN, "DN" },
	{ (long)ent__PackingCodeType__DP, "DP" },
	{ (long)ent__PackingCodeType__DR, "DR" },
	{ (long)ent__PackingCodeType__DS, "DS" },
	{ (long)ent__PackingCodeType__DT, "DT" },
	{ (long)ent__PackingCodeType__DU, "DU" },
	{ (long)ent__PackingCodeType__DV, "DV" },
	{ (long)ent__PackingCodeType__DW, "DW" },
	{ (long)ent__PackingCodeType__DX, "DX" },
	{ (long)ent__PackingCodeType__DY, "DY" },
	{ (long)ent__PackingCodeType__EC, "EC" },
	{ (long)ent__PackingCodeType__ED, "ED" },
	{ (long)ent__PackingCodeType__EE, "EE" },
	{ (long)ent__PackingCodeType__EF, "EF" },
	{ (long)ent__PackingCodeType__EG, "EG" },
	{ (long)ent__PackingCodeType__EH, "EH" },
	{ (long)ent__PackingCodeType__EI, "EI" },
	{ (long)ent__PackingCodeType__EN, "EN" },
	{ (long)ent__PackingCodeType__FC, "FC" },
	{ (long)ent__PackingCodeType__FD, "FD" },
	{ (long)ent__PackingCodeType__FE, "FE" },
	{ (long)ent__PackingCodeType__FI, "FI" },
	{ (long)ent__PackingCodeType__FL, "FL" },
	{ (long)ent__PackingCodeType__FO, "FO" },
	{ (long)ent__PackingCodeType__FP, "FP" },
	{ (long)ent__PackingCodeType__FR, "FR" },
	{ (long)ent__PackingCodeType__FT, "FT" },
	{ (long)ent__PackingCodeType__FX, "FX" },
	{ (long)ent__PackingCodeType__GB, "GB" },
	{ (long)ent__PackingCodeType__GI, "GI" },
	{ (long)ent__PackingCodeType__GL, "GL" },
	{ (long)ent__PackingCodeType__GR, "GR" },
	{ (long)ent__PackingCodeType__GY, "GY" },
	{ (long)ent__PackingCodeType__GZ, "GZ" },
	{ (long)ent__PackingCodeType__HA, "HA" },
	{ (long)ent__PackingCodeType__HB, "HB" },
	{ (long)ent__PackingCodeType__HC, "HC" },
	{ (long)ent__PackingCodeType__HG, "HG" },
	{ (long)ent__PackingCodeType__HN, "HN" },
	{ (long)ent__PackingCodeType__HR, "HR" },
	{ (long)ent__PackingCodeType__IA, "IA" },
	{ (long)ent__PackingCodeType__IB, "IB" },
	{ (long)ent__PackingCodeType__IC, "IC" },
	{ (long)ent__PackingCodeType__ID, "ID" },
	{ (long)ent__PackingCodeType__IE, "IE" },
	{ (long)ent__PackingCodeType__IF, "IF" },
	{ (long)ent__PackingCodeType__IG, "IG" },
	{ (long)ent__PackingCodeType__IH, "IH" },
	{ (long)ent__PackingCodeType__IK, "IK" },
	{ (long)ent__PackingCodeType__IN, "IN" },
	{ (long)ent__PackingCodeType__IZ, "IZ" },
	{ (long)ent__PackingCodeType__JB, "JB" },
	{ (long)ent__PackingCodeType__JC, "JC" },
	{ (long)ent__PackingCodeType__JG, "JG" },
	{ (long)ent__PackingCodeType__JR, "JR" },
	{ (long)ent__PackingCodeType__JT, "JT" },
	{ (long)ent__PackingCodeType__JY, "JY" },
	{ (long)ent__PackingCodeType__KG, "KG" },
	{ (long)ent__PackingCodeType__KI, "KI" },
	{ (long)ent__PackingCodeType__LE, "LE" },
	{ (long)ent__PackingCodeType__LG, "LG" },
	{ (long)ent__PackingCodeType__LT, "LT" },
	{ (long)ent__PackingCodeType__LU, "LU" },
	{ (long)ent__PackingCodeType__LV, "LV" },
	{ (long)ent__PackingCodeType__LZ, "LZ" },
	{ (long)ent__PackingCodeType__MA, "MA" },
	{ (long)ent__PackingCodeType__MB, "MB" },
	{ (long)ent__PackingCodeType__MC, "MC" },
	{ (long)ent__PackingCodeType__ME, "ME" },
	{ (long)ent__PackingCodeType__MR, "MR" },
	{ (long)ent__PackingCodeType__MS, "MS" },
	{ (long)ent__PackingCodeType__MT, "MT" },
	{ (long)ent__PackingCodeType__MW, "MW" },
	{ (long)ent__PackingCodeType__MX, "MX" },
	{ (long)ent__PackingCodeType__NA, "NA" },
	{ (long)ent__PackingCodeType__NE, "NE" },
	{ (long)ent__PackingCodeType__NF, "NF" },
	{ (long)ent__PackingCodeType__NG, "NG" },
	{ (long)ent__PackingCodeType__NS, "NS" },
	{ (long)ent__PackingCodeType__NT, "NT" },
	{ (long)ent__PackingCodeType__NU, "NU" },
	{ (long)ent__PackingCodeType__NV, "NV" },
	{ (long)ent__PackingCodeType__OT, "OT" },
	{ (long)ent__PackingCodeType__OU, "OU" },
	{ (long)ent__PackingCodeType__P2, "P2" },
	{ (long)ent__PackingCodeType__PA, "PA" },
	{ (long)ent__PackingCodeType__PB, "PB" },
	{ (long)ent__PackingCodeType__PC, "PC" },
	{ (long)ent__PackingCodeType__PD, "PD" },
	{ (long)ent__PackingCodeType__PE, "PE" },
	{ (long)ent__PackingCodeType__PF, "PF" },
	{ (long)ent__PackingCodeType__PG, "PG" },
	{ (long)ent__PackingCodeType__PH, "PH" },
	{ (long)ent__PackingCodeType__PI, "PI" },
	{ (long)ent__PackingCodeType__PJ, "PJ" },
	{ (long)ent__PackingCodeType__PK, "PK" },
	{ (long)ent__PackingCodeType__PL, "PL" },
	{ (long)ent__PackingCodeType__PN, "PN" },
	{ (long)ent__PackingCodeType__PO, "PO" },
	{ (long)ent__PackingCodeType__PP, "PP" },
	{ (long)ent__PackingCodeType__PR, "PR" },
	{ (long)ent__PackingCodeType__PT, "PT" },
	{ (long)ent__PackingCodeType__PU, "PU" },
	{ (long)ent__PackingCodeType__PV, "PV" },
	{ (long)ent__PackingCodeType__PX, "PX" },
	{ (long)ent__PackingCodeType__PY, "PY" },
	{ (long)ent__PackingCodeType__PZ, "PZ" },
	{ (long)ent__PackingCodeType__QA, "QA" },
	{ (long)ent__PackingCodeType__QB, "QB" },
	{ (long)ent__PackingCodeType__QC, "QC" },
	{ (long)ent__PackingCodeType__QD, "QD" },
	{ (long)ent__PackingCodeType__QF, "QF" },
	{ (long)ent__PackingCodeType__QG, "QG" },
	{ (long)ent__PackingCodeType__QH, "QH" },
	{ (long)ent__PackingCodeType__QJ, "QJ" },
	{ (long)ent__PackingCodeType__QK, "QK" },
	{ (long)ent__PackingCodeType__QL, "QL" },
	{ (long)ent__PackingCodeType__QM, "QM" },
	{ (long)ent__PackingCodeType__QN, "QN" },
	{ (long)ent__PackingCodeType__QP, "QP" },
	{ (long)ent__PackingCodeType__QQ, "QQ" },
	{ (long)ent__PackingCodeType__QR, "QR" },
	{ (long)ent__PackingCodeType__QS, "QS" },
	{ (long)ent__PackingCodeType__RD, "RD" },
	{ (long)ent__PackingCodeType__RG, "RG" },
	{ (long)ent__PackingCodeType__RJ, "RJ" },
	{ (long)ent__PackingCodeType__RK, "RK" },
	{ (long)ent__PackingCodeType__RL, "RL" },
	{ (long)ent__PackingCodeType__RO, "RO" },
	{ (long)ent__PackingCodeType__RT, "RT" },
	{ (long)ent__PackingCodeType__RZ, "RZ" },
	{ (long)ent__PackingCodeType__SA, "SA" },
	{ (long)ent__PackingCodeType__SB, "SB" },
	{ (long)ent__PackingCodeType__SC, "SC" },
	{ (long)ent__PackingCodeType__SD, "SD" },
	{ (long)ent__PackingCodeType__SE, "SE" },
	{ (long)ent__PackingCodeType__SH, "SH" },
	{ (long)ent__PackingCodeType__SI, "SI" },
	{ (long)ent__PackingCodeType__SK, "SK" },
	{ (long)ent__PackingCodeType__SL, "SL" },
	{ (long)ent__PackingCodeType__SM, "SM" },
	{ (long)ent__PackingCodeType__SO, "SO" },
	{ (long)ent__PackingCodeType__SP, "SP" },
	{ (long)ent__PackingCodeType__SS, "SS" },
	{ (long)ent__PackingCodeType__ST, "ST" },
	{ (long)ent__PackingCodeType__SU, "SU" },
	{ (long)ent__PackingCodeType__SV, "SV" },
	{ (long)ent__PackingCodeType__SW, "SW" },
	{ (long)ent__PackingCodeType__SX, "SX" },
	{ (long)ent__PackingCodeType__SY, "SY" },
	{ (long)ent__PackingCodeType__SZ, "SZ" },
	{ (long)ent__PackingCodeType__T1, "T1" },
	{ (long)ent__PackingCodeType__TB, "TB" },
	{ (long)ent__PackingCodeType__TC, "TC" },
	{ (long)ent__PackingCodeType__TD, "TD" },
	{ (long)ent__PackingCodeType__TE, "TE" },
	{ (long)ent__PackingCodeType__TG, "TG" },
	{ (long)ent__PackingCodeType__TI, "TI" },
	{ (long)ent__PackingCodeType__TK, "TK" },
	{ (long)ent__PackingCodeType__TL, "TL" },
	{ (long)ent__PackingCodeType__TN, "TN" },
	{ (long)ent__PackingCodeType__TO, "TO" },
	{ (long)ent__PackingCodeType__TR, "TR" },
	{ (long)ent__PackingCodeType__TS, "TS" },
	{ (long)ent__PackingCodeType__TT, "TT" },
	{ (long)ent__PackingCodeType__TU, "TU" },
	{ (long)ent__PackingCodeType__TV, "TV" },
	{ (long)ent__PackingCodeType__TW, "TW" },
	{ (long)ent__PackingCodeType__TY, "TY" },
	{ (long)ent__PackingCodeType__TZ, "TZ" },
	{ (long)ent__PackingCodeType__UC, "UC" },
	{ (long)ent__PackingCodeType__UN, "UN" },
	{ (long)ent__PackingCodeType__VA, "VA" },
	{ (long)ent__PackingCodeType__VG, "VG" },
	{ (long)ent__PackingCodeType__VI, "VI" },
	{ (long)ent__PackingCodeType__VK, "VK" },
	{ (long)ent__PackingCodeType__VL, "VL" },
	{ (long)ent__PackingCodeType__VO, "VO" },
	{ (long)ent__PackingCodeType__VP, "VP" },
	{ (long)ent__PackingCodeType__VQ, "VQ" },
	{ (long)ent__PackingCodeType__VR, "VR" },
	{ (long)ent__PackingCodeType__VS, "VS" },
	{ (long)ent__PackingCodeType__VY, "VY" },
	{ (long)ent__PackingCodeType__WA, "WA" },
	{ (long)ent__PackingCodeType__WB, "WB" },
	{ (long)ent__PackingCodeType__WC, "WC" },
	{ (long)ent__PackingCodeType__WD, "WD" },
	{ (long)ent__PackingCodeType__WF, "WF" },
	{ (long)ent__PackingCodeType__WG, "WG" },
	{ (long)ent__PackingCodeType__WH, "WH" },
	{ (long)ent__PackingCodeType__WJ, "WJ" },
	{ (long)ent__PackingCodeType__WK, "WK" },
	{ (long)ent__PackingCodeType__WL, "WL" },
	{ (long)ent__PackingCodeType__WM, "WM" },
	{ (long)ent__PackingCodeType__WN, "WN" },
	{ (long)ent__PackingCodeType__WP, "WP" },
	{ (long)ent__PackingCodeType__WQ, "WQ" },
	{ (long)ent__PackingCodeType__WR, "WR" },
	{ (long)ent__PackingCodeType__WS, "WS" },
	{ (long)ent__PackingCodeType__WT, "WT" },
	{ (long)ent__PackingCodeType__WU, "WU" },
	{ (long)ent__PackingCodeType__WV, "WV" },
	{ (long)ent__PackingCodeType__WW, "WW" },
	{ (long)ent__PackingCodeType__WX, "WX" },
	{ (long)ent__PackingCodeType__WY, "WY" },
	{ (long)ent__PackingCodeType__WZ, "WZ" },
	{ (long)ent__PackingCodeType__XA, "XA" },
	{ (long)ent__PackingCodeType__XB, "XB" },
	{ (long)ent__PackingCodeType__XC, "XC" },
	{ (long)ent__PackingCodeType__XD, "XD" },
	{ (long)ent__PackingCodeType__XF, "XF" },
	{ (long)ent__PackingCodeType__XG, "XG" },
	{ (long)ent__PackingCodeType__XH, "XH" },
	{ (long)ent__PackingCodeType__XJ, "XJ" },
	{ (long)ent__PackingCodeType__XK, "XK" },
	{ (long)ent__PackingCodeType__YA, "YA" },
	{ (long)ent__PackingCodeType__YB, "YB" },
	{ (long)ent__PackingCodeType__YC, "YC" },
	{ (long)ent__PackingCodeType__YD, "YD" },
	{ (long)ent__PackingCodeType__YF, "YF" },
	{ (long)ent__PackingCodeType__YH, "YH" },
	{ (long)ent__PackingCodeType__YJ, "YJ" },
	{ (long)ent__PackingCodeType__YK, "YK" },
	{ (long)ent__PackingCodeType__YL, "YL" },
	{ (long)ent__PackingCodeType__YM, "YM" },
	{ (long)ent__PackingCodeType__YN, "YN" },
	{ (long)ent__PackingCodeType__YP, "YP" },
	{ (long)ent__PackingCodeType__YQ, "YQ" },
	{ (long)ent__PackingCodeType__YR, "YR" },
	{ (long)ent__PackingCodeType__YS, "YS" },
	{ (long)ent__PackingCodeType__YT, "YT" },
	{ (long)ent__PackingCodeType__YV, "YV" },
	{ (long)ent__PackingCodeType__YW, "YW" },
	{ (long)ent__PackingCodeType__YX, "YX" },
	{ (long)ent__PackingCodeType__YY, "YY" },
	{ (long)ent__PackingCodeType__YZ, "YZ" },
	{ (long)ent__PackingCodeType__ZA, "ZA" },
	{ (long)ent__PackingCodeType__ZB, "ZB" },
	{ (long)ent__PackingCodeType__ZC, "ZC" },
	{ (long)ent__PackingCodeType__ZD, "ZD" },
	{ (long)ent__PackingCodeType__ZF, "ZF" },
	{ (long)ent__PackingCodeType__ZG, "ZG" },
	{ (long)ent__PackingCodeType__ZH, "ZH" },
	{ (long)ent__PackingCodeType__ZJ, "ZJ" },
	{ (long)ent__PackingCodeType__ZK, "ZK" },
	{ (long)ent__PackingCodeType__ZL, "ZL" },
	{ (long)ent__PackingCodeType__ZM, "ZM" },
	{ (long)ent__PackingCodeType__ZN, "ZN" },
	{ (long)ent__PackingCodeType__ZP, "ZP" },
	{ (long)ent__PackingCodeType__ZQ, "ZQ" },
	{ (long)ent__PackingCodeType__ZR, "ZR" },
	{ (long)ent__PackingCodeType__ZS, "ZS" },
	{ (long)ent__PackingCodeType__ZT, "ZT" },
	{ (long)ent__PackingCodeType__ZU, "ZU" },
	{ (long)ent__PackingCodeType__ZV, "ZV" },
	{ (long)ent__PackingCodeType__ZW, "ZW" },
	{ (long)ent__PackingCodeType__ZX, "ZX" },
	{ (long)ent__PackingCodeType__ZY, "ZY" },
	{ (long)ent__PackingCodeType__ZZ, "ZZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__PackingCodeType2s(struct soap *soap, enum ent__PackingCodeType n)
{
	const char *s = soap_code_str(soap_codes_ent__PackingCodeType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__PackingCodeType(struct soap *soap, const char *tag, int id, const enum ent__PackingCodeType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__PackingCodeType), type) || soap_send(soap, soap_ent__PackingCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__PackingCodeType(struct soap *soap, const char *s, enum ent__PackingCodeType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__PackingCodeType, s);
	if(map)
		*a = (enum ent__PackingCodeType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 364)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__PackingCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__PackingCodeType * FASTCALL soap_in_ent__PackingCodeType(struct soap *soap, const char *tag, enum ent__PackingCodeType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__PackingCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__PackingCodeType, sizeof(enum ent__PackingCodeType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__PackingCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__PackingCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__PackingCodeType, 0, sizeof(enum ent__PackingCodeType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__PackingCodeType(struct soap *soap, const enum ent__PackingCodeType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__PackingCodeType);
	return soap_out_ent__PackingCodeType(soap, tag?tag:"ent:PackingCodeType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__PackingCodeType * SOAP_FMAC4 soap_get_ent__PackingCodeType(struct soap *soap, enum ent__PackingCodeType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__PackingCodeType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__PackageLevelType(struct soap *soap, enum ent__PackageLevelType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ent__PackageLevelType
	*a = SOAP_DEFAULT_ent__PackageLevelType;
#else
	*a = (enum ent__PackageLevelType)0;
#endif
}

static const struct soap_code_map soap_codes_ent__PackageLevelType[] =
{	{ (long)ent__PackageLevelType__1, "1" },
	{ (long)ent__PackageLevelType__2, "2" },
	{ (long)ent__PackageLevelType__3, "3" },
	{ (long)ent__PackageLevelType__4, "4" },
	{ (long)ent__PackageLevelType__5, "5" },
	{ (long)ent__PackageLevelType__6, "6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ent__PackageLevelType2s(struct soap *soap, enum ent__PackageLevelType n)
{
	const char *s = soap_code_str(soap_codes_ent__PackageLevelType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__PackageLevelType(struct soap *soap, const char *tag, int id, const enum ent__PackageLevelType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__PackageLevelType), type) || soap_send(soap, soap_ent__PackageLevelType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ent__PackageLevelType(struct soap *soap, const char *s, enum ent__PackageLevelType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_ent__PackageLevelType, s);
	if(map)
		*a = (enum ent__PackageLevelType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ent__PackageLevelType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ent__PackageLevelType * FASTCALL soap_in_ent__PackageLevelType(struct soap *soap, const char *tag, enum ent__PackageLevelType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ent__PackageLevelType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__PackageLevelType, sizeof(enum ent__PackageLevelType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2ent__PackageLevelType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum ent__PackageLevelType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__PackageLevelType, 0, sizeof(enum ent__PackageLevelType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__PackageLevelType(struct soap *soap, const enum ent__PackageLevelType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__PackageLevelType);
	return soap_out_ent__PackageLevelType(soap, tag?tag:"ent:PackageLevelType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__PackageLevelType * SOAP_FMAC4 soap_get_ent__PackageLevelType(struct soap *soap, enum ent__PackageLevelType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__PackageLevelType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__ContentEncoding(struct soap *soap, enum app__ContentEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_app__ContentEncoding
	*a = SOAP_DEFAULT_app__ContentEncoding;
#else
	*a = (enum app__ContentEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_app__ContentEncoding[] =
{	{ (long)app__ContentEncoding__plain, "plain" },
	{ (long)app__ContentEncoding__gzip, "gzip" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_app__ContentEncoding2s(struct soap *soap, enum app__ContentEncoding n)
{
	const char *s = soap_code_str(soap_codes_app__ContentEncoding, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ContentEncoding(struct soap *soap, const char *tag, int id, const enum app__ContentEncoding *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ContentEncoding), type) || soap_send(soap, soap_app__ContentEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2app__ContentEncoding(struct soap *soap, const char *s, enum app__ContentEncoding *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_app__ContentEncoding, s);
	if(map)
		*a = (enum app__ContentEncoding)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum app__ContentEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum app__ContentEncoding * FASTCALL soap_in_app__ContentEncoding(struct soap *soap, const char *tag, enum app__ContentEncoding *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum app__ContentEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__ContentEncoding, sizeof(enum app__ContentEncoding), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2app__ContentEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum app__ContentEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ContentEncoding, 0, sizeof(enum app__ContentEncoding), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__ContentEncoding(struct soap *soap, const enum app__ContentEncoding *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__ContentEncoding);
	return soap_out_app__ContentEncoding(soap, tag?tag:"app:ContentEncoding", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ContentEncoding * SOAP_FMAC4 soap_get_app__ContentEncoding(struct soap *soap, enum app__ContentEncoding *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ContentEncoding(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_app__ApplicationStatus
	*a = SOAP_DEFAULT_app__ApplicationStatus;
#else
	*a = (enum app__ApplicationStatus)0;
#endif
}

static const struct soap_code_map soap_codes_app__ApplicationStatus[] =
{	{ (long)app__ApplicationStatus__ACCEPTED, "ACCEPTED" },
	{ (long)app__ApplicationStatus__IN_USCOREPROCESS, "IN_PROCESS" },
	{ (long)app__ApplicationStatus__COMPLETED, "COMPLETED" },
	{ (long)app__ApplicationStatus__REJECTED, "REJECTED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_app__ApplicationStatus2s(struct soap *soap, enum app__ApplicationStatus n)
{
	const char *s = soap_code_str(soap_codes_app__ApplicationStatus, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationStatus(struct soap *soap, const char *tag, int id, const enum app__ApplicationStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationStatus), type) || soap_send(soap, soap_app__ApplicationStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2app__ApplicationStatus(struct soap *soap, const char *s, enum app__ApplicationStatus *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_app__ApplicationStatus, s);
	if(map)
		*a = (enum app__ApplicationStatus)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum app__ApplicationStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum app__ApplicationStatus * FASTCALL soap_in_app__ApplicationStatus(struct soap *soap, const char *tag, enum app__ApplicationStatus *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum app__ApplicationStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationStatus, sizeof(enum app__ApplicationStatus), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2app__ApplicationStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum app__ApplicationStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationStatus, 0, sizeof(enum app__ApplicationStatus), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__ApplicationStatus(struct soap *soap, const enum app__ApplicationStatus *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__ApplicationStatus);
	return soap_out_app__ApplicationStatus(soap, tag?tag:"app:ApplicationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ApplicationStatus * SOAP_FMAC4 soap_get_app__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_base__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_base__RegisterModificationType
	*a = SOAP_DEFAULT_base__RegisterModificationType;
#else
	*a = (enum base__RegisterModificationType)0;
#endif
}

static const struct soap_code_map soap_codes_base__RegisterModificationType[] =
{	{ (long)base__RegisterModificationType__CREATE, "CREATE" },
	{ (long)base__RegisterModificationType__FIND_USCOREOR_USCORECREATE, "FIND_OR_CREATE" },
	{ (long)base__RegisterModificationType__UPDATE, "UPDATE" },
	{ (long)base__RegisterModificationType__DELETE, "DELETE" },
	{ (long)base__RegisterModificationType__MERGE, "MERGE" },
	{ (long)base__RegisterModificationType__ATTACH, "ATTACH" },
	{ (long)base__RegisterModificationType__SPLIT, "SPLIT" },
	{ (long)base__RegisterModificationType__FORK, "FORK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_base__RegisterModificationType2s(struct soap *soap, enum base__RegisterModificationType n)
{
	const char *s = soap_code_str(soap_codes_base__RegisterModificationType, (long)n);
	if(s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int FASTCALL soap_out_base__RegisterModificationType(struct soap *soap, const char *tag, int id, const enum base__RegisterModificationType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__RegisterModificationType), type) || soap_send(soap, soap_base__RegisterModificationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2base__RegisterModificationType(struct soap *soap, const char *s, enum base__RegisterModificationType *a)
{
	const struct soap_code_map *map;
	if(!s)
		return soap->error;
	map = soap_code(soap_codes_base__RegisterModificationType, s);
	if(map)
		*a = (enum base__RegisterModificationType)map->code;
	else {
		long n;
		if(soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum base__RegisterModificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum base__RegisterModificationType * FASTCALL soap_in_base__RegisterModificationType(struct soap *soap, const char *tag, enum base__RegisterModificationType *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum base__RegisterModificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_base__RegisterModificationType, sizeof(enum base__RegisterModificationType), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	if(soap->body && !*soap->href) {
		if(!a || soap_s2base__RegisterModificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (enum base__RegisterModificationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__RegisterModificationType, 0, sizeof(enum base__RegisterModificationType), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__RegisterModificationType(struct soap *soap, const enum base__RegisterModificationType *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__RegisterModificationType);
	return soap_out_base__RegisterModificationType(soap, tag?tag:"base:RegisterModificationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum base__RegisterModificationType * SOAP_FMAC4 soap_get_base__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *p, const char *tag, const char *type)
{
	if((p = soap_in_base__RegisterModificationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

void _ent__BusinessEntity_activityLocation::soap_default(struct soap *soap)
{
	this->_ent__BusinessEntity_activityLocation::__sizeglobalID = 0;
	this->_ent__BusinessEntity_activityLocation::globalID = NULL;
	this->_ent__BusinessEntity_activityLocation::enterprise = NULL;
}

void _ent__BusinessEntity_activityLocation::soap_serialize(struct soap *soap) const
{
	if(this->_ent__BusinessEntity_activityLocation::globalID) {
		for(int i = 0; i < this->_ent__BusinessEntity_activityLocation::__sizeglobalID; i++) {
			soap_serialize_ent__GLNType(soap, this->_ent__BusinessEntity_activityLocation::globalID + i);
		}
	}
	soap_serialize_PointerToent__Enterprise(soap, &this->_ent__BusinessEntity_activityLocation::enterprise);
}

int _ent__BusinessEntity_activityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ent__BusinessEntity_activityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ent__BusinessEntity_activityLocation(struct soap *soap, const char *tag, int id, const _ent__BusinessEntity_activityLocation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ent__BusinessEntity_activityLocation), type))
		return soap->error;
	if(a->_ent__BusinessEntity_activityLocation::globalID) {
		int i;
		for(i = 0; i < a->_ent__BusinessEntity_activityLocation::__sizeglobalID; i++)
			if(soap_out_ent__GLNType(soap, "ent:globalID", -1, a->_ent__BusinessEntity_activityLocation::globalID + i, ""))
				return soap->error;
	}
	if(a->_ent__BusinessEntity_activityLocation::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &a->_ent__BusinessEntity_activityLocation::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterprise"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ent__BusinessEntity_activityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ent__BusinessEntity_activityLocation(soap, tag, this, type);
}

SOAP_FMAC3 _ent__BusinessEntity_activityLocation * FASTCALL soap_in__ent__BusinessEntity_activityLocation(struct soap *soap, const char *tag, _ent__BusinessEntity_activityLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ent__BusinessEntity_activityLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ent__BusinessEntity_activityLocation, sizeof(_ent__BusinessEntity_activityLocation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ent__BusinessEntity_activityLocation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ent__BusinessEntity_activityLocation *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_globalID1 = NULL;
	size_t soap_flag_enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:globalID", 1, NULL)) {
				if(a->_ent__BusinessEntity_activityLocation::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->_ent__BusinessEntity_activityLocation::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->_ent__BusinessEntity_activityLocation::globalID == NULL)
						return NULL;
					*a->_ent__BusinessEntity_activityLocation::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ent__GLNType(soap, "ent:globalID", a->_ent__BusinessEntity_activityLocation::globalID, "ent:GLNType"))
				{	a->_ent__BusinessEntity_activityLocation::__sizeglobalID++;
					a->_ent__BusinessEntity_activityLocation::globalID = NULL;
					continue;
				}
			}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ent__BusinessEntity_activityLocation::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->_ent__BusinessEntity_activityLocation::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->_ent__BusinessEntity_activityLocation::__sizeglobalID)
			a->_ent__BusinessEntity_activityLocation::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->_ent__BusinessEntity_activityLocation::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ent__BusinessEntity_activityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ent__BusinessEntity_activityLocation, 0, sizeof(_ent__BusinessEntity_activityLocation), 0, soap_copy__ent__BusinessEntity_activityLocation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ent__BusinessEntity_activityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ent__BusinessEntity_activityLocation);
	return this->soap_out(soap, tag?tag:"ent:BusinessEntity-activityLocation", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ent__BusinessEntity_activityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ent__BusinessEntity_activityLocation(soap, this, tag, type);
}

SOAP_FMAC3 _ent__BusinessEntity_activityLocation * SOAP_FMAC4 soap_get__ent__BusinessEntity_activityLocation(struct soap *soap, _ent__BusinessEntity_activityLocation *p, const char *tag, const char *type)
{
	if((p = soap_in__ent__BusinessEntity_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ent__BusinessEntity_activityLocation * FASTCALL soap_instantiate__ent__BusinessEntity_activityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ent__BusinessEntity_activityLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ent__BusinessEntity_activityLocation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ent__BusinessEntity_activityLocation);
		ASSIGN_PTR(size, sizeof(_ent__BusinessEntity_activityLocation));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ent__BusinessEntity_activityLocation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ent__BusinessEntity_activityLocation));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ent__BusinessEntity_activityLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ent__BusinessEntity_activityLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ent__BusinessEntity_activityLocation %p -> %p\n", q, p));
	*(_ent__BusinessEntity_activityLocation*)p = *(_ent__BusinessEntity_activityLocation*)q;
}

void _vd__BEActivityLocationsModificationOperation_activityLocation::soap_default(struct soap *soap)
{
	this->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID = 0;
	this->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
	this->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise = NULL;
}

void _vd__BEActivityLocationsModificationOperation_activityLocation::soap_serialize(struct soap *soap) const
{
	if(this->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID) {
		for(int i = 0; i < this->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID; i++) {
			soap_serialize_ent__GLNType(soap, this->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID + i);
		}
	}
	soap_serialize_PointerToent__Enterprise(soap, &this->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise);
}

int _vd__BEActivityLocationsModificationOperation_activityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, int id, const _vd__BEActivityLocationsModificationOperation_activityLocation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation), type))
		return soap->error;
	if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID) {
		int i;
		for(i = 0; i < a->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID; i++)
			if(soap_out_ent__GLNType(soap, "vd:globalID", -1, a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID + i, ""))
				return soap->error;
	}
	if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "vd:enterprise", -1, &a->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:enterprise"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_vd__BEActivityLocationsModificationOperation_activityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, this, type);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation * FASTCALL soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, _vd__BEActivityLocationsModificationOperation_activityLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_vd__BEActivityLocationsModificationOperation_activityLocation *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_globalID1 = NULL;
	size_t soap_flag_enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:globalID", 1, NULL)) {
				if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID == NULL) {
					if(soap_blist_globalID1 == NULL)
						soap_blist_globalID1 = soap_new_block(soap);
					a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = (char **)soap_push_block(soap, soap_blist_globalID1, sizeof(char *));
					if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID == NULL)
						return NULL;
					*a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
				}
				soap_revert(soap);
				if(soap_in_ent__GLNType(soap, "vd:globalID", a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID, "ent:GLNType"))
				{	a->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID++;
					a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
					continue;
				}
			}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "vd:enterprise", &(a->_vd__BEActivityLocationsModificationOperation_activityLocation::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID)
			soap_pop_block(soap, soap_blist_globalID1);
		if(a->_vd__BEActivityLocationsModificationOperation_activityLocation::__sizeglobalID)
			a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = (char **)soap_save_block(soap, soap_blist_globalID1, NULL, 1);
		else
		{	a->_vd__BEActivityLocationsModificationOperation_activityLocation::globalID = NULL;
			if(soap_blist_globalID1)
				soap_end_block(soap, soap_blist_globalID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, 0, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation), 0, soap_copy__vd__BEActivityLocationsModificationOperation_activityLocation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _vd__BEActivityLocationsModificationOperation_activityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation);
	return this->soap_out(soap, tag?tag:"vd:BEActivityLocationsModificationOperation-activityLocation", id, type) ? soap->error : soap_putindependent(soap);
}

void *_vd__BEActivityLocationsModificationOperation_activityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__vd__BEActivityLocationsModificationOperation_activityLocation(soap, this, tag, type);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation * SOAP_FMAC4 soap_get__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation *p, const char *tag, const char *type)
{
	if((p = soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _vd__BEActivityLocationsModificationOperation_activityLocation * FASTCALL soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_vd__BEActivityLocationsModificationOperation_activityLocation);
		ASSIGN_PTR(size, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_vd__BEActivityLocationsModificationOperation_activityLocation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_vd__BEActivityLocationsModificationOperation_activityLocation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _vd__BEActivityLocationsModificationOperation_activityLocation %p -> %p\n", q, p));
	*(_vd__BEActivityLocationsModificationOperation_activityLocation*)p = *(_vd__BEActivityLocationsModificationOperation_activityLocation*)q;
}

SOAP_FMAC3 int FASTCALL soap_out_app__BinaryContent(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_app__BinaryContent);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_app__BinaryContent);
#endif
	if(id < 0)
		return soap->error;
	if(soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if(soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 xsd__base64Binary * FASTCALL soap_in_app__BinaryContent(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__BinaryContent, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced)
		a->soap_default(soap);
	if(soap->body && !*soap->href) {	
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if(soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		
#ifndef WITH_LEANER
		if(*soap->href != '#')
		{	if(soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__BinaryContent, 0, sizeof(xsd__base64Binary), 0, soap_copy_app__BinaryContent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__BinaryContent(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_app__BinaryContent);
	return soap_out_app__BinaryContent(soap, tag?tag:"app:BinaryContent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_app__BinaryContent(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if((p = soap_in_app__BinaryContent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns8__getResearchMethodChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodChangesListResponse::ent__researchMethodList = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ResearchMethodList(soap, &this->_ns8__getResearchMethodChangesListResponse::ent__researchMethodList);
	/* transient soap skipped */
}

int _ns8__getResearchMethodChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodChangesListResponse::ent__researchMethodList) {
		if(soap_out_PointerToent__ResearchMethodList(soap, "ent:researchMethodList", -1, &a->_ns8__getResearchMethodChangesListResponse::ent__researchMethodList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:researchMethodList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListResponse * FASTCALL soap_in__ns8__getResearchMethodChangesListResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodChangesListResponse, sizeof(_ns8__getResearchMethodChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__researchMethodList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__researchMethodList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchMethodList(soap, "ent:researchMethodList", &(a->_ns8__getResearchMethodChangesListResponse::ent__researchMethodList), "ent:ResearchMethodList"))
				{	soap_flag_ent__researchMethodList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodChangesListResponse, 0, sizeof(_ns8__getResearchMethodChangesListResponse), 0, soap_copy__ns8__getResearchMethodChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__researchMethodList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodChangesListResponse(struct soap *soap, _ns8__getResearchMethodChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodChangesListResponse * FASTCALL soap_instantiate__ns8__getResearchMethodChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodChangesListResponse));
		((_ns8__getResearchMethodChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodChangesListResponse*)p = *(_ns8__getResearchMethodChangesListResponse*)q;
}

void _ns8__getResearchMethodChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodChangesListRequest::base__listOptions = NULL;
	this->_ns8__getResearchMethodChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getResearchMethodChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getResearchMethodChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getResearchMethodChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getResearchMethodChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getResearchMethodChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getResearchMethodChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListRequest * FASTCALL soap_in__ns8__getResearchMethodChangesListRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodChangesListRequest, sizeof(_ns8__getResearchMethodChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getResearchMethodChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getResearchMethodChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodChangesListRequest, 0, sizeof(_ns8__getResearchMethodChangesListRequest), 0, soap_copy__ns8__getResearchMethodChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodChangesListRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodChangesListRequest(struct soap *soap, _ns8__getResearchMethodChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodChangesListRequest * FASTCALL soap_instantiate__ns8__getResearchMethodChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodChangesListRequest));
		((_ns8__getResearchMethodChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodChangesListRequest*)p = *(_ns8__getResearchMethodChangesListRequest*)q;
}

void _ns8__getResearchMethodListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodListResponse::ent__researchMethodList = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ResearchMethodList(soap, &this->_ns8__getResearchMethodListResponse::ent__researchMethodList);
	/* transient soap skipped */
}

int _ns8__getResearchMethodListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodListResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodListResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodListResponse::ent__researchMethodList) {
		if(soap_out_PointerToent__ResearchMethodList(soap, "ent:researchMethodList", -1, &a->_ns8__getResearchMethodListResponse::ent__researchMethodList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:researchMethodList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListResponse * FASTCALL soap_in__ns8__getResearchMethodListResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodListResponse, sizeof(_ns8__getResearchMethodListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__researchMethodList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__researchMethodList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchMethodList(soap, "ent:researchMethodList", &(a->_ns8__getResearchMethodListResponse::ent__researchMethodList), "ent:ResearchMethodList"))
				{	soap_flag_ent__researchMethodList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodListResponse, 0, sizeof(_ns8__getResearchMethodListResponse), 0, soap_copy__ns8__getResearchMethodListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__researchMethodList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodListResponse(struct soap *soap, _ns8__getResearchMethodListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodListResponse * FASTCALL soap_instantiate__ns8__getResearchMethodListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodListResponse));
		((_ns8__getResearchMethodListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodListResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodListResponse*)p = *(_ns8__getResearchMethodListResponse*)q;
}

void _ns8__getResearchMethodListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodListRequest::base__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getResearchMethodListRequest::base__listOptions);
	/* transient soap skipped */
}

int _ns8__getResearchMethodListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodListRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getResearchMethodListRequest::base__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListRequest * FASTCALL soap_in__ns8__getResearchMethodListRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodListRequest, sizeof(_ns8__getResearchMethodListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getResearchMethodListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodListRequest, 0, sizeof(_ns8__getResearchMethodListRequest), 0, soap_copy__ns8__getResearchMethodListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getResearchMethodListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodListRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodListRequest(struct soap *soap, _ns8__getResearchMethodListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodListRequest * FASTCALL soap_instantiate__ns8__getResearchMethodListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodListRequest));
		((_ns8__getResearchMethodListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodListRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodListRequest*)p = *(_ns8__getResearchMethodListRequest*)q;
}

void _ns8__getResearchMethodByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodByUuidResponse::ent__researchMethod = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ResearchMethod(soap, &this->_ns8__getResearchMethodByUuidResponse::ent__researchMethod);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByUuidResponse::ent__researchMethod) {
		if(soap_out_PointerToent__ResearchMethod(soap, "ent:researchMethod", -1, &a->_ns8__getResearchMethodByUuidResponse::ent__researchMethod, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:researchMethod"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidResponse * FASTCALL soap_in__ns8__getResearchMethodByUuidResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByUuidResponse, sizeof(_ns8__getResearchMethodByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__researchMethod1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__researchMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchMethod(soap, "ent:researchMethod", &(a->_ns8__getResearchMethodByUuidResponse::ent__researchMethod), "ent:ResearchMethod"))
				{	soap_flag_ent__researchMethod1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByUuidResponse, 0, sizeof(_ns8__getResearchMethodByUuidResponse), 0, soap_copy__ns8__getResearchMethodByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__researchMethod1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodByUuidResponse(struct soap *soap, _ns8__getResearchMethodByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByUuidResponse * FASTCALL soap_instantiate__ns8__getResearchMethodByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByUuidResponse));
		((_ns8__getResearchMethodByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByUuidResponse*)p = *(_ns8__getResearchMethodByUuidResponse*)q;
}

void _ns8__getResearchMethodByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getResearchMethodByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getResearchMethodByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getResearchMethodByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getResearchMethodByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidRequest * FASTCALL soap_in__ns8__getResearchMethodByUuidRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByUuidRequest, sizeof(_ns8__getResearchMethodByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getResearchMethodByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByUuidRequest, 0, sizeof(_ns8__getResearchMethodByUuidRequest), 0, soap_copy__ns8__getResearchMethodByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByUuidRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodByUuidRequest(struct soap *soap, _ns8__getResearchMethodByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByUuidRequest * FASTCALL soap_instantiate__ns8__getResearchMethodByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByUuidRequest));
		((_ns8__getResearchMethodByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByUuidRequest*)p = *(_ns8__getResearchMethodByUuidRequest*)q;
}

void _ns8__getResearchMethodByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getResearchMethodByGuidResponse::ent__researchMethod = NULL;
	/* transient soap skipped */
}

void _ns8__getResearchMethodByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ResearchMethod(soap, &this->_ns8__getResearchMethodByGuidResponse::ent__researchMethod);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByGuidResponse::ent__researchMethod) {
		if(soap_out_PointerToent__ResearchMethod(soap, "ent:researchMethod", -1, &a->_ns8__getResearchMethodByGuidResponse::ent__researchMethod, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:researchMethod"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidResponse * FASTCALL soap_in__ns8__getResearchMethodByGuidResponse(struct soap *soap, const char *tag, _ns8__getResearchMethodByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByGuidResponse, sizeof(_ns8__getResearchMethodByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__researchMethod1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__researchMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchMethod(soap, "ent:researchMethod", &(a->_ns8__getResearchMethodByGuidResponse::ent__researchMethod), "ent:ResearchMethod"))
				{	soap_flag_ent__researchMethod1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByGuidResponse, 0, sizeof(_ns8__getResearchMethodByGuidResponse), 0, soap_copy__ns8__getResearchMethodByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__researchMethod1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidResponse * SOAP_FMAC4 soap_get__ns8__getResearchMethodByGuidResponse(struct soap *soap, _ns8__getResearchMethodByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByGuidResponse * FASTCALL soap_instantiate__ns8__getResearchMethodByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByGuidResponse));
		((_ns8__getResearchMethodByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByGuidResponse*)p = *(_ns8__getResearchMethodByGuidResponse*)q;
}

void _ns8__getResearchMethodByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getResearchMethodByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getResearchMethodByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getResearchMethodByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getResearchMethodByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getResearchMethodByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getResearchMethodByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getResearchMethodByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getResearchMethodByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getResearchMethodByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getResearchMethodByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getResearchMethodByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getResearchMethodByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidRequest * FASTCALL soap_in__ns8__getResearchMethodByGuidRequest(struct soap *soap, const char *tag, _ns8__getResearchMethodByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getResearchMethodByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getResearchMethodByGuidRequest, sizeof(_ns8__getResearchMethodByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getResearchMethodByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getResearchMethodByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getResearchMethodByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getResearchMethodByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getResearchMethodByGuidRequest, 0, sizeof(_ns8__getResearchMethodByGuidRequest), 0, soap_copy__ns8__getResearchMethodByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getResearchMethodByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getResearchMethodByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getResearchMethodByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getResearchMethodByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getResearchMethodByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getResearchMethodByGuidRequest * SOAP_FMAC4 soap_get__ns8__getResearchMethodByGuidRequest(struct soap *soap, _ns8__getResearchMethodByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getResearchMethodByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getResearchMethodByGuidRequest * FASTCALL soap_instantiate__ns8__getResearchMethodByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getResearchMethodByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getResearchMethodByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getResearchMethodByGuidRequest));
		((_ns8__getResearchMethodByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getResearchMethodByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getResearchMethodByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getResearchMethodByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getResearchMethodByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getResearchMethodByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getResearchMethodByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getResearchMethodByGuidRequest*)p = *(_ns8__getResearchMethodByGuidRequest*)q;
}

void _ns8__getDiseaseChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseChangesListResponse::ent__diseaseList = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDiseaseList(soap, &this->_ns8__getDiseaseChangesListResponse::ent__diseaseList);
	/* transient soap skipped */
}

int _ns8__getDiseaseChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseChangesListResponse::ent__diseaseList) {
		if(soap_out_PointerToent__AnimalDiseaseList(soap, "ent:diseaseList", -1, &a->_ns8__getDiseaseChangesListResponse::ent__diseaseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:diseaseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListResponse * FASTCALL soap_in__ns8__getDiseaseChangesListResponse(struct soap *soap, const char *tag, _ns8__getDiseaseChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseChangesListResponse, sizeof(_ns8__getDiseaseChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__diseaseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__diseaseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDiseaseList(soap, "ent:diseaseList", &(a->_ns8__getDiseaseChangesListResponse::ent__diseaseList), "ent:AnimalDiseaseList"))
				{	soap_flag_ent__diseaseList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseChangesListResponse, 0, sizeof(_ns8__getDiseaseChangesListResponse), 0, soap_copy__ns8__getDiseaseChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__diseaseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseChangesListResponse(struct soap *soap, _ns8__getDiseaseChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseChangesListResponse * FASTCALL soap_instantiate__ns8__getDiseaseChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseChangesListResponse));
		((_ns8__getDiseaseChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseChangesListResponse*)p = *(_ns8__getDiseaseChangesListResponse*)q;
}

void _ns8__getDiseaseChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseChangesListRequest::base__listOptions = NULL;
	this->_ns8__getDiseaseChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getDiseaseChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getDiseaseChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getDiseaseChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getDiseaseChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getDiseaseChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getDiseaseChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListRequest * FASTCALL soap_in__ns8__getDiseaseChangesListRequest(struct soap *soap, const char *tag, _ns8__getDiseaseChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseChangesListRequest, sizeof(_ns8__getDiseaseChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getDiseaseChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getDiseaseChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseChangesListRequest, 0, sizeof(_ns8__getDiseaseChangesListRequest), 0, soap_copy__ns8__getDiseaseChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseChangesListRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseChangesListRequest(struct soap *soap, _ns8__getDiseaseChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseChangesListRequest * FASTCALL soap_instantiate__ns8__getDiseaseChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseChangesListRequest));
		((_ns8__getDiseaseChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseChangesListRequest*)p = *(_ns8__getDiseaseChangesListRequest*)q;
}

void _ns8__getDiseaseListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseListResponse::ent__diseaseList = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDiseaseList(soap, &this->_ns8__getDiseaseListResponse::ent__diseaseList);
	/* transient soap skipped */
}

int _ns8__getDiseaseListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseListResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseListResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseListResponse::ent__diseaseList) {
		if(soap_out_PointerToent__AnimalDiseaseList(soap, "ent:diseaseList", -1, &a->_ns8__getDiseaseListResponse::ent__diseaseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:diseaseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseListResponse * FASTCALL soap_in__ns8__getDiseaseListResponse(struct soap *soap, const char *tag, _ns8__getDiseaseListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseListResponse, sizeof(_ns8__getDiseaseListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__diseaseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__diseaseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDiseaseList(soap, "ent:diseaseList", &(a->_ns8__getDiseaseListResponse::ent__diseaseList), "ent:AnimalDiseaseList"))
				{	soap_flag_ent__diseaseList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseListResponse, 0, sizeof(_ns8__getDiseaseListResponse), 0, soap_copy__ns8__getDiseaseListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__diseaseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseListResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseListResponse(struct soap *soap, _ns8__getDiseaseListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseListResponse * FASTCALL soap_instantiate__ns8__getDiseaseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseListResponse));
		((_ns8__getDiseaseListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseListResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseListResponse*)p = *(_ns8__getDiseaseListResponse*)q;
}

void _ns8__getDiseaseListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseListRequest::base__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getDiseaseListRequest::base__listOptions);
	/* transient soap skipped */
}

int _ns8__getDiseaseListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseListRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getDiseaseListRequest::base__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseListRequest * FASTCALL soap_in__ns8__getDiseaseListRequest(struct soap *soap, const char *tag, _ns8__getDiseaseListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseListRequest, sizeof(_ns8__getDiseaseListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getDiseaseListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseListRequest, 0, sizeof(_ns8__getDiseaseListRequest), 0, soap_copy__ns8__getDiseaseListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getDiseaseListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseListRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseListRequest(struct soap *soap, _ns8__getDiseaseListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseListRequest * FASTCALL soap_instantiate__ns8__getDiseaseListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseListRequest));
		((_ns8__getDiseaseListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseListRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseListRequest*)p = *(_ns8__getDiseaseListRequest*)q;
}

void _ns8__getDiseaseByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseByUuidResponse::ent__disease = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDisease(soap, &this->_ns8__getDiseaseByUuidResponse::ent__disease);
	/* transient soap skipped */
}

int _ns8__getDiseaseByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseByUuidResponse::ent__disease) {
		if(soap_out_PointerToent__AnimalDisease(soap, "ent:disease", -1, &a->_ns8__getDiseaseByUuidResponse::ent__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:disease"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidResponse * FASTCALL soap_in__ns8__getDiseaseByUuidResponse(struct soap *soap, const char *tag, _ns8__getDiseaseByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByUuidResponse, sizeof(_ns8__getDiseaseByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__disease1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:disease", &(a->_ns8__getDiseaseByUuidResponse::ent__disease), "ent:AnimalDisease"))
				{	soap_flag_ent__disease1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByUuidResponse, 0, sizeof(_ns8__getDiseaseByUuidResponse), 0, soap_copy__ns8__getDiseaseByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseByUuidResponse(struct soap *soap, _ns8__getDiseaseByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByUuidResponse * FASTCALL soap_instantiate__ns8__getDiseaseByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByUuidResponse));
		((_ns8__getDiseaseByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseByUuidResponse*)p = *(_ns8__getDiseaseByUuidResponse*)q;
}

void _ns8__getDiseaseByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getDiseaseByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getDiseaseByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getDiseaseByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getDiseaseByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getDiseaseByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getDiseaseByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidRequest * FASTCALL soap_in__ns8__getDiseaseByUuidRequest(struct soap *soap, const char *tag, _ns8__getDiseaseByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByUuidRequest, sizeof(_ns8__getDiseaseByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getDiseaseByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByUuidRequest, 0, sizeof(_ns8__getDiseaseByUuidRequest), 0, soap_copy__ns8__getDiseaseByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByUuidRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseByUuidRequest(struct soap *soap, _ns8__getDiseaseByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByUuidRequest * FASTCALL soap_instantiate__ns8__getDiseaseByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByUuidRequest));
		((_ns8__getDiseaseByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseByUuidRequest*)p = *(_ns8__getDiseaseByUuidRequest*)q;
}

void _ns8__getDiseaseByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDiseaseByGuidResponse::ent__disease = NULL;
	/* transient soap skipped */
}

void _ns8__getDiseaseByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDisease(soap, &this->_ns8__getDiseaseByGuidResponse::ent__disease);
	/* transient soap skipped */
}

int _ns8__getDiseaseByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getDiseaseByGuidResponse::ent__disease) {
		if(soap_out_PointerToent__AnimalDisease(soap, "ent:disease", -1, &a->_ns8__getDiseaseByGuidResponse::ent__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:disease"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidResponse * FASTCALL soap_in__ns8__getDiseaseByGuidResponse(struct soap *soap, const char *tag, _ns8__getDiseaseByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByGuidResponse, sizeof(_ns8__getDiseaseByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__disease1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:disease", &(a->_ns8__getDiseaseByGuidResponse::ent__disease), "ent:AnimalDisease"))
				{	soap_flag_ent__disease1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByGuidResponse, 0, sizeof(_ns8__getDiseaseByGuidResponse), 0, soap_copy__ns8__getDiseaseByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidResponse * SOAP_FMAC4 soap_get__ns8__getDiseaseByGuidResponse(struct soap *soap, _ns8__getDiseaseByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByGuidResponse * FASTCALL soap_instantiate__ns8__getDiseaseByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByGuidResponse));
		((_ns8__getDiseaseByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getDiseaseByGuidResponse*)p = *(_ns8__getDiseaseByGuidResponse*)q;
}

void _ns8__getDiseaseByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getDiseaseByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getDiseaseByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getDiseaseByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getDiseaseByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDiseaseByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDiseaseByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDiseaseByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDiseaseByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getDiseaseByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getDiseaseByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDiseaseByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDiseaseByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidRequest * FASTCALL soap_in__ns8__getDiseaseByGuidRequest(struct soap *soap, const char *tag, _ns8__getDiseaseByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDiseaseByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDiseaseByGuidRequest, sizeof(_ns8__getDiseaseByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDiseaseByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDiseaseByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getDiseaseByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDiseaseByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDiseaseByGuidRequest, 0, sizeof(_ns8__getDiseaseByGuidRequest), 0, soap_copy__ns8__getDiseaseByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDiseaseByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDiseaseByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDiseaseByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDiseaseByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDiseaseByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDiseaseByGuidRequest * SOAP_FMAC4 soap_get__ns8__getDiseaseByGuidRequest(struct soap *soap, _ns8__getDiseaseByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDiseaseByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDiseaseByGuidRequest * FASTCALL soap_instantiate__ns8__getDiseaseByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDiseaseByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDiseaseByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDiseaseByGuidRequest));
		((_ns8__getDiseaseByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDiseaseByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDiseaseByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDiseaseByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDiseaseByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDiseaseByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDiseaseByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getDiseaseByGuidRequest*)p = *(_ns8__getDiseaseByGuidRequest*)q;
}

void _ns8__getActualR13nShippingRuleListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nShippingRuleListResponse::ent__r13nShippingRuleList = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nShippingRuleListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__RegionalizationShippingRuleList(soap, &this->_ns8__getActualR13nShippingRuleListResponse::ent__r13nShippingRuleList);
	/* transient soap skipped */
}

int _ns8__getActualR13nShippingRuleListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nShippingRuleListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nShippingRuleListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse), type))
		return soap->error;
	if(a->_ns8__getActualR13nShippingRuleListResponse::ent__r13nShippingRuleList) {
		if(soap_out_PointerToent__RegionalizationShippingRuleList(soap, "ent:r13nShippingRuleList", -1, &a->_ns8__getActualR13nShippingRuleListResponse::ent__r13nShippingRuleList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:r13nShippingRuleList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nShippingRuleListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nShippingRuleListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListResponse * FASTCALL soap_in__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, const char *tag, _ns8__getActualR13nShippingRuleListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nShippingRuleListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse, sizeof(_ns8__getActualR13nShippingRuleListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nShippingRuleListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__r13nShippingRuleList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__r13nShippingRuleList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationShippingRuleList(soap, "ent:r13nShippingRuleList", &(a->_ns8__getActualR13nShippingRuleListResponse::ent__r13nShippingRuleList), "ent:RegionalizationShippingRuleList"))
				{	soap_flag_ent__r13nShippingRuleList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nShippingRuleListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse, 0, sizeof(_ns8__getActualR13nShippingRuleListResponse), 0, soap_copy__ns8__getActualR13nShippingRuleListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__r13nShippingRuleList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nShippingRuleListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nShippingRuleListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nShippingRuleListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nShippingRuleListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListResponse * SOAP_FMAC4 soap_get__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, _ns8__getActualR13nShippingRuleListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nShippingRuleListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nShippingRuleListResponse * FASTCALL soap_instantiate__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nShippingRuleListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nShippingRuleListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nShippingRuleListResponse));
		((_ns8__getActualR13nShippingRuleListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nShippingRuleListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nShippingRuleListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nShippingRuleListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nShippingRuleListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nShippingRuleListResponse %p -> %p\n", q, p));
	*(_ns8__getActualR13nShippingRuleListResponse*)p = *(_ns8__getActualR13nShippingRuleListResponse*)q;
}

void _ns8__getActualR13nShippingRuleListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nShippingRuleListRequest::base__listOptions = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ent__disease = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ent__productType = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ent__product = NULL;
	this->_ns8__getActualR13nShippingRuleListRequest::ent__subProduct = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nShippingRuleListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getActualR13nShippingRuleListRequest::base__listOptions);
	soap_serialize_PointerToent__AnimalDisease(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ent__disease);
	soap_serialize_PointerToent__ProductType(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ent__productType);
	soap_serialize_PointerToent__Product(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ent__product);
	soap_serialize_PointerToent__SubProduct(soap, &this->_ns8__getActualR13nShippingRuleListRequest::ent__subProduct);
	/* transient soap skipped */
}

int _ns8__getActualR13nShippingRuleListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nShippingRuleListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nShippingRuleListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getActualR13nShippingRuleListRequest::ent__disease) {
		if(soap_out_PointerToent__AnimalDisease(soap, "ent:disease", -1, &a->_ns8__getActualR13nShippingRuleListRequest::ent__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:disease"))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "ent:productType", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ent__productType), ""))
		return soap->error;
	if(soap_out_PointerToent__Product(soap, "ent:product", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ent__product), ""))
		return soap->error;
	if(soap_out_PointerToent__SubProduct(soap, "ent:subProduct", -1, &(a->_ns8__getActualR13nShippingRuleListRequest::ent__subProduct), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nShippingRuleListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nShippingRuleListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListRequest * FASTCALL soap_in__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, const char *tag, _ns8__getActualR13nShippingRuleListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nShippingRuleListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest, sizeof(_ns8__getActualR13nShippingRuleListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nShippingRuleListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__disease1 = 1;
	size_t soap_flag_ent__productType1 = 1;
	size_t soap_flag_ent__product1 = 1;
	size_t soap_flag_ent__subProduct1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getActualR13nShippingRuleListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:disease", &(a->_ns8__getActualR13nShippingRuleListRequest::ent__disease), "ent:AnimalDisease"))
				{	soap_flag_ent__disease1--;
					continue;
				}
			if(soap_flag_ent__productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "ent:productType", &(a->_ns8__getActualR13nShippingRuleListRequest::ent__productType), "ent:ProductType"))
				{	soap_flag_ent__productType1--;
					continue;
				}
			if(soap_flag_ent__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "ent:product", &(a->_ns8__getActualR13nShippingRuleListRequest::ent__product), "ent:Product"))
				{	soap_flag_ent__product1--;
					continue;
				}
			if(soap_flag_ent__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "ent:subProduct", &(a->_ns8__getActualR13nShippingRuleListRequest::ent__subProduct), "ent:SubProduct"))
				{	soap_flag_ent__subProduct1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nShippingRuleListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest, 0, sizeof(_ns8__getActualR13nShippingRuleListRequest), 0, soap_copy__ns8__getActualR13nShippingRuleListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nShippingRuleListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nShippingRuleListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nShippingRuleListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nShippingRuleListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nShippingRuleListRequest * SOAP_FMAC4 soap_get__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, _ns8__getActualR13nShippingRuleListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nShippingRuleListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nShippingRuleListRequest * FASTCALL soap_instantiate__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nShippingRuleListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nShippingRuleListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nShippingRuleListRequest));
		((_ns8__getActualR13nShippingRuleListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nShippingRuleListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nShippingRuleListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nShippingRuleListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nShippingRuleListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nShippingRuleListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nShippingRuleListRequest %p -> %p\n", q, p));
	*(_ns8__getActualR13nShippingRuleListRequest*)p = *(_ns8__getActualR13nShippingRuleListRequest*)q;
}

void _ns8__getActualR13nRegionStatusListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nRegionStatusListResponse::ent__r13nRegionStatusList = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nRegionStatusListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__RegionalizationRegionStatusList(soap, &this->_ns8__getActualR13nRegionStatusListResponse::ent__r13nRegionStatusList);
	/* transient soap skipped */
}

int _ns8__getActualR13nRegionStatusListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nRegionStatusListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nRegionStatusListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse), type))
		return soap->error;
	if(a->_ns8__getActualR13nRegionStatusListResponse::ent__r13nRegionStatusList) {
		if(soap_out_PointerToent__RegionalizationRegionStatusList(soap, "ent:r13nRegionStatusList", -1, &a->_ns8__getActualR13nRegionStatusListResponse::ent__r13nRegionStatusList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:r13nRegionStatusList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nRegionStatusListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nRegionStatusListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListResponse * FASTCALL soap_in__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, const char *tag, _ns8__getActualR13nRegionStatusListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nRegionStatusListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse, sizeof(_ns8__getActualR13nRegionStatusListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nRegionStatusListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__r13nRegionStatusList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__r13nRegionStatusList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationRegionStatusList(soap, "ent:r13nRegionStatusList", &(a->_ns8__getActualR13nRegionStatusListResponse::ent__r13nRegionStatusList), "ent:RegionalizationRegionStatusList"))
				{	soap_flag_ent__r13nRegionStatusList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nRegionStatusListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse, 0, sizeof(_ns8__getActualR13nRegionStatusListResponse), 0, soap_copy__ns8__getActualR13nRegionStatusListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__r13nRegionStatusList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nRegionStatusListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nRegionStatusListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nRegionStatusListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nRegionStatusListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListResponse * SOAP_FMAC4 soap_get__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, _ns8__getActualR13nRegionStatusListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nRegionStatusListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nRegionStatusListResponse * FASTCALL soap_instantiate__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nRegionStatusListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nRegionStatusListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nRegionStatusListResponse));
		((_ns8__getActualR13nRegionStatusListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nRegionStatusListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nRegionStatusListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nRegionStatusListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nRegionStatusListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nRegionStatusListResponse %p -> %p\n", q, p));
	*(_ns8__getActualR13nRegionStatusListResponse*)p = *(_ns8__getActualR13nRegionStatusListResponse*)q;
}

void _ns8__getActualR13nRegionStatusListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActualR13nRegionStatusListRequest::base__listOptions = NULL;
	this->_ns8__getActualR13nRegionStatusListRequest::ent__disease = NULL;
	this->_ns8__getActualR13nRegionStatusListRequest::ent__r13nZone = NULL;
	/* transient soap skipped */
}

void _ns8__getActualR13nRegionStatusListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getActualR13nRegionStatusListRequest::base__listOptions);
	soap_serialize_PointerToent__AnimalDisease(soap, &this->_ns8__getActualR13nRegionStatusListRequest::ent__disease);
	soap_serialize_PointerToent__Area(soap, &this->_ns8__getActualR13nRegionStatusListRequest::ent__r13nZone);
	/* transient soap skipped */
}

int _ns8__getActualR13nRegionStatusListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActualR13nRegionStatusListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, const char *tag, int id, const _ns8__getActualR13nRegionStatusListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getActualR13nRegionStatusListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getActualR13nRegionStatusListRequest::ent__disease) {
		if(soap_out_PointerToent__AnimalDisease(soap, "ent:disease", -1, &a->_ns8__getActualR13nRegionStatusListRequest::ent__disease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:disease"))
		return soap->error;
	if(soap_out_PointerToent__Area(soap, "ent:r13nZone", -1, &(a->_ns8__getActualR13nRegionStatusListRequest::ent__r13nZone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActualR13nRegionStatusListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActualR13nRegionStatusListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListRequest * FASTCALL soap_in__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, const char *tag, _ns8__getActualR13nRegionStatusListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActualR13nRegionStatusListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest, sizeof(_ns8__getActualR13nRegionStatusListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActualR13nRegionStatusListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__disease1 = 1;
	size_t soap_flag_ent__r13nZone1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getActualR13nRegionStatusListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:disease", &(a->_ns8__getActualR13nRegionStatusListRequest::ent__disease), "ent:AnimalDisease"))
				{	soap_flag_ent__disease1--;
					continue;
				}
			if(soap_flag_ent__r13nZone1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Area(soap, "ent:r13nZone", &(a->_ns8__getActualR13nRegionStatusListRequest::ent__r13nZone), "ent:Area"))
				{	soap_flag_ent__r13nZone1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActualR13nRegionStatusListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest, 0, sizeof(_ns8__getActualR13nRegionStatusListRequest), 0, soap_copy__ns8__getActualR13nRegionStatusListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__disease1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActualR13nRegionStatusListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getActualR13nRegionStatusListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActualR13nRegionStatusListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActualR13nRegionStatusListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActualR13nRegionStatusListRequest * SOAP_FMAC4 soap_get__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, _ns8__getActualR13nRegionStatusListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActualR13nRegionStatusListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActualR13nRegionStatusListRequest * FASTCALL soap_instantiate__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActualR13nRegionStatusListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActualR13nRegionStatusListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getActualR13nRegionStatusListRequest));
		((_ns8__getActualR13nRegionStatusListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActualR13nRegionStatusListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActualR13nRegionStatusListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getActualR13nRegionStatusListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActualR13nRegionStatusListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActualR13nRegionStatusListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActualR13nRegionStatusListRequest %p -> %p\n", q, p));
	*(_ns8__getActualR13nRegionStatusListRequest*)p = *(_ns8__getActualR13nRegionStatusListRequest*)q;
}

void _ns8__getR13nConditionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getR13nConditionListResponse::ent__r13nConditionList = NULL;
	/* transient soap skipped */
}

void _ns8__getR13nConditionListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__RegionalizationConditionList(soap, &this->_ns8__getR13nConditionListResponse::ent__r13nConditionList);
	/* transient soap skipped */
}

int _ns8__getR13nConditionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getR13nConditionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getR13nConditionListResponse(struct soap *soap, const char *tag, int id, const _ns8__getR13nConditionListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getR13nConditionListResponse), type))
		return soap->error;
	if(a->_ns8__getR13nConditionListResponse::ent__r13nConditionList) {
		if(soap_out_PointerToent__RegionalizationConditionList(soap, "ent:r13nConditionList", -1, &a->_ns8__getR13nConditionListResponse::ent__r13nConditionList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:r13nConditionList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getR13nConditionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getR13nConditionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListResponse * FASTCALL soap_in__ns8__getR13nConditionListResponse(struct soap *soap, const char *tag, _ns8__getR13nConditionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getR13nConditionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getR13nConditionListResponse, sizeof(_ns8__getR13nConditionListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getR13nConditionListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getR13nConditionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__r13nConditionList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__r13nConditionList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationConditionList(soap, "ent:r13nConditionList", &(a->_ns8__getR13nConditionListResponse::ent__r13nConditionList), "ent:RegionalizationConditionList"))
				{	soap_flag_ent__r13nConditionList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getR13nConditionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getR13nConditionListResponse, 0, sizeof(_ns8__getR13nConditionListResponse), 0, soap_copy__ns8__getR13nConditionListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__r13nConditionList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getR13nConditionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getR13nConditionListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getR13nConditionListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getR13nConditionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getR13nConditionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListResponse * SOAP_FMAC4 soap_get__ns8__getR13nConditionListResponse(struct soap *soap, _ns8__getR13nConditionListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getR13nConditionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getR13nConditionListResponse * FASTCALL soap_instantiate__ns8__getR13nConditionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getR13nConditionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getR13nConditionListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getR13nConditionListResponse));
		((_ns8__getR13nConditionListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getR13nConditionListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getR13nConditionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getR13nConditionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getR13nConditionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getR13nConditionListResponse %p -> %p\n", q, p));
	*(_ns8__getR13nConditionListResponse*)p = *(_ns8__getR13nConditionListResponse*)q;
}

void _ns8__getR13nConditionListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getR13nConditionListRequest::base__listOptions = NULL;
	this->_ns8__getR13nConditionListRequest::ent__disease = NULL;
	/* transient soap skipped */
}

void _ns8__getR13nConditionListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getR13nConditionListRequest::base__listOptions);
	soap_serialize_PointerToent__AnimalDisease(soap, &this->_ns8__getR13nConditionListRequest::ent__disease);
	/* transient soap skipped */
}

int _ns8__getR13nConditionListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getR13nConditionListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getR13nConditionListRequest(struct soap *soap, const char *tag, int id, const _ns8__getR13nConditionListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getR13nConditionListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getR13nConditionListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerToent__AnimalDisease(soap, "ent:disease", -1, &(a->_ns8__getR13nConditionListRequest::ent__disease), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getR13nConditionListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getR13nConditionListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListRequest * FASTCALL soap_in__ns8__getR13nConditionListRequest(struct soap *soap, const char *tag, _ns8__getR13nConditionListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getR13nConditionListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getR13nConditionListRequest, sizeof(_ns8__getR13nConditionListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getR13nConditionListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getR13nConditionListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__disease1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getR13nConditionListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:disease", &(a->_ns8__getR13nConditionListRequest::ent__disease), "ent:AnimalDisease"))
				{	soap_flag_ent__disease1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getR13nConditionListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getR13nConditionListRequest, 0, sizeof(_ns8__getR13nConditionListRequest), 0, soap_copy__ns8__getR13nConditionListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getR13nConditionListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getR13nConditionListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getR13nConditionListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getR13nConditionListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getR13nConditionListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getR13nConditionListRequest * SOAP_FMAC4 soap_get__ns8__getR13nConditionListRequest(struct soap *soap, _ns8__getR13nConditionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getR13nConditionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getR13nConditionListRequest * FASTCALL soap_instantiate__ns8__getR13nConditionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getR13nConditionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getR13nConditionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getR13nConditionListRequest));
		((_ns8__getR13nConditionListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getR13nConditionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getR13nConditionListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getR13nConditionListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getR13nConditionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getR13nConditionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getR13nConditionListRequest %p -> %p\n", q, p));
	*(_ns8__getR13nConditionListRequest*)p = *(_ns8__getR13nConditionListRequest*)q;
}

void _ns8__getActivityLocationListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActivityLocationListResponse::ent__activityLocationList = NULL;
	/* transient soap skipped */
}

void _ns8__getActivityLocationListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ActivityLocationList(soap, &this->_ns8__getActivityLocationListResponse::ent__activityLocationList);
	/* transient soap skipped */
}

int _ns8__getActivityLocationListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActivityLocationListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, int id, const _ns8__getActivityLocationListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActivityLocationListResponse), type))
		return soap->error;
	if(a->ent__activityLocationList)
		soap_element_result(soap, "ent:activityLocationList");
	if(a->_ns8__getActivityLocationListResponse::ent__activityLocationList) {
		if(soap_out_PointerToent__ActivityLocationList(soap, "ent:activityLocationList", -1, &a->_ns8__getActivityLocationListResponse::ent__activityLocationList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:activityLocationList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActivityLocationListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActivityLocationListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse * FASTCALL soap_in__ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, _ns8__getActivityLocationListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActivityLocationListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActivityLocationListResponse, sizeof(_ns8__getActivityLocationListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActivityLocationListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActivityLocationListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__activityLocationList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__activityLocationList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ActivityLocationList(soap, "ent:activityLocationList", &(a->_ns8__getActivityLocationListResponse::ent__activityLocationList), "ent:ActivityLocationList"))
				{	soap_flag_ent__activityLocationList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:activityLocationList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActivityLocationListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActivityLocationListResponse, 0, sizeof(_ns8__getActivityLocationListResponse), 0, soap_copy__ns8__getActivityLocationListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__activityLocationList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActivityLocationListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActivityLocationListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getActivityLocationListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActivityLocationListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActivityLocationListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse * SOAP_FMAC4 soap_get__ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActivityLocationListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActivityLocationListResponse * FASTCALL soap_instantiate__ns8__getActivityLocationListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActivityLocationListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActivityLocationListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getActivityLocationListResponse));
		((_ns8__getActivityLocationListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActivityLocationListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getActivityLocationListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActivityLocationListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActivityLocationListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActivityLocationListResponse %p -> %p\n", q, p));
	*(_ns8__getActivityLocationListResponse*)p = *(_ns8__getActivityLocationListResponse*)q;
}

void _ns8__getActivityLocationListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getActivityLocationListRequest::base__listOptions = NULL;
	this->_ns8__getActivityLocationListRequest::ent__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getActivityLocationListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getActivityLocationListRequest::base__listOptions);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->_ns8__getActivityLocationListRequest::ent__businessEntity);
	/* transient soap skipped */
}

int _ns8__getActivityLocationListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getActivityLocationListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, int id, const _ns8__getActivityLocationListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getActivityLocationListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getActivityLocationListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getActivityLocationListRequest::ent__businessEntity) {
		if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &a->_ns8__getActivityLocationListRequest::ent__businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessEntity"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getActivityLocationListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getActivityLocationListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest * FASTCALL soap_in__ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, _ns8__getActivityLocationListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getActivityLocationListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getActivityLocationListRequest, sizeof(_ns8__getActivityLocationListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getActivityLocationListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getActivityLocationListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getActivityLocationListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->_ns8__getActivityLocationListRequest::ent__businessEntity), "ent:BusinessEntity"))
				{	soap_flag_ent__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getActivityLocationListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getActivityLocationListRequest, 0, sizeof(_ns8__getActivityLocationListRequest), 0, soap_copy__ns8__getActivityLocationListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__businessEntity1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getActivityLocationListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getActivityLocationListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getActivityLocationListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getActivityLocationListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getActivityLocationListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest * SOAP_FMAC4 soap_get__ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getActivityLocationListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getActivityLocationListRequest * FASTCALL soap_instantiate__ns8__getActivityLocationListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getActivityLocationListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getActivityLocationListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getActivityLocationListRequest));
		((_ns8__getActivityLocationListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getActivityLocationListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getActivityLocationListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getActivityLocationListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getActivityLocationListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getActivityLocationListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getActivityLocationListRequest %p -> %p\n", q, p));
	*(_ns8__getActivityLocationListRequest*)p = *(_ns8__getActivityLocationListRequest*)q;
}

void _ns8__getBusinessMemberByGLNResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessMemberByGLNResponse::ent__businessMember = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessMemberByGLNResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessMember(soap, &this->_ns8__getBusinessMemberByGLNResponse::ent__businessMember);
	/* transient soap skipped */
}

int _ns8__getBusinessMemberByGLNResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessMemberByGLNResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessMemberByGLNResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse), type))
		return soap->error;
	if(a->ent__businessMember)
		soap_element_result(soap, "ent:businessMember");
	if(a->_ns8__getBusinessMemberByGLNResponse::ent__businessMember) {
		if(soap_out_PointerToent__BusinessMember(soap, "ent:businessMember", -1, &a->_ns8__getBusinessMemberByGLNResponse::ent__businessMember, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessMember"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessMemberByGLNResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessMemberByGLNResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse * FASTCALL soap_in__ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessMemberByGLNResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, sizeof(_ns8__getBusinessMemberByGLNResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessMemberByGLNResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessMemberByGLNResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__businessMember1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__businessMember1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "ent:businessMember", &(a->_ns8__getBusinessMemberByGLNResponse::ent__businessMember), "ent:BusinessMember"))
				{	soap_flag_ent__businessMember1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:businessMember");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessMemberByGLNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, 0, sizeof(_ns8__getBusinessMemberByGLNResponse), 0, soap_copy__ns8__getBusinessMemberByGLNResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__businessMember1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessMemberByGLNResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessMemberByGLNResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessMemberByGLNResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessMemberByGLNResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse * SOAP_FMAC4 soap_get__ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessMemberByGLNResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessMemberByGLNResponse * FASTCALL soap_instantiate__ns8__getBusinessMemberByGLNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessMemberByGLNResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessMemberByGLNResponse));
		((_ns8__getBusinessMemberByGLNResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessMemberByGLNResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessMemberByGLNResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessMemberByGLNResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessMemberByGLNResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessMemberByGLNResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessMemberByGLNResponse*)p = *(_ns8__getBusinessMemberByGLNResponse*)q;
}

void _ns8__getBusinessMemberByGLNRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ent__GLNType(soap, &this->_ns8__getBusinessMemberByGLNRequest::ent__globalID);
	/* transient soap skipped */
}

void _ns8__getBusinessMemberByGLNRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_ent__GLNType(soap, &this->_ns8__getBusinessMemberByGLNRequest::ent__globalID);
	/* transient soap skipped */
}

int _ns8__getBusinessMemberByGLNRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessMemberByGLNRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessMemberByGLNRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest), type))
		return soap->error;
	if(a->_ns8__getBusinessMemberByGLNRequest::ent__globalID) {
		if(soap_out_ent__GLNType(soap, "ent:globalID", -1, &a->_ns8__getBusinessMemberByGLNRequest::ent__globalID, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:globalID"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessMemberByGLNRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessMemberByGLNRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest * FASTCALL soap_in__ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessMemberByGLNRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, sizeof(_ns8__getBusinessMemberByGLNRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessMemberByGLNRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessMemberByGLNRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__globalID1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__GLNType(soap, "ent:globalID", &(a->_ns8__getBusinessMemberByGLNRequest::ent__globalID), "ent:GLNType"))
				{	soap_flag_ent__globalID1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessMemberByGLNRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, 0, sizeof(_ns8__getBusinessMemberByGLNRequest), 0, soap_copy__ns8__getBusinessMemberByGLNRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__globalID1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessMemberByGLNRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessMemberByGLNRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessMemberByGLNRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessMemberByGLNRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest * SOAP_FMAC4 soap_get__ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessMemberByGLNRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessMemberByGLNRequest * FASTCALL soap_instantiate__ns8__getBusinessMemberByGLNRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessMemberByGLNRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessMemberByGLNRequest));
		((_ns8__getBusinessMemberByGLNRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessMemberByGLNRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessMemberByGLNRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessMemberByGLNRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessMemberByGLNRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessMemberByGLNRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessMemberByGLNRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessMemberByGLNRequest*)p = *(_ns8__getBusinessMemberByGLNRequest*)q;
}

void _ns8__getBusinessEntityChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityChangesListResponse::ent__businessEntityList = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntityList(soap, &this->_ns8__getBusinessEntityChangesListResponse::ent__businessEntityList);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse), type))
		return soap->error;
	if(a->ent__businessEntityList)
		soap_element_result(soap, "ent:businessEntityList");
	if(a->_ns8__getBusinessEntityChangesListResponse::ent__businessEntityList) {
		if(soap_out_PointerToent__BusinessEntityList(soap, "ent:businessEntityList", -1, &a->_ns8__getBusinessEntityChangesListResponse::ent__businessEntityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessEntityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse * FASTCALL soap_in__ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, sizeof(_ns8__getBusinessEntityChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__businessEntityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__businessEntityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntityList(soap, "ent:businessEntityList", &(a->_ns8__getBusinessEntityChangesListResponse::ent__businessEntityList), "ent:BusinessEntityList"))
				{	soap_flag_ent__businessEntityList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:businessEntityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, 0, sizeof(_ns8__getBusinessEntityChangesListResponse), 0, soap_copy__ns8__getBusinessEntityChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__businessEntityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityChangesListResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityChangesListResponse));
		((_ns8__getBusinessEntityChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityChangesListResponse*)p = *(_ns8__getBusinessEntityChangesListResponse*)q;
}

void _ns8__getBusinessEntityChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityChangesListRequest::base__listOptions = NULL;
	this->_ns8__getBusinessEntityChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getBusinessEntityChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getBusinessEntityChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getBusinessEntityChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getBusinessEntityChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getBusinessEntityChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest * FASTCALL soap_in__ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, sizeof(_ns8__getBusinessEntityChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getBusinessEntityChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getBusinessEntityChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, 0, sizeof(_ns8__getBusinessEntityChangesListRequest), 0, soap_copy__ns8__getBusinessEntityChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityChangesListRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityChangesListRequest));
		((_ns8__getBusinessEntityChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityChangesListRequest*)p = *(_ns8__getBusinessEntityChangesListRequest*)q;
}

void _ns8__getBusinessEntityListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityListResponse::ent__businessEntityList = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntityList(soap, &this->_ns8__getBusinessEntityListResponse::ent__businessEntityList);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityListResponse), type))
		return soap->error;
	if(a->ent__businessEntityList)
		soap_element_result(soap, "ent:businessEntityList");
	if(a->_ns8__getBusinessEntityListResponse::ent__businessEntityList) {
		if(soap_out_PointerToent__BusinessEntityList(soap, "ent:businessEntityList", -1, &a->_ns8__getBusinessEntityListResponse::ent__businessEntityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessEntityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse * FASTCALL soap_in__ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityListResponse, sizeof(_ns8__getBusinessEntityListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__businessEntityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__businessEntityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntityList(soap, "ent:businessEntityList", &(a->_ns8__getBusinessEntityListResponse::ent__businessEntityList), "ent:BusinessEntityList"))
				{	soap_flag_ent__businessEntityList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:businessEntityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityListResponse, 0, sizeof(_ns8__getBusinessEntityListResponse), 0, soap_copy__ns8__getBusinessEntityListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__businessEntityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityListResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityListResponse));
		((_ns8__getBusinessEntityListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityListResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityListResponse*)p = *(_ns8__getBusinessEntityListResponse*)q;
}

void _ns8__getBusinessEntityListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityListRequest::base__listOptions = NULL;
	this->_ns8__getBusinessEntityListRequest::ent__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getBusinessEntityListRequest::base__listOptions);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->_ns8__getBusinessEntityListRequest::ent__businessEntity);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getBusinessEntityListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &(a->_ns8__getBusinessEntityListRequest::ent__businessEntity), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest * FASTCALL soap_in__ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityListRequest, sizeof(_ns8__getBusinessEntityListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getBusinessEntityListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->_ns8__getBusinessEntityListRequest::ent__businessEntity), "ent:BusinessEntity"))
				{	soap_flag_ent__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityListRequest, 0, sizeof(_ns8__getBusinessEntityListRequest), 0, soap_copy__ns8__getBusinessEntityListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityListRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityListRequest));
		((_ns8__getBusinessEntityListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityListRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityListRequest*)p = *(_ns8__getBusinessEntityListRequest*)q;
}

void _ns8__getBusinessEntityByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityByUuidResponse::ent__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntity(soap, &this->_ns8__getBusinessEntityByUuidResponse::ent__businessEntity);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse), type))
		return soap->error;
	if(a->ent__businessEntity)
		soap_element_result(soap, "ent:businessEntity");
	if(a->_ns8__getBusinessEntityByUuidResponse::ent__businessEntity) {
		if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &a->_ns8__getBusinessEntityByUuidResponse::ent__businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessEntity"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse * FASTCALL soap_in__ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, sizeof(_ns8__getBusinessEntityByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->_ns8__getBusinessEntityByUuidResponse::ent__businessEntity), "ent:BusinessEntity"))
				{	soap_flag_ent__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, 0, sizeof(_ns8__getBusinessEntityByUuidResponse), 0, soap_copy__ns8__getBusinessEntityByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__businessEntity1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByUuidResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByUuidResponse));
		((_ns8__getBusinessEntityByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByUuidResponse*)p = *(_ns8__getBusinessEntityByUuidResponse*)q;
}

void _ns8__getBusinessEntityByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getBusinessEntityByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getBusinessEntityByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getBusinessEntityByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getBusinessEntityByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest * FASTCALL soap_in__ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, sizeof(_ns8__getBusinessEntityByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getBusinessEntityByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, 0, sizeof(_ns8__getBusinessEntityByUuidRequest), 0, soap_copy__ns8__getBusinessEntityByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByUuidRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByUuidRequest));
		((_ns8__getBusinessEntityByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByUuidRequest*)p = *(_ns8__getBusinessEntityByUuidRequest*)q;
}

void _ns8__getBusinessEntityByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getBusinessEntityByGuidResponse::ent__businessEntity = NULL;
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntity(soap, &this->_ns8__getBusinessEntityByGuidResponse::ent__businessEntity);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse), type))
		return soap->error;
	if(a->ent__businessEntity)
		soap_element_result(soap, "ent:businessEntity");
	if(a->_ns8__getBusinessEntityByGuidResponse::ent__businessEntity) {
		if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &a->_ns8__getBusinessEntityByGuidResponse::ent__businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessEntity"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse * FASTCALL soap_in__ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, sizeof(_ns8__getBusinessEntityByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->_ns8__getBusinessEntityByGuidResponse::ent__businessEntity), "ent:BusinessEntity"))
				{	soap_flag_ent__businessEntity1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, 0, sizeof(_ns8__getBusinessEntityByGuidResponse), 0, soap_copy__ns8__getBusinessEntityByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__businessEntity1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByGuidResponse * FASTCALL soap_instantiate__ns8__getBusinessEntityByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByGuidResponse));
		((_ns8__getBusinessEntityByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByGuidResponse*)p = *(_ns8__getBusinessEntityByGuidResponse*)q;
}

void _ns8__getBusinessEntityByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getBusinessEntityByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getBusinessEntityByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getBusinessEntityByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getBusinessEntityByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getBusinessEntityByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getBusinessEntityByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getBusinessEntityByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getBusinessEntityByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getBusinessEntityByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getBusinessEntityByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest * FASTCALL soap_in__ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getBusinessEntityByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, sizeof(_ns8__getBusinessEntityByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getBusinessEntityByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getBusinessEntityByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getBusinessEntityByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getBusinessEntityByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, 0, sizeof(_ns8__getBusinessEntityByGuidRequest), 0, soap_copy__ns8__getBusinessEntityByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getBusinessEntityByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getBusinessEntityByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getBusinessEntityByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getBusinessEntityByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest * SOAP_FMAC4 soap_get__ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getBusinessEntityByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getBusinessEntityByGuidRequest * FASTCALL soap_instantiate__ns8__getBusinessEntityByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getBusinessEntityByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getBusinessEntityByGuidRequest));
		((_ns8__getBusinessEntityByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getBusinessEntityByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getBusinessEntityByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getBusinessEntityByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getBusinessEntityByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getBusinessEntityByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getBusinessEntityByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getBusinessEntityByGuidRequest*)p = *(_ns8__getBusinessEntityByGuidRequest*)q;
}

void _ns8__getRussianEnterpriseChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseChangesListResponse::ent__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__EnterpriseList(soap, &this->_ns8__getRussianEnterpriseChangesListResponse::ent__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse), type))
		return soap->error;
	if(a->ent__enterpriseList)
		soap_element_result(soap, "ent:enterpriseList");
	if(a->_ns8__getRussianEnterpriseChangesListResponse::ent__enterpriseList) {
		if(soap_out_PointerToent__EnterpriseList(soap, "ent:enterpriseList", -1, &a->_ns8__getRussianEnterpriseChangesListResponse::ent__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse * FASTCALL soap_in__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, sizeof(_ns8__getRussianEnterpriseChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseList(soap, "ent:enterpriseList", &(a->_ns8__getRussianEnterpriseChangesListResponse::ent__enterpriseList), "ent:EnterpriseList"))
				{	soap_flag_ent__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, 0, sizeof(_ns8__getRussianEnterpriseChangesListResponse), 0, soap_copy__ns8__getRussianEnterpriseChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseChangesListResponse * FASTCALL soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseChangesListResponse));
		((_ns8__getRussianEnterpriseChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseChangesListResponse*)p = *(_ns8__getRussianEnterpriseChangesListResponse*)q;
}

void _ns8__getRussianEnterpriseChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseChangesListRequest::base__listOptions = NULL;
	this->_ns8__getRussianEnterpriseChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getRussianEnterpriseChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getRussianEnterpriseChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getRussianEnterpriseChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getRussianEnterpriseChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getRussianEnterpriseChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest * FASTCALL soap_in__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, sizeof(_ns8__getRussianEnterpriseChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getRussianEnterpriseChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getRussianEnterpriseChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, 0, sizeof(_ns8__getRussianEnterpriseChangesListRequest), 0, soap_copy__ns8__getRussianEnterpriseChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseChangesListRequest * FASTCALL soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseChangesListRequest));
		((_ns8__getRussianEnterpriseChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseChangesListRequest*)p = *(_ns8__getRussianEnterpriseChangesListRequest*)q;
}

void _ns8__getForeignEnterpriseChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseChangesListResponse::ent__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__EnterpriseList(soap, &this->_ns8__getForeignEnterpriseChangesListResponse::ent__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse), type))
		return soap->error;
	if(a->ent__enterpriseList)
		soap_element_result(soap, "ent:enterpriseList");
	if(a->_ns8__getForeignEnterpriseChangesListResponse::ent__enterpriseList) {
		if(soap_out_PointerToent__EnterpriseList(soap, "ent:enterpriseList", -1, &a->_ns8__getForeignEnterpriseChangesListResponse::ent__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse * FASTCALL soap_in__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, sizeof(_ns8__getForeignEnterpriseChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseList(soap, "ent:enterpriseList", &(a->_ns8__getForeignEnterpriseChangesListResponse::ent__enterpriseList), "ent:EnterpriseList"))
				{	soap_flag_ent__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, 0, sizeof(_ns8__getForeignEnterpriseChangesListResponse), 0, soap_copy__ns8__getForeignEnterpriseChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseChangesListResponse * FASTCALL soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseChangesListResponse));
		((_ns8__getForeignEnterpriseChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseChangesListResponse*)p = *(_ns8__getForeignEnterpriseChangesListResponse*)q;
}

void _ns8__getForeignEnterpriseChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseChangesListRequest::base__listOptions = NULL;
	this->_ns8__getForeignEnterpriseChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getForeignEnterpriseChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getForeignEnterpriseChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getForeignEnterpriseChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getForeignEnterpriseChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getForeignEnterpriseChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest * FASTCALL soap_in__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, sizeof(_ns8__getForeignEnterpriseChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getForeignEnterpriseChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getForeignEnterpriseChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, 0, sizeof(_ns8__getForeignEnterpriseChangesListRequest), 0, soap_copy__ns8__getForeignEnterpriseChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseChangesListRequest * FASTCALL soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseChangesListRequest));
		((_ns8__getForeignEnterpriseChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseChangesListRequest*)p = *(_ns8__getForeignEnterpriseChangesListRequest*)q;
}

void _ns8__getRussianEnterpriseListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseListResponse::ent__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__EnterpriseList(soap, &this->_ns8__getRussianEnterpriseListResponse::ent__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse), type))
		return soap->error;
	if(a->ent__enterpriseList)
		soap_element_result(soap, "ent:enterpriseList");
	if(a->_ns8__getRussianEnterpriseListResponse::ent__enterpriseList) {
		if(soap_out_PointerToent__EnterpriseList(soap, "ent:enterpriseList", -1, &a->_ns8__getRussianEnterpriseListResponse::ent__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse * FASTCALL soap_in__ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, sizeof(_ns8__getRussianEnterpriseListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseList(soap, "ent:enterpriseList", &(a->_ns8__getRussianEnterpriseListResponse::ent__enterpriseList), "ent:EnterpriseList"))
				{	soap_flag_ent__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, 0, sizeof(_ns8__getRussianEnterpriseListResponse), 0, soap_copy__ns8__getRussianEnterpriseListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseListResponse * FASTCALL soap_instantiate__ns8__getRussianEnterpriseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseListResponse));
		((_ns8__getRussianEnterpriseListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseListResponse %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseListResponse*)p = *(_ns8__getRussianEnterpriseListResponse*)q;
}

void _ns8__getRussianEnterpriseListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRussianEnterpriseListRequest::base__listOptions = NULL;
	this->_ns8__getRussianEnterpriseListRequest::ent__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getRussianEnterpriseListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getRussianEnterpriseListRequest::base__listOptions);
	soap_serialize_PointerToent__Enterprise(soap, &this->_ns8__getRussianEnterpriseListRequest::ent__enterprise);
	/* transient soap skipped */
}

int _ns8__getRussianEnterpriseListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRussianEnterpriseListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, int id, const _ns8__getRussianEnterpriseListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getRussianEnterpriseListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &(a->_ns8__getRussianEnterpriseListRequest::ent__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRussianEnterpriseListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRussianEnterpriseListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest * FASTCALL soap_in__ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRussianEnterpriseListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, sizeof(_ns8__getRussianEnterpriseListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRussianEnterpriseListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRussianEnterpriseListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getRussianEnterpriseListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ns8__getRussianEnterpriseListRequest::ent__enterprise), "ent:Enterprise"))
				{	soap_flag_ent__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRussianEnterpriseListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, 0, sizeof(_ns8__getRussianEnterpriseListRequest), 0, soap_copy__ns8__getRussianEnterpriseListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getRussianEnterpriseListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRussianEnterpriseListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRussianEnterpriseListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRussianEnterpriseListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRussianEnterpriseListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest * SOAP_FMAC4 soap_get__ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRussianEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRussianEnterpriseListRequest * FASTCALL soap_instantiate__ns8__getRussianEnterpriseListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRussianEnterpriseListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRussianEnterpriseListRequest));
		((_ns8__getRussianEnterpriseListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRussianEnterpriseListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRussianEnterpriseListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRussianEnterpriseListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRussianEnterpriseListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRussianEnterpriseListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRussianEnterpriseListRequest %p -> %p\n", q, p));
	*(_ns8__getRussianEnterpriseListRequest*)p = *(_ns8__getRussianEnterpriseListRequest*)q;
}

void _ns8__getForeignEnterpriseListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseListResponse::ent__enterpriseList = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__EnterpriseList(soap, &this->_ns8__getForeignEnterpriseListResponse::ent__enterpriseList);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse), type))
		return soap->error;
	if(a->ent__enterpriseList)
		soap_element_result(soap, "ent:enterpriseList");
	if(a->_ns8__getForeignEnterpriseListResponse::ent__enterpriseList) {
		if(soap_out_PointerToent__EnterpriseList(soap, "ent:enterpriseList", -1, &a->_ns8__getForeignEnterpriseListResponse::ent__enterpriseList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse * FASTCALL soap_in__ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, sizeof(_ns8__getForeignEnterpriseListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__enterpriseList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__enterpriseList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseList(soap, "ent:enterpriseList", &(a->_ns8__getForeignEnterpriseListResponse::ent__enterpriseList), "ent:EnterpriseList"))
				{	soap_flag_ent__enterpriseList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:enterpriseList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, 0, sizeof(_ns8__getForeignEnterpriseListResponse), 0, soap_copy__ns8__getForeignEnterpriseListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__enterpriseList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseListResponse * FASTCALL soap_instantiate__ns8__getForeignEnterpriseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseListResponse));
		((_ns8__getForeignEnterpriseListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseListResponse %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseListResponse*)p = *(_ns8__getForeignEnterpriseListResponse*)q;
}

void _ns8__getForeignEnterpriseListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getForeignEnterpriseListRequest::base__listOptions = NULL;
	this->_ns8__getForeignEnterpriseListRequest::ent__enterpriseGroup = NULL;
	this->_ns8__getForeignEnterpriseListRequest::ent__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getForeignEnterpriseListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getForeignEnterpriseListRequest::base__listOptions);
	soap_serialize_PointerToent__EnterpriseGroup(soap, &this->_ns8__getForeignEnterpriseListRequest::ent__enterpriseGroup);
	soap_serialize_PointerToent__Enterprise(soap, &this->_ns8__getForeignEnterpriseListRequest::ent__enterprise);
	/* transient soap skipped */
}

int _ns8__getForeignEnterpriseListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getForeignEnterpriseListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, int id, const _ns8__getForeignEnterpriseListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getForeignEnterpriseListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseGroup(soap, "ent:enterpriseGroup", -1, &(a->_ns8__getForeignEnterpriseListRequest::ent__enterpriseGroup), ""))
		return soap->error;
	if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &(a->_ns8__getForeignEnterpriseListRequest::ent__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getForeignEnterpriseListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getForeignEnterpriseListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest * FASTCALL soap_in__ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getForeignEnterpriseListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, sizeof(_ns8__getForeignEnterpriseListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getForeignEnterpriseListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getForeignEnterpriseListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__enterpriseGroup1 = 1;
	size_t soap_flag_ent__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getForeignEnterpriseListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseGroup(soap, "ent:enterpriseGroup", &(a->_ns8__getForeignEnterpriseListRequest::ent__enterpriseGroup), "ent:EnterpriseGroup"))
				{	soap_flag_ent__enterpriseGroup1--;
					continue;
				}
			if(soap_flag_ent__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ns8__getForeignEnterpriseListRequest::ent__enterprise), "ent:Enterprise"))
				{	soap_flag_ent__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getForeignEnterpriseListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, 0, sizeof(_ns8__getForeignEnterpriseListRequest), 0, soap_copy__ns8__getForeignEnterpriseListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getForeignEnterpriseListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getForeignEnterpriseListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getForeignEnterpriseListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getForeignEnterpriseListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getForeignEnterpriseListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest * SOAP_FMAC4 soap_get__ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getForeignEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getForeignEnterpriseListRequest * FASTCALL soap_instantiate__ns8__getForeignEnterpriseListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getForeignEnterpriseListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getForeignEnterpriseListRequest));
		((_ns8__getForeignEnterpriseListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getForeignEnterpriseListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getForeignEnterpriseListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getForeignEnterpriseListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getForeignEnterpriseListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getForeignEnterpriseListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getForeignEnterpriseListRequest %p -> %p\n", q, p));
	*(_ns8__getForeignEnterpriseListRequest*)p = *(_ns8__getForeignEnterpriseListRequest*)q;
}

void _ns8__getEnterpriseByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getEnterpriseByUuidResponse::ent__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getEnterpriseByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->_ns8__getEnterpriseByUuidResponse::ent__enterprise);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse), type))
		return soap->error;
	if(a->ent__enterprise)
		soap_element_result(soap, "ent:enterprise");
	if(a->_ns8__getEnterpriseByUuidResponse::ent__enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &a->_ns8__getEnterpriseByUuidResponse::ent__enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterprise"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse * FASTCALL soap_in__ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, sizeof(_ns8__getEnterpriseByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ns8__getEnterpriseByUuidResponse::ent__enterprise), "ent:Enterprise"))
				{	soap_flag_ent__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:enterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, 0, sizeof(_ns8__getEnterpriseByUuidResponse), 0, soap_copy__ns8__getEnterpriseByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse * SOAP_FMAC4 soap_get__ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByUuidResponse * FASTCALL soap_instantiate__ns8__getEnterpriseByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByUuidResponse));
		((_ns8__getEnterpriseByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByUuidResponse*)p = *(_ns8__getEnterpriseByUuidResponse*)q;
}

void _ns8__getEnterpriseByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getEnterpriseByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getEnterpriseByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getEnterpriseByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getEnterpriseByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getEnterpriseByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest * FASTCALL soap_in__ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, sizeof(_ns8__getEnterpriseByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getEnterpriseByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, 0, sizeof(_ns8__getEnterpriseByUuidRequest), 0, soap_copy__ns8__getEnterpriseByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest * SOAP_FMAC4 soap_get__ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByUuidRequest * FASTCALL soap_instantiate__ns8__getEnterpriseByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByUuidRequest));
		((_ns8__getEnterpriseByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByUuidRequest*)p = *(_ns8__getEnterpriseByUuidRequest*)q;
}

void _ns8__getEnterpriseByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getEnterpriseByGuidResponse::ent__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getEnterpriseByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->_ns8__getEnterpriseByGuidResponse::ent__enterprise);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse), type))
		return soap->error;
	if(a->ent__enterprise)
		soap_element_result(soap, "ent:enterprise");
	if(a->_ns8__getEnterpriseByGuidResponse::ent__enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &a->_ns8__getEnterpriseByGuidResponse::ent__enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterprise"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse * FASTCALL soap_in__ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, sizeof(_ns8__getEnterpriseByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ns8__getEnterpriseByGuidResponse::ent__enterprise), "ent:Enterprise"))
				{	soap_flag_ent__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:enterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, 0, sizeof(_ns8__getEnterpriseByGuidResponse), 0, soap_copy__ns8__getEnterpriseByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse * SOAP_FMAC4 soap_get__ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByGuidResponse * FASTCALL soap_instantiate__ns8__getEnterpriseByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByGuidResponse));
		((_ns8__getEnterpriseByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByGuidResponse*)p = *(_ns8__getEnterpriseByGuidResponse*)q;
}

void _ns8__getEnterpriseByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getEnterpriseByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getEnterpriseByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getEnterpriseByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getEnterpriseByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getEnterpriseByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getEnterpriseByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getEnterpriseByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getEnterpriseByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getEnterpriseByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getEnterpriseByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest * FASTCALL soap_in__ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getEnterpriseByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, sizeof(_ns8__getEnterpriseByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getEnterpriseByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getEnterpriseByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getEnterpriseByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getEnterpriseByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, 0, sizeof(_ns8__getEnterpriseByGuidRequest), 0, soap_copy__ns8__getEnterpriseByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getEnterpriseByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getEnterpriseByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getEnterpriseByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getEnterpriseByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getEnterpriseByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest * SOAP_FMAC4 soap_get__ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getEnterpriseByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getEnterpriseByGuidRequest * FASTCALL soap_instantiate__ns8__getEnterpriseByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getEnterpriseByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getEnterpriseByGuidRequest));
		((_ns8__getEnterpriseByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getEnterpriseByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getEnterpriseByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getEnterpriseByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getEnterpriseByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getEnterpriseByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getEnterpriseByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getEnterpriseByGuidRequest*)p = *(_ns8__getEnterpriseByGuidRequest*)q;
}

void _ns8__findStreetListByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findStreetListByNameResponse::ent__streetList = NULL;
	/* transient soap skipped */
}

void _ns8__findStreetListByNameResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__StreetList(soap, &this->_ns8__findStreetListByNameResponse::ent__streetList);
	/* transient soap skipped */
}

int _ns8__findStreetListByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findStreetListByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findStreetListByNameResponse(struct soap *soap, const char *tag, int id, const _ns8__findStreetListByNameResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findStreetListByNameResponse), type))
		return soap->error;
	if(a->_ns8__findStreetListByNameResponse::ent__streetList) {
		if(soap_out_PointerToent__StreetList(soap, "ent:streetList", -1, &a->_ns8__findStreetListByNameResponse::ent__streetList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:streetList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findStreetListByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findStreetListByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameResponse * FASTCALL soap_in__ns8__findStreetListByNameResponse(struct soap *soap, const char *tag, _ns8__findStreetListByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findStreetListByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findStreetListByNameResponse, sizeof(_ns8__findStreetListByNameResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findStreetListByNameResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findStreetListByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__streetList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__streetList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__StreetList(soap, "ent:streetList", &(a->_ns8__findStreetListByNameResponse::ent__streetList), "ent:StreetList"))
				{	soap_flag_ent__streetList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findStreetListByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findStreetListByNameResponse, 0, sizeof(_ns8__findStreetListByNameResponse), 0, soap_copy__ns8__findStreetListByNameResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__streetList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findStreetListByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findStreetListByNameResponse);
	return this->soap_out(soap, tag?tag:"ns8:findStreetListByNameResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findStreetListByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findStreetListByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameResponse * SOAP_FMAC4 soap_get__ns8__findStreetListByNameResponse(struct soap *soap, _ns8__findStreetListByNameResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findStreetListByNameResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findStreetListByNameResponse * FASTCALL soap_instantiate__ns8__findStreetListByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findStreetListByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findStreetListByNameResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameResponse);
		ASSIGN_PTR(size, sizeof(_ns8__findStreetListByNameResponse));
		((_ns8__findStreetListByNameResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findStreetListByNameResponse));
		for(int i = 0; i < n; i++)
			((_ns8__findStreetListByNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findStreetListByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findStreetListByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findStreetListByNameResponse %p -> %p\n", q, p));
	*(_ns8__findStreetListByNameResponse*)p = *(_ns8__findStreetListByNameResponse*)q;
}

void _ns8__findStreetListByNameRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findStreetListByNameRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__findStreetListByNameRequest::ent__localityGuid);
	soap_default_string(soap, &this->_ns8__findStreetListByNameRequest::pattern);
	/* transient soap skipped */
}

void _ns8__findStreetListByNameRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__findStreetListByNameRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__findStreetListByNameRequest::ent__localityGuid);
	soap_serialize_string(soap, &this->_ns8__findStreetListByNameRequest::pattern);
	/* transient soap skipped */
}

int _ns8__findStreetListByNameRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findStreetListByNameRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findStreetListByNameRequest(struct soap *soap, const char *tag, int id, const _ns8__findStreetListByNameRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findStreetListByNameRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__findStreetListByNameRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__findStreetListByNameRequest::ent__localityGuid) {
		if(soap_out_base__UUID(soap, "ent:localityGuid", -1, &a->_ns8__findStreetListByNameRequest::ent__localityGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityGuid"))
		return soap->error;
	if(a->_ns8__findStreetListByNameRequest::pattern) {
		if(soap_out_string(soap, "ns8:pattern", -1, &a->_ns8__findStreetListByNameRequest::pattern, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns8:pattern"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findStreetListByNameRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findStreetListByNameRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameRequest * FASTCALL soap_in__ns8__findStreetListByNameRequest(struct soap *soap, const char *tag, _ns8__findStreetListByNameRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findStreetListByNameRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findStreetListByNameRequest, sizeof(_ns8__findStreetListByNameRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findStreetListByNameRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findStreetListByNameRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__localityGuid1 = 1;
	size_t soap_flag_pattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__findStreetListByNameRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:localityGuid", &(a->_ns8__findStreetListByNameRequest::ent__localityGuid), "base:UUID"))
				{	soap_flag_ent__localityGuid1--;
					continue;
				}
			if(soap_flag_pattern1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns8:pattern", &(a->_ns8__findStreetListByNameRequest::pattern), "xsd:string"))
				{	soap_flag_pattern1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findStreetListByNameRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findStreetListByNameRequest, 0, sizeof(_ns8__findStreetListByNameRequest), 0, soap_copy__ns8__findStreetListByNameRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityGuid1 > 0 || soap_flag_pattern1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findStreetListByNameRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findStreetListByNameRequest);
	return this->soap_out(soap, tag?tag:"ns8:findStreetListByNameRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findStreetListByNameRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findStreetListByNameRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findStreetListByNameRequest * SOAP_FMAC4 soap_get__ns8__findStreetListByNameRequest(struct soap *soap, _ns8__findStreetListByNameRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findStreetListByNameRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findStreetListByNameRequest * FASTCALL soap_instantiate__ns8__findStreetListByNameRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findStreetListByNameRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findStreetListByNameRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameRequest);
		ASSIGN_PTR(size, sizeof(_ns8__findStreetListByNameRequest));
		((_ns8__findStreetListByNameRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findStreetListByNameRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findStreetListByNameRequest));
		for(int i = 0; i < n; i++)
			((_ns8__findStreetListByNameRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findStreetListByNameRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findStreetListByNameRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findStreetListByNameRequest %p -> %p\n", q, p));
	*(_ns8__findStreetListByNameRequest*)p = *(_ns8__findStreetListByNameRequest*)q;
}

void _ns8__findLocalityListByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findLocalityListByNameResponse::ent__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__findLocalityListByNameResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__LocalityList(soap, &this->_ns8__findLocalityListByNameResponse::ent__localityList);
	/* transient soap skipped */
}

int _ns8__findLocalityListByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findLocalityListByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findLocalityListByNameResponse(struct soap *soap, const char *tag, int id, const _ns8__findLocalityListByNameResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findLocalityListByNameResponse), type))
		return soap->error;
	if(a->_ns8__findLocalityListByNameResponse::ent__localityList) {
		if(soap_out_PointerToent__LocalityList(soap, "ent:localityList", -1, &a->_ns8__findLocalityListByNameResponse::ent__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findLocalityListByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findLocalityListByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameResponse * FASTCALL soap_in__ns8__findLocalityListByNameResponse(struct soap *soap, const char *tag, _ns8__findLocalityListByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findLocalityListByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findLocalityListByNameResponse, sizeof(_ns8__findLocalityListByNameResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findLocalityListByNameResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findLocalityListByNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__LocalityList(soap, "ent:localityList", &(a->_ns8__findLocalityListByNameResponse::ent__localityList), "ent:LocalityList"))
				{	soap_flag_ent__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findLocalityListByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findLocalityListByNameResponse, 0, sizeof(_ns8__findLocalityListByNameResponse), 0, soap_copy__ns8__findLocalityListByNameResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findLocalityListByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findLocalityListByNameResponse);
	return this->soap_out(soap, tag?tag:"ns8:findLocalityListByNameResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findLocalityListByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findLocalityListByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameResponse * SOAP_FMAC4 soap_get__ns8__findLocalityListByNameResponse(struct soap *soap, _ns8__findLocalityListByNameResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findLocalityListByNameResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findLocalityListByNameResponse * FASTCALL soap_instantiate__ns8__findLocalityListByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findLocalityListByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findLocalityListByNameResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameResponse);
		ASSIGN_PTR(size, sizeof(_ns8__findLocalityListByNameResponse));
		((_ns8__findLocalityListByNameResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findLocalityListByNameResponse));
		for(int i = 0; i < n; i++)
			((_ns8__findLocalityListByNameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findLocalityListByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findLocalityListByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findLocalityListByNameResponse %p -> %p\n", q, p));
	*(_ns8__findLocalityListByNameResponse*)p = *(_ns8__findLocalityListByNameResponse*)q;
}

void _ns8__findLocalityListByNameRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__findLocalityListByNameRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__findLocalityListByNameRequest::ent__regionGuid);
	soap_default_string(soap, &this->_ns8__findLocalityListByNameRequest::pattern);
	/* transient soap skipped */
}

void _ns8__findLocalityListByNameRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__findLocalityListByNameRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__findLocalityListByNameRequest::ent__regionGuid);
	soap_serialize_string(soap, &this->_ns8__findLocalityListByNameRequest::pattern);
	/* transient soap skipped */
}

int _ns8__findLocalityListByNameRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__findLocalityListByNameRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__findLocalityListByNameRequest(struct soap *soap, const char *tag, int id, const _ns8__findLocalityListByNameRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__findLocalityListByNameRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__findLocalityListByNameRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__findLocalityListByNameRequest::ent__regionGuid) {
		if(soap_out_base__UUID(soap, "ent:regionGuid", -1, &a->_ns8__findLocalityListByNameRequest::ent__regionGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:regionGuid"))
		return soap->error;
	if(a->_ns8__findLocalityListByNameRequest::pattern) {
		if(soap_out_string(soap, "ns8:pattern", -1, &a->_ns8__findLocalityListByNameRequest::pattern, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ns8:pattern"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__findLocalityListByNameRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__findLocalityListByNameRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameRequest * FASTCALL soap_in__ns8__findLocalityListByNameRequest(struct soap *soap, const char *tag, _ns8__findLocalityListByNameRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__findLocalityListByNameRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__findLocalityListByNameRequest, sizeof(_ns8__findLocalityListByNameRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__findLocalityListByNameRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__findLocalityListByNameRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__regionGuid1 = 1;
	size_t soap_flag_pattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__findLocalityListByNameRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:regionGuid", &(a->_ns8__findLocalityListByNameRequest::ent__regionGuid), "base:UUID"))
				{	soap_flag_ent__regionGuid1--;
					continue;
				}
			if(soap_flag_pattern1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ns8:pattern", &(a->_ns8__findLocalityListByNameRequest::pattern), "xsd:string"))
				{	soap_flag_pattern1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__findLocalityListByNameRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__findLocalityListByNameRequest, 0, sizeof(_ns8__findLocalityListByNameRequest), 0, soap_copy__ns8__findLocalityListByNameRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__regionGuid1 > 0 || soap_flag_pattern1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__findLocalityListByNameRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__findLocalityListByNameRequest);
	return this->soap_out(soap, tag?tag:"ns8:findLocalityListByNameRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__findLocalityListByNameRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__findLocalityListByNameRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__findLocalityListByNameRequest * SOAP_FMAC4 soap_get__ns8__findLocalityListByNameRequest(struct soap *soap, _ns8__findLocalityListByNameRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__findLocalityListByNameRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__findLocalityListByNameRequest * FASTCALL soap_instantiate__ns8__findLocalityListByNameRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__findLocalityListByNameRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__findLocalityListByNameRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameRequest);
		ASSIGN_PTR(size, sizeof(_ns8__findLocalityListByNameRequest));
		((_ns8__findLocalityListByNameRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__findLocalityListByNameRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__findLocalityListByNameRequest));
		for(int i = 0; i < n; i++)
			((_ns8__findLocalityListByNameRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__findLocalityListByNameRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__findLocalityListByNameRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__findLocalityListByNameRequest %p -> %p\n", q, p));
	*(_ns8__findLocalityListByNameRequest*)p = *(_ns8__findLocalityListByNameRequest*)q;
}

void _ns8__getStreetListByLocalityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getStreetListByLocalityResponse::ent__streetList = NULL;
	/* transient soap skipped */
}

void _ns8__getStreetListByLocalityResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__StreetList(soap, &this->_ns8__getStreetListByLocalityResponse::ent__streetList);
	/* transient soap skipped */
}

int _ns8__getStreetListByLocalityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getStreetListByLocalityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getStreetListByLocalityResponse(struct soap *soap, const char *tag, int id, const _ns8__getStreetListByLocalityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getStreetListByLocalityResponse), type))
		return soap->error;
	if(a->_ns8__getStreetListByLocalityResponse::ent__streetList) {
		if(soap_out_PointerToent__StreetList(soap, "ent:streetList", -1, &a->_ns8__getStreetListByLocalityResponse::ent__streetList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:streetList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getStreetListByLocalityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getStreetListByLocalityResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityResponse * FASTCALL soap_in__ns8__getStreetListByLocalityResponse(struct soap *soap, const char *tag, _ns8__getStreetListByLocalityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getStreetListByLocalityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getStreetListByLocalityResponse, sizeof(_ns8__getStreetListByLocalityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getStreetListByLocalityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getStreetListByLocalityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__streetList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__streetList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__StreetList(soap, "ent:streetList", &(a->_ns8__getStreetListByLocalityResponse::ent__streetList), "ent:StreetList"))
				{	soap_flag_ent__streetList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getStreetListByLocalityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getStreetListByLocalityResponse, 0, sizeof(_ns8__getStreetListByLocalityResponse), 0, soap_copy__ns8__getStreetListByLocalityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__streetList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getStreetListByLocalityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getStreetListByLocalityResponse);
	return this->soap_out(soap, tag?tag:"ns8:getStreetListByLocalityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getStreetListByLocalityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getStreetListByLocalityResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityResponse * SOAP_FMAC4 soap_get__ns8__getStreetListByLocalityResponse(struct soap *soap, _ns8__getStreetListByLocalityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getStreetListByLocalityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getStreetListByLocalityResponse * FASTCALL soap_instantiate__ns8__getStreetListByLocalityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getStreetListByLocalityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getStreetListByLocalityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getStreetListByLocalityResponse));
		((_ns8__getStreetListByLocalityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getStreetListByLocalityResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getStreetListByLocalityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getStreetListByLocalityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getStreetListByLocalityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getStreetListByLocalityResponse %p -> %p\n", q, p));
	*(_ns8__getStreetListByLocalityResponse*)p = *(_ns8__getStreetListByLocalityResponse*)q;
}

void _ns8__getStreetListByLocalityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getStreetListByLocalityRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getStreetListByLocalityRequest::ent__localityGuid);
	/* transient soap skipped */
}

void _ns8__getStreetListByLocalityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getStreetListByLocalityRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getStreetListByLocalityRequest::ent__localityGuid);
	/* transient soap skipped */
}

int _ns8__getStreetListByLocalityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getStreetListByLocalityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getStreetListByLocalityRequest(struct soap *soap, const char *tag, int id, const _ns8__getStreetListByLocalityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getStreetListByLocalityRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getStreetListByLocalityRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getStreetListByLocalityRequest::ent__localityGuid) {
		if(soap_out_base__UUID(soap, "ent:localityGuid", -1, &a->_ns8__getStreetListByLocalityRequest::ent__localityGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getStreetListByLocalityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getStreetListByLocalityRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityRequest * FASTCALL soap_in__ns8__getStreetListByLocalityRequest(struct soap *soap, const char *tag, _ns8__getStreetListByLocalityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getStreetListByLocalityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getStreetListByLocalityRequest, sizeof(_ns8__getStreetListByLocalityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getStreetListByLocalityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getStreetListByLocalityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getStreetListByLocalityRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:localityGuid", &(a->_ns8__getStreetListByLocalityRequest::ent__localityGuid), "base:UUID"))
				{	soap_flag_ent__localityGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getStreetListByLocalityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getStreetListByLocalityRequest, 0, sizeof(_ns8__getStreetListByLocalityRequest), 0, soap_copy__ns8__getStreetListByLocalityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getStreetListByLocalityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getStreetListByLocalityRequest);
	return this->soap_out(soap, tag?tag:"ns8:getStreetListByLocalityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getStreetListByLocalityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getStreetListByLocalityRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getStreetListByLocalityRequest * SOAP_FMAC4 soap_get__ns8__getStreetListByLocalityRequest(struct soap *soap, _ns8__getStreetListByLocalityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getStreetListByLocalityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getStreetListByLocalityRequest * FASTCALL soap_instantiate__ns8__getStreetListByLocalityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getStreetListByLocalityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getStreetListByLocalityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getStreetListByLocalityRequest));
		((_ns8__getStreetListByLocalityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getStreetListByLocalityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getStreetListByLocalityRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getStreetListByLocalityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getStreetListByLocalityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getStreetListByLocalityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getStreetListByLocalityRequest %p -> %p\n", q, p));
	*(_ns8__getStreetListByLocalityRequest*)p = *(_ns8__getStreetListByLocalityRequest*)q;
}

void _ns8__getLocalityListByLocalityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByLocalityResponse::ent__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__getLocalityListByLocalityResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__LocalityList(soap, &this->_ns8__getLocalityListByLocalityResponse::ent__localityList);
	/* transient soap skipped */
}

int _ns8__getLocalityListByLocalityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByLocalityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByLocalityResponse(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByLocalityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByLocalityResponse), type))
		return soap->error;
	if(a->_ns8__getLocalityListByLocalityResponse::ent__localityList) {
		if(soap_out_PointerToent__LocalityList(soap, "ent:localityList", -1, &a->_ns8__getLocalityListByLocalityResponse::ent__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByLocalityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByLocalityResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityResponse * FASTCALL soap_in__ns8__getLocalityListByLocalityResponse(struct soap *soap, const char *tag, _ns8__getLocalityListByLocalityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByLocalityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByLocalityResponse, sizeof(_ns8__getLocalityListByLocalityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByLocalityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByLocalityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__LocalityList(soap, "ent:localityList", &(a->_ns8__getLocalityListByLocalityResponse::ent__localityList), "ent:LocalityList"))
				{	soap_flag_ent__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByLocalityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByLocalityResponse, 0, sizeof(_ns8__getLocalityListByLocalityResponse), 0, soap_copy__ns8__getLocalityListByLocalityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByLocalityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByLocalityResponse);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByLocalityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByLocalityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByLocalityResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityResponse * SOAP_FMAC4 soap_get__ns8__getLocalityListByLocalityResponse(struct soap *soap, _ns8__getLocalityListByLocalityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByLocalityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByLocalityResponse * FASTCALL soap_instantiate__ns8__getLocalityListByLocalityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByLocalityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByLocalityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByLocalityResponse));
		((_ns8__getLocalityListByLocalityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByLocalityResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByLocalityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByLocalityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByLocalityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByLocalityResponse %p -> %p\n", q, p));
	*(_ns8__getLocalityListByLocalityResponse*)p = *(_ns8__getLocalityListByLocalityResponse*)q;
}

void _ns8__getLocalityListByLocalityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByLocalityRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getLocalityListByLocalityRequest::ent__localityGuid);
	/* transient soap skipped */
}

void _ns8__getLocalityListByLocalityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getLocalityListByLocalityRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getLocalityListByLocalityRequest::ent__localityGuid);
	/* transient soap skipped */
}

int _ns8__getLocalityListByLocalityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByLocalityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByLocalityRequest(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByLocalityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByLocalityRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getLocalityListByLocalityRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getLocalityListByLocalityRequest::ent__localityGuid) {
		if(soap_out_base__UUID(soap, "ent:localityGuid", -1, &a->_ns8__getLocalityListByLocalityRequest::ent__localityGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByLocalityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByLocalityRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityRequest * FASTCALL soap_in__ns8__getLocalityListByLocalityRequest(struct soap *soap, const char *tag, _ns8__getLocalityListByLocalityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByLocalityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByLocalityRequest, sizeof(_ns8__getLocalityListByLocalityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByLocalityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByLocalityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getLocalityListByLocalityRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:localityGuid", &(a->_ns8__getLocalityListByLocalityRequest::ent__localityGuid), "base:UUID"))
				{	soap_flag_ent__localityGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByLocalityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByLocalityRequest, 0, sizeof(_ns8__getLocalityListByLocalityRequest), 0, soap_copy__ns8__getLocalityListByLocalityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByLocalityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByLocalityRequest);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByLocalityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByLocalityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByLocalityRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByLocalityRequest * SOAP_FMAC4 soap_get__ns8__getLocalityListByLocalityRequest(struct soap *soap, _ns8__getLocalityListByLocalityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByLocalityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByLocalityRequest * FASTCALL soap_instantiate__ns8__getLocalityListByLocalityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByLocalityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByLocalityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByLocalityRequest));
		((_ns8__getLocalityListByLocalityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByLocalityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByLocalityRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByLocalityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByLocalityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByLocalityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByLocalityRequest %p -> %p\n", q, p));
	*(_ns8__getLocalityListByLocalityRequest*)p = *(_ns8__getLocalityListByLocalityRequest*)q;
}

void _ns8__getLocalityListByDistrictResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByDistrictResponse::ent__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__getLocalityListByDistrictResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__LocalityList(soap, &this->_ns8__getLocalityListByDistrictResponse::ent__localityList);
	/* transient soap skipped */
}

int _ns8__getLocalityListByDistrictResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByDistrictResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByDistrictResponse(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByDistrictResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByDistrictResponse), type))
		return soap->error;
	if(a->_ns8__getLocalityListByDistrictResponse::ent__localityList) {
		if(soap_out_PointerToent__LocalityList(soap, "ent:localityList", -1, &a->_ns8__getLocalityListByDistrictResponse::ent__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByDistrictResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByDistrictResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictResponse * FASTCALL soap_in__ns8__getLocalityListByDistrictResponse(struct soap *soap, const char *tag, _ns8__getLocalityListByDistrictResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByDistrictResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByDistrictResponse, sizeof(_ns8__getLocalityListByDistrictResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByDistrictResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByDistrictResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__LocalityList(soap, "ent:localityList", &(a->_ns8__getLocalityListByDistrictResponse::ent__localityList), "ent:LocalityList"))
				{	soap_flag_ent__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByDistrictResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByDistrictResponse, 0, sizeof(_ns8__getLocalityListByDistrictResponse), 0, soap_copy__ns8__getLocalityListByDistrictResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByDistrictResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByDistrictResponse);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByDistrictResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByDistrictResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByDistrictResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictResponse * SOAP_FMAC4 soap_get__ns8__getLocalityListByDistrictResponse(struct soap *soap, _ns8__getLocalityListByDistrictResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByDistrictResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByDistrictResponse * FASTCALL soap_instantiate__ns8__getLocalityListByDistrictResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByDistrictResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByDistrictResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByDistrictResponse));
		((_ns8__getLocalityListByDistrictResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByDistrictResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByDistrictResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByDistrictResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByDistrictResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByDistrictResponse %p -> %p\n", q, p));
	*(_ns8__getLocalityListByDistrictResponse*)p = *(_ns8__getLocalityListByDistrictResponse*)q;
}

void _ns8__getLocalityListByDistrictRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByDistrictRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getLocalityListByDistrictRequest::ent__districtGuid);
	/* transient soap skipped */
}

void _ns8__getLocalityListByDistrictRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getLocalityListByDistrictRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getLocalityListByDistrictRequest::ent__districtGuid);
	/* transient soap skipped */
}

int _ns8__getLocalityListByDistrictRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByDistrictRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByDistrictRequest(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByDistrictRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByDistrictRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getLocalityListByDistrictRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getLocalityListByDistrictRequest::ent__districtGuid) {
		if(soap_out_base__UUID(soap, "ent:districtGuid", -1, &a->_ns8__getLocalityListByDistrictRequest::ent__districtGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:districtGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByDistrictRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByDistrictRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictRequest * FASTCALL soap_in__ns8__getLocalityListByDistrictRequest(struct soap *soap, const char *tag, _ns8__getLocalityListByDistrictRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByDistrictRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByDistrictRequest, sizeof(_ns8__getLocalityListByDistrictRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByDistrictRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByDistrictRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__districtGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getLocalityListByDistrictRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__districtGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:districtGuid", &(a->_ns8__getLocalityListByDistrictRequest::ent__districtGuid), "base:UUID"))
				{	soap_flag_ent__districtGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByDistrictRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByDistrictRequest, 0, sizeof(_ns8__getLocalityListByDistrictRequest), 0, soap_copy__ns8__getLocalityListByDistrictRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__districtGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByDistrictRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByDistrictRequest);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByDistrictRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByDistrictRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByDistrictRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByDistrictRequest * SOAP_FMAC4 soap_get__ns8__getLocalityListByDistrictRequest(struct soap *soap, _ns8__getLocalityListByDistrictRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByDistrictRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByDistrictRequest * FASTCALL soap_instantiate__ns8__getLocalityListByDistrictRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByDistrictRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByDistrictRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByDistrictRequest));
		((_ns8__getLocalityListByDistrictRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByDistrictRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByDistrictRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByDistrictRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByDistrictRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByDistrictRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByDistrictRequest %p -> %p\n", q, p));
	*(_ns8__getLocalityListByDistrictRequest*)p = *(_ns8__getLocalityListByDistrictRequest*)q;
}

void _ns8__getLocalityListByRegionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByRegionResponse::ent__localityList = NULL;
	/* transient soap skipped */
}

void _ns8__getLocalityListByRegionResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__LocalityList(soap, &this->_ns8__getLocalityListByRegionResponse::ent__localityList);
	/* transient soap skipped */
}

int _ns8__getLocalityListByRegionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByRegionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByRegionResponse(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByRegionResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByRegionResponse), type))
		return soap->error;
	if(a->_ns8__getLocalityListByRegionResponse::ent__localityList) {
		if(soap_out_PointerToent__LocalityList(soap, "ent:localityList", -1, &a->_ns8__getLocalityListByRegionResponse::ent__localityList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:localityList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByRegionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByRegionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionResponse * FASTCALL soap_in__ns8__getLocalityListByRegionResponse(struct soap *soap, const char *tag, _ns8__getLocalityListByRegionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByRegionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByRegionResponse, sizeof(_ns8__getLocalityListByRegionResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByRegionResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByRegionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__localityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__localityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__LocalityList(soap, "ent:localityList", &(a->_ns8__getLocalityListByRegionResponse::ent__localityList), "ent:LocalityList"))
				{	soap_flag_ent__localityList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByRegionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByRegionResponse, 0, sizeof(_ns8__getLocalityListByRegionResponse), 0, soap_copy__ns8__getLocalityListByRegionResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__localityList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByRegionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByRegionResponse);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByRegionResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByRegionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByRegionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionResponse * SOAP_FMAC4 soap_get__ns8__getLocalityListByRegionResponse(struct soap *soap, _ns8__getLocalityListByRegionResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByRegionResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByRegionResponse * FASTCALL soap_instantiate__ns8__getLocalityListByRegionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByRegionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByRegionResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByRegionResponse));
		((_ns8__getLocalityListByRegionResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByRegionResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByRegionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByRegionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByRegionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByRegionResponse %p -> %p\n", q, p));
	*(_ns8__getLocalityListByRegionResponse*)p = *(_ns8__getLocalityListByRegionResponse*)q;
}

void _ns8__getLocalityListByRegionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getLocalityListByRegionRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getLocalityListByRegionRequest::ent__regionGuid);
	/* transient soap skipped */
}

void _ns8__getLocalityListByRegionRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getLocalityListByRegionRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getLocalityListByRegionRequest::ent__regionGuid);
	/* transient soap skipped */
}

int _ns8__getLocalityListByRegionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getLocalityListByRegionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getLocalityListByRegionRequest(struct soap *soap, const char *tag, int id, const _ns8__getLocalityListByRegionRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getLocalityListByRegionRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getLocalityListByRegionRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getLocalityListByRegionRequest::ent__regionGuid) {
		if(soap_out_base__UUID(soap, "ent:regionGuid", -1, &a->_ns8__getLocalityListByRegionRequest::ent__regionGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:regionGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getLocalityListByRegionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getLocalityListByRegionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionRequest * FASTCALL soap_in__ns8__getLocalityListByRegionRequest(struct soap *soap, const char *tag, _ns8__getLocalityListByRegionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getLocalityListByRegionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getLocalityListByRegionRequest, sizeof(_ns8__getLocalityListByRegionRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getLocalityListByRegionRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getLocalityListByRegionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getLocalityListByRegionRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:regionGuid", &(a->_ns8__getLocalityListByRegionRequest::ent__regionGuid), "base:UUID"))
				{	soap_flag_ent__regionGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getLocalityListByRegionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getLocalityListByRegionRequest, 0, sizeof(_ns8__getLocalityListByRegionRequest), 0, soap_copy__ns8__getLocalityListByRegionRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__regionGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getLocalityListByRegionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getLocalityListByRegionRequest);
	return this->soap_out(soap, tag?tag:"ns8:getLocalityListByRegionRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getLocalityListByRegionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getLocalityListByRegionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getLocalityListByRegionRequest * SOAP_FMAC4 soap_get__ns8__getLocalityListByRegionRequest(struct soap *soap, _ns8__getLocalityListByRegionRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getLocalityListByRegionRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getLocalityListByRegionRequest * FASTCALL soap_instantiate__ns8__getLocalityListByRegionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getLocalityListByRegionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getLocalityListByRegionRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getLocalityListByRegionRequest));
		((_ns8__getLocalityListByRegionRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getLocalityListByRegionRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getLocalityListByRegionRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getLocalityListByRegionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getLocalityListByRegionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getLocalityListByRegionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getLocalityListByRegionRequest %p -> %p\n", q, p));
	*(_ns8__getLocalityListByRegionRequest*)p = *(_ns8__getLocalityListByRegionRequest*)q;
}

void _ns8__getDistrictChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictChangesListResponse::ent__districtList = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__DistrictList(soap, &this->_ns8__getDistrictChangesListResponse::ent__districtList);
	/* transient soap skipped */
}

int _ns8__getDistrictChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictChangesListResponse::ent__districtList) {
		if(soap_out_PointerToent__DistrictList(soap, "ent:districtList", -1, &a->_ns8__getDistrictChangesListResponse::ent__districtList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:districtList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListResponse * FASTCALL soap_in__ns8__getDistrictChangesListResponse(struct soap *soap, const char *tag, _ns8__getDistrictChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictChangesListResponse, sizeof(_ns8__getDistrictChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__districtList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__districtList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DistrictList(soap, "ent:districtList", &(a->_ns8__getDistrictChangesListResponse::ent__districtList), "ent:DistrictList"))
				{	soap_flag_ent__districtList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictChangesListResponse, 0, sizeof(_ns8__getDistrictChangesListResponse), 0, soap_copy__ns8__getDistrictChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__districtList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListResponse * SOAP_FMAC4 soap_get__ns8__getDistrictChangesListResponse(struct soap *soap, _ns8__getDistrictChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictChangesListResponse * FASTCALL soap_instantiate__ns8__getDistrictChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictChangesListResponse));
		((_ns8__getDistrictChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictChangesListResponse*)p = *(_ns8__getDistrictChangesListResponse*)q;
}

void _ns8__getDistrictChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictChangesListRequest::base__listOptions = NULL;
	this->_ns8__getDistrictChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getDistrictChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getDistrictChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getDistrictChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getDistrictChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getDistrictChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getDistrictChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListRequest * FASTCALL soap_in__ns8__getDistrictChangesListRequest(struct soap *soap, const char *tag, _ns8__getDistrictChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictChangesListRequest, sizeof(_ns8__getDistrictChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getDistrictChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getDistrictChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictChangesListRequest, 0, sizeof(_ns8__getDistrictChangesListRequest), 0, soap_copy__ns8__getDistrictChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictChangesListRequest * SOAP_FMAC4 soap_get__ns8__getDistrictChangesListRequest(struct soap *soap, _ns8__getDistrictChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictChangesListRequest * FASTCALL soap_instantiate__ns8__getDistrictChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictChangesListRequest));
		((_ns8__getDistrictChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictChangesListRequest*)p = *(_ns8__getDistrictChangesListRequest*)q;
}

void _ns8__getDistrictByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictByUuidResponse::ent__district = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__District(soap, &this->_ns8__getDistrictByUuidResponse::ent__district);
	/* transient soap skipped */
}

int _ns8__getDistrictByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictByUuidResponse::ent__district) {
		if(soap_out_PointerToent__District(soap, "ent:district", -1, &a->_ns8__getDistrictByUuidResponse::ent__district, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:district"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidResponse * FASTCALL soap_in__ns8__getDistrictByUuidResponse(struct soap *soap, const char *tag, _ns8__getDistrictByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByUuidResponse, sizeof(_ns8__getDistrictByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__district1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__District(soap, "ent:district", &(a->_ns8__getDistrictByUuidResponse::ent__district), "ent:District"))
				{	soap_flag_ent__district1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByUuidResponse, 0, sizeof(_ns8__getDistrictByUuidResponse), 0, soap_copy__ns8__getDistrictByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__district1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidResponse * SOAP_FMAC4 soap_get__ns8__getDistrictByUuidResponse(struct soap *soap, _ns8__getDistrictByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByUuidResponse * FASTCALL soap_instantiate__ns8__getDistrictByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByUuidResponse));
		((_ns8__getDistrictByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictByUuidResponse*)p = *(_ns8__getDistrictByUuidResponse*)q;
}

void _ns8__getDistrictByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getDistrictByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getDistrictByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getDistrictByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getDistrictByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getDistrictByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getDistrictByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidRequest * FASTCALL soap_in__ns8__getDistrictByUuidRequest(struct soap *soap, const char *tag, _ns8__getDistrictByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByUuidRequest, sizeof(_ns8__getDistrictByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getDistrictByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByUuidRequest, 0, sizeof(_ns8__getDistrictByUuidRequest), 0, soap_copy__ns8__getDistrictByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByUuidRequest * SOAP_FMAC4 soap_get__ns8__getDistrictByUuidRequest(struct soap *soap, _ns8__getDistrictByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByUuidRequest * FASTCALL soap_instantiate__ns8__getDistrictByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByUuidRequest));
		((_ns8__getDistrictByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictByUuidRequest*)p = *(_ns8__getDistrictByUuidRequest*)q;
}

void _ns8__getDistrictByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictByGuidResponse::ent__district = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__District(soap, &this->_ns8__getDistrictByGuidResponse::ent__district);
	/* transient soap skipped */
}

int _ns8__getDistrictByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictByGuidResponse::ent__district) {
		if(soap_out_PointerToent__District(soap, "ent:district", -1, &a->_ns8__getDistrictByGuidResponse::ent__district, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:district"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidResponse * FASTCALL soap_in__ns8__getDistrictByGuidResponse(struct soap *soap, const char *tag, _ns8__getDistrictByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByGuidResponse, sizeof(_ns8__getDistrictByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__district1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__District(soap, "ent:district", &(a->_ns8__getDistrictByGuidResponse::ent__district), "ent:District"))
				{	soap_flag_ent__district1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByGuidResponse, 0, sizeof(_ns8__getDistrictByGuidResponse), 0, soap_copy__ns8__getDistrictByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__district1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidResponse * SOAP_FMAC4 soap_get__ns8__getDistrictByGuidResponse(struct soap *soap, _ns8__getDistrictByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByGuidResponse * FASTCALL soap_instantiate__ns8__getDistrictByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByGuidResponse));
		((_ns8__getDistrictByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictByGuidResponse*)p = *(_ns8__getDistrictByGuidResponse*)q;
}

void _ns8__getDistrictByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getDistrictByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getDistrictByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getDistrictByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getDistrictByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getDistrictByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getDistrictByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidRequest * FASTCALL soap_in__ns8__getDistrictByGuidRequest(struct soap *soap, const char *tag, _ns8__getDistrictByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictByGuidRequest, sizeof(_ns8__getDistrictByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getDistrictByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictByGuidRequest, 0, sizeof(_ns8__getDistrictByGuidRequest), 0, soap_copy__ns8__getDistrictByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictByGuidRequest * SOAP_FMAC4 soap_get__ns8__getDistrictByGuidRequest(struct soap *soap, _ns8__getDistrictByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictByGuidRequest * FASTCALL soap_instantiate__ns8__getDistrictByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictByGuidRequest));
		((_ns8__getDistrictByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictByGuidRequest*)p = *(_ns8__getDistrictByGuidRequest*)q;
}

void _ns8__getDistrictListByRegionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictListByRegionResponse::ent__districtList = NULL;
	/* transient soap skipped */
}

void _ns8__getDistrictListByRegionResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__DistrictList(soap, &this->_ns8__getDistrictListByRegionResponse::ent__districtList);
	/* transient soap skipped */
}

int _ns8__getDistrictListByRegionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictListByRegionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictListByRegionResponse(struct soap *soap, const char *tag, int id, const _ns8__getDistrictListByRegionResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictListByRegionResponse), type))
		return soap->error;
	if(a->_ns8__getDistrictListByRegionResponse::ent__districtList) {
		if(soap_out_PointerToent__DistrictList(soap, "ent:districtList", -1, &a->_ns8__getDistrictListByRegionResponse::ent__districtList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:districtList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictListByRegionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictListByRegionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionResponse * FASTCALL soap_in__ns8__getDistrictListByRegionResponse(struct soap *soap, const char *tag, _ns8__getDistrictListByRegionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictListByRegionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictListByRegionResponse, sizeof(_ns8__getDistrictListByRegionResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictListByRegionResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictListByRegionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__districtList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__districtList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DistrictList(soap, "ent:districtList", &(a->_ns8__getDistrictListByRegionResponse::ent__districtList), "ent:DistrictList"))
				{	soap_flag_ent__districtList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictListByRegionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictListByRegionResponse, 0, sizeof(_ns8__getDistrictListByRegionResponse), 0, soap_copy__ns8__getDistrictListByRegionResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__districtList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictListByRegionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictListByRegionResponse);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictListByRegionResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictListByRegionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictListByRegionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionResponse * SOAP_FMAC4 soap_get__ns8__getDistrictListByRegionResponse(struct soap *soap, _ns8__getDistrictListByRegionResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictListByRegionResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictListByRegionResponse * FASTCALL soap_instantiate__ns8__getDistrictListByRegionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictListByRegionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictListByRegionResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictListByRegionResponse));
		((_ns8__getDistrictListByRegionResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictListByRegionResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictListByRegionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictListByRegionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictListByRegionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictListByRegionResponse %p -> %p\n", q, p));
	*(_ns8__getDistrictListByRegionResponse*)p = *(_ns8__getDistrictListByRegionResponse*)q;
}

void _ns8__getDistrictListByRegionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getDistrictListByRegionRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getDistrictListByRegionRequest::ent__regionGuid);
	/* transient soap skipped */
}

void _ns8__getDistrictListByRegionRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getDistrictListByRegionRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getDistrictListByRegionRequest::ent__regionGuid);
	/* transient soap skipped */
}

int _ns8__getDistrictListByRegionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getDistrictListByRegionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getDistrictListByRegionRequest(struct soap *soap, const char *tag, int id, const _ns8__getDistrictListByRegionRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getDistrictListByRegionRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getDistrictListByRegionRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getDistrictListByRegionRequest::ent__regionGuid) {
		if(soap_out_base__UUID(soap, "ent:regionGuid", -1, &a->_ns8__getDistrictListByRegionRequest::ent__regionGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:regionGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getDistrictListByRegionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getDistrictListByRegionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionRequest * FASTCALL soap_in__ns8__getDistrictListByRegionRequest(struct soap *soap, const char *tag, _ns8__getDistrictListByRegionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getDistrictListByRegionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getDistrictListByRegionRequest, sizeof(_ns8__getDistrictListByRegionRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getDistrictListByRegionRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getDistrictListByRegionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getDistrictListByRegionRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:regionGuid", &(a->_ns8__getDistrictListByRegionRequest::ent__regionGuid), "base:UUID"))
				{	soap_flag_ent__regionGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getDistrictListByRegionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getDistrictListByRegionRequest, 0, sizeof(_ns8__getDistrictListByRegionRequest), 0, soap_copy__ns8__getDistrictListByRegionRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__regionGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getDistrictListByRegionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getDistrictListByRegionRequest);
	return this->soap_out(soap, tag?tag:"ns8:getDistrictListByRegionRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getDistrictListByRegionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getDistrictListByRegionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getDistrictListByRegionRequest * SOAP_FMAC4 soap_get__ns8__getDistrictListByRegionRequest(struct soap *soap, _ns8__getDistrictListByRegionRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getDistrictListByRegionRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getDistrictListByRegionRequest * FASTCALL soap_instantiate__ns8__getDistrictListByRegionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getDistrictListByRegionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getDistrictListByRegionRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getDistrictListByRegionRequest));
		((_ns8__getDistrictListByRegionRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getDistrictListByRegionRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getDistrictListByRegionRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getDistrictListByRegionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getDistrictListByRegionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getDistrictListByRegionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getDistrictListByRegionRequest %p -> %p\n", q, p));
	*(_ns8__getDistrictListByRegionRequest*)p = *(_ns8__getDistrictListByRegionRequest*)q;
}

void _ns8__getRegionChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionChangesListResponse::ent__regionList = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__RegionList(soap, &this->_ns8__getRegionChangesListResponse::ent__regionList);
	/* transient soap skipped */
}

int _ns8__getRegionChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getRegionChangesListResponse::ent__regionList) {
		if(soap_out_PointerToent__RegionList(soap, "ent:regionList", -1, &a->_ns8__getRegionChangesListResponse::ent__regionList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:regionList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListResponse * FASTCALL soap_in__ns8__getRegionChangesListResponse(struct soap *soap, const char *tag, _ns8__getRegionChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionChangesListResponse, sizeof(_ns8__getRegionChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__regionList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__regionList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionList(soap, "ent:regionList", &(a->_ns8__getRegionChangesListResponse::ent__regionList), "ent:RegionList"))
				{	soap_flag_ent__regionList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionChangesListResponse, 0, sizeof(_ns8__getRegionChangesListResponse), 0, soap_copy__ns8__getRegionChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__regionList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListResponse * SOAP_FMAC4 soap_get__ns8__getRegionChangesListResponse(struct soap *soap, _ns8__getRegionChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionChangesListResponse * FASTCALL soap_instantiate__ns8__getRegionChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionChangesListResponse));
		((_ns8__getRegionChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getRegionChangesListResponse*)p = *(_ns8__getRegionChangesListResponse*)q;
}

void _ns8__getRegionChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionChangesListRequest::base__listOptions = NULL;
	this->_ns8__getRegionChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getRegionChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getRegionChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getRegionChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getRegionChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getRegionChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getRegionChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListRequest * FASTCALL soap_in__ns8__getRegionChangesListRequest(struct soap *soap, const char *tag, _ns8__getRegionChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionChangesListRequest, sizeof(_ns8__getRegionChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getRegionChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getRegionChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionChangesListRequest, 0, sizeof(_ns8__getRegionChangesListRequest), 0, soap_copy__ns8__getRegionChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionChangesListRequest * SOAP_FMAC4 soap_get__ns8__getRegionChangesListRequest(struct soap *soap, _ns8__getRegionChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionChangesListRequest * FASTCALL soap_instantiate__ns8__getRegionChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionChangesListRequest));
		((_ns8__getRegionChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getRegionChangesListRequest*)p = *(_ns8__getRegionChangesListRequest*)q;
}

void _ns8__getRegionByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionByUuidResponse::ent__region = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Region(soap, &this->_ns8__getRegionByUuidResponse::ent__region);
	/* transient soap skipped */
}

int _ns8__getRegionByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getRegionByUuidResponse::ent__region) {
		if(soap_out_PointerToent__Region(soap, "ent:region", -1, &a->_ns8__getRegionByUuidResponse::ent__region, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:region"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidResponse * FASTCALL soap_in__ns8__getRegionByUuidResponse(struct soap *soap, const char *tag, _ns8__getRegionByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByUuidResponse, sizeof(_ns8__getRegionByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__region1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Region(soap, "ent:region", &(a->_ns8__getRegionByUuidResponse::ent__region), "ent:Region"))
				{	soap_flag_ent__region1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByUuidResponse, 0, sizeof(_ns8__getRegionByUuidResponse), 0, soap_copy__ns8__getRegionByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__region1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidResponse * SOAP_FMAC4 soap_get__ns8__getRegionByUuidResponse(struct soap *soap, _ns8__getRegionByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByUuidResponse * FASTCALL soap_instantiate__ns8__getRegionByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByUuidResponse));
		((_ns8__getRegionByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getRegionByUuidResponse*)p = *(_ns8__getRegionByUuidResponse*)q;
}

void _ns8__getRegionByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getRegionByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getRegionByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getRegionByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getRegionByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getRegionByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getRegionByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidRequest * FASTCALL soap_in__ns8__getRegionByUuidRequest(struct soap *soap, const char *tag, _ns8__getRegionByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByUuidRequest, sizeof(_ns8__getRegionByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getRegionByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByUuidRequest, 0, sizeof(_ns8__getRegionByUuidRequest), 0, soap_copy__ns8__getRegionByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByUuidRequest * SOAP_FMAC4 soap_get__ns8__getRegionByUuidRequest(struct soap *soap, _ns8__getRegionByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByUuidRequest * FASTCALL soap_instantiate__ns8__getRegionByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByUuidRequest));
		((_ns8__getRegionByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getRegionByUuidRequest*)p = *(_ns8__getRegionByUuidRequest*)q;
}

void _ns8__getRegionByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionByGuidResponse::ent__region = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Region(soap, &this->_ns8__getRegionByGuidResponse::ent__region);
	/* transient soap skipped */
}

int _ns8__getRegionByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getRegionByGuidResponse::ent__region) {
		if(soap_out_PointerToent__Region(soap, "ent:region", -1, &a->_ns8__getRegionByGuidResponse::ent__region, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:region"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidResponse * FASTCALL soap_in__ns8__getRegionByGuidResponse(struct soap *soap, const char *tag, _ns8__getRegionByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByGuidResponse, sizeof(_ns8__getRegionByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__region1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Region(soap, "ent:region", &(a->_ns8__getRegionByGuidResponse::ent__region), "ent:Region"))
				{	soap_flag_ent__region1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByGuidResponse, 0, sizeof(_ns8__getRegionByGuidResponse), 0, soap_copy__ns8__getRegionByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__region1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidResponse * SOAP_FMAC4 soap_get__ns8__getRegionByGuidResponse(struct soap *soap, _ns8__getRegionByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByGuidResponse * FASTCALL soap_instantiate__ns8__getRegionByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByGuidResponse));
		((_ns8__getRegionByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getRegionByGuidResponse*)p = *(_ns8__getRegionByGuidResponse*)q;
}

void _ns8__getRegionByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getRegionByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getRegionByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getRegionByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getRegionByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getRegionByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getRegionByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidRequest * FASTCALL soap_in__ns8__getRegionByGuidRequest(struct soap *soap, const char *tag, _ns8__getRegionByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionByGuidRequest, sizeof(_ns8__getRegionByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getRegionByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionByGuidRequest, 0, sizeof(_ns8__getRegionByGuidRequest), 0, soap_copy__ns8__getRegionByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionByGuidRequest * SOAP_FMAC4 soap_get__ns8__getRegionByGuidRequest(struct soap *soap, _ns8__getRegionByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionByGuidRequest * FASTCALL soap_instantiate__ns8__getRegionByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionByGuidRequest));
		((_ns8__getRegionByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getRegionByGuidRequest*)p = *(_ns8__getRegionByGuidRequest*)q;
}

void _ns8__getRegionListByCountryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionListByCountryResponse::ent__regionList = NULL;
	/* transient soap skipped */
}

void _ns8__getRegionListByCountryResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__RegionList(soap, &this->_ns8__getRegionListByCountryResponse::ent__regionList);
	/* transient soap skipped */
}

int _ns8__getRegionListByCountryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionListByCountryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionListByCountryResponse(struct soap *soap, const char *tag, int id, const _ns8__getRegionListByCountryResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionListByCountryResponse), type))
		return soap->error;
	if(a->_ns8__getRegionListByCountryResponse::ent__regionList) {
		if(soap_out_PointerToent__RegionList(soap, "ent:regionList", -1, &a->_ns8__getRegionListByCountryResponse::ent__regionList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:regionList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionListByCountryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionListByCountryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryResponse * FASTCALL soap_in__ns8__getRegionListByCountryResponse(struct soap *soap, const char *tag, _ns8__getRegionListByCountryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionListByCountryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionListByCountryResponse, sizeof(_ns8__getRegionListByCountryResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionListByCountryResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionListByCountryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__regionList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__regionList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionList(soap, "ent:regionList", &(a->_ns8__getRegionListByCountryResponse::ent__regionList), "ent:RegionList"))
				{	soap_flag_ent__regionList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionListByCountryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionListByCountryResponse, 0, sizeof(_ns8__getRegionListByCountryResponse), 0, soap_copy__ns8__getRegionListByCountryResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__regionList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionListByCountryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionListByCountryResponse);
	return this->soap_out(soap, tag?tag:"ns8:getRegionListByCountryResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionListByCountryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionListByCountryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryResponse * SOAP_FMAC4 soap_get__ns8__getRegionListByCountryResponse(struct soap *soap, _ns8__getRegionListByCountryResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionListByCountryResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionListByCountryResponse * FASTCALL soap_instantiate__ns8__getRegionListByCountryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionListByCountryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionListByCountryResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionListByCountryResponse));
		((_ns8__getRegionListByCountryResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionListByCountryResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionListByCountryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionListByCountryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionListByCountryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionListByCountryResponse %p -> %p\n", q, p));
	*(_ns8__getRegionListByCountryResponse*)p = *(_ns8__getRegionListByCountryResponse*)q;
}

void _ns8__getRegionListByCountryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getRegionListByCountryRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getRegionListByCountryRequest::ent__countryGuid);
	/* transient soap skipped */
}

void _ns8__getRegionListByCountryRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getRegionListByCountryRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getRegionListByCountryRequest::ent__countryGuid);
	/* transient soap skipped */
}

int _ns8__getRegionListByCountryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getRegionListByCountryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getRegionListByCountryRequest(struct soap *soap, const char *tag, int id, const _ns8__getRegionListByCountryRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getRegionListByCountryRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getRegionListByCountryRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getRegionListByCountryRequest::ent__countryGuid) {
		if(soap_out_base__UUID(soap, "ent:countryGuid", -1, &a->_ns8__getRegionListByCountryRequest::ent__countryGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:countryGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getRegionListByCountryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getRegionListByCountryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryRequest * FASTCALL soap_in__ns8__getRegionListByCountryRequest(struct soap *soap, const char *tag, _ns8__getRegionListByCountryRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getRegionListByCountryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getRegionListByCountryRequest, sizeof(_ns8__getRegionListByCountryRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getRegionListByCountryRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getRegionListByCountryRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__countryGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getRegionListByCountryRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__countryGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:countryGuid", &(a->_ns8__getRegionListByCountryRequest::ent__countryGuid), "base:UUID"))
				{	soap_flag_ent__countryGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getRegionListByCountryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getRegionListByCountryRequest, 0, sizeof(_ns8__getRegionListByCountryRequest), 0, soap_copy__ns8__getRegionListByCountryRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__countryGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getRegionListByCountryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getRegionListByCountryRequest);
	return this->soap_out(soap, tag?tag:"ns8:getRegionListByCountryRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getRegionListByCountryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getRegionListByCountryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getRegionListByCountryRequest * SOAP_FMAC4 soap_get__ns8__getRegionListByCountryRequest(struct soap *soap, _ns8__getRegionListByCountryRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getRegionListByCountryRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getRegionListByCountryRequest * FASTCALL soap_instantiate__ns8__getRegionListByCountryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getRegionListByCountryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getRegionListByCountryRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getRegionListByCountryRequest));
		((_ns8__getRegionListByCountryRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getRegionListByCountryRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getRegionListByCountryRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getRegionListByCountryRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getRegionListByCountryRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getRegionListByCountryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getRegionListByCountryRequest %p -> %p\n", q, p));
	*(_ns8__getRegionListByCountryRequest*)p = *(_ns8__getRegionListByCountryRequest*)q;
}

void _ns8__getCountryChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryChangesListResponse::ent__countryList = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__CountryList(soap, &this->_ns8__getCountryChangesListResponse::ent__countryList);
	/* transient soap skipped */
}

int _ns8__getCountryChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getCountryChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getCountryChangesListResponse::ent__countryList) {
		if(soap_out_PointerToent__CountryList(soap, "ent:countryList", -1, &a->_ns8__getCountryChangesListResponse::ent__countryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:countryList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListResponse * FASTCALL soap_in__ns8__getCountryChangesListResponse(struct soap *soap, const char *tag, _ns8__getCountryChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryChangesListResponse, sizeof(_ns8__getCountryChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__countryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__countryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__CountryList(soap, "ent:countryList", &(a->_ns8__getCountryChangesListResponse::ent__countryList), "ent:CountryList"))
				{	soap_flag_ent__countryList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryChangesListResponse, 0, sizeof(_ns8__getCountryChangesListResponse), 0, soap_copy__ns8__getCountryChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__countryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getCountryChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListResponse * SOAP_FMAC4 soap_get__ns8__getCountryChangesListResponse(struct soap *soap, _ns8__getCountryChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryChangesListResponse * FASTCALL soap_instantiate__ns8__getCountryChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryChangesListResponse));
		((_ns8__getCountryChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getCountryChangesListResponse*)p = *(_ns8__getCountryChangesListResponse*)q;
}

void _ns8__getCountryChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryChangesListRequest::base__listOptions = NULL;
	this->_ns8__getCountryChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getCountryChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getCountryChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getCountryChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getCountryChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getCountryChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getCountryChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getCountryChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListRequest * FASTCALL soap_in__ns8__getCountryChangesListRequest(struct soap *soap, const char *tag, _ns8__getCountryChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryChangesListRequest, sizeof(_ns8__getCountryChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getCountryChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getCountryChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryChangesListRequest, 0, sizeof(_ns8__getCountryChangesListRequest), 0, soap_copy__ns8__getCountryChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getCountryChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryChangesListRequest * SOAP_FMAC4 soap_get__ns8__getCountryChangesListRequest(struct soap *soap, _ns8__getCountryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryChangesListRequest * FASTCALL soap_instantiate__ns8__getCountryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryChangesListRequest));
		((_ns8__getCountryChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getCountryChangesListRequest*)p = *(_ns8__getCountryChangesListRequest*)q;
}

void _ns8__getCountryByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryByUuidResponse::ent__country = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Country(soap, &this->_ns8__getCountryByUuidResponse::ent__country);
	/* transient soap skipped */
}

int _ns8__getCountryByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getCountryByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getCountryByUuidResponse::ent__country) {
		if(soap_out_PointerToent__Country(soap, "ent:country", -1, &a->_ns8__getCountryByUuidResponse::ent__country, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:country"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidResponse * FASTCALL soap_in__ns8__getCountryByUuidResponse(struct soap *soap, const char *tag, _ns8__getCountryByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByUuidResponse, sizeof(_ns8__getCountryByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__country1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Country(soap, "ent:country", &(a->_ns8__getCountryByUuidResponse::ent__country), "ent:Country"))
				{	soap_flag_ent__country1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByUuidResponse, 0, sizeof(_ns8__getCountryByUuidResponse), 0, soap_copy__ns8__getCountryByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__country1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidResponse * SOAP_FMAC4 soap_get__ns8__getCountryByUuidResponse(struct soap *soap, _ns8__getCountryByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByUuidResponse * FASTCALL soap_instantiate__ns8__getCountryByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByUuidResponse));
		((_ns8__getCountryByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getCountryByUuidResponse*)p = *(_ns8__getCountryByUuidResponse*)q;
}

void _ns8__getCountryByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getCountryByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getCountryByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getCountryByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getCountryByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getCountryByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getCountryByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getCountryByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidRequest * FASTCALL soap_in__ns8__getCountryByUuidRequest(struct soap *soap, const char *tag, _ns8__getCountryByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByUuidRequest, sizeof(_ns8__getCountryByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getCountryByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByUuidRequest, 0, sizeof(_ns8__getCountryByUuidRequest), 0, soap_copy__ns8__getCountryByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByUuidRequest * SOAP_FMAC4 soap_get__ns8__getCountryByUuidRequest(struct soap *soap, _ns8__getCountryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByUuidRequest * FASTCALL soap_instantiate__ns8__getCountryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByUuidRequest));
		((_ns8__getCountryByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getCountryByUuidRequest*)p = *(_ns8__getCountryByUuidRequest*)q;
}

void _ns8__getCountryByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getCountryByGuidResponse::ent__country = NULL;
	/* transient soap skipped */
}

void _ns8__getCountryByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Country(soap, &this->_ns8__getCountryByGuidResponse::ent__country);
	/* transient soap skipped */
}

int _ns8__getCountryByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getCountryByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getCountryByGuidResponse::ent__country) {
		if(soap_out_PointerToent__Country(soap, "ent:country", -1, &a->_ns8__getCountryByGuidResponse::ent__country, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:country"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidResponse * FASTCALL soap_in__ns8__getCountryByGuidResponse(struct soap *soap, const char *tag, _ns8__getCountryByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByGuidResponse, sizeof(_ns8__getCountryByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__country1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Country(soap, "ent:country", &(a->_ns8__getCountryByGuidResponse::ent__country), "ent:Country"))
				{	soap_flag_ent__country1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByGuidResponse, 0, sizeof(_ns8__getCountryByGuidResponse), 0, soap_copy__ns8__getCountryByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__country1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidResponse * SOAP_FMAC4 soap_get__ns8__getCountryByGuidResponse(struct soap *soap, _ns8__getCountryByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByGuidResponse * FASTCALL soap_instantiate__ns8__getCountryByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByGuidResponse));
		((_ns8__getCountryByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getCountryByGuidResponse*)p = *(_ns8__getCountryByGuidResponse*)q;
}

void _ns8__getCountryByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getCountryByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getCountryByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getCountryByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getCountryByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getCountryByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getCountryByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getCountryByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getCountryByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getCountryByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getCountryByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getCountryByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getCountryByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidRequest * FASTCALL soap_in__ns8__getCountryByGuidRequest(struct soap *soap, const char *tag, _ns8__getCountryByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getCountryByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getCountryByGuidRequest, sizeof(_ns8__getCountryByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getCountryByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getCountryByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getCountryByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getCountryByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getCountryByGuidRequest, 0, sizeof(_ns8__getCountryByGuidRequest), 0, soap_copy__ns8__getCountryByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getCountryByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getCountryByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getCountryByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getCountryByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getCountryByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getCountryByGuidRequest * SOAP_FMAC4 soap_get__ns8__getCountryByGuidRequest(struct soap *soap, _ns8__getCountryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getCountryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getCountryByGuidRequest * FASTCALL soap_instantiate__ns8__getCountryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getCountryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getCountryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getCountryByGuidRequest));
		((_ns8__getCountryByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getCountryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getCountryByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getCountryByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getCountryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getCountryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getCountryByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getCountryByGuidRequest*)p = *(_ns8__getCountryByGuidRequest*)q;
}

void _ns8__getAllCountryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getAllCountryListResponse::ent__countryList = NULL;
	/* transient soap skipped */
}

void _ns8__getAllCountryListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__CountryList(soap, &this->_ns8__getAllCountryListResponse::ent__countryList);
	/* transient soap skipped */
}

int _ns8__getAllCountryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getAllCountryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getAllCountryListResponse(struct soap *soap, const char *tag, int id, const _ns8__getAllCountryListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getAllCountryListResponse), type))
		return soap->error;
	if(a->_ns8__getAllCountryListResponse::ent__countryList) {
		if(soap_out_PointerToent__CountryList(soap, "ent:countryList", -1, &a->_ns8__getAllCountryListResponse::ent__countryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:countryList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getAllCountryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getAllCountryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getAllCountryListResponse * FASTCALL soap_in__ns8__getAllCountryListResponse(struct soap *soap, const char *tag, _ns8__getAllCountryListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getAllCountryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getAllCountryListResponse, sizeof(_ns8__getAllCountryListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getAllCountryListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getAllCountryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__countryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__countryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__CountryList(soap, "ent:countryList", &(a->_ns8__getAllCountryListResponse::ent__countryList), "ent:CountryList"))
				{	soap_flag_ent__countryList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getAllCountryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getAllCountryListResponse, 0, sizeof(_ns8__getAllCountryListResponse), 0, soap_copy__ns8__getAllCountryListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__countryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getAllCountryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getAllCountryListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getAllCountryListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getAllCountryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getAllCountryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getAllCountryListResponse * SOAP_FMAC4 soap_get__ns8__getAllCountryListResponse(struct soap *soap, _ns8__getAllCountryListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getAllCountryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getAllCountryListResponse * FASTCALL soap_instantiate__ns8__getAllCountryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getAllCountryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getAllCountryListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getAllCountryListResponse));
		((_ns8__getAllCountryListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getAllCountryListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getAllCountryListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getAllCountryListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getAllCountryListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getAllCountryListResponse %p -> %p\n", q, p));
	*(_ns8__getAllCountryListResponse*)p = *(_ns8__getAllCountryListResponse*)q;
}

void _ns8__getAllCountryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getAllCountryListRequest::base__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getAllCountryListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getAllCountryListRequest::base__listOptions);
	/* transient soap skipped */
}

int _ns8__getAllCountryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getAllCountryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getAllCountryListRequest(struct soap *soap, const char *tag, int id, const _ns8__getAllCountryListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getAllCountryListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getAllCountryListRequest::base__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getAllCountryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getAllCountryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getAllCountryListRequest * FASTCALL soap_in__ns8__getAllCountryListRequest(struct soap *soap, const char *tag, _ns8__getAllCountryListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getAllCountryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getAllCountryListRequest, sizeof(_ns8__getAllCountryListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getAllCountryListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getAllCountryListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getAllCountryListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getAllCountryListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getAllCountryListRequest, 0, sizeof(_ns8__getAllCountryListRequest), 0, soap_copy__ns8__getAllCountryListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getAllCountryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getAllCountryListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getAllCountryListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getAllCountryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getAllCountryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getAllCountryListRequest * SOAP_FMAC4 soap_get__ns8__getAllCountryListRequest(struct soap *soap, _ns8__getAllCountryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getAllCountryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getAllCountryListRequest * FASTCALL soap_instantiate__ns8__getAllCountryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getAllCountryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getAllCountryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getAllCountryListRequest));
		((_ns8__getAllCountryListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getAllCountryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getAllCountryListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getAllCountryListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getAllCountryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getAllCountryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getAllCountryListRequest %p -> %p\n", q, p));
	*(_ns8__getAllCountryListRequest*)p = *(_ns8__getAllCountryListRequest*)q;
}

void _ns8__getProductItemChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemChangesListResponse::ent__productItemList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductItemList(soap, &this->_ns8__getProductItemChangesListResponse::ent__productItemList);
	/* transient soap skipped */
}

int _ns8__getProductItemChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemChangesListResponse), type))
		return soap->error;
	if(a->ent__productItemList)
		soap_element_result(soap, "ent:productItemList");
	if(soap_out_PointerToent__ProductItemList(soap, "ent:productItemList", -1, &(a->_ns8__getProductItemChangesListResponse::ent__productItemList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListResponse * FASTCALL soap_in__ns8__getProductItemChangesListResponse(struct soap *soap, const char *tag, _ns8__getProductItemChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemChangesListResponse, sizeof(_ns8__getProductItemChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItemList(soap, "ent:productItemList", &(a->_ns8__getProductItemChangesListResponse::ent__productItemList), "ent:ProductItemList"))
				{	soap_flag_ent__productItemList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:productItemList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemChangesListResponse, 0, sizeof(_ns8__getProductItemChangesListResponse), 0, soap_copy__ns8__getProductItemChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListResponse * SOAP_FMAC4 soap_get__ns8__getProductItemChangesListResponse(struct soap *soap, _ns8__getProductItemChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemChangesListResponse * FASTCALL soap_instantiate__ns8__getProductItemChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemChangesListResponse));
		((_ns8__getProductItemChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemChangesListResponse*)p = *(_ns8__getProductItemChangesListResponse*)q;
}

void _ns8__getProductItemChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemChangesListRequest::base__listOptions = NULL;
	this->_ns8__getProductItemChangesListRequest::base__updateDateInterval = NULL;
	this->_ns8__getProductItemChangesListRequest::ent__businessEntity = NULL;
	this->_ns8__getProductItemChangesListRequest::ent__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getProductItemChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getProductItemChangesListRequest::base__updateDateInterval);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->_ns8__getProductItemChangesListRequest::ent__businessEntity);
	soap_serialize_PointerToent__Enterprise(soap, &this->_ns8__getProductItemChangesListRequest::ent__enterprise);
	/* transient soap skipped */
}

int _ns8__getProductItemChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getProductItemChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getProductItemChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getProductItemChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &(a->_ns8__getProductItemChangesListRequest::ent__businessEntity), ""))
		return soap->error;
	if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &(a->_ns8__getProductItemChangesListRequest::ent__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListRequest * FASTCALL soap_in__ns8__getProductItemChangesListRequest(struct soap *soap, const char *tag, _ns8__getProductItemChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemChangesListRequest, sizeof(_ns8__getProductItemChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	size_t soap_flag_ent__businessEntity1 = 1;
	size_t soap_flag_ent__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getProductItemChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getProductItemChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			if(soap_flag_ent__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->_ns8__getProductItemChangesListRequest::ent__businessEntity), "ent:BusinessEntity"))
				{	soap_flag_ent__businessEntity1--;
					continue;
				}
			if(soap_flag_ent__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ns8__getProductItemChangesListRequest::ent__enterprise), "ent:Enterprise"))
				{	soap_flag_ent__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemChangesListRequest, 0, sizeof(_ns8__getProductItemChangesListRequest), 0, soap_copy__ns8__getProductItemChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductItemChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListRequest * SOAP_FMAC4 soap_get__ns8__getProductItemChangesListRequest(struct soap *soap, _ns8__getProductItemChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemChangesListRequest * FASTCALL soap_instantiate__ns8__getProductItemChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemChangesListRequest));
		((_ns8__getProductItemChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemChangesListRequest*)p = *(_ns8__getProductItemChangesListRequest*)q;
}

void _ns8__getProductItemListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemListResponse::ent__productItemList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductItemList(soap, &this->_ns8__getProductItemListResponse::ent__productItemList);
	/* transient soap skipped */
}

int _ns8__getProductItemListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemListResponse), type))
		return soap->error;
	if(a->ent__productItemList)
		soap_element_result(soap, "ent:productItemList");
	if(soap_out_PointerToent__ProductItemList(soap, "ent:productItemList", -1, &(a->_ns8__getProductItemListResponse::ent__productItemList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemListResponse * FASTCALL soap_in__ns8__getProductItemListResponse(struct soap *soap, const char *tag, _ns8__getProductItemListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemListResponse, sizeof(_ns8__getProductItemListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItemList(soap, "ent:productItemList", &(a->_ns8__getProductItemListResponse::ent__productItemList), "ent:ProductItemList"))
				{	soap_flag_ent__productItemList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:productItemList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemListResponse, 0, sizeof(_ns8__getProductItemListResponse), 0, soap_copy__ns8__getProductItemListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemListResponse * SOAP_FMAC4 soap_get__ns8__getProductItemListResponse(struct soap *soap, _ns8__getProductItemListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemListResponse * FASTCALL soap_instantiate__ns8__getProductItemListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemListResponse));
		((_ns8__getProductItemListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemListResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemListResponse*)p = *(_ns8__getProductItemListResponse*)q;
}

void _ns8__getProductItemListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemListRequest::base__listOptions = NULL;
	this->_ns8__getProductItemListRequest::ent__productType = NULL;
	this->_ns8__getProductItemListRequest::ent__product = NULL;
	this->_ns8__getProductItemListRequest::ent__subProduct = NULL;
	this->_ns8__getProductItemListRequest::ent__businessEntity = NULL;
	this->_ns8__getProductItemListRequest::ent__enterprise = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getProductItemListRequest::base__listOptions);
	soap_serialize_PointerToent__ProductType(soap, &this->_ns8__getProductItemListRequest::ent__productType);
	soap_serialize_PointerToent__Product(soap, &this->_ns8__getProductItemListRequest::ent__product);
	soap_serialize_PointerToent__SubProduct(soap, &this->_ns8__getProductItemListRequest::ent__subProduct);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->_ns8__getProductItemListRequest::ent__businessEntity);
	soap_serialize_PointerToent__Enterprise(soap, &this->_ns8__getProductItemListRequest::ent__enterprise);
	/* transient soap skipped */
}

int _ns8__getProductItemListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getProductItemListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "ent:productType", -1, &(a->_ns8__getProductItemListRequest::ent__productType), ""))
		return soap->error;
	if(soap_out_PointerToent__Product(soap, "ent:product", -1, &(a->_ns8__getProductItemListRequest::ent__product), ""))
		return soap->error;
	if(soap_out_PointerToent__SubProduct(soap, "ent:subProduct", -1, &(a->_ns8__getProductItemListRequest::ent__subProduct), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &(a->_ns8__getProductItemListRequest::ent__businessEntity), ""))
		return soap->error;
	if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &(a->_ns8__getProductItemListRequest::ent__enterprise), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemListRequest * FASTCALL soap_in__ns8__getProductItemListRequest(struct soap *soap, const char *tag, _ns8__getProductItemListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemListRequest, sizeof(_ns8__getProductItemListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__productType1 = 1;
	size_t soap_flag_ent__product1 = 1;
	size_t soap_flag_ent__subProduct1 = 1;
	size_t soap_flag_ent__businessEntity1 = 1;
	size_t soap_flag_ent__enterprise1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getProductItemListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "ent:productType", &(a->_ns8__getProductItemListRequest::ent__productType), "ent:ProductType"))
				{	soap_flag_ent__productType1--;
					continue;
				}
			if(soap_flag_ent__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "ent:product", &(a->_ns8__getProductItemListRequest::ent__product), "ent:Product"))
				{	soap_flag_ent__product1--;
					continue;
				}
			if(soap_flag_ent__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "ent:subProduct", &(a->_ns8__getProductItemListRequest::ent__subProduct), "ent:SubProduct"))
				{	soap_flag_ent__subProduct1--;
					continue;
				}
			if(soap_flag_ent__businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->_ns8__getProductItemListRequest::ent__businessEntity), "ent:BusinessEntity"))
				{	soap_flag_ent__businessEntity1--;
					continue;
				}
			if(soap_flag_ent__enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->_ns8__getProductItemListRequest::ent__enterprise), "ent:Enterprise"))
				{	soap_flag_ent__enterprise1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemListRequest, 0, sizeof(_ns8__getProductItemListRequest), 0, soap_copy__ns8__getProductItemListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemListRequest * SOAP_FMAC4 soap_get__ns8__getProductItemListRequest(struct soap *soap, _ns8__getProductItemListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemListRequest * FASTCALL soap_instantiate__ns8__getProductItemListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemListRequest));
		((_ns8__getProductItemListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemListRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemListRequest*)p = *(_ns8__getProductItemListRequest*)q;
}

void _ns8__getProductItemByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemByUuidResponse::ent__productItem = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductItem(soap, &this->_ns8__getProductItemByUuidResponse::ent__productItem);
	/* transient soap skipped */
}

int _ns8__getProductItemByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByUuidResponse), type))
		return soap->error;
	if(a->ent__productItem)
		soap_element_result(soap, "ent:productItem");
	if(soap_out_PointerToent__ProductItem(soap, "ent:productItem", -1, &(a->_ns8__getProductItemByUuidResponse::ent__productItem), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidResponse * FASTCALL soap_in__ns8__getProductItemByUuidResponse(struct soap *soap, const char *tag, _ns8__getProductItemByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByUuidResponse, sizeof(_ns8__getProductItemByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__productItem1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItem(soap, "ent:productItem", &(a->_ns8__getProductItemByUuidResponse::ent__productItem), "ent:ProductItem"))
				{	soap_flag_ent__productItem1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:productItem");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByUuidResponse, 0, sizeof(_ns8__getProductItemByUuidResponse), 0, soap_copy__ns8__getProductItemByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidResponse * SOAP_FMAC4 soap_get__ns8__getProductItemByUuidResponse(struct soap *soap, _ns8__getProductItemByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByUuidResponse * FASTCALL soap_instantiate__ns8__getProductItemByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByUuidResponse));
		((_ns8__getProductItemByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemByUuidResponse*)p = *(_ns8__getProductItemByUuidResponse*)q;
}

void _ns8__getProductItemByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getProductItemByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getProductItemByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getProductItemByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getProductItemByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductItemByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getProductItemByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidRequest * FASTCALL soap_in__ns8__getProductItemByUuidRequest(struct soap *soap, const char *tag, _ns8__getProductItemByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByUuidRequest, sizeof(_ns8__getProductItemByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getProductItemByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByUuidRequest, 0, sizeof(_ns8__getProductItemByUuidRequest), 0, soap_copy__ns8__getProductItemByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductItemByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidRequest * SOAP_FMAC4 soap_get__ns8__getProductItemByUuidRequest(struct soap *soap, _ns8__getProductItemByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByUuidRequest * FASTCALL soap_instantiate__ns8__getProductItemByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByUuidRequest));
		((_ns8__getProductItemByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemByUuidRequest*)p = *(_ns8__getProductItemByUuidRequest*)q;
}

void _ns8__getProductItemByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductItemByGuidResponse::ent__productItem = NULL;
	/* transient soap skipped */
}

void _ns8__getProductItemByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductItem(soap, &this->_ns8__getProductItemByGuidResponse::ent__productItem);
	/* transient soap skipped */
}

int _ns8__getProductItemByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByGuidResponse), type))
		return soap->error;
	if(a->ent__productItem)
		soap_element_result(soap, "ent:productItem");
	if(soap_out_PointerToent__ProductItem(soap, "ent:productItem", -1, &(a->_ns8__getProductItemByGuidResponse::ent__productItem), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidResponse * FASTCALL soap_in__ns8__getProductItemByGuidResponse(struct soap *soap, const char *tag, _ns8__getProductItemByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByGuidResponse, sizeof(_ns8__getProductItemByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__productItem1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItem(soap, "ent:productItem", &(a->_ns8__getProductItemByGuidResponse::ent__productItem), "ent:ProductItem"))
				{	soap_flag_ent__productItem1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:productItem");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByGuidResponse, 0, sizeof(_ns8__getProductItemByGuidResponse), 0, soap_copy__ns8__getProductItemByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getProductItemByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidResponse * SOAP_FMAC4 soap_get__ns8__getProductItemByGuidResponse(struct soap *soap, _ns8__getProductItemByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByGuidResponse * FASTCALL soap_instantiate__ns8__getProductItemByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByGuidResponse));
		((_ns8__getProductItemByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductItemByGuidResponse*)p = *(_ns8__getProductItemByGuidResponse*)q;
}

void _ns8__getProductItemByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getProductItemByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getProductItemByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getProductItemByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getProductItemByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductItemByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductItemByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductItemByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductItemByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductItemByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getProductItemByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductItemByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductItemByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidRequest * FASTCALL soap_in__ns8__getProductItemByGuidRequest(struct soap *soap, const char *tag, _ns8__getProductItemByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductItemByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductItemByGuidRequest, sizeof(_ns8__getProductItemByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductItemByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductItemByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getProductItemByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductItemByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductItemByGuidRequest, 0, sizeof(_ns8__getProductItemByGuidRequest), 0, soap_copy__ns8__getProductItemByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductItemByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductItemByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductItemByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductItemByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductItemByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidRequest * SOAP_FMAC4 soap_get__ns8__getProductItemByGuidRequest(struct soap *soap, _ns8__getProductItemByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductItemByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductItemByGuidRequest * FASTCALL soap_instantiate__ns8__getProductItemByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductItemByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductItemByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductItemByGuidRequest));
		((_ns8__getProductItemByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductItemByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductItemByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductItemByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductItemByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductItemByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductItemByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductItemByGuidRequest*)p = *(_ns8__getProductItemByGuidRequest*)q;
}

void _ns8__getSubProductChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductChangesListResponse::ent__subProductList = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__SubProductList(soap, &this->_ns8__getSubProductChangesListResponse::ent__subProductList);
	/* transient soap skipped */
}

int _ns8__getSubProductChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductChangesListResponse), type))
		return soap->error;
	if(a->ent__subProductList)
		soap_element_result(soap, "ent:subProductList");
	if(a->_ns8__getSubProductChangesListResponse::ent__subProductList) {
		if(soap_out_PointerToent__SubProductList(soap, "ent:subProductList", -1, &a->_ns8__getSubProductChangesListResponse::ent__subProductList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:subProductList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListResponse * FASTCALL soap_in__ns8__getSubProductChangesListResponse(struct soap *soap, const char *tag, _ns8__getSubProductChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductChangesListResponse, sizeof(_ns8__getSubProductChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__subProductList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__subProductList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProductList(soap, "ent:subProductList", &(a->_ns8__getSubProductChangesListResponse::ent__subProductList), "ent:SubProductList"))
				{	soap_flag_ent__subProductList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:subProductList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductChangesListResponse, 0, sizeof(_ns8__getSubProductChangesListResponse), 0, soap_copy__ns8__getSubProductChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__subProductList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListResponse * SOAP_FMAC4 soap_get__ns8__getSubProductChangesListResponse(struct soap *soap, _ns8__getSubProductChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductChangesListResponse * FASTCALL soap_instantiate__ns8__getSubProductChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductChangesListResponse));
		((_ns8__getSubProductChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductChangesListResponse*)p = *(_ns8__getSubProductChangesListResponse*)q;
}

void _ns8__getSubProductChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductChangesListRequest::base__listOptions = NULL;
	this->_ns8__getSubProductChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getSubProductChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getSubProductChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getSubProductChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getSubProductChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getSubProductChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getSubProductChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListRequest * FASTCALL soap_in__ns8__getSubProductChangesListRequest(struct soap *soap, const char *tag, _ns8__getSubProductChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductChangesListRequest, sizeof(_ns8__getSubProductChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getSubProductChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getSubProductChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductChangesListRequest, 0, sizeof(_ns8__getSubProductChangesListRequest), 0, soap_copy__ns8__getSubProductChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListRequest * SOAP_FMAC4 soap_get__ns8__getSubProductChangesListRequest(struct soap *soap, _ns8__getSubProductChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductChangesListRequest * FASTCALL soap_instantiate__ns8__getSubProductChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductChangesListRequest));
		((_ns8__getSubProductChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductChangesListRequest*)p = *(_ns8__getSubProductChangesListRequest*)q;
}

void _ns8__getSubProductByProductListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByProductListResponse::ent__subProductList = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductByProductListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__SubProductList(soap, &this->_ns8__getSubProductByProductListResponse::ent__subProductList);
	/* transient soap skipped */
}

int _ns8__getSubProductByProductListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByProductListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByProductListResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByProductListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByProductListResponse), type))
		return soap->error;
	if(a->ent__subProductList)
		soap_element_result(soap, "ent:subProductList");
	if(a->_ns8__getSubProductByProductListResponse::ent__subProductList) {
		if(soap_out_PointerToent__SubProductList(soap, "ent:subProductList", -1, &a->_ns8__getSubProductByProductListResponse::ent__subProductList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:subProductList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByProductListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByProductListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListResponse * FASTCALL soap_in__ns8__getSubProductByProductListResponse(struct soap *soap, const char *tag, _ns8__getSubProductByProductListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByProductListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByProductListResponse, sizeof(_ns8__getSubProductByProductListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByProductListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByProductListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__subProductList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__subProductList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProductList(soap, "ent:subProductList", &(a->_ns8__getSubProductByProductListResponse::ent__subProductList), "ent:SubProductList"))
				{	soap_flag_ent__subProductList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:subProductList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByProductListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByProductListResponse, 0, sizeof(_ns8__getSubProductByProductListResponse), 0, soap_copy__ns8__getSubProductByProductListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__subProductList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByProductListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByProductListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByProductListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByProductListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByProductListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListResponse * SOAP_FMAC4 soap_get__ns8__getSubProductByProductListResponse(struct soap *soap, _ns8__getSubProductByProductListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByProductListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByProductListResponse * FASTCALL soap_instantiate__ns8__getSubProductByProductListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByProductListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByProductListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByProductListResponse));
		((_ns8__getSubProductByProductListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByProductListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByProductListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByProductListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByProductListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByProductListResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductByProductListResponse*)p = *(_ns8__getSubProductByProductListResponse*)q;
}

void _ns8__getSubProductByProductListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByProductListRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->_ns8__getSubProductByProductListRequest::ent__productGuid);
	/* transient soap skipped */
}

void _ns8__getSubProductByProductListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getSubProductByProductListRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->_ns8__getSubProductByProductListRequest::ent__productGuid);
	/* transient soap skipped */
}

int _ns8__getSubProductByProductListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByProductListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByProductListRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByProductListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByProductListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getSubProductByProductListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getSubProductByProductListRequest::ent__productGuid) {
		if(soap_out_base__UUID(soap, "ent:productGuid", -1, &a->_ns8__getSubProductByProductListRequest::ent__productGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:productGuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByProductListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByProductListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListRequest * FASTCALL soap_in__ns8__getSubProductByProductListRequest(struct soap *soap, const char *tag, _ns8__getSubProductByProductListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByProductListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByProductListRequest, sizeof(_ns8__getSubProductByProductListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByProductListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByProductListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__productGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getSubProductByProductListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__productGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:productGuid", &(a->_ns8__getSubProductByProductListRequest::ent__productGuid), "base:UUID"))
				{	soap_flag_ent__productGuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByProductListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByProductListRequest, 0, sizeof(_ns8__getSubProductByProductListRequest), 0, soap_copy__ns8__getSubProductByProductListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__productGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByProductListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByProductListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByProductListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByProductListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByProductListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListRequest * SOAP_FMAC4 soap_get__ns8__getSubProductByProductListRequest(struct soap *soap, _ns8__getSubProductByProductListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByProductListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByProductListRequest * FASTCALL soap_instantiate__ns8__getSubProductByProductListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByProductListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByProductListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByProductListRequest));
		((_ns8__getSubProductByProductListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByProductListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByProductListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByProductListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByProductListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByProductListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByProductListRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductByProductListRequest*)p = *(_ns8__getSubProductByProductListRequest*)q;
}

void _ns8__getSubProductByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByUuidResponse::ent__subProduct = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__SubProduct(soap, &this->_ns8__getSubProductByUuidResponse::ent__subProduct);
	/* transient soap skipped */
}

int _ns8__getSubProductByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByUuidResponse), type))
		return soap->error;
	if(a->ent__subProduct)
		soap_element_result(soap, "ent:subProduct");
	if(a->_ns8__getSubProductByUuidResponse::ent__subProduct) {
		if(soap_out_PointerToent__SubProduct(soap, "ent:subProduct", -1, &a->_ns8__getSubProductByUuidResponse::ent__subProduct, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:subProduct"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidResponse * FASTCALL soap_in__ns8__getSubProductByUuidResponse(struct soap *soap, const char *tag, _ns8__getSubProductByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByUuidResponse, sizeof(_ns8__getSubProductByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__subProduct1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "ent:subProduct", &(a->_ns8__getSubProductByUuidResponse::ent__subProduct), "ent:SubProduct"))
				{	soap_flag_ent__subProduct1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:subProduct");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByUuidResponse, 0, sizeof(_ns8__getSubProductByUuidResponse), 0, soap_copy__ns8__getSubProductByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__subProduct1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidResponse * SOAP_FMAC4 soap_get__ns8__getSubProductByUuidResponse(struct soap *soap, _ns8__getSubProductByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByUuidResponse * FASTCALL soap_instantiate__ns8__getSubProductByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByUuidResponse));
		((_ns8__getSubProductByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductByUuidResponse*)p = *(_ns8__getSubProductByUuidResponse*)q;
}

void _ns8__getSubProductByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getSubProductByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getSubProductByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getSubProductByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getSubProductByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getSubProductByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getSubProductByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidRequest * FASTCALL soap_in__ns8__getSubProductByUuidRequest(struct soap *soap, const char *tag, _ns8__getSubProductByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByUuidRequest, sizeof(_ns8__getSubProductByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getSubProductByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByUuidRequest, 0, sizeof(_ns8__getSubProductByUuidRequest), 0, soap_copy__ns8__getSubProductByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidRequest * SOAP_FMAC4 soap_get__ns8__getSubProductByUuidRequest(struct soap *soap, _ns8__getSubProductByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByUuidRequest * FASTCALL soap_instantiate__ns8__getSubProductByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByUuidRequest));
		((_ns8__getSubProductByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductByUuidRequest*)p = *(_ns8__getSubProductByUuidRequest*)q;
}

void _ns8__getSubProductByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getSubProductByGuidResponse::ent__subProduct = NULL;
	/* transient soap skipped */
}

void _ns8__getSubProductByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__SubProduct(soap, &this->_ns8__getSubProductByGuidResponse::ent__subProduct);
	/* transient soap skipped */
}

int _ns8__getSubProductByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByGuidResponse), type))
		return soap->error;
	if(a->ent__subProduct)
		soap_element_result(soap, "ent:subProduct");
	if(a->_ns8__getSubProductByGuidResponse::ent__subProduct) {
		if(soap_out_PointerToent__SubProduct(soap, "ent:subProduct", -1, &a->_ns8__getSubProductByGuidResponse::ent__subProduct, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:subProduct"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidResponse * FASTCALL soap_in__ns8__getSubProductByGuidResponse(struct soap *soap, const char *tag, _ns8__getSubProductByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByGuidResponse, sizeof(_ns8__getSubProductByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__subProduct1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "ent:subProduct", &(a->_ns8__getSubProductByGuidResponse::ent__subProduct), "ent:SubProduct"))
				{	soap_flag_ent__subProduct1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:subProduct");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByGuidResponse, 0, sizeof(_ns8__getSubProductByGuidResponse), 0, soap_copy__ns8__getSubProductByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__subProduct1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidResponse * SOAP_FMAC4 soap_get__ns8__getSubProductByGuidResponse(struct soap *soap, _ns8__getSubProductByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByGuidResponse * FASTCALL soap_instantiate__ns8__getSubProductByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByGuidResponse));
		((_ns8__getSubProductByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getSubProductByGuidResponse*)p = *(_ns8__getSubProductByGuidResponse*)q;
}

void _ns8__getSubProductByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getSubProductByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getSubProductByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getSubProductByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getSubProductByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getSubProductByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getSubProductByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getSubProductByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getSubProductByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getSubProductByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getSubProductByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getSubProductByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getSubProductByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidRequest * FASTCALL soap_in__ns8__getSubProductByGuidRequest(struct soap *soap, const char *tag, _ns8__getSubProductByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getSubProductByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getSubProductByGuidRequest, sizeof(_ns8__getSubProductByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getSubProductByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getSubProductByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getSubProductByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getSubProductByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getSubProductByGuidRequest, 0, sizeof(_ns8__getSubProductByGuidRequest), 0, soap_copy__ns8__getSubProductByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getSubProductByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getSubProductByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getSubProductByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getSubProductByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getSubProductByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidRequest * SOAP_FMAC4 soap_get__ns8__getSubProductByGuidRequest(struct soap *soap, _ns8__getSubProductByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getSubProductByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getSubProductByGuidRequest * FASTCALL soap_instantiate__ns8__getSubProductByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getSubProductByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getSubProductByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getSubProductByGuidRequest));
		((_ns8__getSubProductByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getSubProductByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getSubProductByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getSubProductByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getSubProductByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getSubProductByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getSubProductByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getSubProductByGuidRequest*)p = *(_ns8__getSubProductByGuidRequest*)q;
}

void _ns8__getProductChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductChangesListResponse::ent__productList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductList(soap, &this->_ns8__getProductChangesListResponse::ent__productList);
	/* transient soap skipped */
}

int _ns8__getProductChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductChangesListResponse), type))
		return soap->error;
	if(a->ent__productList)
		soap_element_result(soap, "ent:productList");
	if(a->_ns8__getProductChangesListResponse::ent__productList) {
		if(soap_out_PointerToent__ProductList(soap, "ent:productList", -1, &a->_ns8__getProductChangesListResponse::ent__productList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:productList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductChangesListResponse * FASTCALL soap_in__ns8__getProductChangesListResponse(struct soap *soap, const char *tag, _ns8__getProductChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductChangesListResponse, sizeof(_ns8__getProductChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__productList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__productList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductList(soap, "ent:productList", &(a->_ns8__getProductChangesListResponse::ent__productList), "ent:ProductList"))
				{	soap_flag_ent__productList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:productList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductChangesListResponse, 0, sizeof(_ns8__getProductChangesListResponse), 0, soap_copy__ns8__getProductChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__productList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductChangesListResponse * SOAP_FMAC4 soap_get__ns8__getProductChangesListResponse(struct soap *soap, _ns8__getProductChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductChangesListResponse * FASTCALL soap_instantiate__ns8__getProductChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductChangesListResponse));
		((_ns8__getProductChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getProductChangesListResponse*)p = *(_ns8__getProductChangesListResponse*)q;
}

void _ns8__getProductChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductChangesListRequest::base__listOptions = NULL;
	this->_ns8__getProductChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getProductChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getProductChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getProductChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getProductChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getProductChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getProductChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getProductChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductChangesListRequest * FASTCALL soap_in__ns8__getProductChangesListRequest(struct soap *soap, const char *tag, _ns8__getProductChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductChangesListRequest, sizeof(_ns8__getProductChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getProductChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getProductChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductChangesListRequest, 0, sizeof(_ns8__getProductChangesListRequest), 0, soap_copy__ns8__getProductChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductChangesListRequest * SOAP_FMAC4 soap_get__ns8__getProductChangesListRequest(struct soap *soap, _ns8__getProductChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductChangesListRequest * FASTCALL soap_instantiate__ns8__getProductChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductChangesListRequest));
		((_ns8__getProductChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getProductChangesListRequest*)p = *(_ns8__getProductChangesListRequest*)q;
}

void _ns8__getProductByTypeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByTypeListResponse::ent__productList = NULL;
	/* transient soap skipped */
}

void _ns8__getProductByTypeListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductList(soap, &this->_ns8__getProductByTypeListResponse::ent__productList);
	/* transient soap skipped */
}

int _ns8__getProductByTypeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByTypeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByTypeListResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductByTypeListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByTypeListResponse), type))
		return soap->error;
	if(a->ent__productList)
		soap_element_result(soap, "ent:productList");
	if(a->_ns8__getProductByTypeListResponse::ent__productList) {
		if(soap_out_PointerToent__ProductList(soap, "ent:productList", -1, &a->_ns8__getProductByTypeListResponse::ent__productList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:productList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByTypeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByTypeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListResponse * FASTCALL soap_in__ns8__getProductByTypeListResponse(struct soap *soap, const char *tag, _ns8__getProductByTypeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByTypeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByTypeListResponse, sizeof(_ns8__getProductByTypeListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByTypeListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByTypeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__productList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__productList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductList(soap, "ent:productList", &(a->_ns8__getProductByTypeListResponse::ent__productList), "ent:ProductList"))
				{	soap_flag_ent__productList1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:productList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByTypeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByTypeListResponse, 0, sizeof(_ns8__getProductByTypeListResponse), 0, soap_copy__ns8__getProductByTypeListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__productList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByTypeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByTypeListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductByTypeListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByTypeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByTypeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListResponse * SOAP_FMAC4 soap_get__ns8__getProductByTypeListResponse(struct soap *soap, _ns8__getProductByTypeListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByTypeListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByTypeListResponse * FASTCALL soap_instantiate__ns8__getProductByTypeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByTypeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByTypeListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByTypeListResponse));
		((_ns8__getProductByTypeListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByTypeListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByTypeListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByTypeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByTypeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByTypeListResponse %p -> %p\n", q, p));
	*(_ns8__getProductByTypeListResponse*)p = *(_ns8__getProductByTypeListResponse*)q;
}

void _ns8__getProductByTypeListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByTypeListRequest::base__listOptions = NULL;
	soap_default_ent__ProductType(soap, &this->_ns8__getProductByTypeListRequest::ent__productType);
	/* transient soap skipped */
}

void _ns8__getProductByTypeListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getProductByTypeListRequest::base__listOptions);
	soap_embedded(soap, &this->_ns8__getProductByTypeListRequest::ent__productType, SOAP_TYPE_ent__ProductType);
	/* transient soap skipped */
}

int _ns8__getProductByTypeListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByTypeListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByTypeListRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductByTypeListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByTypeListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getProductByTypeListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_ent__ProductType(soap, "ent:productType", -1, &(a->_ns8__getProductByTypeListRequest::ent__productType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByTypeListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByTypeListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListRequest * FASTCALL soap_in__ns8__getProductByTypeListRequest(struct soap *soap, const char *tag, _ns8__getProductByTypeListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByTypeListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByTypeListRequest, sizeof(_ns8__getProductByTypeListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByTypeListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByTypeListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__productType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getProductByTypeListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__ProductType(soap, "ent:productType", &(a->_ns8__getProductByTypeListRequest::ent__productType), "ent:ProductType"))
				{	soap_flag_ent__productType1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByTypeListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByTypeListRequest, 0, sizeof(_ns8__getProductByTypeListRequest), 0, soap_copy__ns8__getProductByTypeListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__productType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByTypeListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByTypeListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductByTypeListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByTypeListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByTypeListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListRequest * SOAP_FMAC4 soap_get__ns8__getProductByTypeListRequest(struct soap *soap, _ns8__getProductByTypeListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByTypeListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByTypeListRequest * FASTCALL soap_instantiate__ns8__getProductByTypeListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByTypeListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByTypeListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByTypeListRequest));
		((_ns8__getProductByTypeListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByTypeListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByTypeListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByTypeListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByTypeListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByTypeListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByTypeListRequest %p -> %p\n", q, p));
	*(_ns8__getProductByTypeListRequest*)p = *(_ns8__getProductByTypeListRequest*)q;
}

void _ns8__getProductByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByUuidResponse::ent__product = NULL;
	/* transient soap skipped */
}

void _ns8__getProductByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Product(soap, &this->_ns8__getProductByUuidResponse::ent__product);
	/* transient soap skipped */
}

int _ns8__getProductByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByUuidResponse), type))
		return soap->error;
	if(a->ent__product)
		soap_element_result(soap, "ent:product");
	if(a->_ns8__getProductByUuidResponse::ent__product) {
		if(soap_out_PointerToent__Product(soap, "ent:product", -1, &a->_ns8__getProductByUuidResponse::ent__product, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:product"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByUuidResponse * FASTCALL soap_in__ns8__getProductByUuidResponse(struct soap *soap, const char *tag, _ns8__getProductByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByUuidResponse, sizeof(_ns8__getProductByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__product1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "ent:product", &(a->_ns8__getProductByUuidResponse::ent__product), "ent:Product"))
				{	soap_flag_ent__product1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:product");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByUuidResponse, 0, sizeof(_ns8__getProductByUuidResponse), 0, soap_copy__ns8__getProductByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__product1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByUuidResponse * SOAP_FMAC4 soap_get__ns8__getProductByUuidResponse(struct soap *soap, _ns8__getProductByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByUuidResponse * FASTCALL soap_instantiate__ns8__getProductByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByUuidResponse));
		((_ns8__getProductByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductByUuidResponse*)p = *(_ns8__getProductByUuidResponse*)q;
}

void _ns8__getProductByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getProductByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getProductByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getProductByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getProductByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getProductByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByUuidRequest * FASTCALL soap_in__ns8__getProductByUuidRequest(struct soap *soap, const char *tag, _ns8__getProductByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByUuidRequest, sizeof(_ns8__getProductByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getProductByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByUuidRequest, 0, sizeof(_ns8__getProductByUuidRequest), 0, soap_copy__ns8__getProductByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByUuidRequest * SOAP_FMAC4 soap_get__ns8__getProductByUuidRequest(struct soap *soap, _ns8__getProductByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByUuidRequest * FASTCALL soap_instantiate__ns8__getProductByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByUuidRequest));
		((_ns8__getProductByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductByUuidRequest*)p = *(_ns8__getProductByUuidRequest*)q;
}

void _ns8__getProductByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getProductByGuidResponse::ent__product = NULL;
	/* transient soap skipped */
}

void _ns8__getProductByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Product(soap, &this->_ns8__getProductByGuidResponse::ent__product);
	/* transient soap skipped */
}

int _ns8__getProductByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getProductByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByGuidResponse), type))
		return soap->error;
	if(a->ent__product)
		soap_element_result(soap, "ent:product");
	if(a->_ns8__getProductByGuidResponse::ent__product) {
		if(soap_out_PointerToent__Product(soap, "ent:product", -1, &a->_ns8__getProductByGuidResponse::ent__product, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:product"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByGuidResponse * FASTCALL soap_in__ns8__getProductByGuidResponse(struct soap *soap, const char *tag, _ns8__getProductByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByGuidResponse, sizeof(_ns8__getProductByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__product1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "ent:product", &(a->_ns8__getProductByGuidResponse::ent__product), "ent:Product"))
				{	soap_flag_ent__product1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ent:product");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByGuidResponse, 0, sizeof(_ns8__getProductByGuidResponse), 0, soap_copy__ns8__getProductByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__product1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getProductByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByGuidResponse * SOAP_FMAC4 soap_get__ns8__getProductByGuidResponse(struct soap *soap, _ns8__getProductByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByGuidResponse * FASTCALL soap_instantiate__ns8__getProductByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByGuidResponse));
		((_ns8__getProductByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getProductByGuidResponse*)p = *(_ns8__getProductByGuidResponse*)q;
}

void _ns8__getProductByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getProductByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getProductByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getProductByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getProductByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getProductByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getProductByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getProductByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getProductByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getProductByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getProductByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getProductByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getProductByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getProductByGuidRequest * FASTCALL soap_in__ns8__getProductByGuidRequest(struct soap *soap, const char *tag, _ns8__getProductByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getProductByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getProductByGuidRequest, sizeof(_ns8__getProductByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getProductByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getProductByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getProductByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getProductByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getProductByGuidRequest, 0, sizeof(_ns8__getProductByGuidRequest), 0, soap_copy__ns8__getProductByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getProductByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getProductByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getProductByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getProductByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getProductByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getProductByGuidRequest * SOAP_FMAC4 soap_get__ns8__getProductByGuidRequest(struct soap *soap, _ns8__getProductByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getProductByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getProductByGuidRequest * FASTCALL soap_instantiate__ns8__getProductByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getProductByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getProductByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getProductByGuidRequest));
		((_ns8__getProductByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getProductByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getProductByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getProductByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getProductByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getProductByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getProductByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getProductByGuidRequest*)p = *(_ns8__getProductByGuidRequest*)q;
}

void _ns8__getUnitChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitChangesListResponse::ent__unitList = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__UnitList(soap, &this->_ns8__getUnitChangesListResponse::ent__unitList);
	/* transient soap skipped */
}

int _ns8__getUnitChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getUnitChangesListResponse::ent__unitList) {
		if(soap_out_PointerToent__UnitList(soap, "ent:unitList", -1, &a->_ns8__getUnitChangesListResponse::ent__unitList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:unitList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListResponse * FASTCALL soap_in__ns8__getUnitChangesListResponse(struct soap *soap, const char *tag, _ns8__getUnitChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitChangesListResponse, sizeof(_ns8__getUnitChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__unitList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__unitList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__UnitList(soap, "ent:unitList", &(a->_ns8__getUnitChangesListResponse::ent__unitList), "ent:UnitList"))
				{	soap_flag_ent__unitList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitChangesListResponse, 0, sizeof(_ns8__getUnitChangesListResponse), 0, soap_copy__ns8__getUnitChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__unitList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListResponse * SOAP_FMAC4 soap_get__ns8__getUnitChangesListResponse(struct soap *soap, _ns8__getUnitChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitChangesListResponse * FASTCALL soap_instantiate__ns8__getUnitChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitChangesListResponse));
		((_ns8__getUnitChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getUnitChangesListResponse*)p = *(_ns8__getUnitChangesListResponse*)q;
}

void _ns8__getUnitChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitChangesListRequest::base__listOptions = NULL;
	this->_ns8__getUnitChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getUnitChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getUnitChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getUnitChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getUnitChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getUnitChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getUnitChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListRequest * FASTCALL soap_in__ns8__getUnitChangesListRequest(struct soap *soap, const char *tag, _ns8__getUnitChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitChangesListRequest, sizeof(_ns8__getUnitChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getUnitChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getUnitChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitChangesListRequest, 0, sizeof(_ns8__getUnitChangesListRequest), 0, soap_copy__ns8__getUnitChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitChangesListRequest * SOAP_FMAC4 soap_get__ns8__getUnitChangesListRequest(struct soap *soap, _ns8__getUnitChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitChangesListRequest * FASTCALL soap_instantiate__ns8__getUnitChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitChangesListRequest));
		((_ns8__getUnitChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getUnitChangesListRequest*)p = *(_ns8__getUnitChangesListRequest*)q;
}

void _ns8__getUnitListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitListResponse::ent__unitList = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__UnitList(soap, &this->_ns8__getUnitListResponse::ent__unitList);
	/* transient soap skipped */
}

int _ns8__getUnitListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitListResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitListResponse), type))
		return soap->error;
	if(a->_ns8__getUnitListResponse::ent__unitList) {
		if(soap_out_PointerToent__UnitList(soap, "ent:unitList", -1, &a->_ns8__getUnitListResponse::ent__unitList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:unitList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitListResponse * FASTCALL soap_in__ns8__getUnitListResponse(struct soap *soap, const char *tag, _ns8__getUnitListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitListResponse, sizeof(_ns8__getUnitListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__unitList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__unitList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__UnitList(soap, "ent:unitList", &(a->_ns8__getUnitListResponse::ent__unitList), "ent:UnitList"))
				{	soap_flag_ent__unitList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitListResponse, 0, sizeof(_ns8__getUnitListResponse), 0, soap_copy__ns8__getUnitListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__unitList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitListResponse * SOAP_FMAC4 soap_get__ns8__getUnitListResponse(struct soap *soap, _ns8__getUnitListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitListResponse * FASTCALL soap_instantiate__ns8__getUnitListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitListResponse));
		((_ns8__getUnitListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitListResponse %p -> %p\n", q, p));
	*(_ns8__getUnitListResponse*)p = *(_ns8__getUnitListResponse*)q;
}

void _ns8__getUnitListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitListRequest::base__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getUnitListRequest::base__listOptions);
	/* transient soap skipped */
}

int _ns8__getUnitListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitListRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getUnitListRequest::base__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitListRequest * FASTCALL soap_in__ns8__getUnitListRequest(struct soap *soap, const char *tag, _ns8__getUnitListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitListRequest, sizeof(_ns8__getUnitListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getUnitListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitListRequest, 0, sizeof(_ns8__getUnitListRequest), 0, soap_copy__ns8__getUnitListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getUnitListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitListRequest * SOAP_FMAC4 soap_get__ns8__getUnitListRequest(struct soap *soap, _ns8__getUnitListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitListRequest * FASTCALL soap_instantiate__ns8__getUnitListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitListRequest));
		((_ns8__getUnitListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitListRequest %p -> %p\n", q, p));
	*(_ns8__getUnitListRequest*)p = *(_ns8__getUnitListRequest*)q;
}

void _ns8__getUnitByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitByUuidResponse::ent__unit = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Unit(soap, &this->_ns8__getUnitByUuidResponse::ent__unit);
	/* transient soap skipped */
}

int _ns8__getUnitByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getUnitByUuidResponse::ent__unit) {
		if(soap_out_PointerToent__Unit(soap, "ent:unit", -1, &a->_ns8__getUnitByUuidResponse::ent__unit, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:unit"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidResponse * FASTCALL soap_in__ns8__getUnitByUuidResponse(struct soap *soap, const char *tag, _ns8__getUnitByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByUuidResponse, sizeof(_ns8__getUnitByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "ent:unit", &(a->_ns8__getUnitByUuidResponse::ent__unit), "ent:Unit"))
				{	soap_flag_ent__unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByUuidResponse, 0, sizeof(_ns8__getUnitByUuidResponse), 0, soap_copy__ns8__getUnitByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__unit1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidResponse * SOAP_FMAC4 soap_get__ns8__getUnitByUuidResponse(struct soap *soap, _ns8__getUnitByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByUuidResponse * FASTCALL soap_instantiate__ns8__getUnitByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByUuidResponse));
		((_ns8__getUnitByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getUnitByUuidResponse*)p = *(_ns8__getUnitByUuidResponse*)q;
}

void _ns8__getUnitByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getUnitByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getUnitByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getUnitByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getUnitByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getUnitByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getUnitByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidRequest * FASTCALL soap_in__ns8__getUnitByUuidRequest(struct soap *soap, const char *tag, _ns8__getUnitByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByUuidRequest, sizeof(_ns8__getUnitByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getUnitByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByUuidRequest, 0, sizeof(_ns8__getUnitByUuidRequest), 0, soap_copy__ns8__getUnitByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByUuidRequest * SOAP_FMAC4 soap_get__ns8__getUnitByUuidRequest(struct soap *soap, _ns8__getUnitByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByUuidRequest * FASTCALL soap_instantiate__ns8__getUnitByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByUuidRequest));
		((_ns8__getUnitByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getUnitByUuidRequest*)p = *(_ns8__getUnitByUuidRequest*)q;
}

void _ns8__getUnitByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getUnitByGuidResponse::ent__unit = NULL;
	/* transient soap skipped */
}

void _ns8__getUnitByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Unit(soap, &this->_ns8__getUnitByGuidResponse::ent__unit);
	/* transient soap skipped */
}

int _ns8__getUnitByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getUnitByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getUnitByGuidResponse::ent__unit) {
		if(soap_out_PointerToent__Unit(soap, "ent:unit", -1, &a->_ns8__getUnitByGuidResponse::ent__unit, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:unit"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidResponse * FASTCALL soap_in__ns8__getUnitByGuidResponse(struct soap *soap, const char *tag, _ns8__getUnitByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByGuidResponse, sizeof(_ns8__getUnitByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "ent:unit", &(a->_ns8__getUnitByGuidResponse::ent__unit), "ent:Unit"))
				{	soap_flag_ent__unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByGuidResponse, 0, sizeof(_ns8__getUnitByGuidResponse), 0, soap_copy__ns8__getUnitByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__unit1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidResponse * SOAP_FMAC4 soap_get__ns8__getUnitByGuidResponse(struct soap *soap, _ns8__getUnitByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByGuidResponse * FASTCALL soap_instantiate__ns8__getUnitByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByGuidResponse));
		((_ns8__getUnitByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getUnitByGuidResponse*)p = *(_ns8__getUnitByGuidResponse*)q;
}

void _ns8__getUnitByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getUnitByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getUnitByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getUnitByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getUnitByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getUnitByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getUnitByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getUnitByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getUnitByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getUnitByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getUnitByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getUnitByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getUnitByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidRequest * FASTCALL soap_in__ns8__getUnitByGuidRequest(struct soap *soap, const char *tag, _ns8__getUnitByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getUnitByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getUnitByGuidRequest, sizeof(_ns8__getUnitByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getUnitByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getUnitByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getUnitByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getUnitByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getUnitByGuidRequest, 0, sizeof(_ns8__getUnitByGuidRequest), 0, soap_copy__ns8__getUnitByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getUnitByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getUnitByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getUnitByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getUnitByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getUnitByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getUnitByGuidRequest * SOAP_FMAC4 soap_get__ns8__getUnitByGuidRequest(struct soap *soap, _ns8__getUnitByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getUnitByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getUnitByGuidRequest * FASTCALL soap_instantiate__ns8__getUnitByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getUnitByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getUnitByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getUnitByGuidRequest));
		((_ns8__getUnitByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getUnitByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getUnitByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getUnitByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getUnitByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getUnitByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getUnitByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getUnitByGuidRequest*)p = *(_ns8__getUnitByGuidRequest*)q;
}

void _ns8__getPurposeChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeChangesListResponse::ent__purposeList = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__PurposeList(soap, &this->_ns8__getPurposeChangesListResponse::ent__purposeList);
	/* transient soap skipped */
}

int _ns8__getPurposeChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeChangesListResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeChangesListResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeChangesListResponse::ent__purposeList) {
		if(soap_out_PointerToent__PurposeList(soap, "ent:purposeList", -1, &a->_ns8__getPurposeChangesListResponse::ent__purposeList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:purposeList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListResponse * FASTCALL soap_in__ns8__getPurposeChangesListResponse(struct soap *soap, const char *tag, _ns8__getPurposeChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeChangesListResponse, sizeof(_ns8__getPurposeChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__purposeList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__purposeList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PurposeList(soap, "ent:purposeList", &(a->_ns8__getPurposeChangesListResponse::ent__purposeList), "ent:PurposeList"))
				{	soap_flag_ent__purposeList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeChangesListResponse, 0, sizeof(_ns8__getPurposeChangesListResponse), 0, soap_copy__ns8__getPurposeChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__purposeList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeChangesListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListResponse * SOAP_FMAC4 soap_get__ns8__getPurposeChangesListResponse(struct soap *soap, _ns8__getPurposeChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeChangesListResponse * FASTCALL soap_instantiate__ns8__getPurposeChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeChangesListResponse));
		((_ns8__getPurposeChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeChangesListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeChangesListResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeChangesListResponse*)p = *(_ns8__getPurposeChangesListResponse*)q;
}

void _ns8__getPurposeChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeChangesListRequest::base__listOptions = NULL;
	this->_ns8__getPurposeChangesListRequest::base__updateDateInterval = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getPurposeChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->_ns8__getPurposeChangesListRequest::base__updateDateInterval);
	/* transient soap skipped */
}

int _ns8__getPurposeChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeChangesListRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeChangesListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getPurposeChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->_ns8__getPurposeChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->_ns8__getPurposeChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListRequest * FASTCALL soap_in__ns8__getPurposeChangesListRequest(struct soap *soap, const char *tag, _ns8__getPurposeChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeChangesListRequest, sizeof(_ns8__getPurposeChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getPurposeChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->_ns8__getPurposeChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeChangesListRequest, 0, sizeof(_ns8__getPurposeChangesListRequest), 0, soap_copy__ns8__getPurposeChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__updateDateInterval1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeChangesListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeChangesListRequest * SOAP_FMAC4 soap_get__ns8__getPurposeChangesListRequest(struct soap *soap, _ns8__getPurposeChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeChangesListRequest * FASTCALL soap_instantiate__ns8__getPurposeChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeChangesListRequest));
		((_ns8__getPurposeChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeChangesListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeChangesListRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeChangesListRequest*)p = *(_ns8__getPurposeChangesListRequest*)q;
}

void _ns8__getPurposeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeListResponse::ent__purposeList = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__PurposeList(soap, &this->_ns8__getPurposeListResponse::ent__purposeList);
	/* transient soap skipped */
}

int _ns8__getPurposeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeListResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeListResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeListResponse::ent__purposeList) {
		if(soap_out_PointerToent__PurposeList(soap, "ent:purposeList", -1, &a->_ns8__getPurposeListResponse::ent__purposeList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:purposeList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeListResponse * FASTCALL soap_in__ns8__getPurposeListResponse(struct soap *soap, const char *tag, _ns8__getPurposeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeListResponse, sizeof(_ns8__getPurposeListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__purposeList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__purposeList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PurposeList(soap, "ent:purposeList", &(a->_ns8__getPurposeListResponse::ent__purposeList), "ent:PurposeList"))
				{	soap_flag_ent__purposeList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeListResponse, 0, sizeof(_ns8__getPurposeListResponse), 0, soap_copy__ns8__getPurposeListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__purposeList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeListResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeListResponse * SOAP_FMAC4 soap_get__ns8__getPurposeListResponse(struct soap *soap, _ns8__getPurposeListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeListResponse * FASTCALL soap_instantiate__ns8__getPurposeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeListResponse));
		((_ns8__getPurposeListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeListResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeListResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeListResponse*)p = *(_ns8__getPurposeListResponse*)q;
}

void _ns8__getPurposeListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeListRequest::base__listOptions = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->_ns8__getPurposeListRequest::base__listOptions);
	/* transient soap skipped */
}

int _ns8__getPurposeListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeListRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeListRequest), type))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->_ns8__getPurposeListRequest::base__listOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeListRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeListRequest * FASTCALL soap_in__ns8__getPurposeListRequest(struct soap *soap, const char *tag, _ns8__getPurposeListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeListRequest, sizeof(_ns8__getPurposeListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->_ns8__getPurposeListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeListRequest, 0, sizeof(_ns8__getPurposeListRequest), 0, soap_copy__ns8__getPurposeListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns8__getPurposeListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeListRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeListRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeListRequest * SOAP_FMAC4 soap_get__ns8__getPurposeListRequest(struct soap *soap, _ns8__getPurposeListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeListRequest * FASTCALL soap_instantiate__ns8__getPurposeListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeListRequest));
		((_ns8__getPurposeListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeListRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeListRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeListRequest*)p = *(_ns8__getPurposeListRequest*)q;
}

void _ns8__getPurposeByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeByUuidResponse::ent__purpose = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Purpose(soap, &this->_ns8__getPurposeByUuidResponse::ent__purpose);
	/* transient soap skipped */
}

int _ns8__getPurposeByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByUuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByUuidResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeByUuidResponse::ent__purpose) {
		if(soap_out_PointerToent__Purpose(soap, "ent:purpose", -1, &a->_ns8__getPurposeByUuidResponse::ent__purpose, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:purpose"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidResponse * FASTCALL soap_in__ns8__getPurposeByUuidResponse(struct soap *soap, const char *tag, _ns8__getPurposeByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByUuidResponse, sizeof(_ns8__getPurposeByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__purpose1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Purpose(soap, "ent:purpose", &(a->_ns8__getPurposeByUuidResponse::ent__purpose), "ent:Purpose"))
				{	soap_flag_ent__purpose1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByUuidResponse, 0, sizeof(_ns8__getPurposeByUuidResponse), 0, soap_copy__ns8__getPurposeByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__purpose1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByUuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidResponse * SOAP_FMAC4 soap_get__ns8__getPurposeByUuidResponse(struct soap *soap, _ns8__getPurposeByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByUuidResponse * FASTCALL soap_instantiate__ns8__getPurposeByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByUuidResponse));
		((_ns8__getPurposeByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByUuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByUuidResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeByUuidResponse*)p = *(_ns8__getPurposeByUuidResponse*)q;
}

void _ns8__getPurposeByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getPurposeByUuidRequest::base__uuid);
	/* transient soap skipped */
}

void _ns8__getPurposeByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getPurposeByUuidRequest::base__uuid);
	/* transient soap skipped */
}

int _ns8__getPurposeByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByUuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByUuidRequest), type))
		return soap->error;
	if(a->_ns8__getPurposeByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->_ns8__getPurposeByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidRequest * FASTCALL soap_in__ns8__getPurposeByUuidRequest(struct soap *soap, const char *tag, _ns8__getPurposeByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByUuidRequest, sizeof(_ns8__getPurposeByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->_ns8__getPurposeByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByUuidRequest, 0, sizeof(_ns8__getPurposeByUuidRequest), 0, soap_copy__ns8__getPurposeByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__uuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByUuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByUuidRequest * SOAP_FMAC4 soap_get__ns8__getPurposeByUuidRequest(struct soap *soap, _ns8__getPurposeByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByUuidRequest * FASTCALL soap_instantiate__ns8__getPurposeByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByUuidRequest));
		((_ns8__getPurposeByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByUuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByUuidRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeByUuidRequest*)p = *(_ns8__getPurposeByUuidRequest*)q;
}

void _ns8__getPurposeByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns8__getPurposeByGuidResponse::ent__purpose = NULL;
	/* transient soap skipped */
}

void _ns8__getPurposeByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Purpose(soap, &this->_ns8__getPurposeByGuidResponse::ent__purpose);
	/* transient soap skipped */
}

int _ns8__getPurposeByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByGuidResponse(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByGuidResponse), type))
		return soap->error;
	if(a->_ns8__getPurposeByGuidResponse::ent__purpose) {
		if(soap_out_PointerToent__Purpose(soap, "ent:purpose", -1, &a->_ns8__getPurposeByGuidResponse::ent__purpose, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:purpose"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidResponse * FASTCALL soap_in__ns8__getPurposeByGuidResponse(struct soap *soap, const char *tag, _ns8__getPurposeByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByGuidResponse, sizeof(_ns8__getPurposeByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ent__purpose1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ent__purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Purpose(soap, "ent:purpose", &(a->_ns8__getPurposeByGuidResponse::ent__purpose), "ent:Purpose"))
				{	soap_flag_ent__purpose1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByGuidResponse, 0, sizeof(_ns8__getPurposeByGuidResponse), 0, soap_copy__ns8__getPurposeByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ent__purpose1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByGuidResponse);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidResponse * SOAP_FMAC4 soap_get__ns8__getPurposeByGuidResponse(struct soap *soap, _ns8__getPurposeByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByGuidResponse * FASTCALL soap_instantiate__ns8__getPurposeByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidResponse);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByGuidResponse));
		((_ns8__getPurposeByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByGuidResponse));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByGuidResponse %p -> %p\n", q, p));
	*(_ns8__getPurposeByGuidResponse*)p = *(_ns8__getPurposeByGuidResponse*)q;
}

void _ns8__getPurposeByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->_ns8__getPurposeByGuidRequest::base__guid);
	/* transient soap skipped */
}

void _ns8__getPurposeByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->_ns8__getPurposeByGuidRequest::base__guid);
	/* transient soap skipped */
}

int _ns8__getPurposeByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns8__getPurposeByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ns8__getPurposeByGuidRequest(struct soap *soap, const char *tag, int id, const _ns8__getPurposeByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__getPurposeByGuidRequest), type))
		return soap->error;
	if(a->_ns8__getPurposeByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->_ns8__getPurposeByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns8__getPurposeByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns8__getPurposeByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidRequest * FASTCALL soap_in__ns8__getPurposeByGuidRequest(struct soap *soap, const char *tag, _ns8__getPurposeByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns8__getPurposeByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__getPurposeByGuidRequest, sizeof(_ns8__getPurposeByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ns8__getPurposeByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ns8__getPurposeByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base__guid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->_ns8__getPurposeByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ns8__getPurposeByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__getPurposeByGuidRequest, 0, sizeof(_ns8__getPurposeByGuidRequest), 0, soap_copy__ns8__getPurposeByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_base__guid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns8__getPurposeByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns8__getPurposeByGuidRequest);
	return this->soap_out(soap, tag?tag:"ns8:getPurposeByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ns8__getPurposeByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns8__getPurposeByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns8__getPurposeByGuidRequest * SOAP_FMAC4 soap_get__ns8__getPurposeByGuidRequest(struct soap *soap, _ns8__getPurposeByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ns8__getPurposeByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns8__getPurposeByGuidRequest * FASTCALL soap_instantiate__ns8__getPurposeByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns8__getPurposeByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns8__getPurposeByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidRequest);
		ASSIGN_PTR(size, sizeof(_ns8__getPurposeByGuidRequest));
		((_ns8__getPurposeByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ns8__getPurposeByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ns8__getPurposeByGuidRequest));
		for(int i = 0; i < n; i++)
			((_ns8__getPurposeByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns8__getPurposeByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns8__getPurposeByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns8__getPurposeByGuidRequest %p -> %p\n", q, p));
	*(_ns8__getPurposeByGuidRequest*)p = *(_ns8__getPurposeByGuidRequest*)q;
}

void vd__WorkingArea::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__WorkingArea::__union_WorkingArea = 0;
	/* transient soap skipped */
}

void vd__WorkingArea::soap_serialize(struct soap *soap) const
{
	soap_serialize__vd__union_WorkingArea(soap, this->vd__WorkingArea::__union_WorkingArea, &this->vd__WorkingArea::union_WorkingArea);
	/* transient soap skipped */
}

int vd__WorkingArea::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__WorkingArea(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__WorkingArea(struct soap *soap, const char *tag, int id, const vd__WorkingArea *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__WorkingArea), type))
		return soap->error;
	if(soap_out__vd__union_WorkingArea(soap, a->vd__WorkingArea::__union_WorkingArea, &a->vd__WorkingArea::union_WorkingArea))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__WorkingArea::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__WorkingArea(soap, tag, this, type);
}

SOAP_FMAC3 vd__WorkingArea * FASTCALL soap_in_vd__WorkingArea(struct soap *soap, const char *tag, vd__WorkingArea *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__WorkingArea *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__WorkingArea, sizeof(vd__WorkingArea), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	a->soap_default(soap);
	if(!tag || *tag == '-' || (soap->body && !*soap->href)) {
	
		if(!soap_in__vd__union_WorkingArea(soap, &a->__union_WorkingArea, &a->union_WorkingArea))
			return NULL;
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__WorkingArea *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__WorkingArea, 0, sizeof(vd__WorkingArea), 0, soap_copy_vd__WorkingArea);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__WorkingArea::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__WorkingArea);
	return this->soap_out(soap, tag?tag:"vd:WorkingArea", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__WorkingArea::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__WorkingArea(soap, this, tag, type);
}

SOAP_FMAC3 vd__WorkingArea * SOAP_FMAC4 soap_get_vd__WorkingArea(struct soap *soap, vd__WorkingArea *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__WorkingArea * FASTCALL soap_instantiate_vd__WorkingArea(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__WorkingArea(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__WorkingArea, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingArea);
		ASSIGN_PTR(size, sizeof(vd__WorkingArea));
		((vd__WorkingArea*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingArea[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__WorkingArea));
		for(int i = 0; i < n; i++)
			((vd__WorkingArea*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__WorkingArea*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__WorkingArea(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__WorkingArea %p -> %p\n", q, p));
	*(vd__WorkingArea*)p = *(vd__WorkingArea*)q;
}

void vd__UserAuthority::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->vd__UserAuthority::ID);
	soap_default_base__String255(soap, &this->vd__UserAuthority::name);
	this->vd__UserAuthority::granted = NULL;
	/* transient soap skipped */
}

void vd__UserAuthority::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__NCName(soap, &this->vd__UserAuthority::ID);
	soap_serialize_base__String255(soap, &this->vd__UserAuthority::name);
	soap_serialize_PointerTobool(soap, &this->vd__UserAuthority::granted);
	/* transient soap skipped */
}

int vd__UserAuthority::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__UserAuthority(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__UserAuthority(struct soap *soap, const char *tag, int id, const vd__UserAuthority *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__UserAuthority), type))
		return soap->error;
	if(a->vd__UserAuthority::ID) {
		if(soap_out_xsd__NCName(soap, "vd:ID", -1, &a->vd__UserAuthority::ID, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:ID"))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__UserAuthority::name), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:granted", -1, &(a->vd__UserAuthority::granted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__UserAuthority::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__UserAuthority(soap, tag, this, type);
}

SOAP_FMAC3 vd__UserAuthority * FASTCALL soap_in_vd__UserAuthority(struct soap *soap, const char *tag, vd__UserAuthority *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__UserAuthority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__UserAuthority, sizeof(vd__UserAuthority), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__UserAuthority) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__UserAuthority *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_granted1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__NCName(soap, "vd:ID", &(a->vd__UserAuthority::ID), "xsd:NCName"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__UserAuthority::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_granted1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:granted", &(a->vd__UserAuthority::granted), "xsd:boolean"))
				{	soap_flag_granted1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__UserAuthority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__UserAuthority, 0, sizeof(vd__UserAuthority), 0, soap_copy_vd__UserAuthority);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__UserAuthority::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__UserAuthority);
	return this->soap_out(soap, tag?tag:"vd:UserAuthority", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__UserAuthority::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__UserAuthority(soap, this, tag, type);
}

SOAP_FMAC3 vd__UserAuthority * SOAP_FMAC4 soap_get_vd__UserAuthority(struct soap *soap, vd__UserAuthority *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__UserAuthority * FASTCALL soap_instantiate_vd__UserAuthority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__UserAuthority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__UserAuthority, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__UserAuthority);
		ASSIGN_PTR(size, sizeof(vd__UserAuthority));
		((vd__UserAuthority*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__UserAuthority[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__UserAuthority));
		for(int i = 0; i < n; i++)
			((vd__UserAuthority*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__UserAuthority*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__UserAuthority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__UserAuthority %p -> %p\n", q, p));
	*(vd__UserAuthority*)p = *(vd__UserAuthority*)q;
}

void vd__WorkingAreaList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__WorkingAreaList::__sizeworkingArea = 0;
	this->vd__WorkingAreaList::workingArea = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__WorkingAreaList::soap_serialize(struct soap *soap) const
{
	if(this->vd__WorkingAreaList::workingArea) {
		for(int i = 0; i < this->vd__WorkingAreaList::__sizeworkingArea; i++) {
			soap_serialize_PointerTovd__WorkingArea(soap, this->vd__WorkingAreaList::workingArea + i);
		}
	}
	/* transient soap skipped */
}

int vd__WorkingAreaList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__WorkingAreaList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__WorkingAreaList(struct soap *soap, const char *tag, int id, const vd__WorkingAreaList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__WorkingAreaList), "vd:WorkingAreaList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__WorkingAreaList::workingArea) {
		int i;
		for(i = 0; i < a->vd__WorkingAreaList::__sizeworkingArea; i++)
			if(soap_out_PointerTovd__WorkingArea(soap, "vd:workingArea", -1, a->vd__WorkingAreaList::workingArea + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__WorkingAreaList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__WorkingAreaList(soap, tag, this, type);
}

SOAP_FMAC3 vd__WorkingAreaList * FASTCALL soap_in_vd__WorkingAreaList(struct soap *soap, const char *tag, vd__WorkingAreaList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__WorkingAreaList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__WorkingAreaList, sizeof(vd__WorkingAreaList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__WorkingAreaList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__WorkingAreaList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_workingArea1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:workingArea", 1, NULL)) {
				if(a->vd__WorkingAreaList::workingArea == NULL) {
					if(soap_blist_workingArea1 == NULL)
						soap_blist_workingArea1 = soap_new_block(soap);
					a->vd__WorkingAreaList::workingArea = (vd__WorkingArea **)soap_push_block(soap, soap_blist_workingArea1, sizeof(vd__WorkingArea *));
					if(a->vd__WorkingAreaList::workingArea == NULL)
						return NULL;
					*a->vd__WorkingAreaList::workingArea = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__WorkingArea(soap, "vd:workingArea", a->vd__WorkingAreaList::workingArea, "vd:WorkingArea"))
				{	a->vd__WorkingAreaList::__sizeworkingArea++;
					a->vd__WorkingAreaList::workingArea = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__WorkingAreaList::workingArea)
			soap_pop_block(soap, soap_blist_workingArea1);
		if(a->vd__WorkingAreaList::__sizeworkingArea)
			a->vd__WorkingAreaList::workingArea = (vd__WorkingArea **)soap_save_block(soap, soap_blist_workingArea1, NULL, 1);
		else
		{	a->vd__WorkingAreaList::workingArea = NULL;
			if(soap_blist_workingArea1)
				soap_end_block(soap, soap_blist_workingArea1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__WorkingAreaList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__WorkingAreaList, 0, sizeof(vd__WorkingAreaList), 0, soap_copy_vd__WorkingAreaList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__WorkingAreaList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__WorkingAreaList);
	return this->soap_out(soap, tag?tag:"vd:WorkingAreaList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__WorkingAreaList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__WorkingAreaList(soap, this, tag, type);
}

SOAP_FMAC3 vd__WorkingAreaList * SOAP_FMAC4 soap_get_vd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__WorkingAreaList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__WorkingAreaList * FASTCALL soap_instantiate_vd__WorkingAreaList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__WorkingAreaList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__WorkingAreaList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList);
		ASSIGN_PTR(size, sizeof(vd__WorkingAreaList));
		((vd__WorkingAreaList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__WorkingAreaList));
		for(int i = 0; i < n; i++)
			((vd__WorkingAreaList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__WorkingAreaList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__WorkingAreaList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__WorkingAreaList %p -> %p\n", q, p));
	*(vd__WorkingAreaList*)p = *(vd__WorkingAreaList*)q;
}

void vd__AuthorityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__AuthorityList::__sizeauthority = 0;
	this->vd__AuthorityList::authority = NULL;
	/* transient soap skipped */
}

void vd__AuthorityList::soap_serialize(struct soap *soap) const
{
	if(this->vd__AuthorityList::authority) {
		for(int i = 0; i < this->vd__AuthorityList::__sizeauthority; i++) {
			soap_serialize_PointerTovd__UserAuthority(soap, this->vd__AuthorityList::authority + i);
		}
	}
	/* transient soap skipped */
}

int vd__AuthorityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__AuthorityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__AuthorityList(struct soap *soap, const char *tag, int id, const vd__AuthorityList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__AuthorityList), type))
		return soap->error;
	if(a->vd__AuthorityList::authority) {
		int i;
		for(i = 0; i < a->vd__AuthorityList::__sizeauthority; i++)
			if(soap_out_PointerTovd__UserAuthority(soap, "vd:authority", -1, a->vd__AuthorityList::authority + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__AuthorityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__AuthorityList(soap, tag, this, type);
}

SOAP_FMAC3 vd__AuthorityList * FASTCALL soap_in_vd__AuthorityList(struct soap *soap, const char *tag, vd__AuthorityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__AuthorityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__AuthorityList, sizeof(vd__AuthorityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__AuthorityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__AuthorityList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_authority1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:authority", 1, NULL)) {
				if(a->vd__AuthorityList::authority == NULL) {
					if(soap_blist_authority1 == NULL)
						soap_blist_authority1 = soap_new_block(soap);
					a->vd__AuthorityList::authority = (vd__UserAuthority **)soap_push_block(soap, soap_blist_authority1, sizeof(vd__UserAuthority *));
					if(a->vd__AuthorityList::authority == NULL)
						return NULL;
					*a->vd__AuthorityList::authority = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__UserAuthority(soap, "vd:authority", a->vd__AuthorityList::authority, "vd:UserAuthority"))
				{	a->vd__AuthorityList::__sizeauthority++;
					a->vd__AuthorityList::authority = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__AuthorityList::authority)
			soap_pop_block(soap, soap_blist_authority1);
		if(a->vd__AuthorityList::__sizeauthority)
			a->vd__AuthorityList::authority = (vd__UserAuthority **)soap_save_block(soap, soap_blist_authority1, NULL, 1);
		else
		{	a->vd__AuthorityList::authority = NULL;
			if(soap_blist_authority1)
				soap_end_block(soap, soap_blist_authority1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__AuthorityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__AuthorityList, 0, sizeof(vd__AuthorityList), 0, soap_copy_vd__AuthorityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__AuthorityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__AuthorityList);
	return this->soap_out(soap, tag?tag:"vd:AuthorityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__AuthorityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__AuthorityList(soap, this, tag, type);
}

SOAP_FMAC3 vd__AuthorityList * SOAP_FMAC4 soap_get_vd__AuthorityList(struct soap *soap, vd__AuthorityList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__AuthorityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__AuthorityList * FASTCALL soap_instantiate_vd__AuthorityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__AuthorityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__AuthorityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__AuthorityList);
		ASSIGN_PTR(size, sizeof(vd__AuthorityList));
		((vd__AuthorityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__AuthorityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__AuthorityList));
		for(int i = 0; i < n; i++)
			((vd__AuthorityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__AuthorityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__AuthorityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__AuthorityList %p -> %p\n", q, p));
	*(vd__AuthorityList*)p = *(vd__AuthorityList*)q;
}

void vd__UserList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__UserList::__sizeuser = 0;
	this->vd__UserList::user = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__UserList::soap_serialize(struct soap *soap) const
{
	if(this->vd__UserList::user) {
		for(int i = 0; i < this->vd__UserList::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->vd__UserList::user + i);
		}
	}
	/* transient soap skipped */
}

int vd__UserList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__UserList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__UserList(struct soap *soap, const char *tag, int id, const vd__UserList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__UserList), "vd:UserList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__UserList::user) {
		int i;
		for(i = 0; i < a->vd__UserList::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->vd__UserList::user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__UserList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__UserList(soap, tag, this, type);
}

SOAP_FMAC3 vd__UserList * FASTCALL soap_in_vd__UserList(struct soap *soap, const char *tag, vd__UserList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__UserList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__UserList, sizeof(vd__UserList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__UserList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__UserList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->vd__UserList::user == NULL) {
					if(soap_blist_user1 == NULL)
						soap_blist_user1 = soap_new_block(soap);
					a->vd__UserList::user = (vd__User **)soap_push_block(soap, soap_blist_user1, sizeof(vd__User *));
					if(a->vd__UserList::user == NULL)
						return NULL;
					*a->vd__UserList::user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->vd__UserList::user, "vd:User"))
				{	a->vd__UserList::__sizeuser++;
					a->vd__UserList::user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__UserList::user)
			soap_pop_block(soap, soap_blist_user1);
		if(a->vd__UserList::__sizeuser)
			a->vd__UserList::user = (vd__User **)soap_save_block(soap, soap_blist_user1, NULL, 1);
		else
		{	a->vd__UserList::user = NULL;
			if(soap_blist_user1)
				soap_end_block(soap, soap_blist_user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__UserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__UserList, 0, sizeof(vd__UserList), 0, soap_copy_vd__UserList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__UserList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__UserList);
	return this->soap_out(soap, tag?tag:"vd:UserList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__UserList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__UserList(soap, this, tag, type);
}

SOAP_FMAC3 vd__UserList * SOAP_FMAC4 soap_get_vd__UserList(struct soap *soap, vd__UserList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__UserList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__UserList * FASTCALL soap_instantiate_vd__UserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__UserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__UserList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__UserList);
		ASSIGN_PTR(size, sizeof(vd__UserList));
		((vd__UserList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__UserList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__UserList));
		for(int i = 0; i < n; i++)
			((vd__UserList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__UserList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__UserList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__UserList %p -> %p\n", q, p));
	*(vd__UserList*)p = *(vd__UserList*)q;
}

void vd__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->vd__User::login);
	soap_default_base__String255(soap, &this->vd__User::fio);
	soap_default_xsd__date(soap, &this->vd__User::birthDate);
	this->vd__User::identity = NULL;
	this->vd__User::snils = NULL;
	soap_default_base__String255(soap, &this->vd__User::phone);
	soap_default_base__String255(soap, &this->vd__User::workPhone);
	soap_default_base__String255(soap, &this->vd__User::email);
	soap_default_base__String255(soap, &this->vd__User::workEmail);
	this->vd__User::__union_User = 0;
	soap_default_base__String255(soap, &this->vd__User::post);
	this->vd__User::enabled = NULL;
	this->vd__User::nonExpired = NULL;
	this->vd__User::nonLocked = NULL;
	this->vd__User::authorityList = NULL;
	this->vd__User::workingAreaList = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__User::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__NCName(soap, &this->vd__User::login);
	soap_serialize_base__String255(soap, &this->vd__User::fio);
	soap_serialize_xsd__date(soap, &this->vd__User::birthDate);
	soap_serialize_PointerTovd__Document(soap, &this->vd__User::identity);
	soap_serialize_PointerTovd__SNILSType(soap, &this->vd__User::snils);
	soap_serialize_base__String255(soap, &this->vd__User::phone);
	soap_serialize_base__String255(soap, &this->vd__User::workPhone);
	soap_serialize_base__String255(soap, &this->vd__User::email);
	soap_serialize_base__String255(soap, &this->vd__User::workEmail);
	soap_serialize__vd__union_User(soap, this->vd__User::__union_User, &this->vd__User::union_User);
	soap_serialize_base__String255(soap, &this->vd__User::post);
	soap_serialize_PointerTobool(soap, &this->vd__User::enabled);
	soap_serialize_PointerTobool(soap, &this->vd__User::nonExpired);
	soap_serialize_PointerTobool(soap, &this->vd__User::nonLocked);
	soap_serialize_PointerTovd__AuthorityList(soap, &this->vd__User::authorityList);
	soap_serialize_PointerTovd__WorkingAreaList(soap, &this->vd__User::workingAreaList);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__User(struct soap *soap, const char *tag, int id, const vd__User *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__User), "vd:User"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_xsd__NCName(soap, "vd:login", -1, &(a->vd__User::login), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:fio", -1, &(a->vd__User::fio), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:birthDate", -1, &(a->vd__User::birthDate), ""))
		return soap->error;
	if(soap_out_PointerTovd__Document(soap, "vd:identity", -1, &(a->vd__User::identity), ""))
		return soap->error;
	if(soap_out_PointerTovd__SNILSType(soap, "vd:snils", -1, &(a->vd__User::snils), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:phone", -1, &(a->vd__User::phone), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:workPhone", -1, &(a->vd__User::workPhone), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:email", -1, &(a->vd__User::email), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:workEmail", -1, &(a->vd__User::workEmail), ""))
		return soap->error;
	if(soap_out__vd__union_User(soap, a->vd__User::__union_User, &a->vd__User::union_User))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:post", -1, &(a->vd__User::post), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:enabled", -1, &(a->vd__User::enabled), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:nonExpired", -1, &(a->vd__User::nonExpired), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:nonLocked", -1, &(a->vd__User::nonLocked), ""))
		return soap->error;
	if(soap_out_PointerTovd__AuthorityList(soap, "vd:authorityList", -1, &(a->vd__User::authorityList), ""))
		return soap->error;
	if(soap_out_PointerTovd__WorkingAreaList(soap, "vd:workingAreaList", -1, &(a->vd__User::workingAreaList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__User::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__User(soap, tag, this, type);
}

SOAP_FMAC3 vd__User * FASTCALL soap_in_vd__User(struct soap *soap, const char *tag, vd__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__User, sizeof(vd__User), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__User) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__User *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_login1 = 1;
	size_t soap_flag_fio1 = 1;
	size_t soap_flag_birthDate1 = 1;
	size_t soap_flag_identity1 = 1;
	size_t soap_flag_snils1 = 1;
	size_t soap_flag_phone1 = 1;
	size_t soap_flag_workPhone1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_workEmail1 = 1;
	size_t soap_flag_union_User1 = 1;
	size_t soap_flag_post1 = 1;
	size_t soap_flag_enabled1 = 1;
	size_t soap_flag_nonExpired1 = 1;
	size_t soap_flag_nonLocked1 = 1;
	size_t soap_flag_authorityList1 = 1;
	size_t soap_flag_workingAreaList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__NCName(soap, "vd:login", &(a->vd__User::login), "xsd:NCName"))
				{	soap_flag_login1--;
					continue;
				}
			if(soap_flag_fio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:fio", &(a->vd__User::fio), "base:String255"))
				{	soap_flag_fio1--;
					continue;
				}
			if(soap_flag_birthDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:birthDate", &(a->vd__User::birthDate), "xsd:date"))
				{	soap_flag_birthDate1--;
					continue;
				}
			if(soap_flag_identity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Document(soap, "vd:identity", &(a->vd__User::identity), "vd:Document"))
				{	soap_flag_identity1--;
					continue;
				}
			if(soap_flag_snils1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__SNILSType(soap, "vd:snils", &(a->vd__User::snils), "vd:SNILSType"))
				{	soap_flag_snils1--;
					continue;
				}
			if(soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:phone", &(a->vd__User::phone), "base:String255"))
				{	soap_flag_phone1--;
					continue;
				}
			if(soap_flag_workPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:workPhone", &(a->vd__User::workPhone), "base:String255"))
				{	soap_flag_workPhone1--;
					continue;
				}
			if(soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:email", &(a->vd__User::email), "base:String255"))
				{	soap_flag_email1--;
					continue;
				}
			if(soap_flag_workEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:workEmail", &(a->vd__User::workEmail), "base:String255"))
				{	soap_flag_workEmail1--;
					continue;
				}
			if(soap_flag_union_User1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_User(soap, &a->vd__User::__union_User, &a->vd__User::union_User))
				{	soap_flag_union_User1 = 0;
					continue;
				}
			if(soap_flag_post1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:post", &(a->vd__User::post), "base:String255"))
				{	soap_flag_post1--;
					continue;
				}
			if(soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:enabled", &(a->vd__User::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if(soap_flag_nonExpired1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:nonExpired", &(a->vd__User::nonExpired), "xsd:boolean"))
				{	soap_flag_nonExpired1--;
					continue;
				}
			if(soap_flag_nonLocked1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:nonLocked", &(a->vd__User::nonLocked), "xsd:boolean"))
				{	soap_flag_nonLocked1--;
					continue;
				}
			if(soap_flag_authorityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__AuthorityList(soap, "vd:authorityList", &(a->vd__User::authorityList), "vd:AuthorityList"))
				{	soap_flag_authorityList1--;
					continue;
				}
			if(soap_flag_workingAreaList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__WorkingAreaList(soap, "vd:workingAreaList", &(a->vd__User::workingAreaList), "vd:WorkingAreaList"))
				{	soap_flag_workingAreaList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__User, 0, sizeof(vd__User), 0, soap_copy_vd__User);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_User1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__User);
	return this->soap_out(soap, tag?tag:"vd:User", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__User(soap, this, tag, type);
}

SOAP_FMAC3 vd__User * SOAP_FMAC4 soap_get_vd__User(struct soap *soap, vd__User *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__User * FASTCALL soap_instantiate_vd__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__User, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__User);
		ASSIGN_PTR(size, sizeof(vd__User));
		((vd__User*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__User[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__User));
		for(int i = 0; i < n; i++)
			((vd__User*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__User %p -> %p\n", q, p));
	*(vd__User*)p = *(vd__User*)q;
}

void vd__ProcessingProcedure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_vd__ProcessingProcedureType(soap, &this->vd__ProcessingProcedure::type);
	this->vd__ProcessingProcedure::startDateTime = NULL;
	this->vd__ProcessingProcedure::endDateTime = NULL;
	/* transient soap skipped */
}

void vd__ProcessingProcedure::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->vd__ProcessingProcedure::startDateTime);
	soap_serialize_PointerTotime(soap, &this->vd__ProcessingProcedure::endDateTime);
	/* transient soap skipped */
}

int vd__ProcessingProcedure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ProcessingProcedure(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProcessingProcedure(struct soap *soap, const char *tag, int id, const vd__ProcessingProcedure *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProcessingProcedure), type))
		return soap->error;
	if(soap_out_vd__ProcessingProcedureType(soap, "vd:type", -1, &(a->vd__ProcessingProcedure::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:startDateTime", -1, &(a->vd__ProcessingProcedure::startDateTime), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:endDateTime", -1, &(a->vd__ProcessingProcedure::endDateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ProcessingProcedure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ProcessingProcedure(soap, tag, this, type);
}

SOAP_FMAC3 vd__ProcessingProcedure * FASTCALL soap_in_vd__ProcessingProcedure(struct soap *soap, const char *tag, vd__ProcessingProcedure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ProcessingProcedure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProcessingProcedure, sizeof(vd__ProcessingProcedure), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ProcessingProcedure) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ProcessingProcedure *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_startDateTime1 = 1;
	size_t soap_flag_endDateTime1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__ProcessingProcedureType(soap, "vd:type", &(a->vd__ProcessingProcedure::type), "vd:ProcessingProcedureType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_startDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:startDateTime", &(a->vd__ProcessingProcedure::startDateTime), "xsd:dateTime"))
				{	soap_flag_startDateTime1--;
					continue;
				}
			if(soap_flag_endDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:endDateTime", &(a->vd__ProcessingProcedure::endDateTime), "xsd:dateTime"))
				{	soap_flag_endDateTime1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ProcessingProcedure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProcessingProcedure, 0, sizeof(vd__ProcessingProcedure), 0, soap_copy_vd__ProcessingProcedure);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__ProcessingProcedure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ProcessingProcedure);
	return this->soap_out(soap, tag?tag:"vd:ProcessingProcedure", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ProcessingProcedure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ProcessingProcedure(soap, this, tag, type);
}

SOAP_FMAC3 vd__ProcessingProcedure * SOAP_FMAC4 soap_get_vd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ProcessingProcedure * FASTCALL soap_instantiate_vd__ProcessingProcedure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ProcessingProcedure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ProcessingProcedure, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ProcessingProcedure);
		ASSIGN_PTR(size, sizeof(vd__ProcessingProcedure));
		((vd__ProcessingProcedure*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ProcessingProcedure[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ProcessingProcedure));
		for(int i = 0; i < n; i++)
			((vd__ProcessingProcedure*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ProcessingProcedure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ProcessingProcedure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ProcessingProcedure %p -> %p\n", q, p));
	*(vd__ProcessingProcedure*)p = *(vd__ProcessingProcedure*)q;
}

void vd__RouteSectionR13nRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__RouteSectionR13nRules::sqnId = NULL;
	this->vd__RouteSectionR13nRules::__sizeappliedR13nRule = 0;
	this->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
	/* transient soap skipped */
}

void vd__RouteSectionR13nRules::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__SequenceNumber(soap, &this->vd__RouteSectionR13nRules::sqnId);
	if(this->vd__RouteSectionR13nRules::appliedR13nRule) {
		for(int i = 0; i < this->vd__RouteSectionR13nRules::__sizeappliedR13nRule; i++) {
			soap_serialize_PointerToent__RegionalizationShippingRule(soap, this->vd__RouteSectionR13nRules::appliedR13nRule + i);
		}
	}
	/* transient soap skipped */
}

int vd__RouteSectionR13nRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__RouteSectionR13nRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, const vd__RouteSectionR13nRules *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__RouteSectionR13nRules), type))
		return soap->error;
	if(soap_out_PointerTobase__SequenceNumber(soap, "vd:sqnId", -1, &(a->vd__RouteSectionR13nRules::sqnId), ""))
		return soap->error;
	if(a->vd__RouteSectionR13nRules::appliedR13nRule) {
		int i;
		for(i = 0; i < a->vd__RouteSectionR13nRules::__sizeappliedR13nRule; i++)
			if(soap_out_PointerToent__RegionalizationShippingRule(soap, "vd:appliedR13nRule", -1, a->vd__RouteSectionR13nRules::appliedR13nRule + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__RouteSectionR13nRules::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__RouteSectionR13nRules(soap, tag, this, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules * FASTCALL soap_in_vd__RouteSectionR13nRules(struct soap *soap, const char *tag, vd__RouteSectionR13nRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__RouteSectionR13nRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__RouteSectionR13nRules, sizeof(vd__RouteSectionR13nRules), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__RouteSectionR13nRules) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__RouteSectionR13nRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sqnId1 = 1;
	struct soap_blist *soap_blist_appliedR13nRule1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_sqnId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__SequenceNumber(soap, "vd:sqnId", &(a->vd__RouteSectionR13nRules::sqnId), "base:SequenceNumber"))
				{	soap_flag_sqnId1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:appliedR13nRule", 1, NULL)) {
				if(a->vd__RouteSectionR13nRules::appliedR13nRule == NULL) {
					if(soap_blist_appliedR13nRule1 == NULL)
						soap_blist_appliedR13nRule1 = soap_new_block(soap);
					a->vd__RouteSectionR13nRules::appliedR13nRule = (ent__RegionalizationShippingRule **)soap_push_block(soap, soap_blist_appliedR13nRule1, sizeof(ent__RegionalizationShippingRule *));
					if(a->vd__RouteSectionR13nRules::appliedR13nRule == NULL)
						return NULL;
					*a->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationShippingRule(soap, "vd:appliedR13nRule", a->vd__RouteSectionR13nRules::appliedR13nRule, "ent:RegionalizationShippingRule"))
				{	a->vd__RouteSectionR13nRules::__sizeappliedR13nRule++;
					a->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__RouteSectionR13nRules::appliedR13nRule)
			soap_pop_block(soap, soap_blist_appliedR13nRule1);
		if(a->vd__RouteSectionR13nRules::__sizeappliedR13nRule)
			a->vd__RouteSectionR13nRules::appliedR13nRule = (ent__RegionalizationShippingRule **)soap_save_block(soap, soap_blist_appliedR13nRule1, NULL, 1);
		else
		{	a->vd__RouteSectionR13nRules::appliedR13nRule = NULL;
			if(soap_blist_appliedR13nRule1)
				soap_end_block(soap, soap_blist_appliedR13nRule1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__RouteSectionR13nRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__RouteSectionR13nRules, 0, sizeof(vd__RouteSectionR13nRules), 0, soap_copy_vd__RouteSectionR13nRules);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__RouteSectionR13nRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__RouteSectionR13nRules);
	return this->soap_out(soap, tag?tag:"vd:RouteSectionR13nRules", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__RouteSectionR13nRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__RouteSectionR13nRules(soap, this, tag, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules * SOAP_FMAC4 soap_get_vd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__RouteSectionR13nRules * FASTCALL soap_instantiate_vd__RouteSectionR13nRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__RouteSectionR13nRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__RouteSectionR13nRules, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__RouteSectionR13nRules);
		ASSIGN_PTR(size, sizeof(vd__RouteSectionR13nRules));
		((vd__RouteSectionR13nRules*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__RouteSectionR13nRules[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__RouteSectionR13nRules));
		for(int i = 0; i < n; i++)
			((vd__RouteSectionR13nRules*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__RouteSectionR13nRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__RouteSectionR13nRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__RouteSectionR13nRules %p -> %p\n", q, p));
	*(vd__RouteSectionR13nRules*)p = *(vd__RouteSectionR13nRules*)q;
}

void vd__RegionalizationClause::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__RegionalizationClause::condition = NULL;
	soap_default_base__Text(soap, &this->vd__RegionalizationClause::text);
	/* transient soap skipped */
}

void vd__RegionalizationClause::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__RegionalizationCondition(soap, &this->vd__RegionalizationClause::condition);
	soap_serialize_base__Text(soap, &this->vd__RegionalizationClause::text);
	/* transient soap skipped */
}

int vd__RegionalizationClause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__RegionalizationClause(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__RegionalizationClause(struct soap *soap, const char *tag, int id, const vd__RegionalizationClause *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__RegionalizationClause), type))
		return soap->error;
	if(a->vd__RegionalizationClause::condition) {
		if(soap_out_PointerToent__RegionalizationCondition(soap, "vd:condition", -1, &a->vd__RegionalizationClause::condition, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:condition"))
		return soap->error;
	if(soap_out_base__Text(soap, "vd:text", -1, &(a->vd__RegionalizationClause::text), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__RegionalizationClause::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__RegionalizationClause(soap, tag, this, type);
}

SOAP_FMAC3 vd__RegionalizationClause * FASTCALL soap_in_vd__RegionalizationClause(struct soap *soap, const char *tag, vd__RegionalizationClause *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__RegionalizationClause *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__RegionalizationClause, sizeof(vd__RegionalizationClause), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__RegionalizationClause) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__RegionalizationClause *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_condition1 = 1;
	size_t soap_flag_text1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_condition1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationCondition(soap, "vd:condition", &(a->vd__RegionalizationClause::condition), "ent:RegionalizationCondition"))
				{	soap_flag_condition1--;
					continue;
				}
			if(soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:text", &(a->vd__RegionalizationClause::text), "base:Text"))
				{	soap_flag_text1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__RegionalizationClause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__RegionalizationClause, 0, sizeof(vd__RegionalizationClause), 0, soap_copy_vd__RegionalizationClause);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_condition1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__RegionalizationClause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__RegionalizationClause);
	return this->soap_out(soap, tag?tag:"vd:RegionalizationClause", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__RegionalizationClause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__RegionalizationClause(soap, this, tag, type);
}

SOAP_FMAC3 vd__RegionalizationClause * SOAP_FMAC4 soap_get_vd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__RegionalizationClause * FASTCALL soap_instantiate_vd__RegionalizationClause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__RegionalizationClause(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__RegionalizationClause, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__RegionalizationClause);
		ASSIGN_PTR(size, sizeof(vd__RegionalizationClause));
		((vd__RegionalizationClause*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__RegionalizationClause[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__RegionalizationClause));
		for(int i = 0; i < n; i++)
			((vd__RegionalizationClause*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__RegionalizationClause*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__RegionalizationClause(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__RegionalizationClause %p -> %p\n", q, p));
	*(vd__RegionalizationClause*)p = *(vd__RegionalizationClause*)q;
}

void vd__VetDocumentStatusChange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_vd__VetDocumentStatus(soap, &this->vd__VetDocumentStatusChange::status);
	this->vd__VetDocumentStatusChange::specifiedPerson = NULL;
	soap_default_time(soap, &this->vd__VetDocumentStatusChange::actualDateTime);
	soap_default_vd__VetDocumentStatusChangeReason(soap, &this->vd__VetDocumentStatusChange::reason);
	/* transient soap skipped */
}

void vd__VetDocumentStatusChange::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__VetDocumentStatusChange::status, SOAP_TYPE_vd__VetDocumentStatus);
	soap_serialize_PointerTovd__User(soap, &this->vd__VetDocumentStatusChange::specifiedPerson);
	soap_embedded(soap, &this->vd__VetDocumentStatusChange::actualDateTime, SOAP_TYPE_time);
	soap_serialize_vd__VetDocumentStatusChangeReason(soap, &this->vd__VetDocumentStatusChange::reason);
	/* transient soap skipped */
}

int vd__VetDocumentStatusChange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VetDocumentStatusChange(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, const vd__VetDocumentStatusChange *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentStatusChange), type))
		return soap->error;
	if(soap_out_vd__VetDocumentStatus(soap, "vd:status", -1, &(a->vd__VetDocumentStatusChange::status), ""))
		return soap->error;
	if(a->vd__VetDocumentStatusChange::specifiedPerson) {
		if(soap_out_PointerTovd__User(soap, "vd:specifiedPerson", -1, &a->vd__VetDocumentStatusChange::specifiedPerson, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:specifiedPerson"))
		return soap->error;
	if(soap_out_time(soap, "vd:actualDateTime", -1, &(a->vd__VetDocumentStatusChange::actualDateTime), ""))
		return soap->error;
	if(soap_out_vd__VetDocumentStatusChangeReason(soap, "vd:reason", -1, &(a->vd__VetDocumentStatusChange::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__VetDocumentStatusChange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VetDocumentStatusChange(soap, tag, this, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange * FASTCALL soap_in_vd__VetDocumentStatusChange(struct soap *soap, const char *tag, vd__VetDocumentStatusChange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VetDocumentStatusChange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentStatusChange, sizeof(vd__VetDocumentStatusChange), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VetDocumentStatusChange) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VetDocumentStatusChange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_specifiedPerson1 = 1;
	size_t soap_flag_actualDateTime1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__VetDocumentStatus(soap, "vd:status", &(a->vd__VetDocumentStatusChange::status), "vd:VetDocumentStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_specifiedPerson1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:specifiedPerson", &(a->vd__VetDocumentStatusChange::specifiedPerson), "vd:User"))
				{	soap_flag_specifiedPerson1--;
					continue;
				}
			if(soap_flag_actualDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "vd:actualDateTime", &(a->vd__VetDocumentStatusChange::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__VetDocumentStatusChangeReason(soap, "vd:reason", &(a->vd__VetDocumentStatusChange::reason), "vd:VetDocumentStatusChangeReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VetDocumentStatusChange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentStatusChange, 0, sizeof(vd__VetDocumentStatusChange), 0, soap_copy_vd__VetDocumentStatusChange);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0 || soap_flag_specifiedPerson1 > 0 || soap_flag_actualDateTime1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__VetDocumentStatusChange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentStatusChange);
	return this->soap_out(soap, tag?tag:"vd:VetDocumentStatusChange", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VetDocumentStatusChange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VetDocumentStatusChange(soap, this, tag, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange * SOAP_FMAC4 soap_get_vd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VetDocumentStatusChange * FASTCALL soap_instantiate_vd__VetDocumentStatusChange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VetDocumentStatusChange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VetDocumentStatusChange, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentStatusChange);
		ASSIGN_PTR(size, sizeof(vd__VetDocumentStatusChange));
		((vd__VetDocumentStatusChange*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentStatusChange[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VetDocumentStatusChange));
		for(int i = 0; i < n; i++)
			((vd__VetDocumentStatusChange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VetDocumentStatusChange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VetDocumentStatusChange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VetDocumentStatusChange %p -> %p\n", q, p));
	*(vd__VetDocumentStatusChange*)p = *(vd__VetDocumentStatusChange*)q;
}

void vd__StockEntryEventList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockEntryEventList::__sizelaboratoryResearch = 0;
	this->vd__StockEntryEventList::laboratoryResearch = NULL;
	this->vd__StockEntryEventList::__sizequarantine = 0;
	this->vd__StockEntryEventList::quarantine = NULL;
	this->vd__StockEntryEventList::__sizeimmunization = 0;
	this->vd__StockEntryEventList::immunization = NULL;
	this->vd__StockEntryEventList::__sizeveterinaryEvent = 0;
	this->vd__StockEntryEventList::veterinaryEvent = NULL;
	/* transient soap skipped */
}

void vd__StockEntryEventList::soap_serialize(struct soap *soap) const
{
	if(this->vd__StockEntryEventList::laboratoryResearch) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizelaboratoryResearch; i++) {
			soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, this->vd__StockEntryEventList::laboratoryResearch + i);
		}
	}
	if(this->vd__StockEntryEventList::quarantine) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizequarantine; i++) {
			soap_serialize_PointerTovd__QuarantineEvent(soap, this->vd__StockEntryEventList::quarantine + i);
		}
	}
	if(this->vd__StockEntryEventList::immunization) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizeimmunization; i++) {
			soap_serialize_PointerTovd__AnimalMedicationEvent(soap, this->vd__StockEntryEventList::immunization + i);
		}
	}
	if(this->vd__StockEntryEventList::veterinaryEvent) {
		for(int i = 0; i < this->vd__StockEntryEventList::__sizeveterinaryEvent; i++) {
			soap_serialize_PointerTovd__VeterinaryEvent(soap, this->vd__StockEntryEventList::veterinaryEvent + i);
		}
	}
	/* transient soap skipped */
}

int vd__StockEntryEventList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntryEventList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryEventList(struct soap *soap, const char *tag, int id, const vd__StockEntryEventList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntryEventList), type))
		return soap->error;
	if(a->vd__StockEntryEventList::laboratoryResearch) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizelaboratoryResearch; i++)
			if(soap_out_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", -1, a->vd__StockEntryEventList::laboratoryResearch + i, ""))
				return soap->error;
	}
	if(a->vd__StockEntryEventList::quarantine) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizequarantine; i++)
			if(soap_out_PointerTovd__QuarantineEvent(soap, "vd:quarantine", -1, a->vd__StockEntryEventList::quarantine + i, ""))
				return soap->error;
	}
	if(a->vd__StockEntryEventList::immunization) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizeimmunization; i++)
			if(soap_out_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", -1, a->vd__StockEntryEventList::immunization + i, ""))
				return soap->error;
	}
	if(a->vd__StockEntryEventList::veterinaryEvent) {
		int i;
		for(i = 0; i < a->vd__StockEntryEventList::__sizeveterinaryEvent; i++)
			if(soap_out_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", -1, a->vd__StockEntryEventList::veterinaryEvent + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntryEventList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntryEventList(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntryEventList * FASTCALL soap_in_vd__StockEntryEventList(struct soap *soap, const char *tag, vd__StockEntryEventList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntryEventList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntryEventList, sizeof(vd__StockEntryEventList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntryEventList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntryEventList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_laboratoryResearch1 = NULL;
	struct soap_blist *soap_blist_quarantine1 = NULL;
	struct soap_blist *soap_blist_immunization1 = NULL;
	struct soap_blist *soap_blist_veterinaryEvent1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:laboratoryResearch", 1, NULL)) {
				if(a->vd__StockEntryEventList::laboratoryResearch == NULL) {
					if(soap_blist_laboratoryResearch1 == NULL)
						soap_blist_laboratoryResearch1 = soap_new_block(soap);
					a->vd__StockEntryEventList::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_push_block(soap, soap_blist_laboratoryResearch1, sizeof(vd__LaboratoryResearchEvent *));
					if(a->vd__StockEntryEventList::laboratoryResearch == NULL)
						return NULL;
					*a->vd__StockEntryEventList::laboratoryResearch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", a->vd__StockEntryEventList::laboratoryResearch, "vd:LaboratoryResearchEvent"))
				{	a->vd__StockEntryEventList::__sizelaboratoryResearch++;
					a->vd__StockEntryEventList::laboratoryResearch = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:quarantine", 1, NULL)) {
				if(a->vd__StockEntryEventList::quarantine == NULL) {
					if(soap_blist_quarantine1 == NULL)
						soap_blist_quarantine1 = soap_new_block(soap);
					a->vd__StockEntryEventList::quarantine = (vd__QuarantineEvent **)soap_push_block(soap, soap_blist_quarantine1, sizeof(vd__QuarantineEvent *));
					if(a->vd__StockEntryEventList::quarantine == NULL)
						return NULL;
					*a->vd__StockEntryEventList::quarantine = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__QuarantineEvent(soap, "vd:quarantine", a->vd__StockEntryEventList::quarantine, "vd:QuarantineEvent"))
				{	a->vd__StockEntryEventList::__sizequarantine++;
					a->vd__StockEntryEventList::quarantine = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:immunization", 1, NULL)) {
				if(a->vd__StockEntryEventList::immunization == NULL) {
					if(soap_blist_immunization1 == NULL)
						soap_blist_immunization1 = soap_new_block(soap);
					a->vd__StockEntryEventList::immunization = (vd__AnimalMedicationEvent **)soap_push_block(soap, soap_blist_immunization1, sizeof(vd__AnimalMedicationEvent *));
					if(a->vd__StockEntryEventList::immunization == NULL)
						return NULL;
					*a->vd__StockEntryEventList::immunization = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", a->vd__StockEntryEventList::immunization, "vd:AnimalMedicationEvent"))
				{	a->vd__StockEntryEventList::__sizeimmunization++;
					a->vd__StockEntryEventList::immunization = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:veterinaryEvent", 1, NULL)) {
				if(a->vd__StockEntryEventList::veterinaryEvent == NULL) {
					if(soap_blist_veterinaryEvent1 == NULL)
						soap_blist_veterinaryEvent1 = soap_new_block(soap);
					a->vd__StockEntryEventList::veterinaryEvent = (vd__VeterinaryEvent **)soap_push_block(soap, soap_blist_veterinaryEvent1, sizeof(vd__VeterinaryEvent *));
					if(a->vd__StockEntryEventList::veterinaryEvent == NULL)
						return NULL;
					*a->vd__StockEntryEventList::veterinaryEvent = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", a->vd__StockEntryEventList::veterinaryEvent, "vd:VeterinaryEvent"))
				{	a->vd__StockEntryEventList::__sizeveterinaryEvent++;
					a->vd__StockEntryEventList::veterinaryEvent = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntryEventList::laboratoryResearch)
			soap_pop_block(soap, soap_blist_laboratoryResearch1);
		if(a->vd__StockEntryEventList::__sizelaboratoryResearch)
			a->vd__StockEntryEventList::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_save_block(soap, soap_blist_laboratoryResearch1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::laboratoryResearch = NULL;
			if(soap_blist_laboratoryResearch1)
				soap_end_block(soap, soap_blist_laboratoryResearch1);
		}
		if(a->vd__StockEntryEventList::quarantine)
			soap_pop_block(soap, soap_blist_quarantine1);
		if(a->vd__StockEntryEventList::__sizequarantine)
			a->vd__StockEntryEventList::quarantine = (vd__QuarantineEvent **)soap_save_block(soap, soap_blist_quarantine1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::quarantine = NULL;
			if(soap_blist_quarantine1)
				soap_end_block(soap, soap_blist_quarantine1);
		}
		if(a->vd__StockEntryEventList::immunization)
			soap_pop_block(soap, soap_blist_immunization1);
		if(a->vd__StockEntryEventList::__sizeimmunization)
			a->vd__StockEntryEventList::immunization = (vd__AnimalMedicationEvent **)soap_save_block(soap, soap_blist_immunization1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::immunization = NULL;
			if(soap_blist_immunization1)
				soap_end_block(soap, soap_blist_immunization1);
		}
		if(a->vd__StockEntryEventList::veterinaryEvent)
			soap_pop_block(soap, soap_blist_veterinaryEvent1);
		if(a->vd__StockEntryEventList::__sizeveterinaryEvent)
			a->vd__StockEntryEventList::veterinaryEvent = (vd__VeterinaryEvent **)soap_save_block(soap, soap_blist_veterinaryEvent1, NULL, 1);
		else
		{	a->vd__StockEntryEventList::veterinaryEvent = NULL;
			if(soap_blist_veterinaryEvent1)
				soap_end_block(soap, soap_blist_veterinaryEvent1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntryEventList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntryEventList, 0, sizeof(vd__StockEntryEventList), 0, soap_copy_vd__StockEntryEventList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntryEventList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntryEventList);
	return this->soap_out(soap, tag?tag:"vd:StockEntryEventList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntryEventList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntryEventList(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntryEventList * SOAP_FMAC4 soap_get_vd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryEventList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntryEventList * FASTCALL soap_instantiate_vd__StockEntryEventList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntryEventList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntryEventList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryEventList);
		ASSIGN_PTR(size, sizeof(vd__StockEntryEventList));
		((vd__StockEntryEventList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryEventList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntryEventList));
		for(int i = 0; i < n; i++)
			((vd__StockEntryEventList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntryEventList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntryEventList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntryEventList %p -> %p\n", q, p));
	*(vd__StockEntryEventList*)p = *(vd__StockEntryEventList*)q;
}

void vd__BatchOrigin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__BatchOrigin::productItem = NULL;
	this->vd__BatchOrigin::country = NULL;
	this->vd__BatchOrigin::__sizeproducer = 0;
	this->vd__BatchOrigin::producer = NULL;
	/* transient soap skipped */
}

void vd__BatchOrigin::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductItem(soap, &this->vd__BatchOrigin::productItem);
	soap_serialize_PointerToent__Country(soap, &this->vd__BatchOrigin::country);
	if(this->vd__BatchOrigin::producer) {
		for(int i = 0; i < this->vd__BatchOrigin::__sizeproducer; i++) {
			soap_serialize_PointerToent__Producer(soap, this->vd__BatchOrigin::producer + i);
		}
	}
	/* transient soap skipped */
}

int vd__BatchOrigin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__BatchOrigin(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__BatchOrigin(struct soap *soap, const char *tag, int id, const vd__BatchOrigin *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__BatchOrigin), type))
		return soap->error;
	if(soap_out_PointerToent__ProductItem(soap, "vd:productItem", -1, &(a->vd__BatchOrigin::productItem), ""))
		return soap->error;
	if(soap_out_PointerToent__Country(soap, "vd:country", -1, &(a->vd__BatchOrigin::country), ""))
		return soap->error;
	if(a->vd__BatchOrigin::producer) {
		int i;
		for(i = 0; i < a->vd__BatchOrigin::__sizeproducer; i++)
			if(soap_out_PointerToent__Producer(soap, "vd:producer", -1, a->vd__BatchOrigin::producer + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__BatchOrigin::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__BatchOrigin(soap, tag, this, type);
}

SOAP_FMAC3 vd__BatchOrigin * FASTCALL soap_in_vd__BatchOrigin(struct soap *soap, const char *tag, vd__BatchOrigin *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__BatchOrigin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__BatchOrigin, sizeof(vd__BatchOrigin), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__BatchOrigin) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__BatchOrigin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productItem1 = 1;
	size_t soap_flag_country1 = 1;
	struct soap_blist *soap_blist_producer1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItem(soap, "vd:productItem", &(a->vd__BatchOrigin::productItem), "ent:ProductItem"))
				{	soap_flag_productItem1--;
					continue;
				}
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Country(soap, "vd:country", &(a->vd__BatchOrigin::country), "ent:Country"))
				{	soap_flag_country1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:producer", 1, NULL)) {
				if(a->vd__BatchOrigin::producer == NULL) {
					if(soap_blist_producer1 == NULL)
						soap_blist_producer1 = soap_new_block(soap);
					a->vd__BatchOrigin::producer = (ent__Producer **)soap_push_block(soap, soap_blist_producer1, sizeof(ent__Producer *));
					if(a->vd__BatchOrigin::producer == NULL)
						return NULL;
					*a->vd__BatchOrigin::producer = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Producer(soap, "vd:producer", a->vd__BatchOrigin::producer, "ent:Producer"))
				{	a->vd__BatchOrigin::__sizeproducer++;
					a->vd__BatchOrigin::producer = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__BatchOrigin::producer)
			soap_pop_block(soap, soap_blist_producer1);
		if(a->vd__BatchOrigin::__sizeproducer)
			a->vd__BatchOrigin::producer = (ent__Producer **)soap_save_block(soap, soap_blist_producer1, NULL, 1);
		else
		{	a->vd__BatchOrigin::producer = NULL;
			if(soap_blist_producer1)
				soap_end_block(soap, soap_blist_producer1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__BatchOrigin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__BatchOrigin, 0, sizeof(vd__BatchOrigin), 0, soap_copy_vd__BatchOrigin);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__BatchOrigin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__BatchOrigin);
	return this->soap_out(soap, tag?tag:"vd:BatchOrigin", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__BatchOrigin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__BatchOrigin(soap, this, tag, type);
}

SOAP_FMAC3 vd__BatchOrigin * SOAP_FMAC4 soap_get_vd__BatchOrigin(struct soap *soap, vd__BatchOrigin *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__BatchOrigin(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__BatchOrigin * FASTCALL soap_instantiate_vd__BatchOrigin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__BatchOrigin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__BatchOrigin, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__BatchOrigin);
		ASSIGN_PTR(size, sizeof(vd__BatchOrigin));
		((vd__BatchOrigin*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__BatchOrigin[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__BatchOrigin));
		for(int i = 0; i < n; i++)
			((vd__BatchOrigin*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__BatchOrigin*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__BatchOrigin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__BatchOrigin %p -> %p\n", q, p));
	*(vd__BatchOrigin*)p = *(vd__BatchOrigin*)q;
}

void vd__VeterinaryAuthentication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VeterinaryAuthentication::purpose = NULL;
	this->vd__VeterinaryAuthentication::cargoInspected = NULL;
	this->vd__VeterinaryAuthentication::cargoExpertized = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryAuthentication::locationProsperity);
	this->vd__VeterinaryAuthentication::animalSpentPeriod = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryAuthentication::monthsSpent);
	this->vd__VeterinaryAuthentication::__sizelaboratoryResearch = 0;
	this->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
	this->vd__VeterinaryAuthentication::quarantine = NULL;
	this->vd__VeterinaryAuthentication::__sizeimmunization = 0;
	this->vd__VeterinaryAuthentication::immunization = NULL;
	this->vd__VeterinaryAuthentication::__sizeveterinaryEvent = 0;
	this->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
	this->vd__VeterinaryAuthentication::__sizer13nClause = 0;
	this->vd__VeterinaryAuthentication::r13nClause = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryAuthentication::specialMarks);
	/* transient soap skipped */
}

void vd__VeterinaryAuthentication::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Purpose(soap, &this->vd__VeterinaryAuthentication::purpose);
	soap_serialize_PointerTobool(soap, &this->vd__VeterinaryAuthentication::cargoInspected);
	soap_serialize_PointerToent__ResearchResult(soap, &this->vd__VeterinaryAuthentication::cargoExpertized);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryAuthentication::locationProsperity);
	soap_serialize_PointerTovd__AnimalSpentPeriod(soap, &this->vd__VeterinaryAuthentication::animalSpentPeriod);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryAuthentication::monthsSpent);
	if(this->vd__VeterinaryAuthentication::laboratoryResearch) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizelaboratoryResearch; i++) {
			soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, this->vd__VeterinaryAuthentication::laboratoryResearch + i);
		}
	}
	soap_serialize_PointerTovd__QuarantineEvent(soap, &this->vd__VeterinaryAuthentication::quarantine);
	if(this->vd__VeterinaryAuthentication::immunization) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizeimmunization; i++) {
			soap_serialize_PointerTovd__AnimalMedicationEvent(soap, this->vd__VeterinaryAuthentication::immunization + i);
		}
	}
	if(this->vd__VeterinaryAuthentication::veterinaryEvent) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizeveterinaryEvent; i++) {
			soap_serialize_PointerTovd__VeterinaryEvent(soap, this->vd__VeterinaryAuthentication::veterinaryEvent + i);
		}
	}
	if(this->vd__VeterinaryAuthentication::r13nClause) {
		for(int i = 0; i < this->vd__VeterinaryAuthentication::__sizer13nClause; i++) {
			soap_serialize_PointerTovd__RegionalizationClause(soap, this->vd__VeterinaryAuthentication::r13nClause + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryAuthentication::specialMarks);
	/* transient soap skipped */
}

int vd__VeterinaryAuthentication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VeterinaryAuthentication(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VeterinaryAuthentication(struct soap *soap, const char *tag, int id, const vd__VeterinaryAuthentication *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VeterinaryAuthentication), type))
		return soap->error;
	if(soap_out_PointerToent__Purpose(soap, "vd:purpose", -1, &(a->vd__VeterinaryAuthentication::purpose), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:cargoInspected", -1, &(a->vd__VeterinaryAuthentication::cargoInspected), ""))
		return soap->error;
	if(soap_out_PointerToent__ResearchResult(soap, "vd:cargoExpertized", -1, &(a->vd__VeterinaryAuthentication::cargoExpertized), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:locationProsperity", -1, &(a->vd__VeterinaryAuthentication::locationProsperity), ""))
		return soap->error;
	if(soap_out_PointerTovd__AnimalSpentPeriod(soap, "vd:animalSpentPeriod", -1, &(a->vd__VeterinaryAuthentication::animalSpentPeriod), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:monthsSpent", -1, &(a->vd__VeterinaryAuthentication::monthsSpent), ""))
		return soap->error;
	if(a->vd__VeterinaryAuthentication::laboratoryResearch) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizelaboratoryResearch; i++)
			if(soap_out_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", -1, a->vd__VeterinaryAuthentication::laboratoryResearch + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__QuarantineEvent(soap, "vd:quarantine", -1, &(a->vd__VeterinaryAuthentication::quarantine), ""))
		return soap->error;
	if(a->vd__VeterinaryAuthentication::immunization) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizeimmunization; i++)
			if(soap_out_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", -1, a->vd__VeterinaryAuthentication::immunization + i, ""))
				return soap->error;
	}
	if(a->vd__VeterinaryAuthentication::veterinaryEvent) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizeveterinaryEvent; i++)
			if(soap_out_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", -1, a->vd__VeterinaryAuthentication::veterinaryEvent + i, ""))
				return soap->error;
	}
	if(a->vd__VeterinaryAuthentication::r13nClause) {
		int i;
		for(i = 0; i < a->vd__VeterinaryAuthentication::__sizer13nClause; i++)
			if(soap_out_PointerTovd__RegionalizationClause(soap, "vd:r13nClause", -1, a->vd__VeterinaryAuthentication::r13nClause + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:specialMarks", -1, &(a->vd__VeterinaryAuthentication::specialMarks), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__VeterinaryAuthentication::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VeterinaryAuthentication(soap, tag, this, type);
}

SOAP_FMAC3 vd__VeterinaryAuthentication * FASTCALL soap_in_vd__VeterinaryAuthentication(struct soap *soap, const char *tag, vd__VeterinaryAuthentication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VeterinaryAuthentication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VeterinaryAuthentication, sizeof(vd__VeterinaryAuthentication), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VeterinaryAuthentication) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VeterinaryAuthentication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_purpose1 = 1;
	size_t soap_flag_cargoInspected1 = 1;
	size_t soap_flag_cargoExpertized1 = 1;
	size_t soap_flag_locationProsperity1 = 1;
	size_t soap_flag_animalSpentPeriod1 = 1;
	size_t soap_flag_monthsSpent1 = 1;
	struct soap_blist *soap_blist_laboratoryResearch1 = NULL;
	size_t soap_flag_quarantine1 = 1;
	struct soap_blist *soap_blist_immunization1 = NULL;
	struct soap_blist *soap_blist_veterinaryEvent1 = NULL;
	struct soap_blist *soap_blist_r13nClause1 = NULL;
	size_t soap_flag_specialMarks1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_purpose1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Purpose(soap, "vd:purpose", &(a->vd__VeterinaryAuthentication::purpose), "ent:Purpose"))
				{	soap_flag_purpose1--;
					continue;
				}
			if(soap_flag_cargoInspected1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:cargoInspected", &(a->vd__VeterinaryAuthentication::cargoInspected), "xsd:boolean"))
				{	soap_flag_cargoInspected1--;
					continue;
				}
			if(soap_flag_cargoExpertized1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchResult(soap, "vd:cargoExpertized", &(a->vd__VeterinaryAuthentication::cargoExpertized), "ent:ResearchResult"))
				{	soap_flag_cargoExpertized1--;
					continue;
				}
			if(soap_flag_locationProsperity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:locationProsperity", &(a->vd__VeterinaryAuthentication::locationProsperity), "base:String255"))
				{	soap_flag_locationProsperity1--;
					continue;
				}
			if(soap_flag_animalSpentPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__AnimalSpentPeriod(soap, "vd:animalSpentPeriod", &(a->vd__VeterinaryAuthentication::animalSpentPeriod), "vd:AnimalSpentPeriod"))
				{	soap_flag_animalSpentPeriod1--;
					continue;
				}
			if(soap_flag_monthsSpent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:monthsSpent", &(a->vd__VeterinaryAuthentication::monthsSpent), "base:String255"))
				{	soap_flag_monthsSpent1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:laboratoryResearch", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::laboratoryResearch == NULL) {
					if(soap_blist_laboratoryResearch1 == NULL)
						soap_blist_laboratoryResearch1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_push_block(soap, soap_blist_laboratoryResearch1, sizeof(vd__LaboratoryResearchEvent *));
					if(a->vd__VeterinaryAuthentication::laboratoryResearch == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__LaboratoryResearchEvent(soap, "vd:laboratoryResearch", a->vd__VeterinaryAuthentication::laboratoryResearch, "vd:LaboratoryResearchEvent"))
				{	a->vd__VeterinaryAuthentication::__sizelaboratoryResearch++;
					a->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
					continue;
				}
			}
			if(soap_flag_quarantine1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__QuarantineEvent(soap, "vd:quarantine", &(a->vd__VeterinaryAuthentication::quarantine), "vd:QuarantineEvent"))
				{	soap_flag_quarantine1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:immunization", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::immunization == NULL) {
					if(soap_blist_immunization1 == NULL)
						soap_blist_immunization1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::immunization = (vd__AnimalMedicationEvent **)soap_push_block(soap, soap_blist_immunization1, sizeof(vd__AnimalMedicationEvent *));
					if(a->vd__VeterinaryAuthentication::immunization == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::immunization = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__AnimalMedicationEvent(soap, "vd:immunization", a->vd__VeterinaryAuthentication::immunization, "vd:AnimalMedicationEvent"))
				{	a->vd__VeterinaryAuthentication::__sizeimmunization++;
					a->vd__VeterinaryAuthentication::immunization = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:veterinaryEvent", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::veterinaryEvent == NULL) {
					if(soap_blist_veterinaryEvent1 == NULL)
						soap_blist_veterinaryEvent1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::veterinaryEvent = (vd__VeterinaryEvent **)soap_push_block(soap, soap_blist_veterinaryEvent1, sizeof(vd__VeterinaryEvent *));
					if(a->vd__VeterinaryAuthentication::veterinaryEvent == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VeterinaryEvent(soap, "vd:veterinaryEvent", a->vd__VeterinaryAuthentication::veterinaryEvent, "vd:VeterinaryEvent"))
				{	a->vd__VeterinaryAuthentication::__sizeveterinaryEvent++;
					a->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:r13nClause", 1, NULL)) {
				if(a->vd__VeterinaryAuthentication::r13nClause == NULL) {
					if(soap_blist_r13nClause1 == NULL)
						soap_blist_r13nClause1 = soap_new_block(soap);
					a->vd__VeterinaryAuthentication::r13nClause = (vd__RegionalizationClause **)soap_push_block(soap, soap_blist_r13nClause1, sizeof(vd__RegionalizationClause *));
					if(a->vd__VeterinaryAuthentication::r13nClause == NULL)
						return NULL;
					*a->vd__VeterinaryAuthentication::r13nClause = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__RegionalizationClause(soap, "vd:r13nClause", a->vd__VeterinaryAuthentication::r13nClause, "vd:RegionalizationClause"))
				{	a->vd__VeterinaryAuthentication::__sizer13nClause++;
					a->vd__VeterinaryAuthentication::r13nClause = NULL;
					continue;
				}
			}
			if(soap_flag_specialMarks1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:specialMarks", &(a->vd__VeterinaryAuthentication::specialMarks), "base:Text"))
				{	soap_flag_specialMarks1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryAuthentication::laboratoryResearch)
			soap_pop_block(soap, soap_blist_laboratoryResearch1);
		if(a->vd__VeterinaryAuthentication::__sizelaboratoryResearch)
			a->vd__VeterinaryAuthentication::laboratoryResearch = (vd__LaboratoryResearchEvent **)soap_save_block(soap, soap_blist_laboratoryResearch1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::laboratoryResearch = NULL;
			if(soap_blist_laboratoryResearch1)
				soap_end_block(soap, soap_blist_laboratoryResearch1);
		}
		if(a->vd__VeterinaryAuthentication::immunization)
			soap_pop_block(soap, soap_blist_immunization1);
		if(a->vd__VeterinaryAuthentication::__sizeimmunization)
			a->vd__VeterinaryAuthentication::immunization = (vd__AnimalMedicationEvent **)soap_save_block(soap, soap_blist_immunization1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::immunization = NULL;
			if(soap_blist_immunization1)
				soap_end_block(soap, soap_blist_immunization1);
		}
		if(a->vd__VeterinaryAuthentication::veterinaryEvent)
			soap_pop_block(soap, soap_blist_veterinaryEvent1);
		if(a->vd__VeterinaryAuthentication::__sizeveterinaryEvent)
			a->vd__VeterinaryAuthentication::veterinaryEvent = (vd__VeterinaryEvent **)soap_save_block(soap, soap_blist_veterinaryEvent1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::veterinaryEvent = NULL;
			if(soap_blist_veterinaryEvent1)
				soap_end_block(soap, soap_blist_veterinaryEvent1);
		}
		if(a->vd__VeterinaryAuthentication::r13nClause)
			soap_pop_block(soap, soap_blist_r13nClause1);
		if(a->vd__VeterinaryAuthentication::__sizer13nClause)
			a->vd__VeterinaryAuthentication::r13nClause = (vd__RegionalizationClause **)soap_save_block(soap, soap_blist_r13nClause1, NULL, 1);
		else
		{	a->vd__VeterinaryAuthentication::r13nClause = NULL;
			if(soap_blist_r13nClause1)
				soap_end_block(soap, soap_blist_r13nClause1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VeterinaryAuthentication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VeterinaryAuthentication, 0, sizeof(vd__VeterinaryAuthentication), 0, soap_copy_vd__VeterinaryAuthentication);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__VeterinaryAuthentication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VeterinaryAuthentication);
	return this->soap_out(soap, tag?tag:"vd:VeterinaryAuthentication", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VeterinaryAuthentication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VeterinaryAuthentication(soap, this, tag, type);
}

SOAP_FMAC3 vd__VeterinaryAuthentication * SOAP_FMAC4 soap_get_vd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VeterinaryAuthentication(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VeterinaryAuthentication * FASTCALL soap_instantiate_vd__VeterinaryAuthentication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VeterinaryAuthentication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VeterinaryAuthentication, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryAuthentication);
		ASSIGN_PTR(size, sizeof(vd__VeterinaryAuthentication));
		((vd__VeterinaryAuthentication*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryAuthentication[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VeterinaryAuthentication));
		for(int i = 0; i < n; i++)
			((vd__VeterinaryAuthentication*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VeterinaryAuthentication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VeterinaryAuthentication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VeterinaryAuthentication %p -> %p\n", q, p));
	*(vd__VeterinaryAuthentication*)p = *(vd__VeterinaryAuthentication*)q;
}

void vd__QuarantineEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->vd__QuarantineEvent::duration);
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__QuarantineEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__positiveInteger(soap, &this->vd__QuarantineEvent::duration);
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerToent__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__QuarantineEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__QuarantineEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__QuarantineEvent(struct soap *soap, const char *tag, int id, const vd__QuarantineEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__QuarantineEvent), "vd:QuarantineEvent"))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_xsd__positiveInteger(soap, "vd:duration", -1, &(a->vd__QuarantineEvent::duration), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__QuarantineEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__QuarantineEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__QuarantineEvent * FASTCALL soap_in_vd__QuarantineEvent(struct soap *soap, const char *tag, vd__QuarantineEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__QuarantineEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__QuarantineEvent, sizeof(vd__QuarantineEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__QuarantineEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__QuarantineEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	size_t soap_flag_duration1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "ent:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_duration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__positiveInteger(soap, "vd:duration", &(a->vd__QuarantineEvent::duration), "xsd:positiveInteger"))
				{	soap_flag_duration1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__QuarantineEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__QuarantineEvent, 0, sizeof(vd__QuarantineEvent), 0, soap_copy_vd__QuarantineEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__QuarantineEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__QuarantineEvent);
	return this->soap_out(soap, tag?tag:"vd:QuarantineEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__QuarantineEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__QuarantineEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__QuarantineEvent * SOAP_FMAC4 soap_get_vd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__QuarantineEvent * FASTCALL soap_instantiate_vd__QuarantineEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__QuarantineEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__QuarantineEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent);
		ASSIGN_PTR(size, sizeof(vd__QuarantineEvent));
		((vd__QuarantineEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__QuarantineEvent));
		for(int i = 0; i < n; i++)
			((vd__QuarantineEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__QuarantineEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__QuarantineEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__QuarantineEvent %p -> %p\n", q, p));
	*(vd__QuarantineEvent*)p = *(vd__QuarantineEvent*)q;
}

void vd__AnimalMedicationEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__AnimalMedicationEvent::disease = NULL;
	this->vd__AnimalMedicationEvent::medicinalDrug = NULL;
	this->vd__AnimalMedicationEvent::effectiveBeforeDate = NULL;
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__AnimalMedicationEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDisease(soap, &this->vd__AnimalMedicationEvent::disease);
	soap_serialize_PointerToent__MedicinalDrug(soap, &this->vd__AnimalMedicationEvent::medicinalDrug);
	soap_serialize_PointerTotime(soap, &this->vd__AnimalMedicationEvent::effectiveBeforeDate);
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerToent__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__AnimalMedicationEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__AnimalMedicationEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, const vd__AnimalMedicationEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__AnimalMedicationEvent), "vd:AnimalMedicationEvent"))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerToent__AnimalDisease(soap, "vd:disease", -1, &(a->vd__AnimalMedicationEvent::disease), ""))
		return soap->error;
	if(soap_out_PointerToent__MedicinalDrug(soap, "vd:medicinalDrug", -1, &(a->vd__AnimalMedicationEvent::medicinalDrug), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:effectiveBeforeDate", -1, &(a->vd__AnimalMedicationEvent::effectiveBeforeDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__AnimalMedicationEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__AnimalMedicationEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent * FASTCALL soap_in_vd__AnimalMedicationEvent(struct soap *soap, const char *tag, vd__AnimalMedicationEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__AnimalMedicationEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__AnimalMedicationEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__AnimalMedicationEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	size_t soap_flag_disease1 = 1;
	size_t soap_flag_medicinalDrug1 = 1;
	size_t soap_flag_effectiveBeforeDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "ent:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_disease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "vd:disease", &(a->vd__AnimalMedicationEvent::disease), "ent:AnimalDisease"))
				{	soap_flag_disease1--;
					continue;
				}
			if(soap_flag_medicinalDrug1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__MedicinalDrug(soap, "vd:medicinalDrug", &(a->vd__AnimalMedicationEvent::medicinalDrug), "ent:MedicinalDrug"))
				{	soap_flag_medicinalDrug1--;
					continue;
				}
			if(soap_flag_effectiveBeforeDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:effectiveBeforeDate", &(a->vd__AnimalMedicationEvent::effectiveBeforeDate), "xsd:dateTime"))
				{	soap_flag_effectiveBeforeDate1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__AnimalMedicationEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__AnimalMedicationEvent, 0, sizeof(vd__AnimalMedicationEvent), 0, soap_copy_vd__AnimalMedicationEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__AnimalMedicationEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__AnimalMedicationEvent);
	return this->soap_out(soap, tag?tag:"vd:AnimalMedicationEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__AnimalMedicationEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__AnimalMedicationEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent * SOAP_FMAC4 soap_get_vd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__AnimalMedicationEvent * FASTCALL soap_instantiate_vd__AnimalMedicationEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__AnimalMedicationEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__AnimalMedicationEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent);
		ASSIGN_PTR(size, sizeof(vd__AnimalMedicationEvent));
		((vd__AnimalMedicationEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__AnimalMedicationEvent));
		for(int i = 0; i < n; i++)
			((vd__AnimalMedicationEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__AnimalMedicationEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__AnimalMedicationEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__AnimalMedicationEvent %p -> %p\n", q, p));
	*(vd__AnimalMedicationEvent*)p = *(vd__AnimalMedicationEvent*)q;
}

void vd__LaboratoryResearchEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__LaboratoryResearchEvent::__sizebatchID = 0;
	this->vd__LaboratoryResearchEvent::batchID = NULL;
	soap_default_base__String255(soap, &this->vd__LaboratoryResearchEvent::expertiseID);
	this->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_ = 0;
	this->vd__LaboratoryResearchEvent::method = NULL;
	this->vd__LaboratoryResearchEvent::result = NULL;
	soap_default_base__Text(soap, &this->vd__LaboratoryResearchEvent::conclusion);
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__LaboratoryResearchEvent::soap_serialize(struct soap *soap) const
{
	if(this->vd__LaboratoryResearchEvent::batchID) {
		for(int i = 0; i < this->vd__LaboratoryResearchEvent::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__LaboratoryResearchEvent::batchID + i);
		}
	}
	soap_serialize_base__String255(soap, &this->vd__LaboratoryResearchEvent::expertiseID);
	soap_serialize__vd__union_LaboratoryResearchEvent_(soap, this->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &this->vd__LaboratoryResearchEvent::union_LaboratoryResearchEvent_);
	soap_serialize_PointerToent__ResearchMethod(soap, &this->vd__LaboratoryResearchEvent::method);
	soap_serialize_PointerToent__ResearchResult(soap, &this->vd__LaboratoryResearchEvent::result);
	soap_serialize_base__Text(soap, &this->vd__LaboratoryResearchEvent::conclusion);
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerToent__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__LaboratoryResearchEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__LaboratoryResearchEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, const vd__LaboratoryResearchEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__LaboratoryResearchEvent), "vd:LaboratoryResearchEvent"))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__LaboratoryResearchEvent::batchID) {
		int i;
		for(i = 0; i < a->vd__LaboratoryResearchEvent::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__LaboratoryResearchEvent::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_base__String255(soap, "vd:expertiseID", -1, &(a->vd__LaboratoryResearchEvent::expertiseID), ""))
		return soap->error;
	if(soap_out__vd__union_LaboratoryResearchEvent_(soap, a->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &a->vd__LaboratoryResearchEvent::union_LaboratoryResearchEvent_))
		return soap->error;
	if(soap_out_PointerToent__ResearchMethod(soap, "vd:method", -1, &(a->vd__LaboratoryResearchEvent::method), ""))
		return soap->error;
	if(soap_out_PointerToent__ResearchResult(soap, "vd:result", -1, &(a->vd__LaboratoryResearchEvent::result), ""))
		return soap->error;
	if(soap_out_base__Text(soap, "vd:conclusion", -1, &(a->vd__LaboratoryResearchEvent::conclusion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__LaboratoryResearchEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__LaboratoryResearchEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent * FASTCALL soap_in_vd__LaboratoryResearchEvent(struct soap *soap, const char *tag, vd__LaboratoryResearchEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__LaboratoryResearchEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__LaboratoryResearchEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__LaboratoryResearchEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_actualDateTime2 = 1;
	size_t soap_flag_union_VeterinaryEvent2 = 1;
	size_t soap_flag_operator_2 = 1;
	struct soap_blist *soap_blist_referencedDocument2 = NULL;
	size_t soap_flag_notes2 = 1;
	struct soap_blist *soap_blist_batchID1 = NULL;
	size_t soap_flag_expertiseID1 = 1;
	size_t soap_flag_union_LaboratoryResearchEvent_1 = 1;
	size_t soap_flag_method1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_conclusion1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID2--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_actualDateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime2--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent2 = 0;
					continue;
				}
			if(soap_flag_operator_2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "ent:Organization"))
				{	soap_flag_operator_2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument2 == NULL)
						soap_blist_referencedDocument2 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument2, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__LaboratoryResearchEvent::batchID == NULL) {
					if(soap_blist_batchID1 == NULL)
						soap_blist_batchID1 = soap_new_block(soap);
					a->vd__LaboratoryResearchEvent::batchID = (char **)soap_push_block(soap, soap_blist_batchID1, sizeof(char *));
					if(a->vd__LaboratoryResearchEvent::batchID == NULL)
						return NULL;
					*a->vd__LaboratoryResearchEvent::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__LaboratoryResearchEvent::batchID, "base:Identifier"))
				{	a->vd__LaboratoryResearchEvent::__sizebatchID++;
					a->vd__LaboratoryResearchEvent::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_expertiseID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:expertiseID", &(a->vd__LaboratoryResearchEvent::expertiseID), "base:String255"))
				{	soap_flag_expertiseID1--;
					continue;
				}
			if(soap_flag_union_LaboratoryResearchEvent_1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_LaboratoryResearchEvent_(soap, &a->vd__LaboratoryResearchEvent::__union_LaboratoryResearchEvent_, &a->vd__LaboratoryResearchEvent::union_LaboratoryResearchEvent_))
				{	soap_flag_union_LaboratoryResearchEvent_1 = 0;
					continue;
				}
			if(soap_flag_method1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchMethod(soap, "vd:method", &(a->vd__LaboratoryResearchEvent::method), "ent:ResearchMethod"))
				{	soap_flag_method1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ResearchResult(soap, "vd:result", &(a->vd__LaboratoryResearchEvent::result), "ent:ResearchResult"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_conclusion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:conclusion", &(a->vd__LaboratoryResearchEvent::conclusion), "base:Text"))
				{	soap_flag_conclusion1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument2);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument2, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument2)
				soap_end_block(soap, soap_blist_referencedDocument2);
		}
		if(a->vd__LaboratoryResearchEvent::batchID)
			soap_pop_block(soap, soap_blist_batchID1);
		if(a->vd__LaboratoryResearchEvent::__sizebatchID)
			a->vd__LaboratoryResearchEvent::batchID = (char **)soap_save_block(soap, soap_blist_batchID1, NULL, 1);
		else
		{	a->vd__LaboratoryResearchEvent::batchID = NULL;
			if(soap_blist_batchID1)
				soap_end_block(soap, soap_blist_batchID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__LaboratoryResearchEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__LaboratoryResearchEvent, 0, sizeof(vd__LaboratoryResearchEvent), 0, soap_copy_vd__LaboratoryResearchEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent2 || soap_flag_union_LaboratoryResearchEvent_1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__LaboratoryResearchEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__LaboratoryResearchEvent);
	return this->soap_out(soap, tag?tag:"vd:LaboratoryResearchEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__LaboratoryResearchEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__LaboratoryResearchEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent * SOAP_FMAC4 soap_get_vd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__LaboratoryResearchEvent * FASTCALL soap_instantiate_vd__LaboratoryResearchEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__LaboratoryResearchEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__LaboratoryResearchEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent);
		ASSIGN_PTR(size, sizeof(vd__LaboratoryResearchEvent));
		((vd__LaboratoryResearchEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__LaboratoryResearchEvent));
		for(int i = 0; i < n; i++)
			((vd__LaboratoryResearchEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__LaboratoryResearchEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__LaboratoryResearchEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__LaboratoryResearchEvent %p -> %p\n", q, p));
	*(vd__LaboratoryResearchEvent*)p = *(vd__LaboratoryResearchEvent*)q;
}

void vd__VeterinaryEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VeterinaryEvent::ID = NULL;
	soap_default_base__String255(soap, &this->vd__VeterinaryEvent::name);
	this->vd__VeterinaryEvent::type = NULL;
	this->vd__VeterinaryEvent::actualDateTime = NULL;
	this->vd__VeterinaryEvent::__union_VeterinaryEvent = 0;
	this->vd__VeterinaryEvent::operator_ = NULL;
	this->vd__VeterinaryEvent::__sizereferencedDocument = 0;
	this->vd__VeterinaryEvent::referencedDocument = NULL;
	soap_default_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

void vd__VeterinaryEvent::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__VeterinaryEvent::ID);
	soap_serialize_base__String255(soap, &this->vd__VeterinaryEvent::name);
	soap_serialize_PointerTovd__VeterinaryEventType(soap, &this->vd__VeterinaryEvent::type);
	soap_serialize_PointerTotime(soap, &this->vd__VeterinaryEvent::actualDateTime);
	soap_serialize__vd__union_VeterinaryEvent(soap, this->vd__VeterinaryEvent::__union_VeterinaryEvent, &this->vd__VeterinaryEvent::union_VeterinaryEvent);
	soap_serialize_PointerToent__Organization(soap, &this->vd__VeterinaryEvent::operator_);
	if(this->vd__VeterinaryEvent::referencedDocument) {
		for(int i = 0; i < this->vd__VeterinaryEvent::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__Document(soap, this->vd__VeterinaryEvent::referencedDocument + i);
		}
	}
	soap_serialize_base__Text(soap, &this->vd__VeterinaryEvent::notes);
	/* transient soap skipped */
}

int vd__VeterinaryEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VeterinaryEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VeterinaryEvent(struct soap *soap, const char *tag, int id, const vd__VeterinaryEvent *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VeterinaryEvent), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:ID", -1, &(a->vd__VeterinaryEvent::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__VeterinaryEvent::name), ""))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryEventType(soap, "vd:type", -1, &(a->vd__VeterinaryEvent::type), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:actualDateTime", -1, &(a->vd__VeterinaryEvent::actualDateTime), ""))
		return soap->error;
	if(soap_out__vd__union_VeterinaryEvent(soap, a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:operator", -1, &(a->vd__VeterinaryEvent::operator_), ""))
		return soap->error;
	if(a->vd__VeterinaryEvent::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VeterinaryEvent::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__Document(soap, "vd:referencedDocument", -1, a->vd__VeterinaryEvent::referencedDocument + i, ""))
				return soap->error;
	}
	if(soap_out_base__Text(soap, "vd:notes", -1, &(a->vd__VeterinaryEvent::notes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__VeterinaryEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VeterinaryEvent(soap, tag, this, type);
}

SOAP_FMAC3 vd__VeterinaryEvent * FASTCALL soap_in_vd__VeterinaryEvent(struct soap *soap, const char *tag, vd__VeterinaryEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VeterinaryEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VeterinaryEvent, sizeof(vd__VeterinaryEvent), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VeterinaryEvent) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VeterinaryEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_actualDateTime1 = 1;
	size_t soap_flag_union_VeterinaryEvent1 = 1;
	size_t soap_flag_operator_1 = 1;
	struct soap_blist *soap_blist_referencedDocument1 = NULL;
	size_t soap_flag_notes1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:ID", &(a->vd__VeterinaryEvent::ID), "base:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__VeterinaryEvent::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryEventType(soap, "vd:type", &(a->vd__VeterinaryEvent::type), "vd:VeterinaryEventType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_actualDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:actualDateTime", &(a->vd__VeterinaryEvent::actualDateTime), "xsd:dateTime"))
				{	soap_flag_actualDateTime1--;
					continue;
				}
			if(soap_flag_union_VeterinaryEvent1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VeterinaryEvent(soap, &a->vd__VeterinaryEvent::__union_VeterinaryEvent, &a->vd__VeterinaryEvent::union_VeterinaryEvent))
				{	soap_flag_union_VeterinaryEvent1 = 0;
					continue;
				}
			if(soap_flag_operator_1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:operator", &(a->vd__VeterinaryEvent::operator_), "ent:Organization"))
				{	soap_flag_operator_1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VeterinaryEvent::referencedDocument == NULL) {
					if(soap_blist_referencedDocument1 == NULL)
						soap_blist_referencedDocument1 = soap_new_block(soap);
					a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_push_block(soap, soap_blist_referencedDocument1, sizeof(vd__Document *));
					if(a->vd__VeterinaryEvent::referencedDocument == NULL)
						return NULL;
					*a->vd__VeterinaryEvent::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Document(soap, "vd:referencedDocument", a->vd__VeterinaryEvent::referencedDocument, "vd:Document"))
				{	a->vd__VeterinaryEvent::__sizereferencedDocument++;
					a->vd__VeterinaryEvent::referencedDocument = NULL;
					continue;
				}
			}
			if(soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:notes", &(a->vd__VeterinaryEvent::notes), "base:Text"))
				{	soap_flag_notes1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VeterinaryEvent::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument1);
		if(a->vd__VeterinaryEvent::__sizereferencedDocument)
			a->vd__VeterinaryEvent::referencedDocument = (vd__Document **)soap_save_block(soap, soap_blist_referencedDocument1, NULL, 1);
		else
		{	a->vd__VeterinaryEvent::referencedDocument = NULL;
			if(soap_blist_referencedDocument1)
				soap_end_block(soap, soap_blist_referencedDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VeterinaryEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VeterinaryEvent, 0, sizeof(vd__VeterinaryEvent), 0, soap_copy_vd__VeterinaryEvent);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VeterinaryEvent1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__VeterinaryEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VeterinaryEvent);
	return this->soap_out(soap, tag?tag:"vd:VeterinaryEvent", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VeterinaryEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VeterinaryEvent(soap, this, tag, type);
}

SOAP_FMAC3 vd__VeterinaryEvent * SOAP_FMAC4 soap_get_vd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VeterinaryEvent * FASTCALL soap_instantiate_vd__VeterinaryEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VeterinaryEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VeterinaryEvent, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:LaboratoryResearchEvent")) {
		cp->type = SOAP_TYPE_vd__LaboratoryResearchEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__LaboratoryResearchEvent));
			((vd__LaboratoryResearchEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__LaboratoryResearchEvent[n]);
			ASSIGN_PTR(size, n * sizeof(vd__LaboratoryResearchEvent));
			for(int i = 0; i < n; i++)
				((vd__LaboratoryResearchEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__LaboratoryResearchEvent*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:AnimalMedicationEvent")) {
		cp->type = SOAP_TYPE_vd__AnimalMedicationEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__AnimalMedicationEvent));
			((vd__AnimalMedicationEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__AnimalMedicationEvent[n]);
			ASSIGN_PTR(size, n * sizeof(vd__AnimalMedicationEvent));
			for(int i = 0; i < n; i++)
				((vd__AnimalMedicationEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__AnimalMedicationEvent*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:QuarantineEvent")) {
		cp->type = SOAP_TYPE_vd__QuarantineEvent;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__QuarantineEvent));
			((vd__QuarantineEvent*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__QuarantineEvent[n]);
			ASSIGN_PTR(size, n * sizeof(vd__QuarantineEvent));
			for(int i = 0; i < n; i++)
				((vd__QuarantineEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__QuarantineEvent*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryEvent);
		ASSIGN_PTR(size, sizeof(vd__VeterinaryEvent));
		((vd__VeterinaryEvent*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VeterinaryEvent[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VeterinaryEvent));
		for(int i = 0; i < n; i++)
			((vd__VeterinaryEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VeterinaryEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VeterinaryEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VeterinaryEvent %p -> %p\n", q, p));
	*(vd__VeterinaryEvent*)p = *(vd__VeterinaryEvent*)q;
}

void vd__ReferencedDocument::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ent__ReferenceType(soap, &this->vd__ReferencedDocument::relationshipType);
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__ReferencedDocument::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerToent__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerToent__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__ReferencedDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ReferencedDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ReferencedDocument(struct soap *soap, const char *tag, int id, const vd__ReferencedDocument *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ReferencedDocument), "vd:ReferencedDocument"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerToent__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_ent__ReferenceType(soap, "vd:relationshipType", -1, &(a->vd__ReferencedDocument::relationshipType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__ReferencedDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ReferencedDocument(soap, tag, this, type);
}

SOAP_FMAC3 vd__ReferencedDocument * FASTCALL soap_in_vd__ReferencedDocument(struct soap *soap, const char *tag, vd__ReferencedDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ReferencedDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ReferencedDocument, sizeof(vd__ReferencedDocument), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ReferencedDocument) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ReferencedDocument *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_relationshipType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DocumentType(soap, "vd:type", &(a->vd__Document::type), "ent:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "ent:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_relationshipType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__ReferenceType(soap, "vd:relationshipType", &(a->vd__ReferencedDocument::relationshipType), "ent:ReferenceType"))
				{	soap_flag_relationshipType1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ReferencedDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ReferencedDocument, 0, sizeof(vd__ReferencedDocument), 0, soap_copy_vd__ReferencedDocument);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_relationshipType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__ReferencedDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ReferencedDocument);
	return this->soap_out(soap, tag?tag:"vd:ReferencedDocument", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ReferencedDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ReferencedDocument(soap, this, tag, type);
}

SOAP_FMAC3 vd__ReferencedDocument * SOAP_FMAC4 soap_get_vd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ReferencedDocument * FASTCALL soap_instantiate_vd__ReferencedDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ReferencedDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ReferencedDocument, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument);
		ASSIGN_PTR(size, sizeof(vd__ReferencedDocument));
		((vd__ReferencedDocument*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ReferencedDocument));
		for(int i = 0; i < n; i++)
			((vd__ReferencedDocument*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ReferencedDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ReferencedDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ReferencedDocument %p -> %p\n", q, p));
	*(vd__ReferencedDocument*)p = *(vd__ReferencedDocument*)q;
}

void vd__CertifiedConsignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__CertifiedConsignment::consignor = NULL;
	this->vd__CertifiedConsignment::consignee = NULL;
	this->vd__CertifiedConsignment::broker = NULL;
	this->vd__CertifiedConsignment::transportInfo = NULL;
	this->vd__CertifiedConsignment::transportStorageType = NULL;
	this->vd__CertifiedConsignment::shipmentRoute = NULL;
	this->vd__CertifiedConsignment::batch = NULL;
	/* transient soap skipped */
}

void vd__CertifiedConsignment::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__CertifiedConsignment::consignor);
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__CertifiedConsignment::consignee);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__CertifiedConsignment::broker);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__CertifiedConsignment::transportInfo);
	soap_serialize_PointerToent__TransportationStorageType(soap, &this->vd__CertifiedConsignment::transportStorageType);
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->vd__CertifiedConsignment::shipmentRoute);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__CertifiedConsignment::batch);
	/* transient soap skipped */
}

int vd__CertifiedConsignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__CertifiedConsignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__CertifiedConsignment(struct soap *soap, const char *tag, int id, const vd__CertifiedConsignment *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__CertifiedConsignment), type))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:consignor", -1, &(a->vd__CertifiedConsignment::consignor), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:consignee", -1, &(a->vd__CertifiedConsignment::consignee), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "vd:broker", -1, &(a->vd__CertifiedConsignment::broker), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:transportInfo", -1, &(a->vd__CertifiedConsignment::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerToent__TransportationStorageType(soap, "vd:transportStorageType", -1, &(a->vd__CertifiedConsignment::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &(a->vd__CertifiedConsignment::shipmentRoute), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__CertifiedConsignment::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__CertifiedConsignment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__CertifiedConsignment(soap, tag, this, type);
}

SOAP_FMAC3 vd__CertifiedConsignment * FASTCALL soap_in_vd__CertifiedConsignment(struct soap *soap, const char *tag, vd__CertifiedConsignment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__CertifiedConsignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__CertifiedConsignment, sizeof(vd__CertifiedConsignment), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__CertifiedConsignment) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__CertifiedConsignment *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	size_t soap_flag_batch1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:consignor", &(a->vd__CertifiedConsignment::consignor), "ent:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:consignee", &(a->vd__CertifiedConsignment::consignee), "ent:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:broker", &(a->vd__CertifiedConsignment::broker), "ent:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:transportInfo", &(a->vd__CertifiedConsignment::transportInfo), "vd:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__TransportationStorageType(soap, "vd:transportStorageType", &(a->vd__CertifiedConsignment::transportStorageType), "ent:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->vd__CertifiedConsignment::shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__CertifiedConsignment::batch), "vd:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__CertifiedConsignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__CertifiedConsignment, 0, sizeof(vd__CertifiedConsignment), 0, soap_copy_vd__CertifiedConsignment);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__CertifiedConsignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__CertifiedConsignment);
	return this->soap_out(soap, tag?tag:"vd:CertifiedConsignment", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__CertifiedConsignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__CertifiedConsignment(soap, this, tag, type);
}

SOAP_FMAC3 vd__CertifiedConsignment * SOAP_FMAC4 soap_get_vd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__CertifiedConsignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__CertifiedConsignment * FASTCALL soap_instantiate_vd__CertifiedConsignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__CertifiedConsignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__CertifiedConsignment, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedConsignment);
		ASSIGN_PTR(size, sizeof(vd__CertifiedConsignment));
		((vd__CertifiedConsignment*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedConsignment[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__CertifiedConsignment));
		for(int i = 0; i < n; i++)
			((vd__CertifiedConsignment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__CertifiedConsignment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__CertifiedConsignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__CertifiedConsignment %p -> %p\n", q, p));
	*(vd__CertifiedConsignment*)p = *(vd__CertifiedConsignment*)q;
}

void vd__CertifiedBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__CertifiedBatch::producer = NULL;
	this->vd__CertifiedBatch::batch = NULL;
	/* transient soap skipped */
}

void vd__CertifiedBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__CertifiedBatch::producer);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__CertifiedBatch::batch);
	/* transient soap skipped */
}

int vd__CertifiedBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__CertifiedBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__CertifiedBatch(struct soap *soap, const char *tag, int id, const vd__CertifiedBatch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__CertifiedBatch), type))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:producer", -1, &(a->vd__CertifiedBatch::producer), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__CertifiedBatch::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__CertifiedBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__CertifiedBatch(soap, tag, this, type);
}

SOAP_FMAC3 vd__CertifiedBatch * FASTCALL soap_in_vd__CertifiedBatch(struct soap *soap, const char *tag, vd__CertifiedBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__CertifiedBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__CertifiedBatch, sizeof(vd__CertifiedBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__CertifiedBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__CertifiedBatch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_producer1 = 1;
	size_t soap_flag_batch1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:producer", &(a->vd__CertifiedBatch::producer), "ent:BusinessMember"))
				{	soap_flag_producer1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__CertifiedBatch::batch), "vd:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__CertifiedBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__CertifiedBatch, 0, sizeof(vd__CertifiedBatch), 0, soap_copy_vd__CertifiedBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__CertifiedBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__CertifiedBatch);
	return this->soap_out(soap, tag?tag:"vd:CertifiedBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__CertifiedBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__CertifiedBatch(soap, this, tag, type);
}

SOAP_FMAC3 vd__CertifiedBatch * SOAP_FMAC4 soap_get_vd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__CertifiedBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__CertifiedBatch * FASTCALL soap_instantiate_vd__CertifiedBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__CertifiedBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__CertifiedBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedBatch);
		ASSIGN_PTR(size, sizeof(vd__CertifiedBatch));
		((vd__CertifiedBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__CertifiedBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__CertifiedBatch));
		for(int i = 0; i < n; i++)
			((vd__CertifiedBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__CertifiedBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__CertifiedBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__CertifiedBatch %p -> %p\n", q, p));
	*(vd__CertifiedBatch*)p = *(vd__CertifiedBatch*)q;
}

void vd__ENTModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__ENTModificationOperation::type);
	this->vd__ENTModificationOperation::affectedList = NULL;
	this->vd__ENTModificationOperation::resultingList = NULL;
	soap_default_ent__ENTModificationReason(soap, &this->vd__ENTModificationOperation::reason);
	/* transient soap skipped */
}

void vd__ENTModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__ENTModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerToent__EnterpriseList(soap, &this->vd__ENTModificationOperation::affectedList);
	soap_serialize_PointerToent__EnterpriseList(soap, &this->vd__ENTModificationOperation::resultingList);
	soap_serialize_ent__ENTModificationReason(soap, &this->vd__ENTModificationOperation::reason);
	/* transient soap skipped */
}

int vd__ENTModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ENTModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ENTModificationOperation(struct soap *soap, const char *tag, int id, const vd__ENTModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ENTModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__ENTModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseList(soap, "vd:affectedList", -1, &(a->vd__ENTModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseList(soap, "vd:resultingList", -1, &(a->vd__ENTModificationOperation::resultingList), ""))
		return soap->error;
	if(soap_out_ent__ENTModificationReason(soap, "vd:reason", -1, &(a->vd__ENTModificationOperation::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ENTModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ENTModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__ENTModificationOperation * FASTCALL soap_in_vd__ENTModificationOperation(struct soap *soap, const char *tag, vd__ENTModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ENTModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ENTModificationOperation, sizeof(vd__ENTModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ENTModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ENTModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__ENTModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseList(soap, "vd:affectedList", &(a->vd__ENTModificationOperation::affectedList), "ent:EnterpriseList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseList(soap, "vd:resultingList", &(a->vd__ENTModificationOperation::resultingList), "ent:EnterpriseList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__ENTModificationReason(soap, "vd:reason", &(a->vd__ENTModificationOperation::reason), "ent:ENTModificationReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ENTModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ENTModificationOperation, 0, sizeof(vd__ENTModificationOperation), 0, soap_copy_vd__ENTModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__ENTModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ENTModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:ENTModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ENTModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ENTModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__ENTModificationOperation * SOAP_FMAC4 soap_get_vd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ENTModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ENTModificationOperation * FASTCALL soap_instantiate_vd__ENTModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ENTModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ENTModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ENTModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__ENTModificationOperation));
		((vd__ENTModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ENTModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ENTModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__ENTModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ENTModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ENTModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ENTModificationOperation %p -> %p\n", q, p));
	*(vd__ENTModificationOperation*)p = *(vd__ENTModificationOperation*)q;
}

void vd__BEActivityLocationsModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__BEActivityLocationsModificationOperation::type);
	this->vd__BEActivityLocationsModificationOperation::businessEntity = NULL;
	this->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation = 0;
	this->vd__BEActivityLocationsModificationOperation::activityLocation = NULL;
	/* transient soap skipped */
}

void vd__BEActivityLocationsModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__BEActivityLocationsModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__BEActivityLocationsModificationOperation::businessEntity);
	if(this->vd__BEActivityLocationsModificationOperation::activityLocation) {
		for(int i = 0; i < this->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation; i++) {
			soap_embedded(soap, this->vd__BEActivityLocationsModificationOperation::activityLocation + i, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation);
			this->vd__BEActivityLocationsModificationOperation::activityLocation[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int vd__BEActivityLocationsModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__BEActivityLocationsModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, int id, const vd__BEActivityLocationsModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__BEActivityLocationsModificationOperation::type), ""))
		return soap->error;
	if(a->vd__BEActivityLocationsModificationOperation::businessEntity) {
		if(soap_out_PointerToent__BusinessEntity(soap, "vd:businessEntity", -1, &a->vd__BEActivityLocationsModificationOperation::businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:businessEntity"))
		return soap->error;
	if(a->vd__BEActivityLocationsModificationOperation::activityLocation) {
		int i;
		for(i = 0; i < a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation; i++)
			if(a->vd__BEActivityLocationsModificationOperation::activityLocation[i].soap_out(soap, "vd:activityLocation", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__BEActivityLocationsModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__BEActivityLocationsModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation * FASTCALL soap_in_vd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, vd__BEActivityLocationsModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__BEActivityLocationsModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, sizeof(vd__BEActivityLocationsModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__BEActivityLocationsModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__BEActivityLocationsModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_businessEntity1 = 1;
	struct soap_blist *soap_blist_activityLocation1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__BEActivityLocationsModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:businessEntity", &(a->vd__BEActivityLocationsModificationOperation::businessEntity), "ent:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:activityLocation", 1, NULL)) {
				if(a->vd__BEActivityLocationsModificationOperation::activityLocation == NULL) {
					if(soap_blist_activityLocation1 == NULL)
						soap_blist_activityLocation1 = soap_new_block(soap);
					a->vd__BEActivityLocationsModificationOperation::activityLocation = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_push_block(soap, soap_blist_activityLocation1, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation));
					if(a->vd__BEActivityLocationsModificationOperation::activityLocation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->vd__BEActivityLocationsModificationOperation::activityLocation, _vd__BEActivityLocationsModificationOperation_activityLocation);
					a->vd__BEActivityLocationsModificationOperation::activityLocation->soap_default(soap);
				}
				soap_revert(soap);
				if(soap_in__vd__BEActivityLocationsModificationOperation_activityLocation(soap, "vd:activityLocation", a->vd__BEActivityLocationsModificationOperation::activityLocation, ""))
				{	a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation++;
					a->vd__BEActivityLocationsModificationOperation::activityLocation = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__BEActivityLocationsModificationOperation::activityLocation)
			soap_pop_block(soap, soap_blist_activityLocation1);
		if(a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation)
			a->vd__BEActivityLocationsModificationOperation::activityLocation = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_save_block(soap, soap_blist_activityLocation1, NULL, 1);
		else
		{	a->vd__BEActivityLocationsModificationOperation::activityLocation = NULL;
			if(soap_blist_activityLocation1)
				soap_end_block(soap, soap_blist_activityLocation1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__BEActivityLocationsModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, 0, sizeof(vd__BEActivityLocationsModificationOperation), 0, soap_copy_vd__BEActivityLocationsModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_businessEntity1 > 0 || a->vd__BEActivityLocationsModificationOperation::__sizeactivityLocation < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__BEActivityLocationsModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__BEActivityLocationsModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:BEActivityLocationsModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__BEActivityLocationsModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__BEActivityLocationsModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation * SOAP_FMAC4 soap_get_vd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__BEActivityLocationsModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__BEActivityLocationsModificationOperation * FASTCALL soap_instantiate_vd__BEActivityLocationsModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__BEActivityLocationsModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__BEActivityLocationsModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__BEActivityLocationsModificationOperation));
		((vd__BEActivityLocationsModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__BEActivityLocationsModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__BEActivityLocationsModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__BEActivityLocationsModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__BEActivityLocationsModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__BEActivityLocationsModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__BEActivityLocationsModificationOperation %p -> %p\n", q, p));
	*(vd__BEActivityLocationsModificationOperation*)p = *(vd__BEActivityLocationsModificationOperation*)q;
}

void vd__BEModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__BEModificationOperation::type);
	this->vd__BEModificationOperation::affectedList = NULL;
	this->vd__BEModificationOperation::resultingList = NULL;
	soap_default_ent__BEModificationReason(soap, &this->vd__BEModificationOperation::reason);
	/* transient soap skipped */
}

void vd__BEModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__BEModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerToent__BusinessEntityList(soap, &this->vd__BEModificationOperation::affectedList);
	soap_serialize_PointerToent__BusinessEntityList(soap, &this->vd__BEModificationOperation::resultingList);
	soap_serialize_ent__BEModificationReason(soap, &this->vd__BEModificationOperation::reason);
	/* transient soap skipped */
}

int vd__BEModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__BEModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__BEModificationOperation(struct soap *soap, const char *tag, int id, const vd__BEModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__BEModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__BEModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntityList(soap, "vd:affectedList", -1, &(a->vd__BEModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntityList(soap, "vd:resultingList", -1, &(a->vd__BEModificationOperation::resultingList), ""))
		return soap->error;
	if(soap_out_ent__BEModificationReason(soap, "vd:reason", -1, &(a->vd__BEModificationOperation::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__BEModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__BEModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__BEModificationOperation * FASTCALL soap_in_vd__BEModificationOperation(struct soap *soap, const char *tag, vd__BEModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__BEModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__BEModificationOperation, sizeof(vd__BEModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__BEModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__BEModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__BEModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntityList(soap, "vd:affectedList", &(a->vd__BEModificationOperation::affectedList), "ent:BusinessEntityList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntityList(soap, "vd:resultingList", &(a->vd__BEModificationOperation::resultingList), "ent:BusinessEntityList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__BEModificationReason(soap, "vd:reason", &(a->vd__BEModificationOperation::reason), "ent:BEModificationReason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__BEModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__BEModificationOperation, 0, sizeof(vd__BEModificationOperation), 0, soap_copy_vd__BEModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__BEModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__BEModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:BEModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__BEModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__BEModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__BEModificationOperation * SOAP_FMAC4 soap_get_vd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__BEModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__BEModificationOperation * FASTCALL soap_instantiate_vd__BEModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__BEModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__BEModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__BEModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__BEModificationOperation));
		((vd__BEModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__BEModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__BEModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__BEModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__BEModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__BEModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__BEModificationOperation %p -> %p\n", q, p));
	*(vd__BEModificationOperation*)p = *(vd__BEModificationOperation*)q;
}

void vd__PSLModificationOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__RegisterModificationType(soap, &this->vd__PSLModificationOperation::type);
	this->vd__PSLModificationOperation::affectedList = NULL;
	this->vd__PSLModificationOperation::resultingList = NULL;
	/* transient soap skipped */
}

void vd__PSLModificationOperation::soap_serialize(struct soap *soap) const
{
	soap_embedded(soap, &this->vd__PSLModificationOperation::type, SOAP_TYPE_base__RegisterModificationType);
	soap_serialize_PointerToent__ProductItemList(soap, &this->vd__PSLModificationOperation::affectedList);
	soap_serialize_PointerToent__ProductItemList(soap, &this->vd__PSLModificationOperation::resultingList);
	/* transient soap skipped */
}

int vd__PSLModificationOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__PSLModificationOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__PSLModificationOperation(struct soap *soap, const char *tag, int id, const vd__PSLModificationOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__PSLModificationOperation), type))
		return soap->error;
	if(soap_out_base__RegisterModificationType(soap, "vd:type", -1, &(a->vd__PSLModificationOperation::type), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductItemList(soap, "vd:affectedList", -1, &(a->vd__PSLModificationOperation::affectedList), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductItemList(soap, "vd:resultingList", -1, &(a->vd__PSLModificationOperation::resultingList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__PSLModificationOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__PSLModificationOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__PSLModificationOperation * FASTCALL soap_in_vd__PSLModificationOperation(struct soap *soap, const char *tag, vd__PSLModificationOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__PSLModificationOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__PSLModificationOperation, sizeof(vd__PSLModificationOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__PSLModificationOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__PSLModificationOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_base__RegisterModificationType(soap, "vd:type", &(a->vd__PSLModificationOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItemList(soap, "vd:affectedList", &(a->vd__PSLModificationOperation::affectedList), "ent:ProductItemList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItemList(soap, "vd:resultingList", &(a->vd__PSLModificationOperation::resultingList), "ent:ProductItemList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__PSLModificationOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__PSLModificationOperation, 0, sizeof(vd__PSLModificationOperation), 0, soap_copy_vd__PSLModificationOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__PSLModificationOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__PSLModificationOperation);
	return this->soap_out(soap, tag?tag:"vd:PSLModificationOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__PSLModificationOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__PSLModificationOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__PSLModificationOperation * SOAP_FMAC4 soap_get_vd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__PSLModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__PSLModificationOperation * FASTCALL soap_instantiate_vd__PSLModificationOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__PSLModificationOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__PSLModificationOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__PSLModificationOperation);
		ASSIGN_PTR(size, sizeof(vd__PSLModificationOperation));
		((vd__PSLModificationOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__PSLModificationOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__PSLModificationOperation));
		for(int i = 0; i < n; i++)
			((vd__PSLModificationOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__PSLModificationOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__PSLModificationOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__PSLModificationOperation %p -> %p\n", q, p));
	*(vd__PSLModificationOperation*)p = *(vd__PSLModificationOperation*)q;
}

void vd__MergeStockEntriesOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__MergeStockEntriesOperation::type = NULL;
	this->vd__MergeStockEntriesOperation::__sizesourceStockEntry = 0;
	this->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
	this->vd__MergeStockEntriesOperation::__sizeresultStockEntry = 0;
	this->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
	/* transient soap skipped */
}

void vd__MergeStockEntriesOperation::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__RegisterModificationType(soap, &this->vd__MergeStockEntriesOperation::type);
	if(this->vd__MergeStockEntriesOperation::sourceStockEntry) {
		for(int i = 0; i < this->vd__MergeStockEntriesOperation::__sizesourceStockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->vd__MergeStockEntriesOperation::sourceStockEntry + i);
		}
	}
	if(this->vd__MergeStockEntriesOperation::resultStockEntry) {
		for(int i = 0; i < this->vd__MergeStockEntriesOperation::__sizeresultStockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->vd__MergeStockEntriesOperation::resultStockEntry + i);
		}
	}
	/* transient soap skipped */
}

int vd__MergeStockEntriesOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__MergeStockEntriesOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__MergeStockEntriesOperation(struct soap *soap, const char *tag, int id, const vd__MergeStockEntriesOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__MergeStockEntriesOperation), type))
		return soap->error;
	if(soap_out_PointerTobase__RegisterModificationType(soap, "vd:type", -1, &(a->vd__MergeStockEntriesOperation::type), ""))
		return soap->error;
	if(a->vd__MergeStockEntriesOperation::sourceStockEntry) {
		int i;
		for(i = 0; i < a->vd__MergeStockEntriesOperation::__sizesourceStockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", -1, a->vd__MergeStockEntriesOperation::sourceStockEntry + i, ""))
				return soap->error;
	}
	if(a->vd__MergeStockEntriesOperation::resultStockEntry) {
		int i;
		for(i = 0; i < a->vd__MergeStockEntriesOperation::__sizeresultStockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:resultStockEntry", -1, a->vd__MergeStockEntriesOperation::resultStockEntry + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__MergeStockEntriesOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__MergeStockEntriesOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation * FASTCALL soap_in_vd__MergeStockEntriesOperation(struct soap *soap, const char *tag, vd__MergeStockEntriesOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__MergeStockEntriesOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__MergeStockEntriesOperation, sizeof(vd__MergeStockEntriesOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__MergeStockEntriesOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__MergeStockEntriesOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	struct soap_blist *soap_blist_sourceStockEntry1 = NULL;
	struct soap_blist *soap_blist_resultStockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__RegisterModificationType(soap, "vd:type", &(a->vd__MergeStockEntriesOperation::type), "base:RegisterModificationType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:sourceStockEntry", 1, NULL)) {
				if(a->vd__MergeStockEntriesOperation::sourceStockEntry == NULL) {
					if(soap_blist_sourceStockEntry1 == NULL)
						soap_blist_sourceStockEntry1 = soap_new_block(soap);
					a->vd__MergeStockEntriesOperation::sourceStockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_sourceStockEntry1, sizeof(vd__StockEntry *));
					if(a->vd__MergeStockEntriesOperation::sourceStockEntry == NULL)
						return NULL;
					*a->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", a->vd__MergeStockEntriesOperation::sourceStockEntry, "vd:StockEntry"))
				{	a->vd__MergeStockEntriesOperation::__sizesourceStockEntry++;
					a->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:resultStockEntry", 1, NULL)) {
				if(a->vd__MergeStockEntriesOperation::resultStockEntry == NULL) {
					if(soap_blist_resultStockEntry1 == NULL)
						soap_blist_resultStockEntry1 = soap_new_block(soap);
					a->vd__MergeStockEntriesOperation::resultStockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_resultStockEntry1, sizeof(vd__StockEntry *));
					if(a->vd__MergeStockEntriesOperation::resultStockEntry == NULL)
						return NULL;
					*a->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:resultStockEntry", a->vd__MergeStockEntriesOperation::resultStockEntry, "vd:StockEntry"))
				{	a->vd__MergeStockEntriesOperation::__sizeresultStockEntry++;
					a->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__MergeStockEntriesOperation::sourceStockEntry)
			soap_pop_block(soap, soap_blist_sourceStockEntry1);
		if(a->vd__MergeStockEntriesOperation::__sizesourceStockEntry)
			a->vd__MergeStockEntriesOperation::sourceStockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_sourceStockEntry1, NULL, 1);
		else
		{	a->vd__MergeStockEntriesOperation::sourceStockEntry = NULL;
			if(soap_blist_sourceStockEntry1)
				soap_end_block(soap, soap_blist_sourceStockEntry1);
		}
		if(a->vd__MergeStockEntriesOperation::resultStockEntry)
			soap_pop_block(soap, soap_blist_resultStockEntry1);
		if(a->vd__MergeStockEntriesOperation::__sizeresultStockEntry)
			a->vd__MergeStockEntriesOperation::resultStockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_resultStockEntry1, NULL, 1);
		else
		{	a->vd__MergeStockEntriesOperation::resultStockEntry = NULL;
			if(soap_blist_resultStockEntry1)
				soap_end_block(soap, soap_blist_resultStockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__MergeStockEntriesOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__MergeStockEntriesOperation, 0, sizeof(vd__MergeStockEntriesOperation), 0, soap_copy_vd__MergeStockEntriesOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (a->vd__MergeStockEntriesOperation::__sizesourceStockEntry < 2)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__MergeStockEntriesOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__MergeStockEntriesOperation);
	return this->soap_out(soap, tag?tag:"vd:MergeStockEntriesOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__MergeStockEntriesOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__MergeStockEntriesOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation * SOAP_FMAC4 soap_get_vd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__MergeStockEntriesOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__MergeStockEntriesOperation * FASTCALL soap_instantiate_vd__MergeStockEntriesOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__MergeStockEntriesOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__MergeStockEntriesOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__MergeStockEntriesOperation);
		ASSIGN_PTR(size, sizeof(vd__MergeStockEntriesOperation));
		((vd__MergeStockEntriesOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__MergeStockEntriesOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__MergeStockEntriesOperation));
		for(int i = 0; i < n; i++)
			((vd__MergeStockEntriesOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__MergeStockEntriesOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__MergeStockEntriesOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__MergeStockEntriesOperation %p -> %p\n", q, p));
	*(vd__MergeStockEntriesOperation*)p = *(vd__MergeStockEntriesOperation*)q;
}

void vd__ProductionOperation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ProductionOperation::operationId = NULL;
	this->vd__ProductionOperation::__sizerawBatch = 0;
	this->vd__ProductionOperation::rawBatch = NULL;
	this->vd__ProductionOperation::__sizeproductiveBatch = 0;
	this->vd__ProductionOperation::productiveBatch = NULL;
	this->vd__ProductionOperation::finalizeOperation = NULL;
	this->vd__ProductionOperation::__sizeappliedProcess = 0;
	this->vd__ProductionOperation::appliedProcess = NULL;
	/* transient soap skipped */
}

void vd__ProductionOperation::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->vd__ProductionOperation::operationId);
	if(this->vd__ProductionOperation::rawBatch) {
		for(int i = 0; i < this->vd__ProductionOperation::__sizerawBatch; i++) {
			soap_serialize_PointerTovd__RawBatch(soap, this->vd__ProductionOperation::rawBatch + i);
		}
	}
	if(this->vd__ProductionOperation::productiveBatch) {
		for(int i = 0; i < this->vd__ProductionOperation::__sizeproductiveBatch; i++) {
			soap_serialize_PointerTovd__ProductiveBatch(soap, this->vd__ProductionOperation::productiveBatch + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__ProductionOperation::finalizeOperation);
	if(this->vd__ProductionOperation::appliedProcess) {
		for(int i = 0; i < this->vd__ProductionOperation::__sizeappliedProcess; i++) {
			soap_serialize_PointerTovd__ProcessingProcedure(soap, this->vd__ProductionOperation::appliedProcess + i);
		}
	}
	/* transient soap skipped */
}

int vd__ProductionOperation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ProductionOperation(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProductionOperation(struct soap *soap, const char *tag, int id, const vd__ProductionOperation *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProductionOperation), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "vd:operationId", -1, &(a->vd__ProductionOperation::operationId), ""))
		return soap->error;
	if(a->vd__ProductionOperation::rawBatch) {
		int i;
		for(i = 0; i < a->vd__ProductionOperation::__sizerawBatch; i++)
			if(soap_out_PointerTovd__RawBatch(soap, "vd:rawBatch", -1, a->vd__ProductionOperation::rawBatch + i, ""))
				return soap->error;
	}
	if(a->vd__ProductionOperation::productiveBatch) {
		int i;
		for(i = 0; i < a->vd__ProductionOperation::__sizeproductiveBatch; i++)
			if(soap_out_PointerTovd__ProductiveBatch(soap, "vd:productiveBatch", -1, a->vd__ProductionOperation::productiveBatch + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:finalizeOperation", -1, &(a->vd__ProductionOperation::finalizeOperation), ""))
		return soap->error;
	if(a->vd__ProductionOperation::appliedProcess) {
		int i;
		for(i = 0; i < a->vd__ProductionOperation::__sizeappliedProcess; i++)
			if(soap_out_PointerTovd__ProcessingProcedure(soap, "vd:appliedProcess", -1, a->vd__ProductionOperation::appliedProcess + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ProductionOperation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ProductionOperation(soap, tag, this, type);
}

SOAP_FMAC3 vd__ProductionOperation * FASTCALL soap_in_vd__ProductionOperation(struct soap *soap, const char *tag, vd__ProductionOperation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ProductionOperation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProductionOperation, sizeof(vd__ProductionOperation), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ProductionOperation) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ProductionOperation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_operationId1 = 1;
	struct soap_blist *soap_blist_rawBatch1 = NULL;
	struct soap_blist *soap_blist_productiveBatch1 = NULL;
	size_t soap_flag_finalizeOperation1 = 1;
	struct soap_blist *soap_blist_appliedProcess1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_operationId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "vd:operationId", &(a->vd__ProductionOperation::operationId), "base:Identifier"))
				{	soap_flag_operationId1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:rawBatch", 1, NULL)) {
				if(a->vd__ProductionOperation::rawBatch == NULL) {
					if(soap_blist_rawBatch1 == NULL)
						soap_blist_rawBatch1 = soap_new_block(soap);
					a->vd__ProductionOperation::rawBatch = (vd__RawBatch **)soap_push_block(soap, soap_blist_rawBatch1, sizeof(vd__RawBatch *));
					if(a->vd__ProductionOperation::rawBatch == NULL)
						return NULL;
					*a->vd__ProductionOperation::rawBatch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__RawBatch(soap, "vd:rawBatch", a->vd__ProductionOperation::rawBatch, "vd:RawBatch"))
				{	a->vd__ProductionOperation::__sizerawBatch++;
					a->vd__ProductionOperation::rawBatch = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:productiveBatch", 1, NULL)) {
				if(a->vd__ProductionOperation::productiveBatch == NULL) {
					if(soap_blist_productiveBatch1 == NULL)
						soap_blist_productiveBatch1 = soap_new_block(soap);
					a->vd__ProductionOperation::productiveBatch = (vd__ProductiveBatch **)soap_push_block(soap, soap_blist_productiveBatch1, sizeof(vd__ProductiveBatch *));
					if(a->vd__ProductionOperation::productiveBatch == NULL)
						return NULL;
					*a->vd__ProductionOperation::productiveBatch = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ProductiveBatch(soap, "vd:productiveBatch", a->vd__ProductionOperation::productiveBatch, "vd:ProductiveBatch"))
				{	a->vd__ProductionOperation::__sizeproductiveBatch++;
					a->vd__ProductionOperation::productiveBatch = NULL;
					continue;
				}
			}
			if(soap_flag_finalizeOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:finalizeOperation", &(a->vd__ProductionOperation::finalizeOperation), "xsd:boolean"))
				{	soap_flag_finalizeOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:appliedProcess", 1, NULL)) {
				if(a->vd__ProductionOperation::appliedProcess == NULL) {
					if(soap_blist_appliedProcess1 == NULL)
						soap_blist_appliedProcess1 = soap_new_block(soap);
					a->vd__ProductionOperation::appliedProcess = (vd__ProcessingProcedure **)soap_push_block(soap, soap_blist_appliedProcess1, sizeof(vd__ProcessingProcedure *));
					if(a->vd__ProductionOperation::appliedProcess == NULL)
						return NULL;
					*a->vd__ProductionOperation::appliedProcess = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ProcessingProcedure(soap, "vd:appliedProcess", a->vd__ProductionOperation::appliedProcess, "vd:ProcessingProcedure"))
				{	a->vd__ProductionOperation::__sizeappliedProcess++;
					a->vd__ProductionOperation::appliedProcess = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__ProductionOperation::rawBatch)
			soap_pop_block(soap, soap_blist_rawBatch1);
		if(a->vd__ProductionOperation::__sizerawBatch)
			a->vd__ProductionOperation::rawBatch = (vd__RawBatch **)soap_save_block(soap, soap_blist_rawBatch1, NULL, 1);
		else
		{	a->vd__ProductionOperation::rawBatch = NULL;
			if(soap_blist_rawBatch1)
				soap_end_block(soap, soap_blist_rawBatch1);
		}
		if(a->vd__ProductionOperation::productiveBatch)
			soap_pop_block(soap, soap_blist_productiveBatch1);
		if(a->vd__ProductionOperation::__sizeproductiveBatch)
			a->vd__ProductionOperation::productiveBatch = (vd__ProductiveBatch **)soap_save_block(soap, soap_blist_productiveBatch1, NULL, 1);
		else
		{	a->vd__ProductionOperation::productiveBatch = NULL;
			if(soap_blist_productiveBatch1)
				soap_end_block(soap, soap_blist_productiveBatch1);
		}
		if(a->vd__ProductionOperation::appliedProcess)
			soap_pop_block(soap, soap_blist_appliedProcess1);
		if(a->vd__ProductionOperation::__sizeappliedProcess)
			a->vd__ProductionOperation::appliedProcess = (vd__ProcessingProcedure **)soap_save_block(soap, soap_blist_appliedProcess1, NULL, 1);
		else
		{	a->vd__ProductionOperation::appliedProcess = NULL;
			if(soap_blist_appliedProcess1)
				soap_end_block(soap, soap_blist_appliedProcess1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ProductionOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProductionOperation, 0, sizeof(vd__ProductionOperation), 0, soap_copy_vd__ProductionOperation);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ProductionOperation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ProductionOperation);
	return this->soap_out(soap, tag?tag:"vd:ProductionOperation", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ProductionOperation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ProductionOperation(soap, this, tag, type);
}

SOAP_FMAC3 vd__ProductionOperation * SOAP_FMAC4 soap_get_vd__ProductionOperation(struct soap *soap, vd__ProductionOperation *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProductionOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ProductionOperation * FASTCALL soap_instantiate_vd__ProductionOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ProductionOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ProductionOperation, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ProductionOperation);
		ASSIGN_PTR(size, sizeof(vd__ProductionOperation));
		((vd__ProductionOperation*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ProductionOperation[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ProductionOperation));
		for(int i = 0; i < n; i++)
			((vd__ProductionOperation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ProductionOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ProductionOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ProductionOperation %p -> %p\n", q, p));
	*(vd__ProductionOperation*)p = *(vd__ProductionOperation*)q;
}

void vd__ShipmentRoute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ShipmentRoute::__sizeroutePoint = 0;
	this->vd__ShipmentRoute::routePoint = NULL;
	/* transient soap skipped */
}

void vd__ShipmentRoute::soap_serialize(struct soap *soap) const
{
	if(this->vd__ShipmentRoute::routePoint) {
		for(int i = 0; i < this->vd__ShipmentRoute::__sizeroutePoint; i++) {
			soap_serialize_PointerTovd__ShipmentRoutePoint(soap, this->vd__ShipmentRoute::routePoint + i);
		}
	}
	/* transient soap skipped */
}

int vd__ShipmentRoute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ShipmentRoute(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ShipmentRoute(struct soap *soap, const char *tag, int id, const vd__ShipmentRoute *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ShipmentRoute), type))
		return soap->error;
	if(a->vd__ShipmentRoute::routePoint) {
		int i;
		for(i = 0; i < a->vd__ShipmentRoute::__sizeroutePoint; i++)
			if(soap_out_PointerTovd__ShipmentRoutePoint(soap, "vd:routePoint", -1, a->vd__ShipmentRoute::routePoint + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ShipmentRoute::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ShipmentRoute(soap, tag, this, type);
}

SOAP_FMAC3 vd__ShipmentRoute * FASTCALL soap_in_vd__ShipmentRoute(struct soap *soap, const char *tag, vd__ShipmentRoute *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ShipmentRoute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ShipmentRoute, sizeof(vd__ShipmentRoute), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ShipmentRoute) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ShipmentRoute *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_routePoint1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:routePoint", 1, NULL)) {
				if(a->vd__ShipmentRoute::routePoint == NULL) {
					if(soap_blist_routePoint1 == NULL)
						soap_blist_routePoint1 = soap_new_block(soap);
					a->vd__ShipmentRoute::routePoint = (vd__ShipmentRoutePoint **)soap_push_block(soap, soap_blist_routePoint1, sizeof(vd__ShipmentRoutePoint *));
					if(a->vd__ShipmentRoute::routePoint == NULL)
						return NULL;
					*a->vd__ShipmentRoute::routePoint = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ShipmentRoutePoint(soap, "vd:routePoint", a->vd__ShipmentRoute::routePoint, "vd:ShipmentRoutePoint"))
				{	a->vd__ShipmentRoute::__sizeroutePoint++;
					a->vd__ShipmentRoute::routePoint = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__ShipmentRoute::routePoint)
			soap_pop_block(soap, soap_blist_routePoint1);
		if(a->vd__ShipmentRoute::__sizeroutePoint)
			a->vd__ShipmentRoute::routePoint = (vd__ShipmentRoutePoint **)soap_save_block(soap, soap_blist_routePoint1, NULL, 1);
		else
		{	a->vd__ShipmentRoute::routePoint = NULL;
			if(soap_blist_routePoint1)
				soap_end_block(soap, soap_blist_routePoint1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ShipmentRoute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ShipmentRoute, 0, sizeof(vd__ShipmentRoute), 0, soap_copy_vd__ShipmentRoute);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ShipmentRoute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ShipmentRoute);
	return this->soap_out(soap, tag?tag:"vd:ShipmentRoute", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ShipmentRoute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ShipmentRoute(soap, this, tag, type);
}

SOAP_FMAC3 vd__ShipmentRoute * SOAP_FMAC4 soap_get_vd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ShipmentRoute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ShipmentRoute * FASTCALL soap_instantiate_vd__ShipmentRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ShipmentRoute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ShipmentRoute, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoute);
		ASSIGN_PTR(size, sizeof(vd__ShipmentRoute));
		((vd__ShipmentRoute*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoute[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ShipmentRoute));
		for(int i = 0; i < n; i++)
			((vd__ShipmentRoute*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ShipmentRoute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ShipmentRoute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ShipmentRoute %p -> %p\n", q, p));
	*(vd__ShipmentRoute*)p = *(vd__ShipmentRoute*)q;
}

void vd__ShipmentRoutePoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ShipmentRoutePoint::sqnId = NULL;
	this->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint = 0;
	this->vd__ShipmentRoutePoint::transshipment = NULL;
	this->vd__ShipmentRoutePoint::nextTransport = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__ShipmentRoutePoint::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__SequenceNumber(soap, &this->vd__ShipmentRoutePoint::sqnId);
	soap_serialize__vd__union_ShipmentRoutePoint(soap, this->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint, &this->vd__ShipmentRoutePoint::union_ShipmentRoutePoint);
	soap_serialize_PointerTobool(soap, &this->vd__ShipmentRoutePoint::transshipment);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__ShipmentRoutePoint::nextTransport);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__ShipmentRoutePoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ShipmentRoutePoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, const vd__ShipmentRoutePoint *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ShipmentRoutePoint), "vd:ShipmentRoutePoint"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTobase__SequenceNumber(soap, "vd:sqnId", -1, &(a->vd__ShipmentRoutePoint::sqnId), ""))
		return soap->error;
	if(soap_out__vd__union_ShipmentRoutePoint(soap, a->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint, &a->vd__ShipmentRoutePoint::union_ShipmentRoutePoint))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:transshipment", -1, &(a->vd__ShipmentRoutePoint::transshipment), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:nextTransport", -1, &(a->vd__ShipmentRoutePoint::nextTransport), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__ShipmentRoutePoint::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ShipmentRoutePoint(soap, tag, this, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint * FASTCALL soap_in_vd__ShipmentRoutePoint(struct soap *soap, const char *tag, vd__ShipmentRoutePoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ShipmentRoutePoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ShipmentRoutePoint, sizeof(vd__ShipmentRoutePoint), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ShipmentRoutePoint) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ShipmentRoutePoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_sqnId1 = 1;
	size_t soap_flag_union_ShipmentRoutePoint1 = 1;
	size_t soap_flag_transshipment1 = 1;
	size_t soap_flag_nextTransport1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_sqnId1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__SequenceNumber(soap, "vd:sqnId", &(a->vd__ShipmentRoutePoint::sqnId), "base:SequenceNumber"))
				{	soap_flag_sqnId1--;
					continue;
				}
			if(soap_flag_union_ShipmentRoutePoint1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_ShipmentRoutePoint(soap, &a->vd__ShipmentRoutePoint::__union_ShipmentRoutePoint, &a->vd__ShipmentRoutePoint::union_ShipmentRoutePoint))
				{	soap_flag_union_ShipmentRoutePoint1 = 0;
					continue;
				}
			if(soap_flag_transshipment1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:transshipment", &(a->vd__ShipmentRoutePoint::transshipment), "xsd:boolean"))
				{	soap_flag_transshipment1--;
					continue;
				}
			if(soap_flag_nextTransport1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:nextTransport", &(a->vd__ShipmentRoutePoint::nextTransport), "vd:TransportInfo"))
				{	soap_flag_nextTransport1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ShipmentRoutePoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ShipmentRoutePoint, 0, sizeof(vd__ShipmentRoutePoint), 0, soap_copy_vd__ShipmentRoutePoint);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ShipmentRoutePoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ShipmentRoutePoint);
	return this->soap_out(soap, tag?tag:"vd:ShipmentRoutePoint", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ShipmentRoutePoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ShipmentRoutePoint(soap, this, tag, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint * SOAP_FMAC4 soap_get_vd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ShipmentRoutePoint * FASTCALL soap_instantiate_vd__ShipmentRoutePoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ShipmentRoutePoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ShipmentRoutePoint, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint);
		ASSIGN_PTR(size, sizeof(vd__ShipmentRoutePoint));
		((vd__ShipmentRoutePoint*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ShipmentRoutePoint));
		for(int i = 0; i < n; i++)
			((vd__ShipmentRoutePoint*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ShipmentRoutePoint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ShipmentRoutePoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ShipmentRoutePoint %p -> %p\n", q, p));
	*(vd__ShipmentRoutePoint*)p = *(vd__ShipmentRoutePoint*)q;
}

void vd__TransportNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->vd__TransportNumber::containerNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::wagonNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::vehicleNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::trailerNumber);
	soap_default_base__String255(soap, &this->vd__TransportNumber::shipName);
	soap_default_base__String255(soap, &this->vd__TransportNumber::flightNumber);
	/* transient soap skipped */
}

void vd__TransportNumber::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::containerNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::wagonNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::vehicleNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::trailerNumber);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::shipName);
	soap_serialize_base__String255(soap, &this->vd__TransportNumber::flightNumber);
	/* transient soap skipped */
}

int vd__TransportNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__TransportNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__TransportNumber(struct soap *soap, const char *tag, int id, const vd__TransportNumber *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__TransportNumber), type))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:containerNumber", -1, &(a->vd__TransportNumber::containerNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:wagonNumber", -1, &(a->vd__TransportNumber::wagonNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:vehicleNumber", -1, &(a->vd__TransportNumber::vehicleNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:trailerNumber", -1, &(a->vd__TransportNumber::trailerNumber), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:shipName", -1, &(a->vd__TransportNumber::shipName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:flightNumber", -1, &(a->vd__TransportNumber::flightNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__TransportNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__TransportNumber(soap, tag, this, type);
}

SOAP_FMAC3 vd__TransportNumber * FASTCALL soap_in_vd__TransportNumber(struct soap *soap, const char *tag, vd__TransportNumber *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__TransportNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__TransportNumber, sizeof(vd__TransportNumber), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__TransportNumber) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__TransportNumber *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_containerNumber1 = 1;
	size_t soap_flag_wagonNumber1 = 1;
	size_t soap_flag_vehicleNumber1 = 1;
	size_t soap_flag_trailerNumber1 = 1;
	size_t soap_flag_shipName1 = 1;
	size_t soap_flag_flightNumber1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_containerNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:containerNumber", &(a->vd__TransportNumber::containerNumber), "base:String255"))
				{	soap_flag_containerNumber1--;
					continue;
				}
			if(soap_flag_wagonNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:wagonNumber", &(a->vd__TransportNumber::wagonNumber), "base:String255"))
				{	soap_flag_wagonNumber1--;
					continue;
				}
			if(soap_flag_vehicleNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:vehicleNumber", &(a->vd__TransportNumber::vehicleNumber), "base:String255"))
				{	soap_flag_vehicleNumber1--;
					continue;
				}
			if(soap_flag_trailerNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:trailerNumber", &(a->vd__TransportNumber::trailerNumber), "base:String255"))
				{	soap_flag_trailerNumber1--;
					continue;
				}
			if(soap_flag_shipName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:shipName", &(a->vd__TransportNumber::shipName), "base:String255"))
				{	soap_flag_shipName1--;
					continue;
				}
			if(soap_flag_flightNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:flightNumber", &(a->vd__TransportNumber::flightNumber), "base:String255"))
				{	soap_flag_flightNumber1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__TransportNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__TransportNumber, 0, sizeof(vd__TransportNumber), 0, soap_copy_vd__TransportNumber);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__TransportNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__TransportNumber);
	return this->soap_out(soap, tag?tag:"vd:TransportNumber", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__TransportNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__TransportNumber(soap, this, tag, type);
}

SOAP_FMAC3 vd__TransportNumber * SOAP_FMAC4 soap_get_vd__TransportNumber(struct soap *soap, vd__TransportNumber *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__TransportNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__TransportNumber * FASTCALL soap_instantiate_vd__TransportNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__TransportNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__TransportNumber, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__TransportNumber);
		ASSIGN_PTR(size, sizeof(vd__TransportNumber));
		((vd__TransportNumber*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__TransportNumber[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__TransportNumber));
		for(int i = 0; i < n; i++)
			((vd__TransportNumber*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__TransportNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__TransportNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__TransportNumber %p -> %p\n", q, p));
	*(vd__TransportNumber*)p = *(vd__TransportNumber*)q;
}

void vd__TransportInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__TransportInfo::transportType = NULL;
	this->vd__TransportInfo::transportNumber = NULL;
	/* transient soap skipped */
}

void vd__TransportInfo::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__TransportType(soap, &this->vd__TransportInfo::transportType);
	soap_serialize_PointerTovd__TransportNumber(soap, &this->vd__TransportInfo::transportNumber);
	/* transient soap skipped */
}

int vd__TransportInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__TransportInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__TransportInfo(struct soap *soap, const char *tag, int id, const vd__TransportInfo *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__TransportInfo), type))
		return soap->error;
	if(soap_out_PointerToent__TransportType(soap, "vd:transportType", -1, &(a->vd__TransportInfo::transportType), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportNumber(soap, "vd:transportNumber", -1, &(a->vd__TransportInfo::transportNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__TransportInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__TransportInfo(soap, tag, this, type);
}

SOAP_FMAC3 vd__TransportInfo * FASTCALL soap_in_vd__TransportInfo(struct soap *soap, const char *tag, vd__TransportInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__TransportInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__TransportInfo, sizeof(vd__TransportInfo), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__TransportInfo) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__TransportInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_transportType1 = 1;
	size_t soap_flag_transportNumber1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_transportType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__TransportType(soap, "vd:transportType", &(a->vd__TransportInfo::transportType), "ent:TransportType"))
				{	soap_flag_transportType1--;
					continue;
				}
			if(soap_flag_transportNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportNumber(soap, "vd:transportNumber", &(a->vd__TransportInfo::transportNumber), "vd:TransportNumber"))
				{	soap_flag_transportNumber1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__TransportInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__TransportInfo, 0, sizeof(vd__TransportInfo), 0, soap_copy_vd__TransportInfo);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__TransportInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__TransportInfo);
	return this->soap_out(soap, tag?tag:"vd:TransportInfo", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__TransportInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__TransportInfo(soap, this, tag, type);
}

SOAP_FMAC3 vd__TransportInfo * SOAP_FMAC4 soap_get_vd__TransportInfo(struct soap *soap, vd__TransportInfo *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__TransportInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__TransportInfo * FASTCALL soap_instantiate_vd__TransportInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__TransportInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__TransportInfo, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__TransportInfo);
		ASSIGN_PTR(size, sizeof(vd__TransportInfo));
		((vd__TransportInfo*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__TransportInfo[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__TransportInfo));
		for(int i = 0; i < n; i++)
			((vd__TransportInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__TransportInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__TransportInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__TransportInfo %p -> %p\n", q, p));
	*(vd__TransportInfo*)p = *(vd__TransportInfo*)q;
}

void vd__Waybill::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Waybill::consignor = NULL;
	this->vd__Waybill::consignee = NULL;
	this->vd__Waybill::broker = NULL;
	this->vd__Waybill::transportInfo = NULL;
	this->vd__Waybill::transportStorageType = NULL;
	this->vd__Waybill::shipmentRoute = NULL;
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__Waybill::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__Waybill::consignor);
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__Waybill::consignee);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__Waybill::broker);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__Waybill::transportInfo);
	soap_serialize_PointerToent__TransportationStorageType(soap, &this->vd__Waybill::transportStorageType);
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->vd__Waybill::shipmentRoute);
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerToent__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerToent__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__Waybill::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Waybill(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Waybill(struct soap *soap, const char *tag, int id, const vd__Waybill *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Waybill), "vd:Waybill"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerToent__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:consignor", -1, &(a->vd__Waybill::consignor), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:consignee", -1, &(a->vd__Waybill::consignee), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "vd:broker", -1, &(a->vd__Waybill::broker), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:transportInfo", -1, &(a->vd__Waybill::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerToent__TransportationStorageType(soap, "vd:transportStorageType", -1, &(a->vd__Waybill::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &(a->vd__Waybill::shipmentRoute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Waybill::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Waybill(soap, tag, this, type);
}

SOAP_FMAC3 vd__Waybill * FASTCALL soap_in_vd__Waybill(struct soap *soap, const char *tag, vd__Waybill *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Waybill *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Waybill, sizeof(vd__Waybill), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Waybill) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Waybill *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DocumentType(soap, "vd:type", &(a->vd__Document::type), "ent:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "ent:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:consignor", &(a->vd__Waybill::consignor), "ent:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:consignee", &(a->vd__Waybill::consignee), "ent:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:broker", &(a->vd__Waybill::broker), "ent:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:transportInfo", &(a->vd__Waybill::transportInfo), "vd:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__TransportationStorageType(soap, "vd:transportStorageType", &(a->vd__Waybill::transportStorageType), "ent:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->vd__Waybill::shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Waybill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Waybill, 0, sizeof(vd__Waybill), 0, soap_copy_vd__Waybill);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Waybill::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Waybill);
	return this->soap_out(soap, tag?tag:"vd:Waybill", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Waybill::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Waybill(soap, this, tag, type);
}

SOAP_FMAC3 vd__Waybill * SOAP_FMAC4 soap_get_vd__Waybill(struct soap *soap, vd__Waybill *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Waybill(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Waybill * FASTCALL soap_instantiate_vd__Waybill(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Waybill(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Waybill, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Waybill);
		ASSIGN_PTR(size, sizeof(vd__Waybill));
		((vd__Waybill*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Waybill[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Waybill));
		for(int i = 0; i < n; i++)
			((vd__Waybill*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Waybill*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Waybill(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Waybill %p -> %p\n", q, p));
	*(vd__Waybill*)p = *(vd__Waybill*)q;
}

void vd__Document::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__Document::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerToent__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerToent__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__Document::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Document(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Document(struct soap *soap, const char *tag, int id, const vd__Document *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Document), "vd:Document"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerToent__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Document::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Document(soap, tag, this, type);
}

SOAP_FMAC3 vd__Document * FASTCALL soap_in_vd__Document(struct soap *soap, const char *tag, vd__Document *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Document *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Document, sizeof(vd__Document), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Document) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Document *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_form1 = 1;
	size_t soap_flag_issueSeries1 = 1;
	size_t soap_flag_issueNumber1 = 1;
	size_t soap_flag_issueDate1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_issuer1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_form1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form1--;
					continue;
				}
			if(soap_flag_issueSeries1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries1--;
					continue;
				}
			if(soap_flag_issueNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber1--;
					continue;
				}
			if(soap_flag_issueDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DocumentType(soap, "vd:type", &(a->vd__Document::type), "ent:DocumentType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_issuer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "ent:Organization"))
				{	soap_flag_issuer1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Document *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Document, 0, sizeof(vd__Document), 0, soap_copy_vd__Document);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Document::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Document);
	return this->soap_out(soap, tag?tag:"vd:Document", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Document::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Document(soap, this, tag, type);
}

SOAP_FMAC3 vd__Document * SOAP_FMAC4 soap_get_vd__Document(struct soap *soap, vd__Document *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Document * FASTCALL soap_instantiate_vd__Document(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Document(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Document, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:VetDocument")) {
		cp->type = SOAP_TYPE_vd__VetDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__VetDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__VetDocument));
			((vd__VetDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__VetDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__VetDocument));
			for(int i = 0; i < n; i++)
				((vd__VetDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__VetDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:DiscrepancyReport")) {
		cp->type = SOAP_TYPE_vd__DiscrepancyReport;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__DiscrepancyReport));
			((vd__DiscrepancyReport*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport[n]);
			ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReport));
			for(int i = 0; i < n; i++)
				((vd__DiscrepancyReport*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__DiscrepancyReport*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Waybill")) {
		cp->type = SOAP_TYPE_vd__Waybill;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Waybill);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Waybill));
			((vd__Waybill*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Waybill[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Waybill));
			for(int i = 0; i < n; i++)
				((vd__Waybill*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Waybill*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ReferencedDocument")) {
		cp->type = SOAP_TYPE_vd__ReferencedDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ReferencedDocument));
			((vd__ReferencedDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ReferencedDocument));
			for(int i = 0; i < n; i++)
				((vd__ReferencedDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ReferencedDocument*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Document);
		ASSIGN_PTR(size, sizeof(vd__Document));
		((vd__Document*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Document[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Document));
		for(int i = 0; i < n; i++)
			((vd__Document*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Document*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Document(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Document %p -> %p\n", q, p));
	*(vd__Document*)p = *(vd__Document*)q;
}

void vd__StockEntrySearchPattern::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockEntrySearchPattern::blankFilter = NULL;
	soap_default_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	this->vd__StockEntry::batch = NULL;
	this->vd__StockEntry::__sizevetDocument = 0;
	this->vd__StockEntry::vetDocument = NULL;
	this->vd__StockEntry::vetEventList = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__StockEntrySearchPattern::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryBlankFilter(soap, &this->vd__StockEntrySearchPattern::blankFilter);
	soap_serialize_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__StockEntry::batch);
	if(this->vd__StockEntry::vetDocument) {
		for(int i = 0; i < this->vd__StockEntry::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__StockEntry::vetDocument + i);
		}
	}
	soap_serialize_PointerTovd__StockEntryEventList(soap, &this->vd__StockEntry::vetEventList);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__StockEntrySearchPattern::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntrySearchPattern(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntrySearchPattern(struct soap *soap, const char *tag, int id, const vd__StockEntrySearchPattern *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntrySearchPattern), "vd:StockEntrySearchPattern"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_vd__StockEntryNumber(soap, "vd:entryNumber", -1, &(a->vd__StockEntry::entryNumber), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__StockEntry::batch), ""))
		return soap->error;
	if(a->vd__StockEntry::vetDocument) {
		int i;
		for(i = 0; i < a->vd__StockEntry::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->vd__StockEntry::vetDocument + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", -1, &(a->vd__StockEntry::vetEventList), ""))
		return soap->error;
	if(soap_out_PointerTovd__StockEntryBlankFilter(soap, "vd:blankFilter", -1, &(a->vd__StockEntrySearchPattern::blankFilter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntrySearchPattern::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntrySearchPattern(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntrySearchPattern * FASTCALL soap_in_vd__StockEntrySearchPattern(struct soap *soap, const char *tag, vd__StockEntrySearchPattern *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntrySearchPattern *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntrySearchPattern, sizeof(vd__StockEntrySearchPattern), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntrySearchPattern) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntrySearchPattern *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_entryNumber2 = 1;
	size_t soap_flag_batch2 = 1;
	struct soap_blist *soap_blist_vetDocument2 = NULL;
	size_t soap_flag_vetEventList2 = 1;
	size_t soap_flag_blankFilter1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_entryNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__StockEntryNumber(soap, "vd:entryNumber", &(a->vd__StockEntry::entryNumber), "vd:StockEntryNumber"))
				{	soap_flag_entryNumber2--;
					continue;
				}
			if(soap_flag_batch2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__StockEntry::batch), "vd:Batch"))
				{	soap_flag_batch2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->vd__StockEntry::vetDocument == NULL) {
					if(soap_blist_vetDocument2 == NULL)
						soap_blist_vetDocument2 = soap_new_block(soap);
					a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument2, sizeof(vd__VetDocument *));
					if(a->vd__StockEntry::vetDocument == NULL)
						return NULL;
					*a->vd__StockEntry::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->vd__StockEntry::vetDocument, "vd:VetDocument"))
				{	a->vd__StockEntry::__sizevetDocument++;
					a->vd__StockEntry::vetDocument = NULL;
					continue;
				}
			}
			if(soap_flag_vetEventList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", &(a->vd__StockEntry::vetEventList), "vd:StockEntryEventList"))
				{	soap_flag_vetEventList2--;
					continue;
				}
			if(soap_flag_blankFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryBlankFilter(soap, "vd:blankFilter", &(a->vd__StockEntrySearchPattern::blankFilter), "vd:StockEntryBlankFilter"))
				{	soap_flag_blankFilter1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntry::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument2);
		if(a->vd__StockEntry::__sizevetDocument)
			a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument2, NULL, 1);
		else
		{	a->vd__StockEntry::vetDocument = NULL;
			if(soap_blist_vetDocument2)
				soap_end_block(soap, soap_blist_vetDocument2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntrySearchPattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntrySearchPattern, 0, sizeof(vd__StockEntrySearchPattern), 0, soap_copy_vd__StockEntrySearchPattern);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntrySearchPattern::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntrySearchPattern);
	return this->soap_out(soap, tag?tag:"vd:StockEntrySearchPattern", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntrySearchPattern::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntrySearchPattern(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntrySearchPattern * SOAP_FMAC4 soap_get_vd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntrySearchPattern(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntrySearchPattern * FASTCALL soap_instantiate_vd__StockEntrySearchPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntrySearchPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntrySearchPattern, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
		ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
		((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
		for(int i = 0; i < n; i++)
			((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntrySearchPattern*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntrySearchPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntrySearchPattern %p -> %p\n", q, p));
	*(vd__StockEntrySearchPattern*)p = *(vd__StockEntrySearchPattern*)q;
}

void vd__StockDiscrepancy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockDiscrepancy::affectedList = NULL;
	this->vd__StockDiscrepancy::resultingList = NULL;
	soap_default_string(soap, &this->vd__StockDiscrepancy::reason);
	soap_default_xsd__ID(soap, &this->vd__StockDiscrepancy::id);
	/* transient soap skipped */
}

void vd__StockDiscrepancy::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->vd__StockDiscrepancy::affectedList);
	soap_serialize_PointerTovd__StockEntryList(soap, &this->vd__StockDiscrepancy::resultingList);
	soap_serialize_string(soap, &this->vd__StockDiscrepancy::reason);
	/* transient soap skipped */
}

int vd__StockDiscrepancy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockDiscrepancy(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockDiscrepancy(struct soap *soap, const char *tag, int id, const vd__StockDiscrepancy *a, const char *type)
{
	if(((vd__StockDiscrepancy*)a)->id)
		soap_set_attr(soap, "id", ((vd__StockDiscrepancy*)a)->id, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockDiscrepancy), type))
		return soap->error;
	if(soap_out_PointerTovd__StockEntryList(soap, "vd:affectedList", -1, &(a->vd__StockDiscrepancy::affectedList), ""))
		return soap->error;
	if(soap_out_PointerTovd__StockEntryList(soap, "vd:resultingList", -1, &(a->vd__StockDiscrepancy::resultingList), ""))
		return soap->error;
	if(soap_out_string(soap, "vd:reason", -1, &(a->vd__StockDiscrepancy::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__StockDiscrepancy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockDiscrepancy(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockDiscrepancy * FASTCALL soap_in_vd__StockDiscrepancy(struct soap *soap, const char *tag, vd__StockDiscrepancy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockDiscrepancy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockDiscrepancy, sizeof(vd__StockDiscrepancy), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockDiscrepancy) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockDiscrepancy *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((vd__StockDiscrepancy*)a)->id, 0, -1))
		return NULL;
	size_t soap_flag_affectedList1 = 1;
	size_t soap_flag_resultingList1 = 1;
	size_t soap_flag_reason1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_affectedList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:affectedList", &(a->vd__StockDiscrepancy::affectedList), "vd:StockEntryList"))
				{	soap_flag_affectedList1--;
					continue;
				}
			if(soap_flag_resultingList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:resultingList", &(a->vd__StockDiscrepancy::resultingList), "vd:StockEntryList"))
				{	soap_flag_resultingList1--;
					continue;
				}
			if(soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "vd:reason", &(a->vd__StockDiscrepancy::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockDiscrepancy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockDiscrepancy, 0, sizeof(vd__StockDiscrepancy), 0, soap_copy_vd__StockDiscrepancy);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockDiscrepancy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockDiscrepancy);
	return this->soap_out(soap, tag?tag:"vd:StockDiscrepancy", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockDiscrepancy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockDiscrepancy(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockDiscrepancy * SOAP_FMAC4 soap_get_vd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockDiscrepancy * FASTCALL soap_instantiate_vd__StockDiscrepancy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockDiscrepancy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockDiscrepancy, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockDiscrepancy);
		ASSIGN_PTR(size, sizeof(vd__StockDiscrepancy));
		((vd__StockDiscrepancy*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockDiscrepancy[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockDiscrepancy));
		for(int i = 0; i < n; i++)
			((vd__StockDiscrepancy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockDiscrepancy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockDiscrepancy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockDiscrepancy %p -> %p\n", q, p));
	*(vd__StockDiscrepancy*)p = *(vd__StockDiscrepancy*)q;
}

void vd__StockEntryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__StockEntryList::__sizestockEntry = 0;
	this->vd__StockEntryList::stockEntry = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__StockEntryList::soap_serialize(struct soap *soap) const
{
	if(this->vd__StockEntryList::stockEntry) {
		for(int i = 0; i < this->vd__StockEntryList::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->vd__StockEntryList::stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int vd__StockEntryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryList(struct soap *soap, const char *tag, int id, const vd__StockEntryList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntryList), "vd:StockEntryList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__StockEntryList::stockEntry) {
		int i;
		for(i = 0; i < a->vd__StockEntryList::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, a->vd__StockEntryList::stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntryList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntryList(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntryList * FASTCALL soap_in_vd__StockEntryList(struct soap *soap, const char *tag, vd__StockEntryList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntryList, sizeof(vd__StockEntryList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntryList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntryList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:stockEntry", 1, NULL)) {
				if(a->vd__StockEntryList::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->vd__StockEntryList::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->vd__StockEntryList::stockEntry == NULL)
						return NULL;
					*a->vd__StockEntryList::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", a->vd__StockEntryList::stockEntry, "vd:StockEntry"))
				{	a->vd__StockEntryList::__sizestockEntry++;
					a->vd__StockEntryList::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntryList::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->vd__StockEntryList::__sizestockEntry)
			a->vd__StockEntryList::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->vd__StockEntryList::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntryList, 0, sizeof(vd__StockEntryList), 0, soap_copy_vd__StockEntryList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntryList);
	return this->soap_out(soap, tag?tag:"vd:StockEntryList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntryList(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntryList * SOAP_FMAC4 soap_get_vd__StockEntryList(struct soap *soap, vd__StockEntryList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntryList * FASTCALL soap_instantiate_vd__StockEntryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntryList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryList);
		ASSIGN_PTR(size, sizeof(vd__StockEntryList));
		((vd__StockEntryList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntryList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntryList));
		for(int i = 0; i < n; i++)
			((vd__StockEntryList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntryList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntryList %p -> %p\n", q, p));
	*(vd__StockEntryList*)p = *(vd__StockEntryList*)q;
}

void vd__StockEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	this->vd__StockEntry::batch = NULL;
	this->vd__StockEntry::__sizevetDocument = 0;
	this->vd__StockEntry::vetDocument = NULL;
	this->vd__StockEntry::vetEventList = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__StockEntry::soap_serialize(struct soap *soap) const
{
	soap_serialize_vd__StockEntryNumber(soap, &this->vd__StockEntry::entryNumber);
	soap_serialize_PointerTovd__Batch(soap, &this->vd__StockEntry::batch);
	if(this->vd__StockEntry::vetDocument) {
		for(int i = 0; i < this->vd__StockEntry::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__StockEntry::vetDocument + i);
		}
	}
	soap_serialize_PointerTovd__StockEntryEventList(soap, &this->vd__StockEntry::vetEventList);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__StockEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__StockEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntry(struct soap *soap, const char *tag, int id, const vd__StockEntry *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__StockEntry), "vd:StockEntry"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_vd__StockEntryNumber(soap, "vd:entryNumber", -1, &(a->vd__StockEntry::entryNumber), ""))
		return soap->error;
	if(soap_out_PointerTovd__Batch(soap, "vd:batch", -1, &(a->vd__StockEntry::batch), ""))
		return soap->error;
	if(a->vd__StockEntry::vetDocument) {
		int i;
		for(i = 0; i < a->vd__StockEntry::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->vd__StockEntry::vetDocument + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", -1, &(a->vd__StockEntry::vetEventList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__StockEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__StockEntry(soap, tag, this, type);
}

SOAP_FMAC3 vd__StockEntry * FASTCALL soap_in_vd__StockEntry(struct soap *soap, const char *tag, vd__StockEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__StockEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__StockEntry, sizeof(vd__StockEntry), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__StockEntry) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__StockEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_entryNumber1 = 1;
	size_t soap_flag_batch1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	size_t soap_flag_vetEventList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_entryNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__StockEntryNumber(soap, "vd:entryNumber", &(a->vd__StockEntry::entryNumber), "vd:StockEntryNumber"))
				{	soap_flag_entryNumber1--;
					continue;
				}
			if(soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Batch(soap, "vd:batch", &(a->vd__StockEntry::batch), "vd:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->vd__StockEntry::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->vd__StockEntry::vetDocument == NULL)
						return NULL;
					*a->vd__StockEntry::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->vd__StockEntry::vetDocument, "vd:VetDocument"))
				{	a->vd__StockEntry::__sizevetDocument++;
					a->vd__StockEntry::vetDocument = NULL;
					continue;
				}
			}
			if(soap_flag_vetEventList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryEventList(soap, "vd:vetEventList", &(a->vd__StockEntry::vetEventList), "vd:StockEntryEventList"))
				{	soap_flag_vetEventList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__StockEntry::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->vd__StockEntry::__sizevetDocument)
			a->vd__StockEntry::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->vd__StockEntry::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__StockEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__StockEntry, 0, sizeof(vd__StockEntry), 0, soap_copy_vd__StockEntry);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__StockEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__StockEntry);
	return this->soap_out(soap, tag?tag:"vd:StockEntry", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__StockEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__StockEntry(soap, this, tag, type);
}

SOAP_FMAC3 vd__StockEntry * SOAP_FMAC4 soap_get_vd__StockEntry(struct soap *soap, vd__StockEntry *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__StockEntry * FASTCALL soap_instantiate_vd__StockEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__StockEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__StockEntry, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_vd__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
			((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntry);
		ASSIGN_PTR(size, sizeof(vd__StockEntry));
		((vd__StockEntry*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__StockEntry[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__StockEntry));
		for(int i = 0; i < n; i++)
			((vd__StockEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__StockEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__StockEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__StockEntry %p -> %p\n", q, p));
	*(vd__StockEntry*)p = *(vd__StockEntry*)q;
}

void vd__DiscrepancyReason::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->vd__DiscrepancyReason::name);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__DiscrepancyReason::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->vd__DiscrepancyReason::name);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__DiscrepancyReason::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DiscrepancyReason(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DiscrepancyReason(struct soap *soap, const char *tag, int id, const vd__DiscrepancyReason *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DiscrepancyReason), "vd:DiscrepancyReason"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__DiscrepancyReason::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__DiscrepancyReason::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DiscrepancyReason(soap, tag, this, type);
}

SOAP_FMAC3 vd__DiscrepancyReason * FASTCALL soap_in_vd__DiscrepancyReason(struct soap *soap, const char *tag, vd__DiscrepancyReason *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DiscrepancyReason *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DiscrepancyReason, sizeof(vd__DiscrepancyReason), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DiscrepancyReason) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DiscrepancyReason *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__DiscrepancyReason::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DiscrepancyReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DiscrepancyReason, 0, sizeof(vd__DiscrepancyReason), 0, soap_copy_vd__DiscrepancyReason);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__DiscrepancyReason::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DiscrepancyReason);
	return this->soap_out(soap, tag?tag:"vd:DiscrepancyReason", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DiscrepancyReason::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DiscrepancyReason(soap, this, tag, type);
}

SOAP_FMAC3 vd__DiscrepancyReason * SOAP_FMAC4 soap_get_vd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DiscrepancyReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DiscrepancyReason * FASTCALL soap_instantiate_vd__DiscrepancyReason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DiscrepancyReason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DiscrepancyReason, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason);
		ASSIGN_PTR(size, sizeof(vd__DiscrepancyReason));
		((vd__DiscrepancyReason*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReason));
		for(int i = 0; i < n; i++)
			((vd__DiscrepancyReason*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DiscrepancyReason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DiscrepancyReason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DiscrepancyReason %p -> %p\n", q, p));
	*(vd__DiscrepancyReason*)p = *(vd__DiscrepancyReason*)q;
}

void vd__DiscrepancyReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__DiscrepancyReport::reason = NULL;
	soap_default_string(soap, &this->vd__DiscrepancyReport::description);
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__DiscrepancyReport::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__DiscrepancyReason(soap, &this->vd__DiscrepancyReport::reason);
	soap_serialize_string(soap, &this->vd__DiscrepancyReport::description);
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerToent__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerToent__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__DiscrepancyReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DiscrepancyReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DiscrepancyReport(struct soap *soap, const char *tag, int id, const vd__DiscrepancyReport *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DiscrepancyReport), "vd:DiscrepancyReport"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerToent__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTovd__DiscrepancyReason(soap, "vd:reason", -1, &(a->vd__DiscrepancyReport::reason), ""))
		return soap->error;
	if(soap_out_string(soap, "vd:description", -1, &(a->vd__DiscrepancyReport::description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__DiscrepancyReport::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DiscrepancyReport(soap, tag, this, type);
}

SOAP_FMAC3 vd__DiscrepancyReport * FASTCALL soap_in_vd__DiscrepancyReport(struct soap *soap, const char *tag, vd__DiscrepancyReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DiscrepancyReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DiscrepancyReport, sizeof(vd__DiscrepancyReport), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DiscrepancyReport) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DiscrepancyReport *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_description1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DocumentType(soap, "vd:type", &(a->vd__Document::type), "ent:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "ent:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_reason1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DiscrepancyReason(soap, "vd:reason", &(a->vd__DiscrepancyReport::reason), "vd:DiscrepancyReason"))
				{	soap_flag_reason1--;
					continue;
				}
			if(soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "vd:description", &(a->vd__DiscrepancyReport::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DiscrepancyReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DiscrepancyReport, 0, sizeof(vd__DiscrepancyReport), 0, soap_copy_vd__DiscrepancyReport);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__DiscrepancyReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DiscrepancyReport);
	return this->soap_out(soap, tag?tag:"vd:DiscrepancyReport", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DiscrepancyReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DiscrepancyReport(soap, this, tag, type);
}

SOAP_FMAC3 vd__DiscrepancyReport * SOAP_FMAC4 soap_get_vd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DiscrepancyReport * FASTCALL soap_instantiate_vd__DiscrepancyReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DiscrepancyReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DiscrepancyReport, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport);
		ASSIGN_PTR(size, sizeof(vd__DiscrepancyReport));
		((vd__DiscrepancyReport*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReport));
		for(int i = 0; i < n; i++)
			((vd__DiscrepancyReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DiscrepancyReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DiscrepancyReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DiscrepancyReport %p -> %p\n", q, p));
	*(vd__DiscrepancyReport*)p = *(vd__DiscrepancyReport*)q;
}

void vd__VetDocumentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VetDocumentList::__sizevetDocument = 0;
	this->vd__VetDocumentList::vetDocument = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void vd__VetDocumentList::soap_serialize(struct soap *soap) const
{
	if(this->vd__VetDocumentList::vetDocument) {
		for(int i = 0; i < this->vd__VetDocumentList::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__VetDocumentList::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int vd__VetDocumentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VetDocumentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentList(struct soap *soap, const char *tag, int id, const vd__VetDocumentList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocumentList), "vd:VetDocumentList"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__VetDocumentList::vetDocument) {
		int i;
		for(i = 0; i < a->vd__VetDocumentList::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->vd__VetDocumentList::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__VetDocumentList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VetDocumentList(soap, tag, this, type);
}

SOAP_FMAC3 vd__VetDocumentList * FASTCALL soap_in_vd__VetDocumentList(struct soap *soap, const char *tag, vd__VetDocumentList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VetDocumentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocumentList, sizeof(vd__VetDocumentList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VetDocumentList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VetDocumentList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->vd__VetDocumentList::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->vd__VetDocumentList::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->vd__VetDocumentList::vetDocument == NULL)
						return NULL;
					*a->vd__VetDocumentList::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->vd__VetDocumentList::vetDocument, "vd:VetDocument"))
				{	a->vd__VetDocumentList::__sizevetDocument++;
					a->vd__VetDocumentList::vetDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VetDocumentList::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->vd__VetDocumentList::__sizevetDocument)
			a->vd__VetDocumentList::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->vd__VetDocumentList::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VetDocumentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocumentList, 0, sizeof(vd__VetDocumentList), 0, soap_copy_vd__VetDocumentList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__VetDocumentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentList);
	return this->soap_out(soap, tag?tag:"vd:VetDocumentList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VetDocumentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VetDocumentList(soap, this, tag, type);
}

SOAP_FMAC3 vd__VetDocumentList * SOAP_FMAC4 soap_get_vd__VetDocumentList(struct soap *soap, vd__VetDocumentList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VetDocumentList * FASTCALL soap_instantiate_vd__VetDocumentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VetDocumentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VetDocumentList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList);
		ASSIGN_PTR(size, sizeof(vd__VetDocumentList));
		((vd__VetDocumentList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VetDocumentList));
		for(int i = 0; i < n; i++)
			((vd__VetDocumentList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VetDocumentList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VetDocumentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VetDocumentList %p -> %p\n", q, p));
	*(vd__VetDocumentList*)p = *(vd__VetDocumentList*)q;
}

void vd__GoodsDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__GoodsDate::firstDate = NULL;
	this->vd__GoodsDate::secondDate = NULL;
	soap_default_base__String255(soap, &this->vd__GoodsDate::informalDate);
	/* transient soap skipped */
}

void vd__GoodsDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ComplexDate(soap, &this->vd__GoodsDate::firstDate);
	soap_serialize_PointerToent__ComplexDate(soap, &this->vd__GoodsDate::secondDate);
	soap_serialize_base__String255(soap, &this->vd__GoodsDate::informalDate);
	/* transient soap skipped */
}

int vd__GoodsDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__GoodsDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__GoodsDate(struct soap *soap, const char *tag, int id, const vd__GoodsDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__GoodsDate), type))
		return soap->error;
	if(soap_out_PointerToent__ComplexDate(soap, "vd:firstDate", -1, &(a->vd__GoodsDate::firstDate), ""))
		return soap->error;
	if(soap_out_PointerToent__ComplexDate(soap, "vd:secondDate", -1, &(a->vd__GoodsDate::secondDate), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:informalDate", -1, &(a->vd__GoodsDate::informalDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__GoodsDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__GoodsDate(soap, tag, this, type);
}

SOAP_FMAC3 vd__GoodsDate * FASTCALL soap_in_vd__GoodsDate(struct soap *soap, const char *tag, vd__GoodsDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__GoodsDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__GoodsDate, sizeof(vd__GoodsDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__GoodsDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__GoodsDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_firstDate1 = 1;
	size_t soap_flag_secondDate1 = 1;
	size_t soap_flag_informalDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_firstDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ComplexDate(soap, "vd:firstDate", &(a->vd__GoodsDate::firstDate), "ent:ComplexDate"))
				{	soap_flag_firstDate1--;
					continue;
				}
			if(soap_flag_secondDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ComplexDate(soap, "vd:secondDate", &(a->vd__GoodsDate::secondDate), "ent:ComplexDate"))
				{	soap_flag_secondDate1--;
					continue;
				}
			if(soap_flag_informalDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:informalDate", &(a->vd__GoodsDate::informalDate), "base:String255"))
				{	soap_flag_informalDate1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__GoodsDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__GoodsDate, 0, sizeof(vd__GoodsDate), 0, soap_copy_vd__GoodsDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__GoodsDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__GoodsDate);
	return this->soap_out(soap, tag?tag:"vd:GoodsDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__GoodsDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__GoodsDate(soap, this, tag, type);
}

SOAP_FMAC3 vd__GoodsDate * SOAP_FMAC4 soap_get_vd__GoodsDate(struct soap *soap, vd__GoodsDate *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__GoodsDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__GoodsDate * FASTCALL soap_instantiate_vd__GoodsDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__GoodsDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__GoodsDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__GoodsDate);
		ASSIGN_PTR(size, sizeof(vd__GoodsDate));
		((vd__GoodsDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__GoodsDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__GoodsDate));
		for(int i = 0; i < n; i++)
			((vd__GoodsDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__GoodsDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__GoodsDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__GoodsDate %p -> %p\n", q, p));
	*(vd__GoodsDate*)p = *(vd__GoodsDate*)q;
}

void vd__ConsignmentDocumentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__ConsignmentDocumentList::waybill = NULL;
	this->vd__ConsignmentDocumentList::__sizevetCertificate = 0;
	this->vd__ConsignmentDocumentList::vetCertificate = NULL;
	this->vd__ConsignmentDocumentList::__sizerelatedDocument = 0;
	this->vd__ConsignmentDocumentList::relatedDocument = NULL;
	/* transient soap skipped */
}

void vd__ConsignmentDocumentList::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__Waybill(soap, &this->vd__ConsignmentDocumentList::waybill);
	if(this->vd__ConsignmentDocumentList::vetCertificate) {
		for(int i = 0; i < this->vd__ConsignmentDocumentList::__sizevetCertificate; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->vd__ConsignmentDocumentList::vetCertificate + i);
		}
	}
	if(this->vd__ConsignmentDocumentList::relatedDocument) {
		for(int i = 0; i < this->vd__ConsignmentDocumentList::__sizerelatedDocument; i++) {
			soap_serialize_PointerTovd__ReferencedDocument(soap, this->vd__ConsignmentDocumentList::relatedDocument + i);
		}
	}
	/* transient soap skipped */
}

int vd__ConsignmentDocumentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ConsignmentDocumentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ConsignmentDocumentList(struct soap *soap, const char *tag, int id, const vd__ConsignmentDocumentList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ConsignmentDocumentList), type))
		return soap->error;
	if(soap_out_PointerTovd__Waybill(soap, "vd:waybill", -1, &(a->vd__ConsignmentDocumentList::waybill), ""))
		return soap->error;
	if(a->vd__ConsignmentDocumentList::vetCertificate) {
		int i;
		for(i = 0; i < a->vd__ConsignmentDocumentList::__sizevetCertificate; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetCertificate", -1, a->vd__ConsignmentDocumentList::vetCertificate + i, ""))
				return soap->error;
	}
	if(a->vd__ConsignmentDocumentList::relatedDocument) {
		int i;
		for(i = 0; i < a->vd__ConsignmentDocumentList::__sizerelatedDocument; i++)
			if(soap_out_PointerTovd__ReferencedDocument(soap, "vd:relatedDocument", -1, a->vd__ConsignmentDocumentList::relatedDocument + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ConsignmentDocumentList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ConsignmentDocumentList(soap, tag, this, type);
}

SOAP_FMAC3 vd__ConsignmentDocumentList * FASTCALL soap_in_vd__ConsignmentDocumentList(struct soap *soap, const char *tag, vd__ConsignmentDocumentList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ConsignmentDocumentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ConsignmentDocumentList, sizeof(vd__ConsignmentDocumentList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ConsignmentDocumentList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ConsignmentDocumentList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_waybill1 = 1;
	struct soap_blist *soap_blist_vetCertificate1 = NULL;
	struct soap_blist *soap_blist_relatedDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_waybill1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Waybill(soap, "vd:waybill", &(a->vd__ConsignmentDocumentList::waybill), "vd:Waybill"))
				{	soap_flag_waybill1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetCertificate", 1, NULL)) {
				if(a->vd__ConsignmentDocumentList::vetCertificate == NULL) {
					if(soap_blist_vetCertificate1 == NULL)
						soap_blist_vetCertificate1 = soap_new_block(soap);
					a->vd__ConsignmentDocumentList::vetCertificate = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetCertificate1, sizeof(vd__VetDocument *));
					if(a->vd__ConsignmentDocumentList::vetCertificate == NULL)
						return NULL;
					*a->vd__ConsignmentDocumentList::vetCertificate = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetCertificate", a->vd__ConsignmentDocumentList::vetCertificate, "vd:VetDocument"))
				{	a->vd__ConsignmentDocumentList::__sizevetCertificate++;
					a->vd__ConsignmentDocumentList::vetCertificate = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:relatedDocument", 1, NULL)) {
				if(a->vd__ConsignmentDocumentList::relatedDocument == NULL) {
					if(soap_blist_relatedDocument1 == NULL)
						soap_blist_relatedDocument1 = soap_new_block(soap);
					a->vd__ConsignmentDocumentList::relatedDocument = (vd__ReferencedDocument **)soap_push_block(soap, soap_blist_relatedDocument1, sizeof(vd__ReferencedDocument *));
					if(a->vd__ConsignmentDocumentList::relatedDocument == NULL)
						return NULL;
					*a->vd__ConsignmentDocumentList::relatedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ReferencedDocument(soap, "vd:relatedDocument", a->vd__ConsignmentDocumentList::relatedDocument, "vd:ReferencedDocument"))
				{	a->vd__ConsignmentDocumentList::__sizerelatedDocument++;
					a->vd__ConsignmentDocumentList::relatedDocument = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__ConsignmentDocumentList::vetCertificate)
			soap_pop_block(soap, soap_blist_vetCertificate1);
		if(a->vd__ConsignmentDocumentList::__sizevetCertificate)
			a->vd__ConsignmentDocumentList::vetCertificate = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetCertificate1, NULL, 1);
		else
		{	a->vd__ConsignmentDocumentList::vetCertificate = NULL;
			if(soap_blist_vetCertificate1)
				soap_end_block(soap, soap_blist_vetCertificate1);
		}
		if(a->vd__ConsignmentDocumentList::relatedDocument)
			soap_pop_block(soap, soap_blist_relatedDocument1);
		if(a->vd__ConsignmentDocumentList::__sizerelatedDocument)
			a->vd__ConsignmentDocumentList::relatedDocument = (vd__ReferencedDocument **)soap_save_block(soap, soap_blist_relatedDocument1, NULL, 1);
		else
		{	a->vd__ConsignmentDocumentList::relatedDocument = NULL;
			if(soap_blist_relatedDocument1)
				soap_end_block(soap, soap_blist_relatedDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ConsignmentDocumentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ConsignmentDocumentList, 0, sizeof(vd__ConsignmentDocumentList), 0, soap_copy_vd__ConsignmentDocumentList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ConsignmentDocumentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ConsignmentDocumentList);
	return this->soap_out(soap, tag?tag:"vd:ConsignmentDocumentList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ConsignmentDocumentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ConsignmentDocumentList(soap, this, tag, type);
}

SOAP_FMAC3 vd__ConsignmentDocumentList * SOAP_FMAC4 soap_get_vd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ConsignmentDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ConsignmentDocumentList * FASTCALL soap_instantiate_vd__ConsignmentDocumentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ConsignmentDocumentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ConsignmentDocumentList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ConsignmentDocumentList);
		ASSIGN_PTR(size, sizeof(vd__ConsignmentDocumentList));
		((vd__ConsignmentDocumentList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ConsignmentDocumentList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ConsignmentDocumentList));
		for(int i = 0; i < n; i++)
			((vd__ConsignmentDocumentList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ConsignmentDocumentList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ConsignmentDocumentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ConsignmentDocumentList %p -> %p\n", q, p));
	*(vd__ConsignmentDocumentList*)p = *(vd__ConsignmentDocumentList*)q;
}

void vd__DeliveryInspection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__DeliveryInspection::responsible = NULL;
	soap_default_vd__DeliveryInspectionResult(soap, &this->vd__DeliveryInspection::result);
	soap_default_base__Text(soap, &this->vd__DeliveryInspection::info);
	/* transient soap skipped */
}

void vd__DeliveryInspection::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__User(soap, &this->vd__DeliveryInspection::responsible);
	soap_serialize_base__Text(soap, &this->vd__DeliveryInspection::info);
	/* transient soap skipped */
}

int vd__DeliveryInspection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DeliveryInspection(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryInspection(struct soap *soap, const char *tag, int id, const vd__DeliveryInspection *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryInspection), type))
		return soap->error;
	if(soap_out_PointerTovd__User(soap, "vd:responsible", -1, &(a->vd__DeliveryInspection::responsible), ""))
		return soap->error;
	if(soap_out_vd__DeliveryInspectionResult(soap, "vd:result", -1, &(a->vd__DeliveryInspection::result), ""))
		return soap->error;
	if(soap_out_base__Text(soap, "vd:info", -1, &(a->vd__DeliveryInspection::info), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__DeliveryInspection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DeliveryInspection(soap, tag, this, type);
}

SOAP_FMAC3 vd__DeliveryInspection * FASTCALL soap_in_vd__DeliveryInspection(struct soap *soap, const char *tag, vd__DeliveryInspection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DeliveryInspection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryInspection, sizeof(vd__DeliveryInspection), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DeliveryInspection) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DeliveryInspection *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_responsible1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_info1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_responsible1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:responsible", &(a->vd__DeliveryInspection::responsible), "vd:User"))
				{	soap_flag_responsible1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__DeliveryInspectionResult(soap, "vd:result", &(a->vd__DeliveryInspection::result), "vd:DeliveryInspectionResult"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_info1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "vd:info", &(a->vd__DeliveryInspection::info), "base:Text"))
				{	soap_flag_info1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DeliveryInspection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryInspection, 0, sizeof(vd__DeliveryInspection), 0, soap_copy_vd__DeliveryInspection);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__DeliveryInspection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DeliveryInspection);
	return this->soap_out(soap, tag?tag:"vd:DeliveryInspection", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DeliveryInspection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DeliveryInspection(soap, this, tag, type);
}

SOAP_FMAC3 vd__DeliveryInspection * SOAP_FMAC4 soap_get_vd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryInspection(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DeliveryInspection * FASTCALL soap_instantiate_vd__DeliveryInspection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DeliveryInspection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DeliveryInspection, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryInspection);
		ASSIGN_PTR(size, sizeof(vd__DeliveryInspection));
		((vd__DeliveryInspection*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryInspection[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DeliveryInspection));
		for(int i = 0; i < n; i++)
			((vd__DeliveryInspection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DeliveryInspection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DeliveryInspection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DeliveryInspection %p -> %p\n", q, p));
	*(vd__DeliveryInspection*)p = *(vd__DeliveryInspection*)q;
}

void vd__DeliveryFactList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ent__DocumentNature(soap, &this->vd__DeliveryFactList::vetCertificatePresence);
	this->vd__DeliveryFactList::docInspection = NULL;
	this->vd__DeliveryFactList::vetInspection = NULL;
	soap_default_vd__DeliveryDecision(soap, &this->vd__DeliveryFactList::decision);
	/* transient soap skipped */
}

void vd__DeliveryFactList::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__DeliveryInspection(soap, &this->vd__DeliveryFactList::docInspection);
	soap_serialize_PointerTovd__DeliveryInspection(soap, &this->vd__DeliveryFactList::vetInspection);
	/* transient soap skipped */
}

int vd__DeliveryFactList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__DeliveryFactList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__DeliveryFactList(struct soap *soap, const char *tag, int id, const vd__DeliveryFactList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__DeliveryFactList), type))
		return soap->error;
	if(soap_out_ent__DocumentNature(soap, "vd:vetCertificatePresence", -1, &(a->vd__DeliveryFactList::vetCertificatePresence), ""))
		return soap->error;
	if(a->vd__DeliveryFactList::docInspection) {
		if(soap_out_PointerTovd__DeliveryInspection(soap, "vd:docInspection", -1, &a->vd__DeliveryFactList::docInspection, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:docInspection"))
		return soap->error;
	if(a->vd__DeliveryFactList::vetInspection) {
		if(soap_out_PointerTovd__DeliveryInspection(soap, "vd:vetInspection", -1, &a->vd__DeliveryFactList::vetInspection, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetInspection"))
		return soap->error;
	if(soap_out_vd__DeliveryDecision(soap, "vd:decision", -1, &(a->vd__DeliveryFactList::decision), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__DeliveryFactList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__DeliveryFactList(soap, tag, this, type);
}

SOAP_FMAC3 vd__DeliveryFactList * FASTCALL soap_in_vd__DeliveryFactList(struct soap *soap, const char *tag, vd__DeliveryFactList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__DeliveryFactList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__DeliveryFactList, sizeof(vd__DeliveryFactList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__DeliveryFactList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__DeliveryFactList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vetCertificatePresence1 = 1;
	size_t soap_flag_docInspection1 = 1;
	size_t soap_flag_vetInspection1 = 1;
	size_t soap_flag_decision1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_vetCertificatePresence1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__DocumentNature(soap, "vd:vetCertificatePresence", &(a->vd__DeliveryFactList::vetCertificatePresence), "ent:DocumentNature"))
				{	soap_flag_vetCertificatePresence1--;
					continue;
				}
			if(soap_flag_docInspection1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DeliveryInspection(soap, "vd:docInspection", &(a->vd__DeliveryFactList::docInspection), "vd:DeliveryInspection"))
				{	soap_flag_docInspection1--;
					continue;
				}
			if(soap_flag_vetInspection1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DeliveryInspection(soap, "vd:vetInspection", &(a->vd__DeliveryFactList::vetInspection), "vd:DeliveryInspection"))
				{	soap_flag_vetInspection1--;
					continue;
				}
			if(soap_flag_decision1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_vd__DeliveryDecision(soap, "vd:decision", &(a->vd__DeliveryFactList::decision), "vd:DeliveryDecision"))
				{	soap_flag_decision1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__DeliveryFactList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__DeliveryFactList, 0, sizeof(vd__DeliveryFactList), 0, soap_copy_vd__DeliveryFactList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vetCertificatePresence1 > 0 || soap_flag_docInspection1 > 0 || soap_flag_vetInspection1 > 0 || soap_flag_decision1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__DeliveryFactList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__DeliveryFactList);
	return this->soap_out(soap, tag?tag:"vd:DeliveryFactList", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__DeliveryFactList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__DeliveryFactList(soap, this, tag, type);
}

SOAP_FMAC3 vd__DeliveryFactList * SOAP_FMAC4 soap_get_vd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__DeliveryFactList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__DeliveryFactList * FASTCALL soap_instantiate_vd__DeliveryFactList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__DeliveryFactList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__DeliveryFactList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryFactList);
		ASSIGN_PTR(size, sizeof(vd__DeliveryFactList));
		((vd__DeliveryFactList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__DeliveryFactList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__DeliveryFactList));
		for(int i = 0; i < n; i++)
			((vd__DeliveryFactList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__DeliveryFactList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__DeliveryFactList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__DeliveryFactList %p -> %p\n", q, p));
	*(vd__DeliveryFactList*)p = *(vd__DeliveryFactList*)q;
}

void vd__Delivery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Delivery::deliveryDate = NULL;
	this->vd__Delivery::consignor = NULL;
	this->vd__Delivery::consignee = NULL;
	this->vd__Delivery::__sizeconsignment = 0;
	this->vd__Delivery::consignment = NULL;
	this->vd__Delivery::broker = NULL;
	this->vd__Delivery::transportInfo = NULL;
	this->vd__Delivery::transportStorageType = NULL;
	this->vd__Delivery::shipmentRoute = NULL;
	this->vd__Delivery::accompanyingForms = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__Delivery::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->vd__Delivery::deliveryDate);
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__Delivery::consignor);
	soap_serialize_PointerToent__BusinessMember(soap, &this->vd__Delivery::consignee);
	if(this->vd__Delivery::consignment) {
		for(int i = 0; i < this->vd__Delivery::__sizeconsignment; i++) {
			soap_serialize_PointerTovd__Consignment(soap, this->vd__Delivery::consignment + i);
		}
	}
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__Delivery::broker);
	soap_serialize_PointerTovd__TransportInfo(soap, &this->vd__Delivery::transportInfo);
	soap_serialize_PointerToent__TransportationStorageType(soap, &this->vd__Delivery::transportStorageType);
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->vd__Delivery::shipmentRoute);
	soap_serialize_PointerTovd__ConsignmentDocumentList(soap, &this->vd__Delivery::accompanyingForms);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__Delivery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Delivery(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Delivery(struct soap *soap, const char *tag, int id, const vd__Delivery *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Delivery), "vd:Delivery"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTotime(soap, "vd:deliveryDate", -1, &(a->vd__Delivery::deliveryDate), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:consignor", -1, &(a->vd__Delivery::consignor), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "vd:consignee", -1, &(a->vd__Delivery::consignee), ""))
		return soap->error;
	if(a->vd__Delivery::consignment) {
		int i;
		for(i = 0; i < a->vd__Delivery::__sizeconsignment; i++)
			if(soap_out_PointerTovd__Consignment(soap, "vd:consignment", -1, a->vd__Delivery::consignment + i, ""))
				return soap->error;
	}
	if(soap_out_PointerToent__BusinessEntity(soap, "vd:broker", -1, &(a->vd__Delivery::broker), ""))
		return soap->error;
	if(soap_out_PointerTovd__TransportInfo(soap, "vd:transportInfo", -1, &(a->vd__Delivery::transportInfo), ""))
		return soap->error;
	if(soap_out_PointerToent__TransportationStorageType(soap, "vd:transportStorageType", -1, &(a->vd__Delivery::transportStorageType), ""))
		return soap->error;
	if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &(a->vd__Delivery::shipmentRoute), ""))
		return soap->error;
	if(soap_out_PointerTovd__ConsignmentDocumentList(soap, "vd:accompanyingForms", -1, &(a->vd__Delivery::accompanyingForms), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Delivery::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Delivery(soap, tag, this, type);
}

SOAP_FMAC3 vd__Delivery * FASTCALL soap_in_vd__Delivery(struct soap *soap, const char *tag, vd__Delivery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Delivery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Delivery, sizeof(vd__Delivery), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Delivery) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Delivery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_deliveryDate1 = 1;
	size_t soap_flag_consignor1 = 1;
	size_t soap_flag_consignee1 = 1;
	struct soap_blist *soap_blist_consignment1 = NULL;
	size_t soap_flag_broker1 = 1;
	size_t soap_flag_transportInfo1 = 1;
	size_t soap_flag_transportStorageType1 = 1;
	size_t soap_flag_shipmentRoute1 = 1;
	size_t soap_flag_accompanyingForms1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_deliveryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:deliveryDate", &(a->vd__Delivery::deliveryDate), "xsd:dateTime"))
				{	soap_flag_deliveryDate1--;
					continue;
				}
			if(soap_flag_consignor1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:consignor", &(a->vd__Delivery::consignor), "ent:BusinessMember"))
				{	soap_flag_consignor1--;
					continue;
				}
			if(soap_flag_consignee1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:consignee", &(a->vd__Delivery::consignee), "ent:BusinessMember"))
				{	soap_flag_consignee1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:consignment", 1, NULL)) {
				if(a->vd__Delivery::consignment == NULL) {
					if(soap_blist_consignment1 == NULL)
						soap_blist_consignment1 = soap_new_block(soap);
					a->vd__Delivery::consignment = (vd__Consignment **)soap_push_block(soap, soap_blist_consignment1, sizeof(vd__Consignment *));
					if(a->vd__Delivery::consignment == NULL)
						return NULL;
					*a->vd__Delivery::consignment = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Consignment(soap, "vd:consignment", a->vd__Delivery::consignment, "vd:Consignment"))
				{	a->vd__Delivery::__sizeconsignment++;
					a->vd__Delivery::consignment = NULL;
					continue;
				}
			}
			if(soap_flag_broker1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:broker", &(a->vd__Delivery::broker), "ent:BusinessEntity"))
				{	soap_flag_broker1--;
					continue;
				}
			if(soap_flag_transportInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__TransportInfo(soap, "vd:transportInfo", &(a->vd__Delivery::transportInfo), "vd:TransportInfo"))
				{	soap_flag_transportInfo1--;
					continue;
				}
			if(soap_flag_transportStorageType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__TransportationStorageType(soap, "vd:transportStorageType", &(a->vd__Delivery::transportStorageType), "ent:TransportationStorageType"))
				{	soap_flag_transportStorageType1--;
					continue;
				}
			if(soap_flag_shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->vd__Delivery::shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_shipmentRoute1--;
					continue;
				}
			if(soap_flag_accompanyingForms1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ConsignmentDocumentList(soap, "vd:accompanyingForms", &(a->vd__Delivery::accompanyingForms), "vd:ConsignmentDocumentList"))
				{	soap_flag_accompanyingForms1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Delivery::consignment)
			soap_pop_block(soap, soap_blist_consignment1);
		if(a->vd__Delivery::__sizeconsignment)
			a->vd__Delivery::consignment = (vd__Consignment **)soap_save_block(soap, soap_blist_consignment1, NULL, 1);
		else
		{	a->vd__Delivery::consignment = NULL;
			if(soap_blist_consignment1)
				soap_end_block(soap, soap_blist_consignment1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Delivery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Delivery, 0, sizeof(vd__Delivery), 0, soap_copy_vd__Delivery);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Delivery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Delivery);
	return this->soap_out(soap, tag?tag:"vd:Delivery", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Delivery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Delivery(soap, this, tag, type);
}

SOAP_FMAC3 vd__Delivery * SOAP_FMAC4 soap_get_vd__Delivery(struct soap *soap, vd__Delivery *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Delivery * FASTCALL soap_instantiate_vd__Delivery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Delivery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Delivery, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Delivery);
		ASSIGN_PTR(size, sizeof(vd__Delivery));
		((vd__Delivery*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Delivery[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Delivery));
		for(int i = 0; i < n; i++)
			((vd__Delivery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Delivery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Delivery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Delivery %p -> %p\n", q, p));
	*(vd__Delivery*)p = *(vd__Delivery*)q;
}

void vd__ProductiveBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__ID(soap, &this->vd__ProductiveBatch::id);
	this->vd__Batch::productType = NULL;
	this->vd__Batch::product = NULL;
	this->vd__Batch::subProduct = NULL;
	this->vd__Batch::productItem = NULL;
	this->vd__Batch::volume = NULL;
	this->vd__Batch::unit = NULL;
	this->vd__Batch::dateOfProduction = NULL;
	this->vd__Batch::expiryDate = NULL;
	this->vd__Batch::__sizebatchID = 0;
	this->vd__Batch::batchID = NULL;
	this->vd__Batch::perishable = NULL;
	this->vd__Batch::origin = NULL;
	this->vd__Batch::lowGradeCargo = NULL;
	this->vd__Batch::packageList = NULL;
	this->vd__Batch::owner = NULL;
	/* transient soap skipped */
}

void vd__ProductiveBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductType(soap, &this->vd__Batch::productType);
	soap_serialize_PointerToent__Product(soap, &this->vd__Batch::product);
	soap_serialize_PointerToent__SubProduct(soap, &this->vd__Batch::subProduct);
	soap_serialize_PointerToent__ProductItem(soap, &this->vd__Batch::productItem);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__Batch::volume);
	soap_serialize_PointerToent__Unit(soap, &this->vd__Batch::unit);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::dateOfProduction);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::expiryDate);
	if(this->vd__Batch::batchID) {
		for(int i = 0; i < this->vd__Batch::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__Batch::perishable);
	soap_serialize_PointerTovd__BatchOrigin(soap, &this->vd__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->vd__Batch::lowGradeCargo);
	soap_serialize_PointerToent__PackageList(soap, &this->vd__Batch::packageList);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__Batch::owner);
	/* transient soap skipped */
}

int vd__ProductiveBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__ProductiveBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__ProductiveBatch(struct soap *soap, const char *tag, int id, const vd__ProductiveBatch *a, const char *type)
{
	if(((vd__ProductiveBatch*)a)->id)
		soap_set_attr(soap, "id", ((vd__ProductiveBatch*)a)->id, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__ProductiveBatch), "vd:ProductiveBatch"))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "vd:productType", -1, &(a->vd__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerToent__Product(soap, "vd:product", -1, &(a->vd__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerToent__SubProduct(soap, "vd:subProduct", -1, &(a->vd__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductItem(soap, "vd:productItem", -1, &(a->vd__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerToent__Unit(soap, "vd:unit", -1, &(a->vd__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", -1, &(a->vd__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:expiryDate", -1, &(a->vd__Batch::expiryDate), ""))
		return soap->error;
	if(a->vd__Batch::batchID) {
		int i;
		for(i = 0; i < a->vd__Batch::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:perishable", -1, &(a->vd__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTovd__BatchOrigin(soap, "vd:origin", -1, &(a->vd__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:lowGradeCargo", -1, &(a->vd__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerToent__PackageList(soap, "vd:packageList", -1, &(a->vd__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "vd:owner", -1, &(a->vd__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__ProductiveBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__ProductiveBatch(soap, tag, this, type);
}

SOAP_FMAC3 vd__ProductiveBatch * FASTCALL soap_in_vd__ProductiveBatch(struct soap *soap, const char *tag, vd__ProductiveBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__ProductiveBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__ProductiveBatch, sizeof(vd__ProductiveBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__ProductiveBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__ProductiveBatch *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((vd__ProductiveBatch*)a)->id, 0, -1))
		return NULL;
	size_t soap_flag_productType2 = 1;
	size_t soap_flag_product2 = 1;
	size_t soap_flag_subProduct2 = 1;
	size_t soap_flag_productItem2 = 1;
	size_t soap_flag_volume2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_dateOfProduction2 = 1;
	size_t soap_flag_expiryDate2 = 1;
	struct soap_blist *soap_blist_batchID2 = NULL;
	size_t soap_flag_perishable2 = 1;
	size_t soap_flag_origin2 = 1;
	size_t soap_flag_lowGradeCargo2 = 1;
	size_t soap_flag_packageList2 = 1;
	size_t soap_flag_owner2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "vd:productType", &(a->vd__Batch::productType), "ent:ProductType"))
				{	soap_flag_productType2--;
					continue;
				}
			if(soap_flag_product2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "vd:product", &(a->vd__Batch::product), "ent:Product"))
				{	soap_flag_product2--;
					continue;
				}
			if(soap_flag_subProduct2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "vd:subProduct", &(a->vd__Batch::subProduct), "ent:SubProduct"))
				{	soap_flag_subProduct2--;
					continue;
				}
			if(soap_flag_productItem2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItem(soap, "vd:productItem", &(a->vd__Batch::productItem), "ent:ProductItem"))
				{	soap_flag_productItem2--;
					continue;
				}
			if(soap_flag_volume2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__Batch::volume), "base:Decimal"))
				{	soap_flag_volume2--;
					continue;
				}
			if(soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "vd:unit", &(a->vd__Batch::unit), "ent:Unit"))
				{	soap_flag_unit2--;
					continue;
				}
			if(soap_flag_dateOfProduction2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", &(a->vd__Batch::dateOfProduction), "vd:GoodsDate"))
				{	soap_flag_dateOfProduction2--;
					continue;
				}
			if(soap_flag_expiryDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:expiryDate", &(a->vd__Batch::expiryDate), "vd:GoodsDate"))
				{	soap_flag_expiryDate2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__Batch::batchID == NULL) {
					if(soap_blist_batchID2 == NULL)
						soap_blist_batchID2 = soap_new_block(soap);
					a->vd__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID2, sizeof(char *));
					if(a->vd__Batch::batchID == NULL)
						return NULL;
					*a->vd__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__Batch::batchID, "base:Identifier"))
				{	a->vd__Batch::__sizebatchID++;
					a->vd__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:perishable", &(a->vd__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable2--;
					continue;
				}
			if(soap_flag_origin2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BatchOrigin(soap, "vd:origin", &(a->vd__Batch::origin), "vd:BatchOrigin"))
				{	soap_flag_origin2--;
					continue;
				}
			if(soap_flag_lowGradeCargo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:lowGradeCargo", &(a->vd__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo2--;
					continue;
				}
			if(soap_flag_packageList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackageList(soap, "vd:packageList", &(a->vd__Batch::packageList), "ent:PackageList"))
				{	soap_flag_packageList2--;
					continue;
				}
			if(soap_flag_owner2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:owner", &(a->vd__Batch::owner), "ent:BusinessEntity"))
				{	soap_flag_owner2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID2);
		if(a->vd__Batch::__sizebatchID)
			a->vd__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID2, NULL, 1);
		else
		{	a->vd__Batch::batchID = NULL;
			if(soap_blist_batchID2)
				soap_end_block(soap, soap_blist_batchID2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__ProductiveBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__ProductiveBatch, 0, sizeof(vd__ProductiveBatch), 0, soap_copy_vd__ProductiveBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__ProductiveBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__ProductiveBatch);
	return this->soap_out(soap, tag?tag:"vd:ProductiveBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__ProductiveBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__ProductiveBatch(soap, this, tag, type);
}

SOAP_FMAC3 vd__ProductiveBatch * SOAP_FMAC4 soap_get_vd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__ProductiveBatch * FASTCALL soap_instantiate_vd__ProductiveBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__ProductiveBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__ProductiveBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch);
		ASSIGN_PTR(size, sizeof(vd__ProductiveBatch));
		((vd__ProductiveBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__ProductiveBatch));
		for(int i = 0; i < n; i++)
			((vd__ProductiveBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__ProductiveBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__ProductiveBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__ProductiveBatch %p -> %p\n", q, p));
	*(vd__ProductiveBatch*)p = *(vd__ProductiveBatch*)q;
}

void vd__RawBatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__RawBatch::sourceStockEntry = NULL;
	this->vd__RawBatch::volume = NULL;
	this->vd__RawBatch::unit = NULL;
	this->vd__RawBatch::packageList = NULL;
	/* transient soap skipped */
}

void vd__RawBatch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->vd__RawBatch::sourceStockEntry);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__RawBatch::volume);
	soap_serialize_PointerToent__Unit(soap, &this->vd__RawBatch::unit);
	soap_serialize_PointerToent__PackageList(soap, &this->vd__RawBatch::packageList);
	/* transient soap skipped */
}

int vd__RawBatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__RawBatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__RawBatch(struct soap *soap, const char *tag, int id, const vd__RawBatch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__RawBatch), type))
		return soap->error;
	if(soap_out_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", -1, &(a->vd__RawBatch::sourceStockEntry), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__RawBatch::volume), ""))
		return soap->error;
	if(soap_out_PointerToent__Unit(soap, "vd:unit", -1, &(a->vd__RawBatch::unit), ""))
		return soap->error;
	if(soap_out_PointerToent__PackageList(soap, "vd:packageList", -1, &(a->vd__RawBatch::packageList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__RawBatch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__RawBatch(soap, tag, this, type);
}

SOAP_FMAC3 vd__RawBatch * FASTCALL soap_in_vd__RawBatch(struct soap *soap, const char *tag, vd__RawBatch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__RawBatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__RawBatch, sizeof(vd__RawBatch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__RawBatch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__RawBatch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sourceStockEntry1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_packageList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_sourceStockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", &(a->vd__RawBatch::sourceStockEntry), "vd:StockEntry"))
				{	soap_flag_sourceStockEntry1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__RawBatch::volume), "base:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "vd:unit", &(a->vd__RawBatch::unit), "ent:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if(soap_flag_packageList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackageList(soap, "vd:packageList", &(a->vd__RawBatch::packageList), "ent:PackageList"))
				{	soap_flag_packageList1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__RawBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__RawBatch, 0, sizeof(vd__RawBatch), 0, soap_copy_vd__RawBatch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__RawBatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__RawBatch);
	return this->soap_out(soap, tag?tag:"vd:RawBatch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__RawBatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__RawBatch(soap, this, tag, type);
}

SOAP_FMAC3 vd__RawBatch * SOAP_FMAC4 soap_get_vd__RawBatch(struct soap *soap, vd__RawBatch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__RawBatch * FASTCALL soap_instantiate_vd__RawBatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__RawBatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__RawBatch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__RawBatch);
		ASSIGN_PTR(size, sizeof(vd__RawBatch));
		((vd__RawBatch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__RawBatch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__RawBatch));
		for(int i = 0; i < n; i++)
			((vd__RawBatch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__RawBatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__RawBatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__RawBatch %p -> %p\n", q, p));
	*(vd__RawBatch*)p = *(vd__RawBatch*)q;
}

void vd__Consignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Consignment::sourceStockEntry = NULL;
	soap_default_xsd__ID(soap, &this->vd__Consignment::id);
	soap_default_xsd__IDREF(soap, &this->vd__Consignment::partOf);
	this->vd__Batch::productType = NULL;
	this->vd__Batch::product = NULL;
	this->vd__Batch::subProduct = NULL;
	this->vd__Batch::productItem = NULL;
	this->vd__Batch::volume = NULL;
	this->vd__Batch::unit = NULL;
	this->vd__Batch::dateOfProduction = NULL;
	this->vd__Batch::expiryDate = NULL;
	this->vd__Batch::__sizebatchID = 0;
	this->vd__Batch::batchID = NULL;
	this->vd__Batch::perishable = NULL;
	this->vd__Batch::origin = NULL;
	this->vd__Batch::lowGradeCargo = NULL;
	this->vd__Batch::packageList = NULL;
	this->vd__Batch::owner = NULL;
	/* transient soap skipped */
}

void vd__Consignment::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->vd__Consignment::sourceStockEntry);
	soap_serialize_PointerToent__ProductType(soap, &this->vd__Batch::productType);
	soap_serialize_PointerToent__Product(soap, &this->vd__Batch::product);
	soap_serialize_PointerToent__SubProduct(soap, &this->vd__Batch::subProduct);
	soap_serialize_PointerToent__ProductItem(soap, &this->vd__Batch::productItem);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__Batch::volume);
	soap_serialize_PointerToent__Unit(soap, &this->vd__Batch::unit);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::dateOfProduction);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::expiryDate);
	if(this->vd__Batch::batchID) {
		for(int i = 0; i < this->vd__Batch::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__Batch::perishable);
	soap_serialize_PointerTovd__BatchOrigin(soap, &this->vd__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->vd__Batch::lowGradeCargo);
	soap_serialize_PointerToent__PackageList(soap, &this->vd__Batch::packageList);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__Batch::owner);
	/* transient soap skipped */
}

int vd__Consignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Consignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Consignment(struct soap *soap, const char *tag, int id, const vd__Consignment *a, const char *type)
{
	if(((vd__Consignment*)a)->id)
		soap_set_attr(soap, "id", ((vd__Consignment*)a)->id, 1);
	if(((vd__Consignment*)a)->partOf)
		soap_set_attr(soap, "partOf", ((vd__Consignment*)a)->partOf, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Consignment), "vd:Consignment"))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "vd:productType", -1, &(a->vd__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerToent__Product(soap, "vd:product", -1, &(a->vd__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerToent__SubProduct(soap, "vd:subProduct", -1, &(a->vd__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductItem(soap, "vd:productItem", -1, &(a->vd__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerToent__Unit(soap, "vd:unit", -1, &(a->vd__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", -1, &(a->vd__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:expiryDate", -1, &(a->vd__Batch::expiryDate), ""))
		return soap->error;
	if(a->vd__Batch::batchID) {
		int i;
		for(i = 0; i < a->vd__Batch::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:perishable", -1, &(a->vd__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTovd__BatchOrigin(soap, "vd:origin", -1, &(a->vd__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:lowGradeCargo", -1, &(a->vd__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerToent__PackageList(soap, "vd:packageList", -1, &(a->vd__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "vd:owner", -1, &(a->vd__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", -1, &(a->vd__Consignment::sourceStockEntry), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vd__Consignment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Consignment(soap, tag, this, type);
}

SOAP_FMAC3 vd__Consignment * FASTCALL soap_in_vd__Consignment(struct soap *soap, const char *tag, vd__Consignment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Consignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Consignment, sizeof(vd__Consignment), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Consignment) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Consignment *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "id", 0), &((vd__Consignment*)a)->id, 0, -1))
		return NULL;
	if(soap_s2string(soap, soap_attr_value(soap, "partOf", 0), &((vd__Consignment*)a)->partOf, 0, -1))
		return NULL;
	size_t soap_flag_productType2 = 1;
	size_t soap_flag_product2 = 1;
	size_t soap_flag_subProduct2 = 1;
	size_t soap_flag_productItem2 = 1;
	size_t soap_flag_volume2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_dateOfProduction2 = 1;
	size_t soap_flag_expiryDate2 = 1;
	struct soap_blist *soap_blist_batchID2 = NULL;
	size_t soap_flag_perishable2 = 1;
	size_t soap_flag_origin2 = 1;
	size_t soap_flag_lowGradeCargo2 = 1;
	size_t soap_flag_packageList2 = 1;
	size_t soap_flag_owner2 = 1;
	size_t soap_flag_sourceStockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "vd:productType", &(a->vd__Batch::productType), "ent:ProductType"))
				{	soap_flag_productType2--;
					continue;
				}
			if(soap_flag_product2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "vd:product", &(a->vd__Batch::product), "ent:Product"))
				{	soap_flag_product2--;
					continue;
				}
			if(soap_flag_subProduct2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "vd:subProduct", &(a->vd__Batch::subProduct), "ent:SubProduct"))
				{	soap_flag_subProduct2--;
					continue;
				}
			if(soap_flag_productItem2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItem(soap, "vd:productItem", &(a->vd__Batch::productItem), "ent:ProductItem"))
				{	soap_flag_productItem2--;
					continue;
				}
			if(soap_flag_volume2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__Batch::volume), "base:Decimal"))
				{	soap_flag_volume2--;
					continue;
				}
			if(soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "vd:unit", &(a->vd__Batch::unit), "ent:Unit"))
				{	soap_flag_unit2--;
					continue;
				}
			if(soap_flag_dateOfProduction2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", &(a->vd__Batch::dateOfProduction), "vd:GoodsDate"))
				{	soap_flag_dateOfProduction2--;
					continue;
				}
			if(soap_flag_expiryDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:expiryDate", &(a->vd__Batch::expiryDate), "vd:GoodsDate"))
				{	soap_flag_expiryDate2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__Batch::batchID == NULL) {
					if(soap_blist_batchID2 == NULL)
						soap_blist_batchID2 = soap_new_block(soap);
					a->vd__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID2, sizeof(char *));
					if(a->vd__Batch::batchID == NULL)
						return NULL;
					*a->vd__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__Batch::batchID, "base:Identifier"))
				{	a->vd__Batch::__sizebatchID++;
					a->vd__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:perishable", &(a->vd__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable2--;
					continue;
				}
			if(soap_flag_origin2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BatchOrigin(soap, "vd:origin", &(a->vd__Batch::origin), "vd:BatchOrigin"))
				{	soap_flag_origin2--;
					continue;
				}
			if(soap_flag_lowGradeCargo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:lowGradeCargo", &(a->vd__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo2--;
					continue;
				}
			if(soap_flag_packageList2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackageList(soap, "vd:packageList", &(a->vd__Batch::packageList), "ent:PackageList"))
				{	soap_flag_packageList2--;
					continue;
				}
			if(soap_flag_owner2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:owner", &(a->vd__Batch::owner), "ent:BusinessEntity"))
				{	soap_flag_owner2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_sourceStockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:sourceStockEntry", &(a->vd__Consignment::sourceStockEntry), "vd:StockEntry"))
				{	soap_flag_sourceStockEntry1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID2);
		if(a->vd__Batch::__sizebatchID)
			a->vd__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID2, NULL, 1);
		else
		{	a->vd__Batch::batchID = NULL;
			if(soap_blist_batchID2)
				soap_end_block(soap, soap_blist_batchID2);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Consignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Consignment, 0, sizeof(vd__Consignment), 0, soap_copy_vd__Consignment);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Consignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Consignment);
	return this->soap_out(soap, tag?tag:"vd:Consignment", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Consignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Consignment(soap, this, tag, type);
}

SOAP_FMAC3 vd__Consignment * SOAP_FMAC4 soap_get_vd__Consignment(struct soap *soap, vd__Consignment *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Consignment * FASTCALL soap_instantiate_vd__Consignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Consignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Consignment, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Consignment);
		ASSIGN_PTR(size, sizeof(vd__Consignment));
		((vd__Consignment*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Consignment[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Consignment));
		for(int i = 0; i < n; i++)
			((vd__Consignment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Consignment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Consignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Consignment %p -> %p\n", q, p));
	*(vd__Consignment*)p = *(vd__Consignment*)q;
}

void vd__Batch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__Batch::productType = NULL;
	this->vd__Batch::product = NULL;
	this->vd__Batch::subProduct = NULL;
	this->vd__Batch::productItem = NULL;
	this->vd__Batch::volume = NULL;
	this->vd__Batch::unit = NULL;
	this->vd__Batch::dateOfProduction = NULL;
	this->vd__Batch::expiryDate = NULL;
	this->vd__Batch::__sizebatchID = 0;
	this->vd__Batch::batchID = NULL;
	this->vd__Batch::perishable = NULL;
	this->vd__Batch::origin = NULL;
	this->vd__Batch::lowGradeCargo = NULL;
	this->vd__Batch::packageList = NULL;
	this->vd__Batch::owner = NULL;
	/* transient soap skipped */
}

void vd__Batch::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductType(soap, &this->vd__Batch::productType);
	soap_serialize_PointerToent__Product(soap, &this->vd__Batch::product);
	soap_serialize_PointerToent__SubProduct(soap, &this->vd__Batch::subProduct);
	soap_serialize_PointerToent__ProductItem(soap, &this->vd__Batch::productItem);
	soap_serialize_PointerTobase__Decimal(soap, &this->vd__Batch::volume);
	soap_serialize_PointerToent__Unit(soap, &this->vd__Batch::unit);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::dateOfProduction);
	soap_serialize_PointerTovd__GoodsDate(soap, &this->vd__Batch::expiryDate);
	if(this->vd__Batch::batchID) {
		for(int i = 0; i < this->vd__Batch::__sizebatchID; i++) {
			soap_serialize_base__Identifier(soap, this->vd__Batch::batchID + i);
		}
	}
	soap_serialize_PointerTobool(soap, &this->vd__Batch::perishable);
	soap_serialize_PointerTovd__BatchOrigin(soap, &this->vd__Batch::origin);
	soap_serialize_PointerTobool(soap, &this->vd__Batch::lowGradeCargo);
	soap_serialize_PointerToent__PackageList(soap, &this->vd__Batch::packageList);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->vd__Batch::owner);
	/* transient soap skipped */
}

int vd__Batch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__Batch(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__Batch(struct soap *soap, const char *tag, int id, const vd__Batch *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__Batch), type))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "vd:productType", -1, &(a->vd__Batch::productType), ""))
		return soap->error;
	if(soap_out_PointerToent__Product(soap, "vd:product", -1, &(a->vd__Batch::product), ""))
		return soap->error;
	if(soap_out_PointerToent__SubProduct(soap, "vd:subProduct", -1, &(a->vd__Batch::subProduct), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductItem(soap, "vd:productItem", -1, &(a->vd__Batch::productItem), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "vd:volume", -1, &(a->vd__Batch::volume), ""))
		return soap->error;
	if(soap_out_PointerToent__Unit(soap, "vd:unit", -1, &(a->vd__Batch::unit), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", -1, &(a->vd__Batch::dateOfProduction), ""))
		return soap->error;
	if(soap_out_PointerTovd__GoodsDate(soap, "vd:expiryDate", -1, &(a->vd__Batch::expiryDate), ""))
		return soap->error;
	if(a->vd__Batch::batchID) {
		int i;
		for(i = 0; i < a->vd__Batch::__sizebatchID; i++)
			if(soap_out_base__Identifier(soap, "vd:batchID", -1, a->vd__Batch::batchID + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTobool(soap, "vd:perishable", -1, &(a->vd__Batch::perishable), ""))
		return soap->error;
	if(soap_out_PointerTovd__BatchOrigin(soap, "vd:origin", -1, &(a->vd__Batch::origin), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:lowGradeCargo", -1, &(a->vd__Batch::lowGradeCargo), ""))
		return soap->error;
	if(soap_out_PointerToent__PackageList(soap, "vd:packageList", -1, &(a->vd__Batch::packageList), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "vd:owner", -1, &(a->vd__Batch::owner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *vd__Batch::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__Batch(soap, tag, this, type);
}

SOAP_FMAC3 vd__Batch * FASTCALL soap_in_vd__Batch(struct soap *soap, const char *tag, vd__Batch *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__Batch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__Batch, sizeof(vd__Batch), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__Batch) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__Batch *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_subProduct1 = 1;
	size_t soap_flag_productItem1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_dateOfProduction1 = 1;
	size_t soap_flag_expiryDate1 = 1;
	struct soap_blist *soap_blist_batchID1 = NULL;
	size_t soap_flag_perishable1 = 1;
	size_t soap_flag_origin1 = 1;
	size_t soap_flag_lowGradeCargo1 = 1;
	size_t soap_flag_packageList1 = 1;
	size_t soap_flag_owner1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "vd:productType", &(a->vd__Batch::productType), "ent:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap_flag_product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "vd:product", &(a->vd__Batch::product), "ent:Product"))
				{	soap_flag_product1--;
					continue;
				}
			if(soap_flag_subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "vd:subProduct", &(a->vd__Batch::subProduct), "ent:SubProduct"))
				{	soap_flag_subProduct1--;
					continue;
				}
			if(soap_flag_productItem1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItem(soap, "vd:productItem", &(a->vd__Batch::productItem), "ent:ProductItem"))
				{	soap_flag_productItem1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "vd:volume", &(a->vd__Batch::volume), "base:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "vd:unit", &(a->vd__Batch::unit), "ent:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if(soap_flag_dateOfProduction1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:dateOfProduction", &(a->vd__Batch::dateOfProduction), "vd:GoodsDate"))
				{	soap_flag_dateOfProduction1--;
					continue;
				}
			if(soap_flag_expiryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__GoodsDate(soap, "vd:expiryDate", &(a->vd__Batch::expiryDate), "vd:GoodsDate"))
				{	soap_flag_expiryDate1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:batchID", 1, NULL)) {
				if(a->vd__Batch::batchID == NULL) {
					if(soap_blist_batchID1 == NULL)
						soap_blist_batchID1 = soap_new_block(soap);
					a->vd__Batch::batchID = (char **)soap_push_block(soap, soap_blist_batchID1, sizeof(char *));
					if(a->vd__Batch::batchID == NULL)
						return NULL;
					*a->vd__Batch::batchID = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__Identifier(soap, "vd:batchID", a->vd__Batch::batchID, "base:Identifier"))
				{	a->vd__Batch::__sizebatchID++;
					a->vd__Batch::batchID = NULL;
					continue;
				}
			}
			if(soap_flag_perishable1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:perishable", &(a->vd__Batch::perishable), "xsd:boolean"))
				{	soap_flag_perishable1--;
					continue;
				}
			if(soap_flag_origin1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BatchOrigin(soap, "vd:origin", &(a->vd__Batch::origin), "vd:BatchOrigin"))
				{	soap_flag_origin1--;
					continue;
				}
			if(soap_flag_lowGradeCargo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:lowGradeCargo", &(a->vd__Batch::lowGradeCargo), "xsd:boolean"))
				{	soap_flag_lowGradeCargo1--;
					continue;
				}
			if(soap_flag_packageList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackageList(soap, "vd:packageList", &(a->vd__Batch::packageList), "ent:PackageList"))
				{	soap_flag_packageList1--;
					continue;
				}
			if(soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "vd:owner", &(a->vd__Batch::owner), "ent:BusinessEntity"))
				{	soap_flag_owner1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__Batch::batchID)
			soap_pop_block(soap, soap_blist_batchID1);
		if(a->vd__Batch::__sizebatchID)
			a->vd__Batch::batchID = (char **)soap_save_block(soap, soap_blist_batchID1, NULL, 1);
		else
		{	a->vd__Batch::batchID = NULL;
			if(soap_blist_batchID1)
				soap_end_block(soap, soap_blist_batchID1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__Batch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__Batch, 0, sizeof(vd__Batch), 0, soap_copy_vd__Batch);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int vd__Batch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__Batch);
	return this->soap_out(soap, tag?tag:"vd:Batch", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__Batch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__Batch(soap, this, tag, type);
}

SOAP_FMAC3 vd__Batch * SOAP_FMAC4 soap_get_vd__Batch(struct soap *soap, vd__Batch *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__Batch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__Batch * FASTCALL soap_instantiate_vd__Batch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__Batch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__Batch, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "vd:Consignment")) {
		cp->type = SOAP_TYPE_vd__Consignment;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Consignment);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Consignment));
			((vd__Consignment*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Consignment[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Consignment));
			for(int i = 0; i < n; i++)
				((vd__Consignment*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Consignment*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ProductiveBatch")) {
		cp->type = SOAP_TYPE_vd__ProductiveBatch;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ProductiveBatch));
			((vd__ProductiveBatch*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ProductiveBatch[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ProductiveBatch));
			for(int i = 0; i < n; i++)
				((vd__ProductiveBatch*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ProductiveBatch*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__Batch);
		ASSIGN_PTR(size, sizeof(vd__Batch));
		((vd__Batch*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__Batch[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__Batch));
		for(int i = 0; i < n; i++)
			((vd__Batch*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__Batch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__Batch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__Batch %p -> %p\n", q, p));
	*(vd__Batch*)p = *(vd__Batch*)q;
}

void vd__VetDocument::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->vd__VetDocument::vetDForm = NULL;
	this->vd__VetDocument::vetDType = NULL;
	this->vd__VetDocument::vetDStatus = NULL;
	this->vd__VetDocument::finalized = NULL;
	this->vd__VetDocument::lastUpdateDate = NULL;
	this->vd__VetDocument::__union_VetDocument = 0;
	this->vd__VetDocument::authentication = NULL;
	soap_default_base__String255(soap, &this->vd__VetDocument::precedingVetDocuments);
	this->vd__VetDocument::__sizereferencedDocument = 0;
	this->vd__VetDocument::referencedDocument = NULL;
	this->vd__VetDocument::__sizestatusChange = 0;
	this->vd__VetDocument::statusChange = NULL;
	soap_default_base__String255(soap, &this->vd__Document::name);
	soap_default_base__String255(soap, &this->vd__Document::form);
	soap_default_base__String255(soap, &this->vd__Document::issueSeries);
	soap_default_base__String255(soap, &this->vd__Document::issueNumber);
	soap_default_xsd__date(soap, &this->vd__Document::issueDate);
	this->vd__Document::type = NULL;
	this->vd__Document::issuer = NULL;
	soap_default_xsd__IDREF(soap, &this->vd__Document::for_);
	this->vd__Document::qualifier = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void vd__VetDocument::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocumentForm(soap, &this->vd__VetDocument::vetDForm);
	soap_serialize_PointerTovd__VetDocumentType(soap, &this->vd__VetDocument::vetDType);
	soap_serialize_PointerTovd__VetDocumentStatus(soap, &this->vd__VetDocument::vetDStatus);
	soap_serialize_PointerTobool(soap, &this->vd__VetDocument::finalized);
	soap_serialize_PointerTotime(soap, &this->vd__VetDocument::lastUpdateDate);
	soap_serialize__vd__union_VetDocument(soap, this->vd__VetDocument::__union_VetDocument, &this->vd__VetDocument::union_VetDocument);
	soap_serialize_PointerTovd__VeterinaryAuthentication(soap, &this->vd__VetDocument::authentication);
	soap_serialize_base__String255(soap, &this->vd__VetDocument::precedingVetDocuments);
	if(this->vd__VetDocument::referencedDocument) {
		for(int i = 0; i < this->vd__VetDocument::__sizereferencedDocument; i++) {
			soap_serialize_PointerTovd__ReferencedDocument(soap, this->vd__VetDocument::referencedDocument + i);
		}
	}
	if(this->vd__VetDocument::statusChange) {
		for(int i = 0; i < this->vd__VetDocument::__sizestatusChange; i++) {
			soap_serialize_PointerTovd__VetDocumentStatusChange(soap, this->vd__VetDocument::statusChange + i);
		}
	}
	soap_serialize_base__String255(soap, &this->vd__Document::name);
	soap_serialize_base__String255(soap, &this->vd__Document::form);
	soap_serialize_base__String255(soap, &this->vd__Document::issueSeries);
	soap_serialize_base__String255(soap, &this->vd__Document::issueNumber);
	soap_serialize_xsd__date(soap, &this->vd__Document::issueDate);
	soap_serialize_PointerToent__DocumentType(soap, &this->vd__Document::type);
	soap_serialize_PointerToent__Organization(soap, &this->vd__Document::issuer);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int vd__VetDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vd__VetDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocument(struct soap *soap, const char *tag, int id, const vd__VetDocument *a, const char *type)
{
	if(((vd__Document*)a)->for_)
		soap_set_attr(soap, "for", ((vd__Document*)a)->for_, 1);
	if(((vd__Document*)a)->qualifier)
		if(*((vd__Document*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((vd__Document*)a)->qualifier, 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vd__VetDocument), "vd:VetDocument"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "vd:name", -1, &(a->vd__Document::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:form", -1, &(a->vd__Document::form), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueSeries", -1, &(a->vd__Document::issueSeries), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:issueNumber", -1, &(a->vd__Document::issueNumber), ""))
		return soap->error;
	if(soap_out_xsd__date(soap, "vd:issueDate", -1, &(a->vd__Document::issueDate), ""))
		return soap->error;
	if(soap_out_PointerToent__DocumentType(soap, "vd:type", -1, &(a->vd__Document::type), ""))
		return soap->error;
	if(soap_out_PointerToent__Organization(soap, "vd:issuer", -1, &(a->vd__Document::issuer), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentForm(soap, "vd:vetDForm", -1, &(a->vd__VetDocument::vetDForm), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentType(soap, "vd:vetDType", -1, &(a->vd__VetDocument::vetDType), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentStatus(soap, "vd:vetDStatus", -1, &(a->vd__VetDocument::vetDStatus), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "vd:finalized", -1, &(a->vd__VetDocument::finalized), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "vd:lastUpdateDate", -1, &(a->vd__VetDocument::lastUpdateDate), ""))
		return soap->error;
	if(soap_out__vd__union_VetDocument(soap, a->vd__VetDocument::__union_VetDocument, &a->vd__VetDocument::union_VetDocument))
		return soap->error;
	if(soap_out_PointerTovd__VeterinaryAuthentication(soap, "vd:authentication", -1, &(a->vd__VetDocument::authentication), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "vd:precedingVetDocuments", -1, &(a->vd__VetDocument::precedingVetDocuments), ""))
		return soap->error;
	if(a->vd__VetDocument::referencedDocument) {
		int i;
		for(i = 0; i < a->vd__VetDocument::__sizereferencedDocument; i++)
			if(soap_out_PointerTovd__ReferencedDocument(soap, "vd:referencedDocument", -1, a->vd__VetDocument::referencedDocument + i, ""))
				return soap->error;
	}
	if(a->vd__VetDocument::statusChange) {
		int i;
		for(i = 0; i < a->vd__VetDocument::__sizestatusChange; i++)
			if(soap_out_PointerTovd__VetDocumentStatusChange(soap, "vd:statusChange", -1, a->vd__VetDocument::statusChange + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *vd__VetDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_vd__VetDocument(soap, tag, this, type);
}

SOAP_FMAC3 vd__VetDocument * FASTCALL soap_in_vd__VetDocument(struct soap *soap, const char *tag, vd__VetDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vd__VetDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_vd__VetDocument, sizeof(vd__VetDocument), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_vd__VetDocument) {
			soap_revert(soap);
			*soap->id = '\0';
			return (vd__VetDocument *)a->soap_in(soap, tag, type);
		}
	}
	if(soap_s2string(soap, soap_attr_value(soap, "for", 0), &((vd__Document*)a)->for_, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((vd__Document*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((vd__Document*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_form2 = 1;
	size_t soap_flag_issueSeries2 = 1;
	size_t soap_flag_issueNumber2 = 1;
	size_t soap_flag_issueDate2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_issuer2 = 1;
	size_t soap_flag_vetDForm1 = 1;
	size_t soap_flag_vetDType1 = 1;
	size_t soap_flag_vetDStatus1 = 1;
	size_t soap_flag_finalized1 = 1;
	size_t soap_flag_lastUpdateDate1 = 1;
	size_t soap_flag_union_VetDocument1 = 1;
	size_t soap_flag_authentication1 = 1;
	size_t soap_flag_precedingVetDocuments1 = 1;
	struct soap_blist *soap_blist_referencedDocument1 = NULL;
	struct soap_blist *soap_blist_statusChange1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:name", &(a->vd__Document::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_form2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:form", &(a->vd__Document::form), "base:String255"))
				{	soap_flag_form2--;
					continue;
				}
			if(soap_flag_issueSeries2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueSeries", &(a->vd__Document::issueSeries), "base:String255"))
				{	soap_flag_issueSeries2--;
					continue;
				}
			if(soap_flag_issueNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:issueNumber", &(a->vd__Document::issueNumber), "base:String255"))
				{	soap_flag_issueNumber2--;
					continue;
				}
			if(soap_flag_issueDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__date(soap, "vd:issueDate", &(a->vd__Document::issueDate), "xsd:date"))
				{	soap_flag_issueDate2--;
					continue;
				}
			if(soap_flag_type2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__DocumentType(soap, "vd:type", &(a->vd__Document::type), "ent:DocumentType"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_issuer2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Organization(soap, "vd:issuer", &(a->vd__Document::issuer), "ent:Organization"))
				{	soap_flag_issuer2--;
					continue;
				}
			if(soap_flag_vetDForm1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentForm(soap, "vd:vetDForm", &(a->vd__VetDocument::vetDForm), "vd:VetDocumentForm"))
				{	soap_flag_vetDForm1--;
					continue;
				}
			if(soap_flag_vetDType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentType(soap, "vd:vetDType", &(a->vd__VetDocument::vetDType), "vd:VetDocumentType"))
				{	soap_flag_vetDType1--;
					continue;
				}
			if(soap_flag_vetDStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentStatus(soap, "vd:vetDStatus", &(a->vd__VetDocument::vetDStatus), "vd:VetDocumentStatus"))
				{	soap_flag_vetDStatus1--;
					continue;
				}
			if(soap_flag_finalized1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "vd:finalized", &(a->vd__VetDocument::finalized), "xsd:boolean"))
				{	soap_flag_finalized1--;
					continue;
				}
			if(soap_flag_lastUpdateDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "vd:lastUpdateDate", &(a->vd__VetDocument::lastUpdateDate), "xsd:dateTime"))
				{	soap_flag_lastUpdateDate1--;
					continue;
				}
			if(soap_flag_union_VetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in__vd__union_VetDocument(soap, &a->vd__VetDocument::__union_VetDocument, &a->vd__VetDocument::union_VetDocument))
				{	soap_flag_union_VetDocument1 = 0;
					continue;
				}
			if(soap_flag_authentication1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VeterinaryAuthentication(soap, "vd:authentication", &(a->vd__VetDocument::authentication), "vd:VeterinaryAuthentication"))
				{	soap_flag_authentication1--;
					continue;
				}
			if(soap_flag_precedingVetDocuments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "vd:precedingVetDocuments", &(a->vd__VetDocument::precedingVetDocuments), "base:String255"))
				{	soap_flag_precedingVetDocuments1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:referencedDocument", 1, NULL)) {
				if(a->vd__VetDocument::referencedDocument == NULL) {
					if(soap_blist_referencedDocument1 == NULL)
						soap_blist_referencedDocument1 = soap_new_block(soap);
					a->vd__VetDocument::referencedDocument = (vd__ReferencedDocument **)soap_push_block(soap, soap_blist_referencedDocument1, sizeof(vd__ReferencedDocument *));
					if(a->vd__VetDocument::referencedDocument == NULL)
						return NULL;
					*a->vd__VetDocument::referencedDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__ReferencedDocument(soap, "vd:referencedDocument", a->vd__VetDocument::referencedDocument, "vd:ReferencedDocument"))
				{	a->vd__VetDocument::__sizereferencedDocument++;
					a->vd__VetDocument::referencedDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:statusChange", 1, NULL)) {
				if(a->vd__VetDocument::statusChange == NULL) {
					if(soap_blist_statusChange1 == NULL)
						soap_blist_statusChange1 = soap_new_block(soap);
					a->vd__VetDocument::statusChange = (vd__VetDocumentStatusChange **)soap_push_block(soap, soap_blist_statusChange1, sizeof(vd__VetDocumentStatusChange *));
					if(a->vd__VetDocument::statusChange == NULL)
						return NULL;
					*a->vd__VetDocument::statusChange = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocumentStatusChange(soap, "vd:statusChange", a->vd__VetDocument::statusChange, "vd:VetDocumentStatusChange"))
				{	a->vd__VetDocument::__sizestatusChange++;
					a->vd__VetDocument::statusChange = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->vd__VetDocument::referencedDocument)
			soap_pop_block(soap, soap_blist_referencedDocument1);
		if(a->vd__VetDocument::__sizereferencedDocument)
			a->vd__VetDocument::referencedDocument = (vd__ReferencedDocument **)soap_save_block(soap, soap_blist_referencedDocument1, NULL, 1);
		else
		{	a->vd__VetDocument::referencedDocument = NULL;
			if(soap_blist_referencedDocument1)
				soap_end_block(soap, soap_blist_referencedDocument1);
		}
		if(a->vd__VetDocument::statusChange)
			soap_pop_block(soap, soap_blist_statusChange1);
		if(a->vd__VetDocument::__sizestatusChange)
			a->vd__VetDocument::statusChange = (vd__VetDocumentStatusChange **)soap_save_block(soap, soap_blist_statusChange1, NULL, 1);
		else
		{	a->vd__VetDocument::statusChange = NULL;
			if(soap_blist_statusChange1)
				soap_end_block(soap, soap_blist_statusChange1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (vd__VetDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vd__VetDocument, 0, sizeof(vd__VetDocument), 0, soap_copy_vd__VetDocument);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_VetDocument1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int vd__VetDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_vd__VetDocument);
	return this->soap_out(soap, tag?tag:"vd:VetDocument", id, type) ? soap->error : soap_putindependent(soap);
}

void *vd__VetDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vd__VetDocument(soap, this, tag, type);
}

SOAP_FMAC3 vd__VetDocument * SOAP_FMAC4 soap_get_vd__VetDocument(struct soap *soap, vd__VetDocument *p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 vd__VetDocument * FASTCALL soap_instantiate_vd__VetDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_vd__VetDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_vd__VetDocument, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocument);
		ASSIGN_PTR(size, sizeof(vd__VetDocument));
		((vd__VetDocument*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(vd__VetDocument[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(vd__VetDocument));
		for(int i = 0; i < n; i++)
			((vd__VetDocument*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (vd__VetDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_vd__VetDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying vd__VetDocument %p -> %p\n", q, p));
	*(vd__VetDocument*)p = *(vd__VetDocument*)q;
}

void ent__ActivityLocationList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ActivityLocationList::__sizelocation = 0;
	this->ent__ActivityLocationList::location = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__ActivityLocationList::soap_serialize(struct soap *soap) const
{
	if(this->ent__ActivityLocationList::location) {
		for(int i = 0; i < this->ent__ActivityLocationList::__sizelocation; i++) {
			soap_serialize_PointerToent__BusinessMember(soap, this->ent__ActivityLocationList::location + i);
		}
	}
	/* transient soap skipped */
}

int ent__ActivityLocationList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ActivityLocationList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ActivityLocationList(struct soap *soap, const char *tag, int id, const ent__ActivityLocationList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ActivityLocationList), "ent:ActivityLocationList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__ActivityLocationList::location) {
		int i;
		for(i = 0; i < a->ent__ActivityLocationList::__sizelocation; i++)
			if(soap_out_PointerToent__BusinessMember(soap, "ent:location", -1, a->ent__ActivityLocationList::location + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__ActivityLocationList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ActivityLocationList(soap, tag, this, type);
}

SOAP_FMAC3 ent__ActivityLocationList * FASTCALL soap_in_ent__ActivityLocationList(struct soap *soap, const char *tag, ent__ActivityLocationList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ActivityLocationList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ActivityLocationList, sizeof(ent__ActivityLocationList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ActivityLocationList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ActivityLocationList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_location1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:location", 1, NULL)) {
				if(a->ent__ActivityLocationList::location == NULL) {
					if(soap_blist_location1 == NULL)
						soap_blist_location1 = soap_new_block(soap);
					a->ent__ActivityLocationList::location = (ent__BusinessMember **)soap_push_block(soap, soap_blist_location1, sizeof(ent__BusinessMember *));
					if(a->ent__ActivityLocationList::location == NULL)
						return NULL;
					*a->ent__ActivityLocationList::location = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__BusinessMember(soap, "ent:location", a->ent__ActivityLocationList::location, "ent:BusinessMember"))
				{	a->ent__ActivityLocationList::__sizelocation++;
					a->ent__ActivityLocationList::location = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__ActivityLocationList::location)
			soap_pop_block(soap, soap_blist_location1);
		if(a->ent__ActivityLocationList::__sizelocation)
			a->ent__ActivityLocationList::location = (ent__BusinessMember **)soap_save_block(soap, soap_blist_location1, NULL, 1);
		else
		{	a->ent__ActivityLocationList::location = NULL;
			if(soap_blist_location1)
				soap_end_block(soap, soap_blist_location1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ActivityLocationList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ActivityLocationList, 0, sizeof(ent__ActivityLocationList), 0, soap_copy_ent__ActivityLocationList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ActivityLocationList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ActivityLocationList);
	return this->soap_out(soap, tag?tag:"ent:ActivityLocationList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ActivityLocationList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ActivityLocationList(soap, this, tag, type);
}

SOAP_FMAC3 ent__ActivityLocationList * SOAP_FMAC4 soap_get_ent__ActivityLocationList(struct soap *soap, ent__ActivityLocationList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ActivityLocationList * FASTCALL soap_instantiate_ent__ActivityLocationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ActivityLocationList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ActivityLocationList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ActivityLocationList);
		ASSIGN_PTR(size, sizeof(ent__ActivityLocationList));
		((ent__ActivityLocationList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ActivityLocationList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ActivityLocationList));
		for(int i = 0; i < n; i++)
			((ent__ActivityLocationList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ActivityLocationList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ActivityLocationList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ActivityLocationList %p -> %p\n", q, p));
	*(ent__ActivityLocationList*)p = *(ent__ActivityLocationList*)q;
}

void ent__ResearchMethodList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ResearchMethodList::__sizemethod = 0;
	this->ent__ResearchMethodList::method = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__ResearchMethodList::soap_serialize(struct soap *soap) const
{
	if(this->ent__ResearchMethodList::method) {
		for(int i = 0; i < this->ent__ResearchMethodList::__sizemethod; i++) {
			soap_serialize_PointerToent__ResearchMethod(soap, this->ent__ResearchMethodList::method + i);
		}
	}
	/* transient soap skipped */
}

int ent__ResearchMethodList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ResearchMethodList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ResearchMethodList(struct soap *soap, const char *tag, int id, const ent__ResearchMethodList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ResearchMethodList), "ent:ResearchMethodList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__ResearchMethodList::method) {
		int i;
		for(i = 0; i < a->ent__ResearchMethodList::__sizemethod; i++)
			if(soap_out_PointerToent__ResearchMethod(soap, "ent:method", -1, a->ent__ResearchMethodList::method + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__ResearchMethodList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ResearchMethodList(soap, tag, this, type);
}

SOAP_FMAC3 ent__ResearchMethodList * FASTCALL soap_in_ent__ResearchMethodList(struct soap *soap, const char *tag, ent__ResearchMethodList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ResearchMethodList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ResearchMethodList, sizeof(ent__ResearchMethodList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ResearchMethodList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ResearchMethodList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_method1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:method", 1, NULL)) {
				if(a->ent__ResearchMethodList::method == NULL) {
					if(soap_blist_method1 == NULL)
						soap_blist_method1 = soap_new_block(soap);
					a->ent__ResearchMethodList::method = (ent__ResearchMethod **)soap_push_block(soap, soap_blist_method1, sizeof(ent__ResearchMethod *));
					if(a->ent__ResearchMethodList::method == NULL)
						return NULL;
					*a->ent__ResearchMethodList::method = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__ResearchMethod(soap, "ent:method", a->ent__ResearchMethodList::method, "ent:ResearchMethod"))
				{	a->ent__ResearchMethodList::__sizemethod++;
					a->ent__ResearchMethodList::method = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__ResearchMethodList::method)
			soap_pop_block(soap, soap_blist_method1);
		if(a->ent__ResearchMethodList::__sizemethod)
			a->ent__ResearchMethodList::method = (ent__ResearchMethod **)soap_save_block(soap, soap_blist_method1, NULL, 1);
		else
		{	a->ent__ResearchMethodList::method = NULL;
			if(soap_blist_method1)
				soap_end_block(soap, soap_blist_method1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ResearchMethodList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ResearchMethodList, 0, sizeof(ent__ResearchMethodList), 0, soap_copy_ent__ResearchMethodList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ResearchMethodList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ResearchMethodList);
	return this->soap_out(soap, tag?tag:"ent:ResearchMethodList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ResearchMethodList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ResearchMethodList(soap, this, tag, type);
}

SOAP_FMAC3 ent__ResearchMethodList * SOAP_FMAC4 soap_get_ent__ResearchMethodList(struct soap *soap, ent__ResearchMethodList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ResearchMethodList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ResearchMethodList * FASTCALL soap_instantiate_ent__ResearchMethodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ResearchMethodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ResearchMethodList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ResearchMethodList);
		ASSIGN_PTR(size, sizeof(ent__ResearchMethodList));
		((ent__ResearchMethodList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ResearchMethodList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ResearchMethodList));
		for(int i = 0; i < n; i++)
			((ent__ResearchMethodList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ResearchMethodList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ResearchMethodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ResearchMethodList %p -> %p\n", q, p));
	*(ent__ResearchMethodList*)p = *(ent__ResearchMethodList*)q;
}

void ent__AnimalDiseaseList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__AnimalDiseaseList::__sizedisease = 0;
	this->ent__AnimalDiseaseList::disease = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__AnimalDiseaseList::soap_serialize(struct soap *soap) const
{
	if(this->ent__AnimalDiseaseList::disease) {
		for(int i = 0; i < this->ent__AnimalDiseaseList::__sizedisease; i++) {
			soap_serialize_PointerToent__AnimalDisease(soap, this->ent__AnimalDiseaseList::disease + i);
		}
	}
	/* transient soap skipped */
}

int ent__AnimalDiseaseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__AnimalDiseaseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__AnimalDiseaseList(struct soap *soap, const char *tag, int id, const ent__AnimalDiseaseList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__AnimalDiseaseList), "ent:AnimalDiseaseList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__AnimalDiseaseList::disease) {
		int i;
		for(i = 0; i < a->ent__AnimalDiseaseList::__sizedisease; i++)
			if(soap_out_PointerToent__AnimalDisease(soap, "ent:disease", -1, a->ent__AnimalDiseaseList::disease + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__AnimalDiseaseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__AnimalDiseaseList(soap, tag, this, type);
}

SOAP_FMAC3 ent__AnimalDiseaseList * FASTCALL soap_in_ent__AnimalDiseaseList(struct soap *soap, const char *tag, ent__AnimalDiseaseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__AnimalDiseaseList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__AnimalDiseaseList, sizeof(ent__AnimalDiseaseList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__AnimalDiseaseList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__AnimalDiseaseList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_disease1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:disease", 1, NULL)) {
				if(a->ent__AnimalDiseaseList::disease == NULL) {
					if(soap_blist_disease1 == NULL)
						soap_blist_disease1 = soap_new_block(soap);
					a->ent__AnimalDiseaseList::disease = (ent__AnimalDisease **)soap_push_block(soap, soap_blist_disease1, sizeof(ent__AnimalDisease *));
					if(a->ent__AnimalDiseaseList::disease == NULL)
						return NULL;
					*a->ent__AnimalDiseaseList::disease = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:disease", a->ent__AnimalDiseaseList::disease, "ent:AnimalDisease"))
				{	a->ent__AnimalDiseaseList::__sizedisease++;
					a->ent__AnimalDiseaseList::disease = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__AnimalDiseaseList::disease)
			soap_pop_block(soap, soap_blist_disease1);
		if(a->ent__AnimalDiseaseList::__sizedisease)
			a->ent__AnimalDiseaseList::disease = (ent__AnimalDisease **)soap_save_block(soap, soap_blist_disease1, NULL, 1);
		else
		{	a->ent__AnimalDiseaseList::disease = NULL;
			if(soap_blist_disease1)
				soap_end_block(soap, soap_blist_disease1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__AnimalDiseaseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__AnimalDiseaseList, 0, sizeof(ent__AnimalDiseaseList), 0, soap_copy_ent__AnimalDiseaseList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__AnimalDiseaseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__AnimalDiseaseList);
	return this->soap_out(soap, tag?tag:"ent:AnimalDiseaseList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__AnimalDiseaseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__AnimalDiseaseList(soap, this, tag, type);
}

SOAP_FMAC3 ent__AnimalDiseaseList * SOAP_FMAC4 soap_get_ent__AnimalDiseaseList(struct soap *soap, ent__AnimalDiseaseList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__AnimalDiseaseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__AnimalDiseaseList * FASTCALL soap_instantiate_ent__AnimalDiseaseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__AnimalDiseaseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__AnimalDiseaseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__AnimalDiseaseList);
		ASSIGN_PTR(size, sizeof(ent__AnimalDiseaseList));
		((ent__AnimalDiseaseList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__AnimalDiseaseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__AnimalDiseaseList));
		for(int i = 0; i < n; i++)
			((ent__AnimalDiseaseList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__AnimalDiseaseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__AnimalDiseaseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__AnimalDiseaseList %p -> %p\n", q, p));
	*(ent__AnimalDiseaseList*)p = *(ent__AnimalDiseaseList*)q;
}

void ent__RegionalizationShippingRuleList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationShippingRuleList::__sizerule = 0;
	this->ent__RegionalizationShippingRuleList::rule = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__RegionalizationShippingRuleList::soap_serialize(struct soap *soap) const
{
	if(this->ent__RegionalizationShippingRuleList::rule) {
		for(int i = 0; i < this->ent__RegionalizationShippingRuleList::__sizerule; i++) {
			soap_serialize_PointerToent__RegionalizationShippingRule(soap, this->ent__RegionalizationShippingRuleList::rule + i);
		}
	}
	/* transient soap skipped */
}

int ent__RegionalizationShippingRuleList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationShippingRuleList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationShippingRuleList(struct soap *soap, const char *tag, int id, const ent__RegionalizationShippingRuleList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationShippingRuleList), "ent:RegionalizationShippingRuleList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__RegionalizationShippingRuleList::rule) {
		int i;
		for(i = 0; i < a->ent__RegionalizationShippingRuleList::__sizerule; i++)
			if(soap_out_PointerToent__RegionalizationShippingRule(soap, "ent:rule", -1, a->ent__RegionalizationShippingRuleList::rule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationShippingRuleList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationShippingRuleList(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRuleList * FASTCALL soap_in_ent__RegionalizationShippingRuleList(struct soap *soap, const char *tag, ent__RegionalizationShippingRuleList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationShippingRuleList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationShippingRuleList, sizeof(ent__RegionalizationShippingRuleList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationShippingRuleList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationShippingRuleList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_rule1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:rule", 1, NULL)) {
				if(a->ent__RegionalizationShippingRuleList::rule == NULL) {
					if(soap_blist_rule1 == NULL)
						soap_blist_rule1 = soap_new_block(soap);
					a->ent__RegionalizationShippingRuleList::rule = (ent__RegionalizationShippingRule **)soap_push_block(soap, soap_blist_rule1, sizeof(ent__RegionalizationShippingRule *));
					if(a->ent__RegionalizationShippingRuleList::rule == NULL)
						return NULL;
					*a->ent__RegionalizationShippingRuleList::rule = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationShippingRule(soap, "ent:rule", a->ent__RegionalizationShippingRuleList::rule, "ent:RegionalizationShippingRule"))
				{	a->ent__RegionalizationShippingRuleList::__sizerule++;
					a->ent__RegionalizationShippingRuleList::rule = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationShippingRuleList::rule)
			soap_pop_block(soap, soap_blist_rule1);
		if(a->ent__RegionalizationShippingRuleList::__sizerule)
			a->ent__RegionalizationShippingRuleList::rule = (ent__RegionalizationShippingRule **)soap_save_block(soap, soap_blist_rule1, NULL, 1);
		else
		{	a->ent__RegionalizationShippingRuleList::rule = NULL;
			if(soap_blist_rule1)
				soap_end_block(soap, soap_blist_rule1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationShippingRuleList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationShippingRuleList, 0, sizeof(ent__RegionalizationShippingRuleList), 0, soap_copy_ent__RegionalizationShippingRuleList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationShippingRuleList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationShippingRuleList);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationShippingRuleList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationShippingRuleList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationShippingRuleList(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRuleList * SOAP_FMAC4 soap_get_ent__RegionalizationShippingRuleList(struct soap *soap, ent__RegionalizationShippingRuleList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationShippingRuleList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationShippingRuleList * FASTCALL soap_instantiate_ent__RegionalizationShippingRuleList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationShippingRuleList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationShippingRuleList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRuleList);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationShippingRuleList));
		((ent__RegionalizationShippingRuleList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRuleList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationShippingRuleList));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationShippingRuleList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationShippingRuleList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationShippingRuleList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationShippingRuleList %p -> %p\n", q, p));
	*(ent__RegionalizationShippingRuleList*)p = *(ent__RegionalizationShippingRuleList*)q;
}

void ent__RegionalizationRegionStatusList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationRegionStatusList::__sizestatus = 0;
	this->ent__RegionalizationRegionStatusList::status = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__RegionalizationRegionStatusList::soap_serialize(struct soap *soap) const
{
	if(this->ent__RegionalizationRegionStatusList::status) {
		for(int i = 0; i < this->ent__RegionalizationRegionStatusList::__sizestatus; i++) {
			soap_serialize_PointerToent__RegionalizationRegionStatus(soap, this->ent__RegionalizationRegionStatusList::status + i);
		}
	}
	/* transient soap skipped */
}

int ent__RegionalizationRegionStatusList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationRegionStatusList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationRegionStatusList(struct soap *soap, const char *tag, int id, const ent__RegionalizationRegionStatusList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationRegionStatusList), "ent:RegionalizationRegionStatusList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__RegionalizationRegionStatusList::status) {
		int i;
		for(i = 0; i < a->ent__RegionalizationRegionStatusList::__sizestatus; i++)
			if(soap_out_PointerToent__RegionalizationRegionStatus(soap, "ent:status", -1, a->ent__RegionalizationRegionStatusList::status + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationRegionStatusList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationRegionStatusList(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatusList * FASTCALL soap_in_ent__RegionalizationRegionStatusList(struct soap *soap, const char *tag, ent__RegionalizationRegionStatusList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationRegionStatusList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationRegionStatusList, sizeof(ent__RegionalizationRegionStatusList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationRegionStatusList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationRegionStatusList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_status1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:status", 1, NULL)) {
				if(a->ent__RegionalizationRegionStatusList::status == NULL) {
					if(soap_blist_status1 == NULL)
						soap_blist_status1 = soap_new_block(soap);
					a->ent__RegionalizationRegionStatusList::status = (ent__RegionalizationRegionStatus **)soap_push_block(soap, soap_blist_status1, sizeof(ent__RegionalizationRegionStatus *));
					if(a->ent__RegionalizationRegionStatusList::status == NULL)
						return NULL;
					*a->ent__RegionalizationRegionStatusList::status = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationRegionStatus(soap, "ent:status", a->ent__RegionalizationRegionStatusList::status, "ent:RegionalizationRegionStatus"))
				{	a->ent__RegionalizationRegionStatusList::__sizestatus++;
					a->ent__RegionalizationRegionStatusList::status = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationRegionStatusList::status)
			soap_pop_block(soap, soap_blist_status1);
		if(a->ent__RegionalizationRegionStatusList::__sizestatus)
			a->ent__RegionalizationRegionStatusList::status = (ent__RegionalizationRegionStatus **)soap_save_block(soap, soap_blist_status1, NULL, 1);
		else
		{	a->ent__RegionalizationRegionStatusList::status = NULL;
			if(soap_blist_status1)
				soap_end_block(soap, soap_blist_status1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationRegionStatusList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationRegionStatusList, 0, sizeof(ent__RegionalizationRegionStatusList), 0, soap_copy_ent__RegionalizationRegionStatusList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationRegionStatusList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationRegionStatusList);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationRegionStatusList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationRegionStatusList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationRegionStatusList(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatusList * SOAP_FMAC4 soap_get_ent__RegionalizationRegionStatusList(struct soap *soap, ent__RegionalizationRegionStatusList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationRegionStatusList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationRegionStatusList * FASTCALL soap_instantiate_ent__RegionalizationRegionStatusList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationRegionStatusList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationRegionStatusList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatusList);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationRegionStatusList));
		((ent__RegionalizationRegionStatusList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatusList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationRegionStatusList));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationRegionStatusList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationRegionStatusList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationRegionStatusList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationRegionStatusList %p -> %p\n", q, p));
	*(ent__RegionalizationRegionStatusList*)p = *(ent__RegionalizationRegionStatusList*)q;
}

void ent__RegionalizationConditionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationConditionList::__sizecondition = 0;
	this->ent__RegionalizationConditionList::condition = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__RegionalizationConditionList::soap_serialize(struct soap *soap) const
{
	if(this->ent__RegionalizationConditionList::condition) {
		for(int i = 0; i < this->ent__RegionalizationConditionList::__sizecondition; i++) {
			soap_serialize_PointerToent__RegionalizationCondition(soap, this->ent__RegionalizationConditionList::condition + i);
		}
	}
	/* transient soap skipped */
}

int ent__RegionalizationConditionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationConditionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationConditionList(struct soap *soap, const char *tag, int id, const ent__RegionalizationConditionList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationConditionList), "ent:RegionalizationConditionList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__RegionalizationConditionList::condition) {
		int i;
		for(i = 0; i < a->ent__RegionalizationConditionList::__sizecondition; i++)
			if(soap_out_PointerToent__RegionalizationCondition(soap, "ent:condition", -1, a->ent__RegionalizationConditionList::condition + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationConditionList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationConditionList(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationConditionList * FASTCALL soap_in_ent__RegionalizationConditionList(struct soap *soap, const char *tag, ent__RegionalizationConditionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationConditionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationConditionList, sizeof(ent__RegionalizationConditionList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationConditionList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationConditionList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_condition1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:condition", 1, NULL)) {
				if(a->ent__RegionalizationConditionList::condition == NULL) {
					if(soap_blist_condition1 == NULL)
						soap_blist_condition1 = soap_new_block(soap);
					a->ent__RegionalizationConditionList::condition = (ent__RegionalizationCondition **)soap_push_block(soap, soap_blist_condition1, sizeof(ent__RegionalizationCondition *));
					if(a->ent__RegionalizationConditionList::condition == NULL)
						return NULL;
					*a->ent__RegionalizationConditionList::condition = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationCondition(soap, "ent:condition", a->ent__RegionalizationConditionList::condition, "ent:RegionalizationCondition"))
				{	a->ent__RegionalizationConditionList::__sizecondition++;
					a->ent__RegionalizationConditionList::condition = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationConditionList::condition)
			soap_pop_block(soap, soap_blist_condition1);
		if(a->ent__RegionalizationConditionList::__sizecondition)
			a->ent__RegionalizationConditionList::condition = (ent__RegionalizationCondition **)soap_save_block(soap, soap_blist_condition1, NULL, 1);
		else
		{	a->ent__RegionalizationConditionList::condition = NULL;
			if(soap_blist_condition1)
				soap_end_block(soap, soap_blist_condition1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationConditionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationConditionList, 0, sizeof(ent__RegionalizationConditionList), 0, soap_copy_ent__RegionalizationConditionList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationConditionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationConditionList);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationConditionList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationConditionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationConditionList(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationConditionList * SOAP_FMAC4 soap_get_ent__RegionalizationConditionList(struct soap *soap, ent__RegionalizationConditionList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationConditionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationConditionList * FASTCALL soap_instantiate_ent__RegionalizationConditionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationConditionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationConditionList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationConditionList);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationConditionList));
		((ent__RegionalizationConditionList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationConditionList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationConditionList));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationConditionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationConditionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationConditionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationConditionList %p -> %p\n", q, p));
	*(ent__RegionalizationConditionList*)p = *(ent__RegionalizationConditionList*)q;
}

void ent__Area::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__Address::country = NULL;
	this->ent__Address::federalDistrict = NULL;
	this->ent__Address::region = NULL;
	this->ent__Address::district = NULL;
	this->ent__Address::locality = NULL;
	this->ent__Address::subLocality = NULL;
	this->ent__Address::street = NULL;
	soap_default_base__String255(soap, &this->ent__Address::house);
	soap_default_base__String255(soap, &this->ent__Address::building);
	soap_default_base__String255(soap, &this->ent__Address::room);
	soap_default_base__String255(soap, &this->ent__Address::postIndex);
	soap_default_base__String255(soap, &this->ent__Address::postBox);
	this->ent__Address::additionalInfo = NULL;
	this->ent__Address::addressView = NULL;
	this->ent__Address::enAddressView = NULL;
	/* transient soap skipped */
}

void ent__Area::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Country(soap, &this->ent__Address::country);
	soap_serialize_PointerToent__FederalDistrict(soap, &this->ent__Address::federalDistrict);
	soap_serialize_PointerToent__Region(soap, &this->ent__Address::region);
	soap_serialize_PointerToent__District(soap, &this->ent__Address::district);
	soap_serialize_PointerToent__Locality(soap, &this->ent__Address::locality);
	soap_serialize_PointerToent__Locality(soap, &this->ent__Address::subLocality);
	soap_serialize_PointerToent__Street(soap, &this->ent__Address::street);
	soap_serialize_base__String255(soap, &this->ent__Address::house);
	soap_serialize_base__String255(soap, &this->ent__Address::building);
	soap_serialize_base__String255(soap, &this->ent__Address::room);
	soap_serialize_base__String255(soap, &this->ent__Address::postIndex);
	soap_serialize_base__String255(soap, &this->ent__Address::postBox);
	soap_serialize_PointerTobase__NText(soap, &this->ent__Address::additionalInfo);
	soap_serialize_PointerTobase__NText(soap, &this->ent__Address::addressView);
	soap_serialize_PointerTobase__NText(soap, &this->ent__Address::enAddressView);
	/* transient soap skipped */
}

int ent__Area::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Area(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Area(struct soap *soap, const char *tag, int id, const ent__Area *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Area), "ent:Area"))
		return soap->error;
	if(soap_out_PointerToent__Country(soap, "ent:country", -1, &(a->ent__Address::country), ""))
		return soap->error;
	if(soap_out_PointerToent__FederalDistrict(soap, "ent:federalDistrict", -1, &(a->ent__Address::federalDistrict), ""))
		return soap->error;
	if(soap_out_PointerToent__Region(soap, "ent:region", -1, &(a->ent__Address::region), ""))
		return soap->error;
	if(soap_out_PointerToent__District(soap, "ent:district", -1, &(a->ent__Address::district), ""))
		return soap->error;
	if(soap_out_PointerToent__Locality(soap, "ent:locality", -1, &(a->ent__Address::locality), ""))
		return soap->error;
	if(soap_out_PointerToent__Locality(soap, "ent:subLocality", -1, &(a->ent__Address::subLocality), ""))
		return soap->error;
	if(soap_out_PointerToent__Street(soap, "ent:street", -1, &(a->ent__Address::street), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:house", -1, &(a->ent__Address::house), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:building", -1, &(a->ent__Address::building), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:room", -1, &(a->ent__Address::room), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:postIndex", -1, &(a->ent__Address::postIndex), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:postBox", -1, &(a->ent__Address::postBox), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "ent:additionalInfo", -1, &(a->ent__Address::additionalInfo), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "ent:addressView", -1, &(a->ent__Address::addressView), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "ent:enAddressView", -1, &(a->ent__Address::enAddressView), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Area::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Area(soap, tag, this, type);
}

SOAP_FMAC3 ent__Area * FASTCALL soap_in_ent__Area(struct soap *soap, const char *tag, ent__Area *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Area *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Area, sizeof(ent__Area), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Area) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Area *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country2 = 1;
	size_t soap_flag_federalDistrict2 = 1;
	size_t soap_flag_region2 = 1;
	size_t soap_flag_district2 = 1;
	size_t soap_flag_locality2 = 1;
	size_t soap_flag_subLocality2 = 1;
	size_t soap_flag_street2 = 1;
	size_t soap_flag_house2 = 1;
	size_t soap_flag_building2 = 1;
	size_t soap_flag_room2 = 1;
	size_t soap_flag_postIndex2 = 1;
	size_t soap_flag_postBox2 = 1;
	size_t soap_flag_additionalInfo2 = 1;
	size_t soap_flag_addressView2 = 1;
	size_t soap_flag_enAddressView2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Country(soap, "ent:country", &(a->ent__Address::country), "ent:Country"))
				{	soap_flag_country2--;
					continue;
				}
			if(soap_flag_federalDistrict2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__FederalDistrict(soap, "ent:federalDistrict", &(a->ent__Address::federalDistrict), "ent:FederalDistrict"))
				{	soap_flag_federalDistrict2--;
					continue;
				}
			if(soap_flag_region2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Region(soap, "ent:region", &(a->ent__Address::region), "ent:Region"))
				{	soap_flag_region2--;
					continue;
				}
			if(soap_flag_district2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__District(soap, "ent:district", &(a->ent__Address::district), "ent:District"))
				{	soap_flag_district2--;
					continue;
				}
			if(soap_flag_locality2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Locality(soap, "ent:locality", &(a->ent__Address::locality), "ent:Locality"))
				{	soap_flag_locality2--;
					continue;
				}
			if(soap_flag_subLocality2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Locality(soap, "ent:subLocality", &(a->ent__Address::subLocality), "ent:Locality"))
				{	soap_flag_subLocality2--;
					continue;
				}
			if(soap_flag_street2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Street(soap, "ent:street", &(a->ent__Address::street), "ent:Street"))
				{	soap_flag_street2--;
					continue;
				}
			if(soap_flag_house2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:house", &(a->ent__Address::house), "base:String255"))
				{	soap_flag_house2--;
					continue;
				}
			if(soap_flag_building2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:building", &(a->ent__Address::building), "base:String255"))
				{	soap_flag_building2--;
					continue;
				}
			if(soap_flag_room2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:room", &(a->ent__Address::room), "base:String255"))
				{	soap_flag_room2--;
					continue;
				}
			if(soap_flag_postIndex2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:postIndex", &(a->ent__Address::postIndex), "base:String255"))
				{	soap_flag_postIndex2--;
					continue;
				}
			if(soap_flag_postBox2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:postBox", &(a->ent__Address::postBox), "base:String255"))
				{	soap_flag_postBox2--;
					continue;
				}
			if(soap_flag_additionalInfo2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:additionalInfo", &(a->ent__Address::additionalInfo), "base:NText"))
				{	soap_flag_additionalInfo2--;
					continue;
				}
			if(soap_flag_addressView2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:addressView", &(a->ent__Address::addressView), "base:NText"))
				{	soap_flag_addressView2--;
					continue;
				}
			if(soap_flag_enAddressView2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:enAddressView", &(a->ent__Address::enAddressView), "base:NText"))
				{	soap_flag_enAddressView2--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Area *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Area, 0, sizeof(ent__Area), 0, soap_copy_ent__Area);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Area::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Area);
	return this->soap_out(soap, tag?tag:"ent:Area", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Area::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Area(soap, this, tag, type);
}

SOAP_FMAC3 ent__Area * SOAP_FMAC4 soap_get_ent__Area(struct soap *soap, ent__Area *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Area * FASTCALL soap_instantiate_ent__Area(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Area(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Area, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Area);
		ASSIGN_PTR(size, sizeof(ent__Area));
		((ent__Area*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Area[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Area));
		for(int i = 0; i < n; i++)
			((ent__Area*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Area*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Area(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Area %p -> %p\n", q, p));
	*(ent__Area*)p = *(ent__Area*)q;
}

void ent__RegionalizationRegionStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationRegionStatus::referenceNumber = NULL;
	this->ent__RegionalizationRegionStatus::r13nZone = NULL;
	this->ent__RegionalizationRegionStatus::__sizeexcludedR13nZone = 0;
	this->ent__RegionalizationRegionStatus::excludedR13nZone = NULL;
	this->ent__RegionalizationRegionStatus::__sizer13nStatus = 0;
	this->ent__RegionalizationRegionStatus::r13nStatus = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__RegionalizationRegionStatus::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->ent__RegionalizationRegionStatus::referenceNumber);
	soap_serialize_PointerToent__Area(soap, &this->ent__RegionalizationRegionStatus::r13nZone);
	if(this->ent__RegionalizationRegionStatus::excludedR13nZone) {
		for(int i = 0; i < this->ent__RegionalizationRegionStatus::__sizeexcludedR13nZone; i++) {
			soap_serialize_PointerToent__Area(soap, this->ent__RegionalizationRegionStatus::excludedR13nZone + i);
		}
	}
	if(this->ent__RegionalizationRegionStatus::r13nStatus) {
		for(int i = 0; i < this->ent__RegionalizationRegionStatus::__sizer13nStatus; i++) {
			soap_serialize_PointerToent__RegionalizationStatus(soap, this->ent__RegionalizationRegionStatus::r13nStatus + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__RegionalizationRegionStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationRegionStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, const ent__RegionalizationRegionStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationRegionStatus), "ent:RegionalizationRegionStatus"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "ent:referenceNumber", -1, &(a->ent__RegionalizationRegionStatus::referenceNumber), ""))
		return soap->error;
	if(soap_out_PointerToent__Area(soap, "ent:r13nZone", -1, &(a->ent__RegionalizationRegionStatus::r13nZone), ""))
		return soap->error;
	if(a->ent__RegionalizationRegionStatus::excludedR13nZone) {
		int i;
		for(i = 0; i < a->ent__RegionalizationRegionStatus::__sizeexcludedR13nZone; i++)
			if(soap_out_PointerToent__Area(soap, "ent:excludedR13nZone", -1, a->ent__RegionalizationRegionStatus::excludedR13nZone + i, ""))
				return soap->error;
	}
	if(a->ent__RegionalizationRegionStatus::r13nStatus) {
		int i;
		for(i = 0; i < a->ent__RegionalizationRegionStatus::__sizer13nStatus; i++)
			if(soap_out_PointerToent__RegionalizationStatus(soap, "ent:r13nStatus", -1, a->ent__RegionalizationRegionStatus::r13nStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationRegionStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationRegionStatus(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatus * FASTCALL soap_in_ent__RegionalizationRegionStatus(struct soap *soap, const char *tag, ent__RegionalizationRegionStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationRegionStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationRegionStatus, sizeof(ent__RegionalizationRegionStatus), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationRegionStatus) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationRegionStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_r13nZone1 = 1;
	struct soap_blist *soap_blist_excludedR13nZone1 = NULL;
	struct soap_blist *soap_blist_r13nStatus1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "ent:referenceNumber", &(a->ent__RegionalizationRegionStatus::referenceNumber), "base:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_r13nZone1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Area(soap, "ent:r13nZone", &(a->ent__RegionalizationRegionStatus::r13nZone), "ent:Area"))
				{	soap_flag_r13nZone1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:excludedR13nZone", 1, NULL)) {
				if(a->ent__RegionalizationRegionStatus::excludedR13nZone == NULL) {
					if(soap_blist_excludedR13nZone1 == NULL)
						soap_blist_excludedR13nZone1 = soap_new_block(soap);
					a->ent__RegionalizationRegionStatus::excludedR13nZone = (ent__Area **)soap_push_block(soap, soap_blist_excludedR13nZone1, sizeof(ent__Area *));
					if(a->ent__RegionalizationRegionStatus::excludedR13nZone == NULL)
						return NULL;
					*a->ent__RegionalizationRegionStatus::excludedR13nZone = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Area(soap, "ent:excludedR13nZone", a->ent__RegionalizationRegionStatus::excludedR13nZone, "ent:Area"))
				{	a->ent__RegionalizationRegionStatus::__sizeexcludedR13nZone++;
					a->ent__RegionalizationRegionStatus::excludedR13nZone = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:r13nStatus", 1, NULL)) {
				if(a->ent__RegionalizationRegionStatus::r13nStatus == NULL) {
					if(soap_blist_r13nStatus1 == NULL)
						soap_blist_r13nStatus1 = soap_new_block(soap);
					a->ent__RegionalizationRegionStatus::r13nStatus = (ent__RegionalizationStatus **)soap_push_block(soap, soap_blist_r13nStatus1, sizeof(ent__RegionalizationStatus *));
					if(a->ent__RegionalizationRegionStatus::r13nStatus == NULL)
						return NULL;
					*a->ent__RegionalizationRegionStatus::r13nStatus = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationStatus(soap, "ent:r13nStatus", a->ent__RegionalizationRegionStatus::r13nStatus, "ent:RegionalizationStatus"))
				{	a->ent__RegionalizationRegionStatus::__sizer13nStatus++;
					a->ent__RegionalizationRegionStatus::r13nStatus = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationRegionStatus::excludedR13nZone)
			soap_pop_block(soap, soap_blist_excludedR13nZone1);
		if(a->ent__RegionalizationRegionStatus::__sizeexcludedR13nZone)
			a->ent__RegionalizationRegionStatus::excludedR13nZone = (ent__Area **)soap_save_block(soap, soap_blist_excludedR13nZone1, NULL, 1);
		else
		{	a->ent__RegionalizationRegionStatus::excludedR13nZone = NULL;
			if(soap_blist_excludedR13nZone1)
				soap_end_block(soap, soap_blist_excludedR13nZone1);
		}
		if(a->ent__RegionalizationRegionStatus::r13nStatus)
			soap_pop_block(soap, soap_blist_r13nStatus1);
		if(a->ent__RegionalizationRegionStatus::__sizer13nStatus)
			a->ent__RegionalizationRegionStatus::r13nStatus = (ent__RegionalizationStatus **)soap_save_block(soap, soap_blist_r13nStatus1, NULL, 1);
		else
		{	a->ent__RegionalizationRegionStatus::r13nStatus = NULL;
			if(soap_blist_r13nStatus1)
				soap_end_block(soap, soap_blist_r13nStatus1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationRegionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationRegionStatus, 0, sizeof(ent__RegionalizationRegionStatus), 0, soap_copy_ent__RegionalizationRegionStatus);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationRegionStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationRegionStatus);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationRegionStatus", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationRegionStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationRegionStatus(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatus * SOAP_FMAC4 soap_get_ent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationRegionStatus * FASTCALL soap_instantiate_ent__RegionalizationRegionStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationRegionStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationRegionStatus, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatus);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationRegionStatus));
		((ent__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatus[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationRegionStatus));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationRegionStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationRegionStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationRegionStatus %p -> %p\n", q, p));
	*(ent__RegionalizationRegionStatus*)p = *(ent__RegionalizationRegionStatus*)q;
}

void ent__RegionalizationStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationStatus::relatedDisease = NULL;
	soap_default_ent__ProsperityType(soap, &this->ent__RegionalizationStatus::prosperity);
	soap_default_ent__VaccinationType(soap, &this->ent__RegionalizationStatus::vaccination);
	/* transient soap skipped */
}

void ent__RegionalizationStatus::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDisease(soap, &this->ent__RegionalizationStatus::relatedDisease);
	/* transient soap skipped */
}

int ent__RegionalizationStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationStatus(struct soap *soap, const char *tag, int id, const ent__RegionalizationStatus *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationStatus), type))
		return soap->error;
	if(a->ent__RegionalizationStatus::relatedDisease) {
		if(soap_out_PointerToent__AnimalDisease(soap, "ent:relatedDisease", -1, &a->ent__RegionalizationStatus::relatedDisease, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:relatedDisease"))
		return soap->error;
	if(soap_out_ent__ProsperityType(soap, "ent:prosperity", -1, &(a->ent__RegionalizationStatus::prosperity), ""))
		return soap->error;
	if(soap_out_ent__VaccinationType(soap, "ent:vaccination", -1, &(a->ent__RegionalizationStatus::vaccination), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationStatus(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationStatus * FASTCALL soap_in_ent__RegionalizationStatus(struct soap *soap, const char *tag, ent__RegionalizationStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationStatus, sizeof(ent__RegionalizationStatus), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationStatus) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_relatedDisease1 = 1;
	size_t soap_flag_prosperity1 = 1;
	size_t soap_flag_vaccination1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_relatedDisease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:relatedDisease", &(a->ent__RegionalizationStatus::relatedDisease), "ent:AnimalDisease"))
				{	soap_flag_relatedDisease1--;
					continue;
				}
			if(soap_flag_prosperity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__ProsperityType(soap, "ent:prosperity", &(a->ent__RegionalizationStatus::prosperity), "ent:ProsperityType"))
				{	soap_flag_prosperity1--;
					continue;
				}
			if(soap_flag_vaccination1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__VaccinationType(soap, "ent:vaccination", &(a->ent__RegionalizationStatus::vaccination), "ent:VaccinationType"))
				{	soap_flag_vaccination1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationStatus, 0, sizeof(ent__RegionalizationStatus), 0, soap_copy_ent__RegionalizationStatus);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_relatedDisease1 > 0 || soap_flag_prosperity1 > 0 || soap_flag_vaccination1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__RegionalizationStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationStatus);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationStatus", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationStatus(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationStatus * SOAP_FMAC4 soap_get_ent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationStatus * FASTCALL soap_instantiate_ent__RegionalizationStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationStatus, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationStatus);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationStatus));
		((ent__RegionalizationStatus*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationStatus[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationStatus));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationStatus %p -> %p\n", q, p));
	*(ent__RegionalizationStatus*)p = *(ent__RegionalizationStatus*)q;
}

void ent__RegionalizationShippingRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationShippingRule::referenceNumber = NULL;
	this->ent__RegionalizationShippingRule::fromR13nStatus = NULL;
	this->ent__RegionalizationShippingRule::toR13nStatus = NULL;
	this->ent__RegionalizationShippingRule::__sizecargoType = 0;
	this->ent__RegionalizationShippingRule::cargoType = NULL;
	this->ent__RegionalizationShippingRule::decision = NULL;
	this->ent__RegionalizationShippingRule::__sizerequirement = 0;
	this->ent__RegionalizationShippingRule::requirement = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__RegionalizationShippingRule::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->ent__RegionalizationShippingRule::referenceNumber);
	soap_serialize_PointerToent__RegionalizationStatus(soap, &this->ent__RegionalizationShippingRule::fromR13nStatus);
	soap_serialize_PointerToent__RegionalizationStatus(soap, &this->ent__RegionalizationShippingRule::toR13nStatus);
	if(this->ent__RegionalizationShippingRule::cargoType) {
		for(int i = 0; i < this->ent__RegionalizationShippingRule::__sizecargoType; i++) {
			soap_serialize_PointerToent__SubProduct(soap, this->ent__RegionalizationShippingRule::cargoType + i);
		}
	}
	soap_serialize_PointerToent__RegionalizationDecision(soap, &this->ent__RegionalizationShippingRule::decision);
	if(this->ent__RegionalizationShippingRule::requirement) {
		for(int i = 0; i < this->ent__RegionalizationShippingRule::__sizerequirement; i++) {
			soap_serialize_PointerToent__RegionalizationRequirement(soap, this->ent__RegionalizationShippingRule::requirement + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__RegionalizationShippingRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationShippingRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, const ent__RegionalizationShippingRule *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationShippingRule), "ent:RegionalizationShippingRule"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "ent:referenceNumber", -1, &(a->ent__RegionalizationShippingRule::referenceNumber), ""))
		return soap->error;
	if(soap_out_PointerToent__RegionalizationStatus(soap, "ent:fromR13nStatus", -1, &(a->ent__RegionalizationShippingRule::fromR13nStatus), ""))
		return soap->error;
	if(soap_out_PointerToent__RegionalizationStatus(soap, "ent:toR13nStatus", -1, &(a->ent__RegionalizationShippingRule::toR13nStatus), ""))
		return soap->error;
	if(a->ent__RegionalizationShippingRule::cargoType) {
		int i;
		for(i = 0; i < a->ent__RegionalizationShippingRule::__sizecargoType; i++)
			if(soap_out_PointerToent__SubProduct(soap, "ent:cargoType", -1, a->ent__RegionalizationShippingRule::cargoType + i, ""))
				return soap->error;
	}
	if(soap_out_PointerToent__RegionalizationDecision(soap, "ent:decision", -1, &(a->ent__RegionalizationShippingRule::decision), ""))
		return soap->error;
	if(a->ent__RegionalizationShippingRule::requirement) {
		int i;
		for(i = 0; i < a->ent__RegionalizationShippingRule::__sizerequirement; i++)
			if(soap_out_PointerToent__RegionalizationRequirement(soap, "ent:requirement", -1, a->ent__RegionalizationShippingRule::requirement + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationShippingRule::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationShippingRule(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRule * FASTCALL soap_in_ent__RegionalizationShippingRule(struct soap *soap, const char *tag, ent__RegionalizationShippingRule *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationShippingRule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationShippingRule, sizeof(ent__RegionalizationShippingRule), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationShippingRule) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationShippingRule *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_fromR13nStatus1 = 1;
	size_t soap_flag_toR13nStatus1 = 1;
	struct soap_blist *soap_blist_cargoType1 = NULL;
	size_t soap_flag_decision1 = 1;
	struct soap_blist *soap_blist_requirement1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "ent:referenceNumber", &(a->ent__RegionalizationShippingRule::referenceNumber), "base:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_fromR13nStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationStatus(soap, "ent:fromR13nStatus", &(a->ent__RegionalizationShippingRule::fromR13nStatus), "ent:RegionalizationStatus"))
				{	soap_flag_fromR13nStatus1--;
					continue;
				}
			if(soap_flag_toR13nStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationStatus(soap, "ent:toR13nStatus", &(a->ent__RegionalizationShippingRule::toR13nStatus), "ent:RegionalizationStatus"))
				{	soap_flag_toR13nStatus1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:cargoType", 1, NULL)) {
				if(a->ent__RegionalizationShippingRule::cargoType == NULL) {
					if(soap_blist_cargoType1 == NULL)
						soap_blist_cargoType1 = soap_new_block(soap);
					a->ent__RegionalizationShippingRule::cargoType = (ent__SubProduct **)soap_push_block(soap, soap_blist_cargoType1, sizeof(ent__SubProduct *));
					if(a->ent__RegionalizationShippingRule::cargoType == NULL)
						return NULL;
					*a->ent__RegionalizationShippingRule::cargoType = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__SubProduct(soap, "ent:cargoType", a->ent__RegionalizationShippingRule::cargoType, "ent:SubProduct"))
				{	a->ent__RegionalizationShippingRule::__sizecargoType++;
					a->ent__RegionalizationShippingRule::cargoType = NULL;
					continue;
				}
			}
			if(soap_flag_decision1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__RegionalizationDecision(soap, "ent:decision", &(a->ent__RegionalizationShippingRule::decision), "ent:RegionalizationDecision"))
				{	soap_flag_decision1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:requirement", 1, NULL)) {
				if(a->ent__RegionalizationShippingRule::requirement == NULL) {
					if(soap_blist_requirement1 == NULL)
						soap_blist_requirement1 = soap_new_block(soap);
					a->ent__RegionalizationShippingRule::requirement = (ent__RegionalizationRequirement **)soap_push_block(soap, soap_blist_requirement1, sizeof(ent__RegionalizationRequirement *));
					if(a->ent__RegionalizationShippingRule::requirement == NULL)
						return NULL;
					*a->ent__RegionalizationShippingRule::requirement = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationRequirement(soap, "ent:requirement", a->ent__RegionalizationShippingRule::requirement, "ent:RegionalizationRequirement"))
				{	a->ent__RegionalizationShippingRule::__sizerequirement++;
					a->ent__RegionalizationShippingRule::requirement = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationShippingRule::cargoType)
			soap_pop_block(soap, soap_blist_cargoType1);
		if(a->ent__RegionalizationShippingRule::__sizecargoType)
			a->ent__RegionalizationShippingRule::cargoType = (ent__SubProduct **)soap_save_block(soap, soap_blist_cargoType1, NULL, 1);
		else
		{	a->ent__RegionalizationShippingRule::cargoType = NULL;
			if(soap_blist_cargoType1)
				soap_end_block(soap, soap_blist_cargoType1);
		}
		if(a->ent__RegionalizationShippingRule::requirement)
			soap_pop_block(soap, soap_blist_requirement1);
		if(a->ent__RegionalizationShippingRule::__sizerequirement)
			a->ent__RegionalizationShippingRule::requirement = (ent__RegionalizationRequirement **)soap_save_block(soap, soap_blist_requirement1, NULL, 1);
		else
		{	a->ent__RegionalizationShippingRule::requirement = NULL;
			if(soap_blist_requirement1)
				soap_end_block(soap, soap_blist_requirement1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationShippingRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationShippingRule, 0, sizeof(ent__RegionalizationShippingRule), 0, soap_copy_ent__RegionalizationShippingRule);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationShippingRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationShippingRule);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationShippingRule", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationShippingRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationShippingRule(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRule * SOAP_FMAC4 soap_get_ent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationShippingRule * FASTCALL soap_instantiate_ent__RegionalizationShippingRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationShippingRule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationShippingRule, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRule);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationShippingRule));
		((ent__RegionalizationShippingRule*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRule[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationShippingRule));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationShippingRule*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationShippingRule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationShippingRule %p -> %p\n", q, p));
	*(ent__RegionalizationShippingRule*)p = *(ent__RegionalizationShippingRule*)q;
}

void ent__RegionalizationRequirement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationRequirement::relatedDisease = NULL;
	soap_default_ent__RegionalizationDecision(soap, &this->ent__RegionalizationRequirement::type);
	this->ent__RegionalizationRequirement::__sizeconditionGroup = 0;
	this->ent__RegionalizationRequirement::conditionGroup = NULL;
	/* transient soap skipped */
}

void ent__RegionalizationRequirement::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__AnimalDisease(soap, &this->ent__RegionalizationRequirement::relatedDisease);
	soap_embedded(soap, &this->ent__RegionalizationRequirement::type, SOAP_TYPE_ent__RegionalizationDecision);
	if(this->ent__RegionalizationRequirement::conditionGroup) {
		for(int i = 0; i < this->ent__RegionalizationRequirement::__sizeconditionGroup; i++) {
			soap_serialize_PointerToent__RegionalizationConditionGroup(soap, this->ent__RegionalizationRequirement::conditionGroup + i);
		}
	}
	/* transient soap skipped */
}

int ent__RegionalizationRequirement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationRequirement(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationRequirement(struct soap *soap, const char *tag, int id, const ent__RegionalizationRequirement *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationRequirement), type))
		return soap->error;
	if(soap_out_PointerToent__AnimalDisease(soap, "ent:relatedDisease", -1, &(a->ent__RegionalizationRequirement::relatedDisease), ""))
		return soap->error;
	if(soap_out_ent__RegionalizationDecision(soap, "ent:type", -1, &(a->ent__RegionalizationRequirement::type), ""))
		return soap->error;
	if(a->ent__RegionalizationRequirement::conditionGroup) {
		int i;
		for(i = 0; i < a->ent__RegionalizationRequirement::__sizeconditionGroup; i++)
			if(soap_out_PointerToent__RegionalizationConditionGroup(soap, "ent:conditionGroup", -1, a->ent__RegionalizationRequirement::conditionGroup + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationRequirement::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationRequirement(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationRequirement * FASTCALL soap_in_ent__RegionalizationRequirement(struct soap *soap, const char *tag, ent__RegionalizationRequirement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationRequirement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationRequirement, sizeof(ent__RegionalizationRequirement), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationRequirement) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationRequirement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_relatedDisease1 = 1;
	size_t soap_flag_type1 = 1;
	struct soap_blist *soap_blist_conditionGroup1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_relatedDisease1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:relatedDisease", &(a->ent__RegionalizationRequirement::relatedDisease), "ent:AnimalDisease"))
				{	soap_flag_relatedDisease1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__RegionalizationDecision(soap, "ent:type", &(a->ent__RegionalizationRequirement::type), "ent:RegionalizationDecision"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:conditionGroup", 1, NULL)) {
				if(a->ent__RegionalizationRequirement::conditionGroup == NULL) {
					if(soap_blist_conditionGroup1 == NULL)
						soap_blist_conditionGroup1 = soap_new_block(soap);
					a->ent__RegionalizationRequirement::conditionGroup = (ent__RegionalizationConditionGroup **)soap_push_block(soap, soap_blist_conditionGroup1, sizeof(ent__RegionalizationConditionGroup *));
					if(a->ent__RegionalizationRequirement::conditionGroup == NULL)
						return NULL;
					*a->ent__RegionalizationRequirement::conditionGroup = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationConditionGroup(soap, "ent:conditionGroup", a->ent__RegionalizationRequirement::conditionGroup, "ent:RegionalizationConditionGroup"))
				{	a->ent__RegionalizationRequirement::__sizeconditionGroup++;
					a->ent__RegionalizationRequirement::conditionGroup = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationRequirement::conditionGroup)
			soap_pop_block(soap, soap_blist_conditionGroup1);
		if(a->ent__RegionalizationRequirement::__sizeconditionGroup)
			a->ent__RegionalizationRequirement::conditionGroup = (ent__RegionalizationConditionGroup **)soap_save_block(soap, soap_blist_conditionGroup1, NULL, 1);
		else
		{	a->ent__RegionalizationRequirement::conditionGroup = NULL;
			if(soap_blist_conditionGroup1)
				soap_end_block(soap, soap_blist_conditionGroup1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationRequirement, 0, sizeof(ent__RegionalizationRequirement), 0, soap_copy_ent__RegionalizationRequirement);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__RegionalizationRequirement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationRequirement);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationRequirement", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationRequirement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationRequirement(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationRequirement * SOAP_FMAC4 soap_get_ent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationRequirement * FASTCALL soap_instantiate_ent__RegionalizationRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationRequirement, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRequirement);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationRequirement));
		((ent__RegionalizationRequirement*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRequirement[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationRequirement));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationRequirement*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationRequirement %p -> %p\n", q, p));
	*(ent__RegionalizationRequirement*)p = *(ent__RegionalizationRequirement*)q;
}

void ent__RegionalizationConditionGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationConditionGroup::__sizecondition = 0;
	this->ent__RegionalizationConditionGroup::condition = NULL;
	/* transient soap skipped */
}

void ent__RegionalizationConditionGroup::soap_serialize(struct soap *soap) const
{
	if(this->ent__RegionalizationConditionGroup::condition) {
		for(int i = 0; i < this->ent__RegionalizationConditionGroup::__sizecondition; i++) {
			soap_serialize_PointerToent__RegionalizationCondition(soap, this->ent__RegionalizationConditionGroup::condition + i);
		}
	}
	/* transient soap skipped */
}

int ent__RegionalizationConditionGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationConditionGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, const ent__RegionalizationConditionGroup *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationConditionGroup), type))
		return soap->error;
	if(a->ent__RegionalizationConditionGroup::condition) {
		int i;
		for(i = 0; i < a->ent__RegionalizationConditionGroup::__sizecondition; i++)
			if(soap_out_PointerToent__RegionalizationCondition(soap, "ent:condition", -1, a->ent__RegionalizationConditionGroup::condition + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationConditionGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationConditionGroup(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationConditionGroup * FASTCALL soap_in_ent__RegionalizationConditionGroup(struct soap *soap, const char *tag, ent__RegionalizationConditionGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationConditionGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationConditionGroup, sizeof(ent__RegionalizationConditionGroup), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationConditionGroup) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationConditionGroup *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_condition1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:condition", 1, NULL)) {
				if(a->ent__RegionalizationConditionGroup::condition == NULL) {
					if(soap_blist_condition1 == NULL)
						soap_blist_condition1 = soap_new_block(soap);
					a->ent__RegionalizationConditionGroup::condition = (ent__RegionalizationCondition **)soap_push_block(soap, soap_blist_condition1, sizeof(ent__RegionalizationCondition *));
					if(a->ent__RegionalizationConditionGroup::condition == NULL)
						return NULL;
					*a->ent__RegionalizationConditionGroup::condition = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__RegionalizationCondition(soap, "ent:condition", a->ent__RegionalizationConditionGroup::condition, "ent:RegionalizationCondition"))
				{	a->ent__RegionalizationConditionGroup::__sizecondition++;
					a->ent__RegionalizationConditionGroup::condition = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationConditionGroup::condition)
			soap_pop_block(soap, soap_blist_condition1);
		if(a->ent__RegionalizationConditionGroup::__sizecondition)
			a->ent__RegionalizationConditionGroup::condition = (ent__RegionalizationCondition **)soap_save_block(soap, soap_blist_condition1, NULL, 1);
		else
		{	a->ent__RegionalizationConditionGroup::condition = NULL;
			if(soap_blist_condition1)
				soap_end_block(soap, soap_blist_condition1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationConditionGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationConditionGroup, 0, sizeof(ent__RegionalizationConditionGroup), 0, soap_copy_ent__RegionalizationConditionGroup);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationConditionGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationConditionGroup);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationConditionGroup", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationConditionGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationConditionGroup(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationConditionGroup * SOAP_FMAC4 soap_get_ent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationConditionGroup * FASTCALL soap_instantiate_ent__RegionalizationConditionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationConditionGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationConditionGroup, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationConditionGroup);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationConditionGroup));
		((ent__RegionalizationConditionGroup*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationConditionGroup[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationConditionGroup));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationConditionGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationConditionGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationConditionGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationConditionGroup %p -> %p\n", q, p));
	*(ent__RegionalizationConditionGroup*)p = *(ent__RegionalizationConditionGroup*)q;
}

void ent__RegionalizationCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionalizationCondition::referenceNumber = NULL;
	soap_default_base__Text(soap, &this->ent__RegionalizationCondition::text);
	this->ent__RegionalizationCondition::strict = NULL;
	this->ent__RegionalizationCondition::__sizerelatedDisease = 0;
	this->ent__RegionalizationCondition::relatedDisease = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__RegionalizationCondition::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->ent__RegionalizationCondition::referenceNumber);
	soap_serialize_base__Text(soap, &this->ent__RegionalizationCondition::text);
	soap_serialize_PointerTobool(soap, &this->ent__RegionalizationCondition::strict);
	if(this->ent__RegionalizationCondition::relatedDisease) {
		for(int i = 0; i < this->ent__RegionalizationCondition::__sizerelatedDisease; i++) {
			soap_serialize_PointerToent__AnimalDisease(soap, this->ent__RegionalizationCondition::relatedDisease + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__RegionalizationCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionalizationCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionalizationCondition(struct soap *soap, const char *tag, int id, const ent__RegionalizationCondition *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionalizationCondition), "ent:RegionalizationCondition"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "ent:referenceNumber", -1, &(a->ent__RegionalizationCondition::referenceNumber), ""))
		return soap->error;
	if(soap_out_base__Text(soap, "ent:text", -1, &(a->ent__RegionalizationCondition::text), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:strict", -1, &(a->ent__RegionalizationCondition::strict), ""))
		return soap->error;
	if(a->ent__RegionalizationCondition::relatedDisease) {
		int i;
		for(i = 0; i < a->ent__RegionalizationCondition::__sizerelatedDisease; i++)
			if(soap_out_PointerToent__AnimalDisease(soap, "ent:relatedDisease", -1, a->ent__RegionalizationCondition::relatedDisease + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionalizationCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionalizationCondition(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionalizationCondition * FASTCALL soap_in_ent__RegionalizationCondition(struct soap *soap, const char *tag, ent__RegionalizationCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionalizationCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionalizationCondition, sizeof(ent__RegionalizationCondition), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionalizationCondition) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionalizationCondition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_strict1 = 1;
	struct soap_blist *soap_blist_relatedDisease1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_referenceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "ent:referenceNumber", &(a->ent__RegionalizationCondition::referenceNumber), "base:Identifier"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if(soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Text(soap, "ent:text", &(a->ent__RegionalizationCondition::text), "base:Text"))
				{	soap_flag_text1--;
					continue;
				}
			if(soap_flag_strict1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:strict", &(a->ent__RegionalizationCondition::strict), "xsd:boolean"))
				{	soap_flag_strict1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:relatedDisease", 1, NULL)) {
				if(a->ent__RegionalizationCondition::relatedDisease == NULL) {
					if(soap_blist_relatedDisease1 == NULL)
						soap_blist_relatedDisease1 = soap_new_block(soap);
					a->ent__RegionalizationCondition::relatedDisease = (ent__AnimalDisease **)soap_push_block(soap, soap_blist_relatedDisease1, sizeof(ent__AnimalDisease *));
					if(a->ent__RegionalizationCondition::relatedDisease == NULL)
						return NULL;
					*a->ent__RegionalizationCondition::relatedDisease = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__AnimalDisease(soap, "ent:relatedDisease", a->ent__RegionalizationCondition::relatedDisease, "ent:AnimalDisease"))
				{	a->ent__RegionalizationCondition::__sizerelatedDisease++;
					a->ent__RegionalizationCondition::relatedDisease = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionalizationCondition::relatedDisease)
			soap_pop_block(soap, soap_blist_relatedDisease1);
		if(a->ent__RegionalizationCondition::__sizerelatedDisease)
			a->ent__RegionalizationCondition::relatedDisease = (ent__AnimalDisease **)soap_save_block(soap, soap_blist_relatedDisease1, NULL, 1);
		else
		{	a->ent__RegionalizationCondition::relatedDisease = NULL;
			if(soap_blist_relatedDisease1)
				soap_end_block(soap, soap_blist_relatedDisease1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionalizationCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionalizationCondition, 0, sizeof(ent__RegionalizationCondition), 0, soap_copy_ent__RegionalizationCondition);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionalizationCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionalizationCondition);
	return this->soap_out(soap, tag?tag:"ent:RegionalizationCondition", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionalizationCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionalizationCondition(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionalizationCondition * SOAP_FMAC4 soap_get_ent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionalizationCondition * FASTCALL soap_instantiate_ent__RegionalizationCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionalizationCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionalizationCondition, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationCondition);
		ASSIGN_PTR(size, sizeof(ent__RegionalizationCondition));
		((ent__RegionalizationCondition*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionalizationCondition[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionalizationCondition));
		for(int i = 0; i < n; i++)
			((ent__RegionalizationCondition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionalizationCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionalizationCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionalizationCondition %p -> %p\n", q, p));
	*(ent__RegionalizationCondition*)p = *(ent__RegionalizationCondition*)q;
}

void ent__MedicinalDrug::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__MedicinalDrug::ID = NULL;
	soap_default_base__String255(soap, &this->ent__MedicinalDrug::name);
	soap_default_base__String255(soap, &this->ent__MedicinalDrug::series);
	this->ent__MedicinalDrug::producer = NULL;
	/* transient soap skipped */
}

void ent__MedicinalDrug::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->ent__MedicinalDrug::ID);
	soap_serialize_base__String255(soap, &this->ent__MedicinalDrug::name);
	soap_serialize_base__String255(soap, &this->ent__MedicinalDrug::series);
	soap_serialize_PointerToent__BusinessMember(soap, &this->ent__MedicinalDrug::producer);
	/* transient soap skipped */
}

int ent__MedicinalDrug::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__MedicinalDrug(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__MedicinalDrug(struct soap *soap, const char *tag, int id, const ent__MedicinalDrug *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__MedicinalDrug), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "ent:ID", -1, &(a->ent__MedicinalDrug::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__MedicinalDrug::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:series", -1, &(a->ent__MedicinalDrug::series), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessMember(soap, "ent:producer", -1, &(a->ent__MedicinalDrug::producer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__MedicinalDrug::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__MedicinalDrug(soap, tag, this, type);
}

SOAP_FMAC3 ent__MedicinalDrug * FASTCALL soap_in_ent__MedicinalDrug(struct soap *soap, const char *tag, ent__MedicinalDrug *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__MedicinalDrug *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__MedicinalDrug, sizeof(ent__MedicinalDrug), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__MedicinalDrug) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__MedicinalDrug *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_series1 = 1;
	size_t soap_flag_producer1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "ent:ID", &(a->ent__MedicinalDrug::ID), "base:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__MedicinalDrug::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_series1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:series", &(a->ent__MedicinalDrug::series), "base:String255"))
				{	soap_flag_series1--;
					continue;
				}
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "ent:producer", &(a->ent__MedicinalDrug::producer), "ent:BusinessMember"))
				{	soap_flag_producer1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__MedicinalDrug *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__MedicinalDrug, 0, sizeof(ent__MedicinalDrug), 0, soap_copy_ent__MedicinalDrug);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__MedicinalDrug::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__MedicinalDrug);
	return this->soap_out(soap, tag?tag:"ent:MedicinalDrug", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__MedicinalDrug::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__MedicinalDrug(soap, this, tag, type);
}

SOAP_FMAC3 ent__MedicinalDrug * SOAP_FMAC4 soap_get_ent__MedicinalDrug(struct soap *soap, ent__MedicinalDrug *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__MedicinalDrug(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__MedicinalDrug * FASTCALL soap_instantiate_ent__MedicinalDrug(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__MedicinalDrug(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__MedicinalDrug, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__MedicinalDrug);
		ASSIGN_PTR(size, sizeof(ent__MedicinalDrug));
		((ent__MedicinalDrug*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__MedicinalDrug[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__MedicinalDrug));
		for(int i = 0; i < n; i++)
			((ent__MedicinalDrug*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__MedicinalDrug*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__MedicinalDrug(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__MedicinalDrug %p -> %p\n", q, p));
	*(ent__MedicinalDrug*)p = *(ent__MedicinalDrug*)q;
}

void ent__ResearchMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__ResearchMethod::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__ResearchMethod::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__ResearchMethod::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__ResearchMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ResearchMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ResearchMethod(struct soap *soap, const char *tag, int id, const ent__ResearchMethod *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ResearchMethod), "ent:ResearchMethod"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__ResearchMethod::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__ResearchMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ResearchMethod(soap, tag, this, type);
}

SOAP_FMAC3 ent__ResearchMethod * FASTCALL soap_in_ent__ResearchMethod(struct soap *soap, const char *tag, ent__ResearchMethod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ResearchMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ResearchMethod, sizeof(ent__ResearchMethod), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ResearchMethod) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ResearchMethod *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__ResearchMethod::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ResearchMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ResearchMethod, 0, sizeof(ent__ResearchMethod), 0, soap_copy_ent__ResearchMethod);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ResearchMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ResearchMethod);
	return this->soap_out(soap, tag?tag:"ent:ResearchMethod", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ResearchMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ResearchMethod(soap, this, tag, type);
}

SOAP_FMAC3 ent__ResearchMethod * SOAP_FMAC4 soap_get_ent__ResearchMethod(struct soap *soap, ent__ResearchMethod *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ResearchMethod * FASTCALL soap_instantiate_ent__ResearchMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ResearchMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ResearchMethod, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ResearchMethod);
		ASSIGN_PTR(size, sizeof(ent__ResearchMethod));
		((ent__ResearchMethod*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ResearchMethod[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ResearchMethod));
		for(int i = 0; i < n; i++)
			((ent__ResearchMethod*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ResearchMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ResearchMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ResearchMethod %p -> %p\n", q, p));
	*(ent__ResearchMethod*)p = *(ent__ResearchMethod*)q;
}

void ent__AnimalDisease::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__AnimalDisease::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__AnimalDisease::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__AnimalDisease::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__AnimalDisease::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__AnimalDisease(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__AnimalDisease(struct soap *soap, const char *tag, int id, const ent__AnimalDisease *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__AnimalDisease), "ent:AnimalDisease"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__AnimalDisease::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__AnimalDisease::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__AnimalDisease(soap, tag, this, type);
}

SOAP_FMAC3 ent__AnimalDisease * FASTCALL soap_in_ent__AnimalDisease(struct soap *soap, const char *tag, ent__AnimalDisease *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__AnimalDisease *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__AnimalDisease, sizeof(ent__AnimalDisease), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__AnimalDisease) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__AnimalDisease *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__AnimalDisease::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__AnimalDisease *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__AnimalDisease, 0, sizeof(ent__AnimalDisease), 0, soap_copy_ent__AnimalDisease);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__AnimalDisease::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__AnimalDisease);
	return this->soap_out(soap, tag?tag:"ent:AnimalDisease", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__AnimalDisease::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__AnimalDisease(soap, this, tag, type);
}

SOAP_FMAC3 ent__AnimalDisease * SOAP_FMAC4 soap_get_ent__AnimalDisease(struct soap *soap, ent__AnimalDisease *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__AnimalDisease * FASTCALL soap_instantiate_ent__AnimalDisease(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__AnimalDisease(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__AnimalDisease, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__AnimalDisease);
		ASSIGN_PTR(size, sizeof(ent__AnimalDisease));
		((ent__AnimalDisease*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__AnimalDisease[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__AnimalDisease));
		for(int i = 0; i < n; i++)
			((ent__AnimalDisease*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__AnimalDisease*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__AnimalDisease(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__AnimalDisease %p -> %p\n", q, p));
	*(ent__AnimalDisease*)p = *(ent__AnimalDisease*)q;
}

void ent__Indicator::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Indicator::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Indicator::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Indicator::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Indicator::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Indicator(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Indicator(struct soap *soap, const char *tag, int id, const ent__Indicator *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Indicator), "ent:Indicator"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Indicator::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Indicator::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Indicator(soap, tag, this, type);
}

SOAP_FMAC3 ent__Indicator * FASTCALL soap_in_ent__Indicator(struct soap *soap, const char *tag, ent__Indicator *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Indicator *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Indicator, sizeof(ent__Indicator), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Indicator) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Indicator *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Indicator::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Indicator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Indicator, 0, sizeof(ent__Indicator), 0, soap_copy_ent__Indicator);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Indicator::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Indicator);
	return this->soap_out(soap, tag?tag:"ent:Indicator", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Indicator::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Indicator(soap, this, tag, type);
}

SOAP_FMAC3 ent__Indicator * SOAP_FMAC4 soap_get_ent__Indicator(struct soap *soap, ent__Indicator *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Indicator(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Indicator * FASTCALL soap_instantiate_ent__Indicator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Indicator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Indicator, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Indicator);
		ASSIGN_PTR(size, sizeof(ent__Indicator));
		((ent__Indicator*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Indicator[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Indicator));
		for(int i = 0; i < n; i++)
			((ent__Indicator*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Indicator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Indicator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Indicator %p -> %p\n", q, p));
	*(ent__Indicator*)p = *(ent__Indicator*)q;
}

void ent__Organization::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__Organization::ID = NULL;
	soap_default_base__String255(soap, &this->ent__Organization::name);
	this->ent__Organization::address = NULL;
	/* transient soap skipped */
}

void ent__Organization::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__Identifier(soap, &this->ent__Organization::ID);
	soap_serialize_base__String255(soap, &this->ent__Organization::name);
	soap_serialize_PointerToent__Address(soap, &this->ent__Organization::address);
	/* transient soap skipped */
}

int ent__Organization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Organization(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Organization(struct soap *soap, const char *tag, int id, const ent__Organization *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Organization), type))
		return soap->error;
	if(soap_out_PointerTobase__Identifier(soap, "ent:ID", -1, &(a->ent__Organization::ID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Organization::name), ""))
		return soap->error;
	if(soap_out_PointerToent__Address(soap, "ent:address", -1, &(a->ent__Organization::address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Organization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Organization(soap, tag, this, type);
}

SOAP_FMAC3 ent__Organization * FASTCALL soap_in_ent__Organization(struct soap *soap, const char *tag, ent__Organization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Organization *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Organization, sizeof(ent__Organization), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Organization) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Organization *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Identifier(soap, "ent:ID", &(a->ent__Organization::ID), "base:Identifier"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Organization::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Address(soap, "ent:address", &(a->ent__Organization::address), "ent:Address"))
				{	soap_flag_address1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Organization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Organization, 0, sizeof(ent__Organization), 0, soap_copy_ent__Organization);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Organization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Organization);
	return this->soap_out(soap, tag?tag:"ent:Organization", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Organization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Organization(soap, this, tag, type);
}

SOAP_FMAC3 ent__Organization * SOAP_FMAC4 soap_get_ent__Organization(struct soap *soap, ent__Organization *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Organization(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Organization * FASTCALL soap_instantiate_ent__Organization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Organization(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Organization, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Organization);
		ASSIGN_PTR(size, sizeof(ent__Organization));
		((ent__Organization*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Organization[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Organization));
		for(int i = 0; i < n; i++)
			((ent__Organization*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Organization*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Organization(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Organization %p -> %p\n", q, p));
	*(ent__Organization*)p = *(ent__Organization*)q;
}

void ent__EnterpriseOfficialRegistration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ent__GRNType(soap, &this->ent__EnterpriseOfficialRegistration::ID);
	this->ent__EnterpriseOfficialRegistration::businessEntity = NULL;
	soap_default_base__String255(soap, &this->ent__EnterpriseOfficialRegistration::kpp);
	/* transient soap skipped */
}

void ent__EnterpriseOfficialRegistration::soap_serialize(struct soap *soap) const
{
	soap_serialize_ent__GRNType(soap, &this->ent__EnterpriseOfficialRegistration::ID);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->ent__EnterpriseOfficialRegistration::businessEntity);
	soap_serialize_base__String255(soap, &this->ent__EnterpriseOfficialRegistration::kpp);
	/* transient soap skipped */
}

int ent__EnterpriseOfficialRegistration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__EnterpriseOfficialRegistration(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, const ent__EnterpriseOfficialRegistration *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseOfficialRegistration), type))
		return soap->error;
	if(soap_out_ent__GRNType(soap, "ent:ID", -1, &(a->ent__EnterpriseOfficialRegistration::ID), ""))
		return soap->error;
	if(a->ent__EnterpriseOfficialRegistration::businessEntity) {
		if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &a->ent__EnterpriseOfficialRegistration::businessEntity, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:businessEntity"))
		return soap->error;
	if(a->ent__EnterpriseOfficialRegistration::kpp) {
		if(soap_out_base__String255(soap, "ent:kpp", -1, &a->ent__EnterpriseOfficialRegistration::kpp, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:kpp"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__EnterpriseOfficialRegistration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__EnterpriseOfficialRegistration(soap, tag, this, type);
}

SOAP_FMAC3 ent__EnterpriseOfficialRegistration * FASTCALL soap_in_ent__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, ent__EnterpriseOfficialRegistration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__EnterpriseOfficialRegistration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseOfficialRegistration, sizeof(ent__EnterpriseOfficialRegistration), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__EnterpriseOfficialRegistration) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__EnterpriseOfficialRegistration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_businessEntity1 = 1;
	size_t soap_flag_kpp1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__GRNType(soap, "ent:ID", &(a->ent__EnterpriseOfficialRegistration::ID), "ent:GRNType"))
				{	soap_flag_ID1--;
					continue;
				}
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->ent__EnterpriseOfficialRegistration::businessEntity), "ent:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap_flag_kpp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:kpp", &(a->ent__EnterpriseOfficialRegistration::kpp), "base:String255"))
				{	soap_flag_kpp1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__EnterpriseOfficialRegistration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseOfficialRegistration, 0, sizeof(ent__EnterpriseOfficialRegistration), 0, soap_copy_ent__EnterpriseOfficialRegistration);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_businessEntity1 > 0 || soap_flag_kpp1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__EnterpriseOfficialRegistration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseOfficialRegistration);
	return this->soap_out(soap, tag?tag:"ent:EnterpriseOfficialRegistration", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__EnterpriseOfficialRegistration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__EnterpriseOfficialRegistration(soap, this, tag, type);
}

SOAP_FMAC3 ent__EnterpriseOfficialRegistration * SOAP_FMAC4 soap_get_ent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__EnterpriseOfficialRegistration * FASTCALL soap_instantiate_ent__EnterpriseOfficialRegistration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__EnterpriseOfficialRegistration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__EnterpriseOfficialRegistration, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseOfficialRegistration);
		ASSIGN_PTR(size, sizeof(ent__EnterpriseOfficialRegistration));
		((ent__EnterpriseOfficialRegistration*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseOfficialRegistration[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__EnterpriseOfficialRegistration));
		for(int i = 0; i < n; i++)
			((ent__EnterpriseOfficialRegistration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__EnterpriseOfficialRegistration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__EnterpriseOfficialRegistration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__EnterpriseOfficialRegistration %p -> %p\n", q, p));
	*(ent__EnterpriseOfficialRegistration*)p = *(ent__EnterpriseOfficialRegistration*)q;
}

void ent__Location::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Location::name);
	this->ent__Location::address = NULL;
	/* transient soap skipped */
}

void ent__Location::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Location::name);
	soap_serialize_PointerToent__Address(soap, &this->ent__Location::address);
	/* transient soap skipped */
}

int ent__Location::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Location(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Location(struct soap *soap, const char *tag, int id, const ent__Location *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Location), type))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Location::name), ""))
		return soap->error;
	if(soap_out_PointerToent__Address(soap, "ent:address", -1, &(a->ent__Location::address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Location::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Location(soap, tag, this, type);
}

SOAP_FMAC3 ent__Location * FASTCALL soap_in_ent__Location(struct soap *soap, const char *tag, ent__Location *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Location *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Location, sizeof(ent__Location), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Location) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Location *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Location::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Address(soap, "ent:address", &(a->ent__Location::address), "ent:Address"))
				{	soap_flag_address1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Location *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Location, 0, sizeof(ent__Location), 0, soap_copy_ent__Location);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Location::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Location);
	return this->soap_out(soap, tag?tag:"ent:Location", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Location::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Location(soap, this, tag, type);
}

SOAP_FMAC3 ent__Location * SOAP_FMAC4 soap_get_ent__Location(struct soap *soap, ent__Location *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Location(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Location * FASTCALL soap_instantiate_ent__Location(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Location(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Location, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Location);
		ASSIGN_PTR(size, sizeof(ent__Location));
		((ent__Location*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Location[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Location));
		for(int i = 0; i < n; i++)
			((ent__Location*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Location*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Location(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Location %p -> %p\n", q, p));
	*(ent__Location*)p = *(ent__Location*)q;
}

void ent__Packaging::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__Packaging::packagingType = NULL;
	soap_default_xsd__integer(soap, &this->ent__Packaging::quantity);
	this->ent__Packaging::volume = NULL;
	this->ent__Packaging::unit = NULL;
	/* transient soap skipped */
}

void ent__Packaging::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__PackingType(soap, &this->ent__Packaging::packagingType);
	soap_serialize_xsd__integer(soap, &this->ent__Packaging::quantity);
	soap_serialize_PointerTobase__Decimal(soap, &this->ent__Packaging::volume);
	soap_serialize_PointerToent__Unit(soap, &this->ent__Packaging::unit);
	/* transient soap skipped */
}

int ent__Packaging::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Packaging(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Packaging(struct soap *soap, const char *tag, int id, const ent__Packaging *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Packaging), type))
		return soap->error;
	if(a->ent__Packaging::packagingType) {
		if(soap_out_PointerToent__PackingType(soap, "ent:packagingType", -1, &a->ent__Packaging::packagingType, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:packagingType"))
		return soap->error;
	if(soap_out_xsd__integer(soap, "ent:quantity", -1, &(a->ent__Packaging::quantity), ""))
		return soap->error;
	if(soap_out_PointerTobase__Decimal(soap, "ent:volume", -1, &(a->ent__Packaging::volume), ""))
		return soap->error;
	if(soap_out_PointerToent__Unit(soap, "ent:unit", -1, &(a->ent__Packaging::unit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Packaging::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Packaging(soap, tag, this, type);
}

SOAP_FMAC3 ent__Packaging * FASTCALL soap_in_ent__Packaging(struct soap *soap, const char *tag, ent__Packaging *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Packaging *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Packaging, sizeof(ent__Packaging), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Packaging) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Packaging *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_packagingType1 = 1;
	size_t soap_flag_quantity1 = 1;
	size_t soap_flag_volume1 = 1;
	size_t soap_flag_unit1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_packagingType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackingType(soap, "ent:packagingType", &(a->ent__Packaging::packagingType), "ent:PackingType"))
				{	soap_flag_packagingType1--;
					continue;
				}
			if(soap_flag_quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "ent:quantity", &(a->ent__Packaging::quantity), "xsd:integer"))
				{	soap_flag_quantity1--;
					continue;
				}
			if(soap_flag_volume1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__Decimal(soap, "ent:volume", &(a->ent__Packaging::volume), "base:Decimal"))
				{	soap_flag_volume1--;
					continue;
				}
			if(soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Unit(soap, "ent:unit", &(a->ent__Packaging::unit), "ent:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Packaging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Packaging, 0, sizeof(ent__Packaging), 0, soap_copy_ent__Packaging);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_packagingType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__Packaging::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Packaging);
	return this->soap_out(soap, tag?tag:"ent:Packaging", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Packaging::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Packaging(soap, this, tag, type);
}

SOAP_FMAC3 ent__Packaging * SOAP_FMAC4 soap_get_ent__Packaging(struct soap *soap, ent__Packaging *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Packaging(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Packaging * FASTCALL soap_instantiate_ent__Packaging(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Packaging(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Packaging, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Packaging);
		ASSIGN_PTR(size, sizeof(ent__Packaging));
		((ent__Packaging*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Packaging[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Packaging));
		for(int i = 0; i < n; i++)
			((ent__Packaging*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Packaging*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Packaging(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Packaging %p -> %p\n", q, p));
	*(ent__Packaging*)p = *(ent__Packaging*)q;
}

void ent__ProductItemProducing::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ProductItemProducing::location = NULL;
	/* transient soap skipped */
}

void ent__ProductItemProducing::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->ent__ProductItemProducing::location);
	/* transient soap skipped */
}

int ent__ProductItemProducing::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ProductItemProducing(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductItemProducing(struct soap *soap, const char *tag, int id, const ent__ProductItemProducing *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProductItemProducing), type))
		return soap->error;
	if(a->ent__ProductItemProducing::location) {
		if(soap_out_PointerToent__Enterprise(soap, "ent:location", -1, &a->ent__ProductItemProducing::location, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:location"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__ProductItemProducing::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ProductItemProducing(soap, tag, this, type);
}

SOAP_FMAC3 ent__ProductItemProducing * FASTCALL soap_in_ent__ProductItemProducing(struct soap *soap, const char *tag, ent__ProductItemProducing *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ProductItemProducing *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductItemProducing, sizeof(ent__ProductItemProducing), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ProductItemProducing) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ProductItemProducing *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_location1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_location1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:location", &(a->ent__ProductItemProducing::location), "ent:Enterprise"))
				{	soap_flag_location1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ProductItemProducing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProductItemProducing, 0, sizeof(ent__ProductItemProducing), 0, soap_copy_ent__ProductItemProducing);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_location1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__ProductItemProducing::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ProductItemProducing);
	return this->soap_out(soap, tag?tag:"ent:ProductItemProducing", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ProductItemProducing::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ProductItemProducing(soap, this, tag, type);
}

SOAP_FMAC3 ent__ProductItemProducing * SOAP_FMAC4 soap_get_ent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ProductItemProducing * FASTCALL soap_instantiate_ent__ProductItemProducing(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ProductItemProducing(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ProductItemProducing, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ProductItemProducing);
		ASSIGN_PTR(size, sizeof(ent__ProductItemProducing));
		((ent__ProductItemProducing*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ProductItemProducing[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ProductItemProducing));
		for(int i = 0; i < n; i++)
			((ent__ProductItemProducing*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ProductItemProducing*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ProductItemProducing(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ProductItemProducing %p -> %p\n", q, p));
	*(ent__ProductItemProducing*)p = *(ent__ProductItemProducing*)q;
}

void ent__ComplexDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ComplexDate::year = NULL;
	this->ent__ComplexDate::month = NULL;
	this->ent__ComplexDate::day = NULL;
	this->ent__ComplexDate::hour = NULL;
	this->ent__ComplexDate::minute = NULL;
	/* transient soap skipped */
}

void ent__ComplexDate::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Year(soap, &this->ent__ComplexDate::year);
	soap_serialize_PointerToent__Month(soap, &this->ent__ComplexDate::month);
	soap_serialize_PointerToent__Day(soap, &this->ent__ComplexDate::day);
	soap_serialize_PointerToent__Hour(soap, &this->ent__ComplexDate::hour);
	soap_serialize_PointerToent__Minute(soap, &this->ent__ComplexDate::minute);
	/* transient soap skipped */
}

int ent__ComplexDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ComplexDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ComplexDate(struct soap *soap, const char *tag, int id, const ent__ComplexDate *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ComplexDate), type))
		return soap->error;
	if(soap_out_PointerToent__Year(soap, "ent:year", -1, &(a->ent__ComplexDate::year), ""))
		return soap->error;
	if(soap_out_PointerToent__Month(soap, "ent:month", -1, &(a->ent__ComplexDate::month), ""))
		return soap->error;
	if(soap_out_PointerToent__Day(soap, "ent:day", -1, &(a->ent__ComplexDate::day), ""))
		return soap->error;
	if(soap_out_PointerToent__Hour(soap, "ent:hour", -1, &(a->ent__ComplexDate::hour), ""))
		return soap->error;
	if(soap_out_PointerToent__Minute(soap, "ent:minute", -1, &(a->ent__ComplexDate::minute), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__ComplexDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ComplexDate(soap, tag, this, type);
}

SOAP_FMAC3 ent__ComplexDate * FASTCALL soap_in_ent__ComplexDate(struct soap *soap, const char *tag, ent__ComplexDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ComplexDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ComplexDate, sizeof(ent__ComplexDate), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ComplexDate) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ComplexDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_year1 = 1;
	size_t soap_flag_month1 = 1;
	size_t soap_flag_day1 = 1;
	size_t soap_flag_hour1 = 1;
	size_t soap_flag_minute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_year1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Year(soap, "ent:year", &(a->ent__ComplexDate::year), "ent:Year"))
				{	soap_flag_year1--;
					continue;
				}
			if(soap_flag_month1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Month(soap, "ent:month", &(a->ent__ComplexDate::month), "ent:Month"))
				{	soap_flag_month1--;
					continue;
				}
			if(soap_flag_day1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Day(soap, "ent:day", &(a->ent__ComplexDate::day), "ent:Day"))
				{	soap_flag_day1--;
					continue;
				}
			if(soap_flag_hour1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Hour(soap, "ent:hour", &(a->ent__ComplexDate::hour), "ent:Hour"))
				{	soap_flag_hour1--;
					continue;
				}
			if(soap_flag_minute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Minute(soap, "ent:minute", &(a->ent__ComplexDate::minute), "ent:Minute"))
				{	soap_flag_minute1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ComplexDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ComplexDate, 0, sizeof(ent__ComplexDate), 0, soap_copy_ent__ComplexDate);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ComplexDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ComplexDate);
	return this->soap_out(soap, tag?tag:"ent:ComplexDate", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ComplexDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ComplexDate(soap, this, tag, type);
}

SOAP_FMAC3 ent__ComplexDate * SOAP_FMAC4 soap_get_ent__ComplexDate(struct soap *soap, ent__ComplexDate *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ComplexDate * FASTCALL soap_instantiate_ent__ComplexDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ComplexDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ComplexDate, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ComplexDate);
		ASSIGN_PTR(size, sizeof(ent__ComplexDate));
		((ent__ComplexDate*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ComplexDate[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ComplexDate));
		for(int i = 0; i < n; i++)
			((ent__ComplexDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ComplexDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ComplexDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ComplexDate %p -> %p\n", q, p));
	*(ent__ComplexDate*)p = *(ent__ComplexDate*)q;
}

void ent__PackageList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__PackageList::__sizepackage = 0;
	this->ent__PackageList::package = NULL;
	/* transient soap skipped */
}

void ent__PackageList::soap_serialize(struct soap *soap) const
{
	if(this->ent__PackageList::package) {
		for(int i = 0; i < this->ent__PackageList::__sizepackage; i++) {
			soap_serialize_PointerToent__Package(soap, this->ent__PackageList::package + i);
		}
	}
	/* transient soap skipped */
}

int ent__PackageList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__PackageList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__PackageList(struct soap *soap, const char *tag, int id, const ent__PackageList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__PackageList), type))
		return soap->error;
	if(a->ent__PackageList::package) {
		int i;
		for(i = 0; i < a->ent__PackageList::__sizepackage; i++)
			if(soap_out_PointerToent__Package(soap, "ent:package", -1, a->ent__PackageList::package + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__PackageList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__PackageList(soap, tag, this, type);
}

SOAP_FMAC3 ent__PackageList * FASTCALL soap_in_ent__PackageList(struct soap *soap, const char *tag, ent__PackageList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__PackageList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__PackageList, sizeof(ent__PackageList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__PackageList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__PackageList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_package1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:package", 1, NULL)) {
				if(a->ent__PackageList::package == NULL) {
					if(soap_blist_package1 == NULL)
						soap_blist_package1 = soap_new_block(soap);
					a->ent__PackageList::package = (ent__Package **)soap_push_block(soap, soap_blist_package1, sizeof(ent__Package *));
					if(a->ent__PackageList::package == NULL)
						return NULL;
					*a->ent__PackageList::package = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Package(soap, "ent:package", a->ent__PackageList::package, "ent:Package"))
				{	a->ent__PackageList::__sizepackage++;
					a->ent__PackageList::package = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__PackageList::package)
			soap_pop_block(soap, soap_blist_package1);
		if(a->ent__PackageList::__sizepackage)
			a->ent__PackageList::package = (ent__Package **)soap_save_block(soap, soap_blist_package1, NULL, 1);
		else
		{	a->ent__PackageList::package = NULL;
			if(soap_blist_package1)
				soap_end_block(soap, soap_blist_package1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__PackageList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__PackageList, 0, sizeof(ent__PackageList), 0, soap_copy_ent__PackageList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__PackageList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__PackageList);
	return this->soap_out(soap, tag?tag:"ent:PackageList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__PackageList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__PackageList(soap, this, tag, type);
}

SOAP_FMAC3 ent__PackageList * SOAP_FMAC4 soap_get_ent__PackageList(struct soap *soap, ent__PackageList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__PackageList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__PackageList * FASTCALL soap_instantiate_ent__PackageList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__PackageList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__PackageList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__PackageList);
		ASSIGN_PTR(size, sizeof(ent__PackageList));
		((ent__PackageList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__PackageList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__PackageList));
		for(int i = 0; i < n; i++)
			((ent__PackageList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__PackageList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__PackageList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__PackageList %p -> %p\n", q, p));
	*(ent__PackageList*)p = *(ent__PackageList*)q;
}

void ent__Package::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ent__PackageLevelType(soap, &this->ent__Package::level);
	this->ent__Package::packingType = NULL;
	soap_default_xsd__integer(soap, &this->ent__Package::quantity);
	this->ent__Package::__sizeproductMarks = 0;
	this->ent__Package::productMarks = NULL;
	/* transient soap skipped */
}

void ent__Package::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__PackingType(soap, &this->ent__Package::packingType);
	soap_serialize_xsd__integer(soap, &this->ent__Package::quantity);
	if(this->ent__Package::productMarks) {
		for(int i = 0; i < this->ent__Package::__sizeproductMarks; i++) {
			soap_serialize_PointerToent__ProductMarks(soap, this->ent__Package::productMarks + i);
		}
	}
	/* transient soap skipped */
}

int ent__Package::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Package(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Package(struct soap *soap, const char *tag, int id, const ent__Package *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Package), type))
		return soap->error;
	if(soap_out_ent__PackageLevelType(soap, "ent:level", -1, &(a->ent__Package::level), ""))
		return soap->error;
	if(a->ent__Package::packingType) {
		if(soap_out_PointerToent__PackingType(soap, "ent:packingType", -1, &a->ent__Package::packingType, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:packingType"))
		return soap->error;
	if(soap_out_xsd__integer(soap, "ent:quantity", -1, &(a->ent__Package::quantity), ""))
		return soap->error;
	if(a->ent__Package::productMarks) {
		int i;
		for(i = 0; i < a->ent__Package::__sizeproductMarks; i++)
			if(soap_out_PointerToent__ProductMarks(soap, "ent:productMarks", -1, a->ent__Package::productMarks + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Package::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Package(soap, tag, this, type);
}

SOAP_FMAC3 ent__Package * FASTCALL soap_in_ent__Package(struct soap *soap, const char *tag, ent__Package *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Package *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Package, sizeof(ent__Package), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Package) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Package *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_level1 = 1;
	size_t soap_flag_packingType1 = 1;
	size_t soap_flag_quantity1 = 1;
	struct soap_blist *soap_blist_productMarks1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_ent__PackageLevelType(soap, "ent:level", &(a->ent__Package::level), "ent:PackageLevelType"))
				{	soap_flag_level1--;
					continue;
				}
			if(soap_flag_packingType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackingType(soap, "ent:packingType", &(a->ent__Package::packingType), "ent:PackingType"))
				{	soap_flag_packingType1--;
					continue;
				}
			if(soap_flag_quantity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "ent:quantity", &(a->ent__Package::quantity), "xsd:integer"))
				{	soap_flag_quantity1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:productMarks", 1, NULL)) {
				if(a->ent__Package::productMarks == NULL) {
					if(soap_blist_productMarks1 == NULL)
						soap_blist_productMarks1 = soap_new_block(soap);
					a->ent__Package::productMarks = (ent__ProductMarks **)soap_push_block(soap, soap_blist_productMarks1, sizeof(ent__ProductMarks *));
					if(a->ent__Package::productMarks == NULL)
						return NULL;
					*a->ent__Package::productMarks = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__ProductMarks(soap, "ent:productMarks", a->ent__Package::productMarks, "ent:ProductMarks"))
				{	a->ent__Package::__sizeproductMarks++;
					a->ent__Package::productMarks = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__Package::productMarks)
			soap_pop_block(soap, soap_blist_productMarks1);
		if(a->ent__Package::__sizeproductMarks)
			a->ent__Package::productMarks = (ent__ProductMarks **)soap_save_block(soap, soap_blist_productMarks1, NULL, 1);
		else
		{	a->ent__Package::productMarks = NULL;
			if(soap_blist_productMarks1)
				soap_end_block(soap, soap_blist_productMarks1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Package *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Package, 0, sizeof(ent__Package), 0, soap_copy_ent__Package);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0 || soap_flag_packingType1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__Package::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Package);
	return this->soap_out(soap, tag?tag:"ent:Package", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Package::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Package(soap, this, tag, type);
}

SOAP_FMAC3 ent__Package * SOAP_FMAC4 soap_get_ent__Package(struct soap *soap, ent__Package *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Package * FASTCALL soap_instantiate_ent__Package(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Package(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Package, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Package);
		ASSIGN_PTR(size, sizeof(ent__Package));
		((ent__Package*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Package[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Package));
		for(int i = 0; i < n; i++)
			((ent__Package*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Package*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Package(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Package %p -> %p\n", q, p));
	*(ent__Package*)p = *(ent__Package*)q;
}

void ent__ProductMarks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__ProductMarks::__item);
	this->ent__ProductMarks::class_ = (enum ent__ProductMarkingClass)0;
	/* transient soap skipped */
}

void ent__ProductMarks::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__ProductMarks::__item);
	/* transient soap skipped */
}

int ent__ProductMarks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ProductMarks(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductMarks(struct soap *soap, const char *tag, int id, const ent__ProductMarks *a, const char *type)
{
	soap_set_attr(soap, "class", soap_ent__ProductMarkingClass2s(soap, ((ent__ProductMarks*)a)->class_), 1);
	return soap_out_base__String255(soap, tag, id, &a->ent__ProductMarks::__item, "");
}

void *ent__ProductMarks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ProductMarks(soap, tag, this, type);
}

SOAP_FMAC3 ent__ProductMarks * FASTCALL soap_in_ent__ProductMarks(struct soap *soap, const char *tag, ent__ProductMarks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (ent__ProductMarks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductMarks, sizeof(ent__ProductMarks), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ProductMarks)
			return (ent__ProductMarks *)a->soap_in(soap, tag, type);
	}
	if(soap_s2ent__ProductMarkingClass(soap, soap_attr_value(soap, "class", 0), &((ent__ProductMarks*)a)->class_))
		return NULL;
	if(!soap_in_base__String255(soap, tag, &(a->ent__ProductMarks::__item), "ent:ProductMarks"))
		return NULL;
	return a;
}

int ent__ProductMarks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ProductMarks);
	return this->soap_out(soap, tag?tag:"ent:ProductMarks", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ProductMarks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ProductMarks(soap, this, tag, type);
}

SOAP_FMAC3 ent__ProductMarks * SOAP_FMAC4 soap_get_ent__ProductMarks(struct soap *soap, ent__ProductMarks *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ProductMarks * FASTCALL soap_instantiate_ent__ProductMarks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ProductMarks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ProductMarks, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ProductMarks);
		ASSIGN_PTR(size, sizeof(ent__ProductMarks));
		((ent__ProductMarks*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ProductMarks[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ProductMarks));
		for(int i = 0; i < n; i++)
			((ent__ProductMarks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ProductMarks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ProductMarks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ProductMarks %p -> %p\n", q, p));
	*(ent__ProductMarks*)p = *(ent__ProductMarks*)q;
}

void ent__ProductItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ProductItemList::__sizeproductItem = 0;
	this->ent__ProductItemList::productItem = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__ProductItemList::soap_serialize(struct soap *soap) const
{
	if(this->ent__ProductItemList::productItem) {
		for(int i = 0; i < this->ent__ProductItemList::__sizeproductItem; i++) {
			soap_serialize_PointerToent__ProductItem(soap, this->ent__ProductItemList::productItem + i);
		}
	}
	/* transient soap skipped */
}

int ent__ProductItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ProductItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductItemList(struct soap *soap, const char *tag, int id, const ent__ProductItemList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProductItemList), "ent:ProductItemList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__ProductItemList::productItem) {
		int i;
		for(i = 0; i < a->ent__ProductItemList::__sizeproductItem; i++)
			if(soap_out_PointerToent__ProductItem(soap, "ent:productItem", -1, a->ent__ProductItemList::productItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__ProductItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ProductItemList(soap, tag, this, type);
}

SOAP_FMAC3 ent__ProductItemList * FASTCALL soap_in_ent__ProductItemList(struct soap *soap, const char *tag, ent__ProductItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ProductItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductItemList, sizeof(ent__ProductItemList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ProductItemList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ProductItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_productItem1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:productItem", 1, NULL)) {
				if(a->ent__ProductItemList::productItem == NULL) {
					if(soap_blist_productItem1 == NULL)
						soap_blist_productItem1 = soap_new_block(soap);
					a->ent__ProductItemList::productItem = (ent__ProductItem **)soap_push_block(soap, soap_blist_productItem1, sizeof(ent__ProductItem *));
					if(a->ent__ProductItemList::productItem == NULL)
						return NULL;
					*a->ent__ProductItemList::productItem = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__ProductItem(soap, "ent:productItem", a->ent__ProductItemList::productItem, "ent:ProductItem"))
				{	a->ent__ProductItemList::__sizeproductItem++;
					a->ent__ProductItemList::productItem = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__ProductItemList::productItem)
			soap_pop_block(soap, soap_blist_productItem1);
		if(a->ent__ProductItemList::__sizeproductItem)
			a->ent__ProductItemList::productItem = (ent__ProductItem **)soap_save_block(soap, soap_blist_productItem1, NULL, 1);
		else
		{	a->ent__ProductItemList::productItem = NULL;
			if(soap_blist_productItem1)
				soap_end_block(soap, soap_blist_productItem1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ProductItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProductItemList, 0, sizeof(ent__ProductItemList), 0, soap_copy_ent__ProductItemList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ProductItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ProductItemList);
	return this->soap_out(soap, tag?tag:"ent:ProductItemList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ProductItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ProductItemList(soap, this, tag, type);
}

SOAP_FMAC3 ent__ProductItemList * SOAP_FMAC4 soap_get_ent__ProductItemList(struct soap *soap, ent__ProductItemList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ProductItemList * FASTCALL soap_instantiate_ent__ProductItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ProductItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ProductItemList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ProductItemList);
		ASSIGN_PTR(size, sizeof(ent__ProductItemList));
		((ent__ProductItemList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ProductItemList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ProductItemList));
		for(int i = 0; i < n; i++)
			((ent__ProductItemList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ProductItemList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ProductItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ProductItemList %p -> %p\n", q, p));
	*(ent__ProductItemList*)p = *(ent__ProductItemList*)q;
}

void ent__SubProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__SubProductList::__sizesubProduct = 0;
	this->ent__SubProductList::subProduct = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__SubProductList::soap_serialize(struct soap *soap) const
{
	if(this->ent__SubProductList::subProduct) {
		for(int i = 0; i < this->ent__SubProductList::__sizesubProduct; i++) {
			soap_serialize_PointerToent__SubProduct(soap, this->ent__SubProductList::subProduct + i);
		}
	}
	/* transient soap skipped */
}

int ent__SubProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__SubProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__SubProductList(struct soap *soap, const char *tag, int id, const ent__SubProductList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__SubProductList), "ent:SubProductList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__SubProductList::subProduct) {
		int i;
		for(i = 0; i < a->ent__SubProductList::__sizesubProduct; i++)
			if(soap_out_PointerToent__SubProduct(soap, "ent:subProduct", -1, a->ent__SubProductList::subProduct + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__SubProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__SubProductList(soap, tag, this, type);
}

SOAP_FMAC3 ent__SubProductList * FASTCALL soap_in_ent__SubProductList(struct soap *soap, const char *tag, ent__SubProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__SubProductList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__SubProductList, sizeof(ent__SubProductList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__SubProductList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__SubProductList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_subProduct1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:subProduct", 1, NULL)) {
				if(a->ent__SubProductList::subProduct == NULL) {
					if(soap_blist_subProduct1 == NULL)
						soap_blist_subProduct1 = soap_new_block(soap);
					a->ent__SubProductList::subProduct = (ent__SubProduct **)soap_push_block(soap, soap_blist_subProduct1, sizeof(ent__SubProduct *));
					if(a->ent__SubProductList::subProduct == NULL)
						return NULL;
					*a->ent__SubProductList::subProduct = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__SubProduct(soap, "ent:subProduct", a->ent__SubProductList::subProduct, "ent:SubProduct"))
				{	a->ent__SubProductList::__sizesubProduct++;
					a->ent__SubProductList::subProduct = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__SubProductList::subProduct)
			soap_pop_block(soap, soap_blist_subProduct1);
		if(a->ent__SubProductList::__sizesubProduct)
			a->ent__SubProductList::subProduct = (ent__SubProduct **)soap_save_block(soap, soap_blist_subProduct1, NULL, 1);
		else
		{	a->ent__SubProductList::subProduct = NULL;
			if(soap_blist_subProduct1)
				soap_end_block(soap, soap_blist_subProduct1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__SubProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__SubProductList, 0, sizeof(ent__SubProductList), 0, soap_copy_ent__SubProductList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__SubProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__SubProductList);
	return this->soap_out(soap, tag?tag:"ent:SubProductList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__SubProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__SubProductList(soap, this, tag, type);
}

SOAP_FMAC3 ent__SubProductList * SOAP_FMAC4 soap_get_ent__SubProductList(struct soap *soap, ent__SubProductList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__SubProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__SubProductList * FASTCALL soap_instantiate_ent__SubProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__SubProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__SubProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__SubProductList);
		ASSIGN_PTR(size, sizeof(ent__SubProductList));
		((ent__SubProductList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__SubProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__SubProductList));
		for(int i = 0; i < n; i++)
			((ent__SubProductList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__SubProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__SubProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__SubProductList %p -> %p\n", q, p));
	*(ent__SubProductList*)p = *(ent__SubProductList*)q;
}

void ent__ProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ProductList::__sizeproduct = 0;
	this->ent__ProductList::product = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__ProductList::soap_serialize(struct soap *soap) const
{
	if(this->ent__ProductList::product) {
		for(int i = 0; i < this->ent__ProductList::__sizeproduct; i++) {
			soap_serialize_PointerToent__Product(soap, this->ent__ProductList::product + i);
		}
	}
	/* transient soap skipped */
}

int ent__ProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductList(struct soap *soap, const char *tag, int id, const ent__ProductList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProductList), "ent:ProductList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__ProductList::product) {
		int i;
		for(i = 0; i < a->ent__ProductList::__sizeproduct; i++)
			if(soap_out_PointerToent__Product(soap, "ent:product", -1, a->ent__ProductList::product + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__ProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ProductList(soap, tag, this, type);
}

SOAP_FMAC3 ent__ProductList * FASTCALL soap_in_ent__ProductList(struct soap *soap, const char *tag, ent__ProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ProductList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductList, sizeof(ent__ProductList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ProductList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ProductList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_product1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:product", 1, NULL)) {
				if(a->ent__ProductList::product == NULL) {
					if(soap_blist_product1 == NULL)
						soap_blist_product1 = soap_new_block(soap);
					a->ent__ProductList::product = (ent__Product **)soap_push_block(soap, soap_blist_product1, sizeof(ent__Product *));
					if(a->ent__ProductList::product == NULL)
						return NULL;
					*a->ent__ProductList::product = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Product(soap, "ent:product", a->ent__ProductList::product, "ent:Product"))
				{	a->ent__ProductList::__sizeproduct++;
					a->ent__ProductList::product = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__ProductList::product)
			soap_pop_block(soap, soap_blist_product1);
		if(a->ent__ProductList::__sizeproduct)
			a->ent__ProductList::product = (ent__Product **)soap_save_block(soap, soap_blist_product1, NULL, 1);
		else
		{	a->ent__ProductList::product = NULL;
			if(soap_blist_product1)
				soap_end_block(soap, soap_blist_product1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProductList, 0, sizeof(ent__ProductList), 0, soap_copy_ent__ProductList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ProductList);
	return this->soap_out(soap, tag?tag:"ent:ProductList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ProductList(soap, this, tag, type);
}

SOAP_FMAC3 ent__ProductList * SOAP_FMAC4 soap_get_ent__ProductList(struct soap *soap, ent__ProductList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ProductList * FASTCALL soap_instantiate_ent__ProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ProductList);
		ASSIGN_PTR(size, sizeof(ent__ProductList));
		((ent__ProductList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ProductList));
		for(int i = 0; i < n; i++)
			((ent__ProductList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ProductList %p -> %p\n", q, p));
	*(ent__ProductList*)p = *(ent__ProductList*)q;
}

void ent__SubProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__SubProduct::name);
	soap_default_base__String255(soap, &this->ent__SubProduct::code);
	soap_default_base__String255(soap, &this->ent__SubProduct::englishName);
	soap_default_base__UUID(soap, &this->ent__SubProduct::productGuid);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__SubProduct::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__SubProduct::name);
	soap_serialize_base__String255(soap, &this->ent__SubProduct::code);
	soap_serialize_base__String255(soap, &this->ent__SubProduct::englishName);
	soap_serialize_base__UUID(soap, &this->ent__SubProduct::productGuid);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__SubProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__SubProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__SubProduct(struct soap *soap, const char *tag, int id, const ent__SubProduct *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__SubProduct), "ent:SubProduct"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__SubProduct::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:code", -1, &(a->ent__SubProduct::code), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__SubProduct::englishName), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:productGuid", -1, &(a->ent__SubProduct::productGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__SubProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__SubProduct(soap, tag, this, type);
}

SOAP_FMAC3 ent__SubProduct * FASTCALL soap_in_ent__SubProduct(struct soap *soap, const char *tag, ent__SubProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__SubProduct *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__SubProduct, sizeof(ent__SubProduct), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__SubProduct) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__SubProduct *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_productGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__SubProduct::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:code", &(a->ent__SubProduct::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__SubProduct::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_productGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:productGuid", &(a->ent__SubProduct::productGuid), "base:UUID"))
				{	soap_flag_productGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__SubProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__SubProduct, 0, sizeof(ent__SubProduct), 0, soap_copy_ent__SubProduct);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__SubProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__SubProduct);
	return this->soap_out(soap, tag?tag:"ent:SubProduct", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__SubProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__SubProduct(soap, this, tag, type);
}

SOAP_FMAC3 ent__SubProduct * SOAP_FMAC4 soap_get_ent__SubProduct(struct soap *soap, ent__SubProduct *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__SubProduct * FASTCALL soap_instantiate_ent__SubProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__SubProduct(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__SubProduct, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__SubProduct);
		ASSIGN_PTR(size, sizeof(ent__SubProduct));
		((ent__SubProduct*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__SubProduct[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__SubProduct));
		for(int i = 0; i < n; i++)
			((ent__SubProduct*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__SubProduct*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__SubProduct(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__SubProduct %p -> %p\n", q, p));
	*(ent__SubProduct*)p = *(ent__SubProduct*)q;
}

void ent__Product::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Product::name);
	soap_default_base__String255(soap, &this->ent__Product::code);
	soap_default_base__String255(soap, &this->ent__Product::englishName);
	this->ent__Product::productType = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Product::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Product::name);
	soap_serialize_base__String255(soap, &this->ent__Product::code);
	soap_serialize_base__String255(soap, &this->ent__Product::englishName);
	soap_serialize_PointerToent__ProductType(soap, &this->ent__Product::productType);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Product::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Product(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Product(struct soap *soap, const char *tag, int id, const ent__Product *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Product), "ent:Product"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Product::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:code", -1, &(a->ent__Product::code), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__Product::englishName), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "ent:productType", -1, &(a->ent__Product::productType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Product::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Product(soap, tag, this, type);
}

SOAP_FMAC3 ent__Product * FASTCALL soap_in_ent__Product(struct soap *soap, const char *tag, ent__Product *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Product *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Product, sizeof(ent__Product), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Product) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Product *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_productType1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Product::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:code", &(a->ent__Product::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__Product::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "ent:productType", &(a->ent__Product::productType), "ent:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Product *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Product, 0, sizeof(ent__Product), 0, soap_copy_ent__Product);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Product::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Product);
	return this->soap_out(soap, tag?tag:"ent:Product", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Product::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Product(soap, this, tag, type);
}

SOAP_FMAC3 ent__Product * SOAP_FMAC4 soap_get_ent__Product(struct soap *soap, ent__Product *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Product * FASTCALL soap_instantiate_ent__Product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Product(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Product, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Product);
		ASSIGN_PTR(size, sizeof(ent__Product));
		((ent__Product*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Product[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Product));
		for(int i = 0; i < n; i++)
			((ent__Product*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Product*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Product(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Product %p -> %p\n", q, p));
	*(ent__Product*)p = *(ent__Product*)q;
}

void ent__ProductItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ent__GTINType(soap, &this->ent__ProductItem::globalID);
	soap_default_base__String255(soap, &this->ent__ProductItem::name);
	soap_default_base__String255(soap, &this->ent__ProductItem::code);
	this->ent__ProductItem::productType = NULL;
	this->ent__ProductItem::product = NULL;
	this->ent__ProductItem::subProduct = NULL;
	this->ent__ProductItem::correspondsToGost = NULL;
	soap_default_base__String255(soap, &this->ent__ProductItem::gost);
	this->ent__ProductItem::producer = NULL;
	this->ent__ProductItem::tmOwner = NULL;
	this->ent__ProductItem::__sizeproducing = 0;
	this->ent__ProductItem::producing = NULL;
	this->ent__ProductItem::packaging = NULL;
	this->ent__ProductItem::isPublic = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__ProductItem::soap_serialize(struct soap *soap) const
{
	soap_serialize_ent__GTINType(soap, &this->ent__ProductItem::globalID);
	soap_serialize_base__String255(soap, &this->ent__ProductItem::name);
	soap_serialize_base__String255(soap, &this->ent__ProductItem::code);
	soap_serialize_PointerToent__ProductType(soap, &this->ent__ProductItem::productType);
	soap_serialize_PointerToent__Product(soap, &this->ent__ProductItem::product);
	soap_serialize_PointerToent__SubProduct(soap, &this->ent__ProductItem::subProduct);
	soap_serialize_PointerTobool(soap, &this->ent__ProductItem::correspondsToGost);
	soap_serialize_base__String255(soap, &this->ent__ProductItem::gost);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->ent__ProductItem::producer);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->ent__ProductItem::tmOwner);
	if(this->ent__ProductItem::producing) {
		for(int i = 0; i < this->ent__ProductItem::__sizeproducing; i++) {
			soap_serialize_PointerToent__ProductItemProducing(soap, this->ent__ProductItem::producing + i);
		}
	}
	soap_serialize_PointerToent__Packaging(soap, &this->ent__ProductItem::packaging);
	soap_serialize_PointerTobool(soap, &this->ent__ProductItem::isPublic);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__ProductItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ProductItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProductItem(struct soap *soap, const char *tag, int id, const ent__ProductItem *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProductItem), "ent:ProductItem"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_ent__GTINType(soap, "ent:globalID", -1, &(a->ent__ProductItem::globalID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__ProductItem::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:code", -1, &(a->ent__ProductItem::code), ""))
		return soap->error;
	if(soap_out_PointerToent__ProductType(soap, "ent:productType", -1, &(a->ent__ProductItem::productType), ""))
		return soap->error;
	if(soap_out_PointerToent__Product(soap, "ent:product", -1, &(a->ent__ProductItem::product), ""))
		return soap->error;
	if(soap_out_PointerToent__SubProduct(soap, "ent:subProduct", -1, &(a->ent__ProductItem::subProduct), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:correspondsToGost", -1, &(a->ent__ProductItem::correspondsToGost), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:gost", -1, &(a->ent__ProductItem::gost), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:producer", -1, &(a->ent__ProductItem::producer), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:tmOwner", -1, &(a->ent__ProductItem::tmOwner), ""))
		return soap->error;
	if(a->ent__ProductItem::producing) {
		int i;
		for(i = 0; i < a->ent__ProductItem::__sizeproducing; i++)
			if(soap_out_PointerToent__ProductItemProducing(soap, "ent:producing", -1, a->ent__ProductItem::producing + i, ""))
				return soap->error;
	}
	if(soap_out_PointerToent__Packaging(soap, "ent:packaging", -1, &(a->ent__ProductItem::packaging), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:isPublic", -1, &(a->ent__ProductItem::isPublic), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__ProductItem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ProductItem(soap, tag, this, type);
}

SOAP_FMAC3 ent__ProductItem * FASTCALL soap_in_ent__ProductItem(struct soap *soap, const char *tag, ent__ProductItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ProductItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProductItem, sizeof(ent__ProductItem), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ProductItem) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ProductItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_globalID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_subProduct1 = 1;
	size_t soap_flag_correspondsToGost1 = 1;
	size_t soap_flag_gost1 = 1;
	size_t soap_flag_producer1 = 1;
	size_t soap_flag_tmOwner1 = 1;
	struct soap_blist *soap_blist_producing1 = NULL;
	size_t soap_flag_packaging1 = 1;
	size_t soap_flag_isPublic1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__GTINType(soap, "ent:globalID", &(a->ent__ProductItem::globalID), "ent:GTINType"))
				{	soap_flag_globalID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__ProductItem::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:code", &(a->ent__ProductItem::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_productType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductType(soap, "ent:productType", &(a->ent__ProductItem::productType), "ent:ProductType"))
				{	soap_flag_productType1--;
					continue;
				}
			if(soap_flag_product1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Product(soap, "ent:product", &(a->ent__ProductItem::product), "ent:Product"))
				{	soap_flag_product1--;
					continue;
				}
			if(soap_flag_subProduct1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__SubProduct(soap, "ent:subProduct", &(a->ent__ProductItem::subProduct), "ent:SubProduct"))
				{	soap_flag_subProduct1--;
					continue;
				}
			if(soap_flag_correspondsToGost1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:correspondsToGost", &(a->ent__ProductItem::correspondsToGost), "xsd:boolean"))
				{	soap_flag_correspondsToGost1--;
					continue;
				}
			if(soap_flag_gost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:gost", &(a->ent__ProductItem::gost), "base:String255"))
				{	soap_flag_gost1--;
					continue;
				}
			if(soap_flag_producer1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:producer", &(a->ent__ProductItem::producer), "ent:BusinessEntity"))
				{	soap_flag_producer1--;
					continue;
				}
			if(soap_flag_tmOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:tmOwner", &(a->ent__ProductItem::tmOwner), "ent:BusinessEntity"))
				{	soap_flag_tmOwner1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:producing", 1, NULL)) {
				if(a->ent__ProductItem::producing == NULL) {
					if(soap_blist_producing1 == NULL)
						soap_blist_producing1 = soap_new_block(soap);
					a->ent__ProductItem::producing = (ent__ProductItemProducing **)soap_push_block(soap, soap_blist_producing1, sizeof(ent__ProductItemProducing *));
					if(a->ent__ProductItem::producing == NULL)
						return NULL;
					*a->ent__ProductItem::producing = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__ProductItemProducing(soap, "ent:producing", a->ent__ProductItem::producing, "ent:ProductItemProducing"))
				{	a->ent__ProductItem::__sizeproducing++;
					a->ent__ProductItem::producing = NULL;
					continue;
				}
			}
			if(soap_flag_packaging1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Packaging(soap, "ent:packaging", &(a->ent__ProductItem::packaging), "ent:Packaging"))
				{	soap_flag_packaging1--;
					continue;
				}
			if(soap_flag_isPublic1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:isPublic", &(a->ent__ProductItem::isPublic), "xsd:boolean"))
				{	soap_flag_isPublic1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__ProductItem::producing)
			soap_pop_block(soap, soap_blist_producing1);
		if(a->ent__ProductItem::__sizeproducing)
			a->ent__ProductItem::producing = (ent__ProductItemProducing **)soap_save_block(soap, soap_blist_producing1, NULL, 1);
		else
		{	a->ent__ProductItem::producing = NULL;
			if(soap_blist_producing1)
				soap_end_block(soap, soap_blist_producing1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ProductItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProductItem, 0, sizeof(ent__ProductItem), 0, soap_copy_ent__ProductItem);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ProductItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ProductItem);
	return this->soap_out(soap, tag?tag:"ent:ProductItem", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ProductItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ProductItem(soap, this, tag, type);
}

SOAP_FMAC3 ent__ProductItem * SOAP_FMAC4 soap_get_ent__ProductItem(struct soap *soap, ent__ProductItem *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ProductItem * FASTCALL soap_instantiate_ent__ProductItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ProductItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ProductItem, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ProductItem);
		ASSIGN_PTR(size, sizeof(ent__ProductItem));
		((ent__ProductItem*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ProductItem[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ProductItem));
		for(int i = 0; i < n; i++)
			((ent__ProductItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ProductItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ProductItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ProductItem %p -> %p\n", q, p));
	*(ent__ProductItem*)p = *(ent__ProductItem*)q;
}

void ent__BusinessEntityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__BusinessEntityList::__sizebusinessEntity = 0;
	this->ent__BusinessEntityList::businessEntity = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__BusinessEntityList::soap_serialize(struct soap *soap) const
{
	if(this->ent__BusinessEntityList::businessEntity) {
		for(int i = 0; i < this->ent__BusinessEntityList::__sizebusinessEntity; i++) {
			soap_serialize_PointerToent__BusinessEntity(soap, this->ent__BusinessEntityList::businessEntity + i);
		}
	}
	/* transient soap skipped */
}

int ent__BusinessEntityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__BusinessEntityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__BusinessEntityList(struct soap *soap, const char *tag, int id, const ent__BusinessEntityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__BusinessEntityList), "ent:BusinessEntityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__BusinessEntityList::businessEntity) {
		int i;
		for(i = 0; i < a->ent__BusinessEntityList::__sizebusinessEntity; i++)
			if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, a->ent__BusinessEntityList::businessEntity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__BusinessEntityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__BusinessEntityList(soap, tag, this, type);
}

SOAP_FMAC3 ent__BusinessEntityList * FASTCALL soap_in_ent__BusinessEntityList(struct soap *soap, const char *tag, ent__BusinessEntityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__BusinessEntityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__BusinessEntityList, sizeof(ent__BusinessEntityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__BusinessEntityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__BusinessEntityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_businessEntity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:businessEntity", 1, NULL)) {
				if(a->ent__BusinessEntityList::businessEntity == NULL) {
					if(soap_blist_businessEntity1 == NULL)
						soap_blist_businessEntity1 = soap_new_block(soap);
					a->ent__BusinessEntityList::businessEntity = (ent__BusinessEntity **)soap_push_block(soap, soap_blist_businessEntity1, sizeof(ent__BusinessEntity *));
					if(a->ent__BusinessEntityList::businessEntity == NULL)
						return NULL;
					*a->ent__BusinessEntityList::businessEntity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", a->ent__BusinessEntityList::businessEntity, "ent:BusinessEntity"))
				{	a->ent__BusinessEntityList::__sizebusinessEntity++;
					a->ent__BusinessEntityList::businessEntity = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__BusinessEntityList::businessEntity)
			soap_pop_block(soap, soap_blist_businessEntity1);
		if(a->ent__BusinessEntityList::__sizebusinessEntity)
			a->ent__BusinessEntityList::businessEntity = (ent__BusinessEntity **)soap_save_block(soap, soap_blist_businessEntity1, NULL, 1);
		else
		{	a->ent__BusinessEntityList::businessEntity = NULL;
			if(soap_blist_businessEntity1)
				soap_end_block(soap, soap_blist_businessEntity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__BusinessEntityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__BusinessEntityList, 0, sizeof(ent__BusinessEntityList), 0, soap_copy_ent__BusinessEntityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__BusinessEntityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__BusinessEntityList);
	return this->soap_out(soap, tag?tag:"ent:BusinessEntityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__BusinessEntityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__BusinessEntityList(soap, this, tag, type);
}

SOAP_FMAC3 ent__BusinessEntityList * SOAP_FMAC4 soap_get_ent__BusinessEntityList(struct soap *soap, ent__BusinessEntityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__BusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__BusinessEntityList * FASTCALL soap_instantiate_ent__BusinessEntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__BusinessEntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__BusinessEntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__BusinessEntityList);
		ASSIGN_PTR(size, sizeof(ent__BusinessEntityList));
		((ent__BusinessEntityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__BusinessEntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__BusinessEntityList));
		for(int i = 0; i < n; i++)
			((ent__BusinessEntityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__BusinessEntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__BusinessEntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__BusinessEntityList %p -> %p\n", q, p));
	*(ent__BusinessEntityList*)p = *(ent__BusinessEntityList*)q;
}

void ent__IncorporationForm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__IncorporationForm::name);
	soap_default_base__String255(soap, &this->ent__IncorporationForm::code);
	soap_default_base__String255(soap, &this->ent__IncorporationForm::shortName);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__IncorporationForm::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__IncorporationForm::name);
	soap_serialize_base__String255(soap, &this->ent__IncorporationForm::code);
	soap_serialize_base__String255(soap, &this->ent__IncorporationForm::shortName);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__IncorporationForm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__IncorporationForm(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__IncorporationForm(struct soap *soap, const char *tag, int id, const ent__IncorporationForm *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__IncorporationForm), "ent:IncorporationForm"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__IncorporationForm::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:code", -1, &(a->ent__IncorporationForm::code), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:shortName", -1, &(a->ent__IncorporationForm::shortName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__IncorporationForm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__IncorporationForm(soap, tag, this, type);
}

SOAP_FMAC3 ent__IncorporationForm * FASTCALL soap_in_ent__IncorporationForm(struct soap *soap, const char *tag, ent__IncorporationForm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__IncorporationForm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__IncorporationForm, sizeof(ent__IncorporationForm), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__IncorporationForm) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__IncorporationForm *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_shortName1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__IncorporationForm::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:code", &(a->ent__IncorporationForm::code), "base:String255"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:shortName", &(a->ent__IncorporationForm::shortName), "base:String255"))
				{	soap_flag_shortName1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__IncorporationForm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__IncorporationForm, 0, sizeof(ent__IncorporationForm), 0, soap_copy_ent__IncorporationForm);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__IncorporationForm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__IncorporationForm);
	return this->soap_out(soap, tag?tag:"ent:IncorporationForm", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__IncorporationForm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__IncorporationForm(soap, this, tag, type);
}

SOAP_FMAC3 ent__IncorporationForm * SOAP_FMAC4 soap_get_ent__IncorporationForm(struct soap *soap, ent__IncorporationForm *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__IncorporationForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__IncorporationForm * FASTCALL soap_instantiate_ent__IncorporationForm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__IncorporationForm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__IncorporationForm, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__IncorporationForm);
		ASSIGN_PTR(size, sizeof(ent__IncorporationForm));
		((ent__IncorporationForm*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__IncorporationForm[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__IncorporationForm));
		for(int i = 0; i < n; i++)
			((ent__IncorporationForm*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__IncorporationForm*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__IncorporationForm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__IncorporationForm %p -> %p\n", q, p));
	*(ent__IncorporationForm*)p = *(ent__IncorporationForm*)q;
}

void ent__BusinessEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__BusinessEntity::type = NULL;
	soap_default_base__String255(soap, &this->ent__BusinessEntity::name);
	this->ent__BusinessEntity::incorporationForm = NULL;
	soap_default_base__String255(soap, &this->ent__BusinessEntity::fullName);
	soap_default_base__String255(soap, &this->ent__BusinessEntity::fio);
	soap_default_base__String255(soap, &this->ent__BusinessEntity::passport);
	soap_default_base__String255(soap, &this->ent__BusinessEntity::inn);
	soap_default_base__String255(soap, &this->ent__BusinessEntity::kpp);
	soap_default_base__String255(soap, &this->ent__BusinessEntity::ogrn);
	this->ent__BusinessEntity::juridicalAddress = NULL;
	this->ent__BusinessEntity::__sizeactivityLocation = 0;
	this->ent__BusinessEntity::activityLocation = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__BusinessEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntityType(soap, &this->ent__BusinessEntity::type);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::name);
	soap_serialize_PointerToent__IncorporationForm(soap, &this->ent__BusinessEntity::incorporationForm);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::fullName);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::fio);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::passport);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::inn);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::kpp);
	soap_serialize_base__String255(soap, &this->ent__BusinessEntity::ogrn);
	soap_serialize_PointerToent__Address(soap, &this->ent__BusinessEntity::juridicalAddress);
	if(this->ent__BusinessEntity::activityLocation) {
		for(int i = 0; i < this->ent__BusinessEntity::__sizeactivityLocation; i++) {
			soap_embedded(soap, this->ent__BusinessEntity::activityLocation + i, SOAP_TYPE__ent__BusinessEntity_activityLocation);
			this->ent__BusinessEntity::activityLocation[i].soap_serialize(soap);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__BusinessEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__BusinessEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__BusinessEntity(struct soap *soap, const char *tag, int id, const ent__BusinessEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__BusinessEntity), "ent:BusinessEntity"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntityType(soap, "ent:type", -1, &(a->ent__BusinessEntity::type), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__BusinessEntity::name), ""))
		return soap->error;
	if(soap_out_PointerToent__IncorporationForm(soap, "ent:incorporationForm", -1, &(a->ent__BusinessEntity::incorporationForm), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:fullName", -1, &(a->ent__BusinessEntity::fullName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:fio", -1, &(a->ent__BusinessEntity::fio), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:passport", -1, &(a->ent__BusinessEntity::passport), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:inn", -1, &(a->ent__BusinessEntity::inn), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:kpp", -1, &(a->ent__BusinessEntity::kpp), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:ogrn", -1, &(a->ent__BusinessEntity::ogrn), ""))
		return soap->error;
	if(soap_out_PointerToent__Address(soap, "ent:juridicalAddress", -1, &(a->ent__BusinessEntity::juridicalAddress), ""))
		return soap->error;
	if(a->ent__BusinessEntity::activityLocation) {
		int i;
		for(i = 0; i < a->ent__BusinessEntity::__sizeactivityLocation; i++)
			if(a->ent__BusinessEntity::activityLocation[i].soap_out(soap, "ent:activityLocation", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__BusinessEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__BusinessEntity(soap, tag, this, type);
}

SOAP_FMAC3 ent__BusinessEntity * FASTCALL soap_in_ent__BusinessEntity(struct soap *soap, const char *tag, ent__BusinessEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__BusinessEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__BusinessEntity, sizeof(ent__BusinessEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__BusinessEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__BusinessEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_incorporationForm1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_fio1 = 1;
	size_t soap_flag_passport1 = 1;
	size_t soap_flag_inn1 = 1;
	size_t soap_flag_kpp1 = 1;
	size_t soap_flag_ogrn1 = 1;
	size_t soap_flag_juridicalAddress1 = 1;
	struct soap_blist *soap_blist_activityLocation1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntityType(soap, "ent:type", &(a->ent__BusinessEntity::type), "ent:BusinessEntityType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__BusinessEntity::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_incorporationForm1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__IncorporationForm(soap, "ent:incorporationForm", &(a->ent__BusinessEntity::incorporationForm), "ent:IncorporationForm"))
				{	soap_flag_incorporationForm1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:fullName", &(a->ent__BusinessEntity::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_fio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:fio", &(a->ent__BusinessEntity::fio), "base:String255"))
				{	soap_flag_fio1--;
					continue;
				}
			if(soap_flag_passport1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:passport", &(a->ent__BusinessEntity::passport), "base:String255"))
				{	soap_flag_passport1--;
					continue;
				}
			if(soap_flag_inn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:inn", &(a->ent__BusinessEntity::inn), "base:String255"))
				{	soap_flag_inn1--;
					continue;
				}
			if(soap_flag_kpp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:kpp", &(a->ent__BusinessEntity::kpp), "base:String255"))
				{	soap_flag_kpp1--;
					continue;
				}
			if(soap_flag_ogrn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:ogrn", &(a->ent__BusinessEntity::ogrn), "base:String255"))
				{	soap_flag_ogrn1--;
					continue;
				}
			if(soap_flag_juridicalAddress1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Address(soap, "ent:juridicalAddress", &(a->ent__BusinessEntity::juridicalAddress), "ent:Address"))
				{	soap_flag_juridicalAddress1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:activityLocation", 1, NULL)) {
				if(a->ent__BusinessEntity::activityLocation == NULL) {
					if(soap_blist_activityLocation1 == NULL)
						soap_blist_activityLocation1 = soap_new_block(soap);
					a->ent__BusinessEntity::activityLocation = (_ent__BusinessEntity_activityLocation *)soap_push_block(soap, soap_blist_activityLocation1, sizeof(_ent__BusinessEntity_activityLocation));
					if(a->ent__BusinessEntity::activityLocation == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ent__BusinessEntity::activityLocation, _ent__BusinessEntity_activityLocation);
					a->ent__BusinessEntity::activityLocation->soap_default(soap);
				}
				soap_revert(soap);
				if(soap_in__ent__BusinessEntity_activityLocation(soap, "ent:activityLocation", a->ent__BusinessEntity::activityLocation, ""))
				{	a->ent__BusinessEntity::__sizeactivityLocation++;
					a->ent__BusinessEntity::activityLocation = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__BusinessEntity::activityLocation)
			soap_pop_block(soap, soap_blist_activityLocation1);
		if(a->ent__BusinessEntity::__sizeactivityLocation)
			a->ent__BusinessEntity::activityLocation = (_ent__BusinessEntity_activityLocation *)soap_save_block(soap, soap_blist_activityLocation1, NULL, 1);
		else
		{	a->ent__BusinessEntity::activityLocation = NULL;
			if(soap_blist_activityLocation1)
				soap_end_block(soap, soap_blist_activityLocation1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__BusinessEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__BusinessEntity, 0, sizeof(ent__BusinessEntity), 0, soap_copy_ent__BusinessEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__BusinessEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__BusinessEntity);
	return this->soap_out(soap, tag?tag:"ent:BusinessEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__BusinessEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__BusinessEntity(soap, this, tag, type);
}

SOAP_FMAC3 ent__BusinessEntity * SOAP_FMAC4 soap_get_ent__BusinessEntity(struct soap *soap, ent__BusinessEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__BusinessEntity * FASTCALL soap_instantiate_ent__BusinessEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__BusinessEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__BusinessEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__BusinessEntity);
		ASSIGN_PTR(size, sizeof(ent__BusinessEntity));
		((ent__BusinessEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__BusinessEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__BusinessEntity));
		for(int i = 0; i < n; i++)
			((ent__BusinessEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__BusinessEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__BusinessEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__BusinessEntity %p -> %p\n", q, p));
	*(ent__BusinessEntity*)p = *(ent__BusinessEntity*)q;
}

void ent__BusinessMember::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__BusinessMember::businessEntity = NULL;
	this->ent__BusinessMember::enterprise = NULL;
	soap_default_ent__GLNType(soap, &this->ent__BusinessMember::globalID);
	/* transient soap skipped */
}

void ent__BusinessMember::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntity(soap, &this->ent__BusinessMember::businessEntity);
	soap_serialize_PointerToent__Enterprise(soap, &this->ent__BusinessMember::enterprise);
	soap_serialize_ent__GLNType(soap, &this->ent__BusinessMember::globalID);
	/* transient soap skipped */
}

int ent__BusinessMember::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__BusinessMember(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__BusinessMember(struct soap *soap, const char *tag, int id, const ent__BusinessMember *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__BusinessMember), type))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:businessEntity", -1, &(a->ent__BusinessMember::businessEntity), ""))
		return soap->error;
	if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &(a->ent__BusinessMember::enterprise), ""))
		return soap->error;
	if(soap_out_ent__GLNType(soap, "ent:globalID", -1, &(a->ent__BusinessMember::globalID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__BusinessMember::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__BusinessMember(soap, tag, this, type);
}

SOAP_FMAC3 ent__BusinessMember * FASTCALL soap_in_ent__BusinessMember(struct soap *soap, const char *tag, ent__BusinessMember *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__BusinessMember *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__BusinessMember, sizeof(ent__BusinessMember), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__BusinessMember) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__BusinessMember *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessEntity1 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_globalID1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:businessEntity", &(a->ent__BusinessMember::businessEntity), "ent:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->ent__BusinessMember::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_globalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__GLNType(soap, "ent:globalID", &(a->ent__BusinessMember::globalID), "ent:GLNType"))
				{	soap_flag_globalID1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__BusinessMember *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__BusinessMember, 0, sizeof(ent__BusinessMember), 0, soap_copy_ent__BusinessMember);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__BusinessMember::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__BusinessMember);
	return this->soap_out(soap, tag?tag:"ent:BusinessMember", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__BusinessMember::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__BusinessMember(soap, this, tag, type);
}

SOAP_FMAC3 ent__BusinessMember * SOAP_FMAC4 soap_get_ent__BusinessMember(struct soap *soap, ent__BusinessMember *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__BusinessMember * FASTCALL soap_instantiate_ent__BusinessMember(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__BusinessMember(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__BusinessMember, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__BusinessMember);
		ASSIGN_PTR(size, sizeof(ent__BusinessMember));
		((ent__BusinessMember*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__BusinessMember[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__BusinessMember));
		for(int i = 0; i < n; i++)
			((ent__BusinessMember*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__BusinessMember*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__BusinessMember(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__BusinessMember %p -> %p\n", q, p));
	*(ent__BusinessMember*)p = *(ent__BusinessMember*)q;
}

void ent__EnterpriseList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__EnterpriseList::__sizeenterprise = 0;
	this->ent__EnterpriseList::enterprise = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__EnterpriseList::soap_serialize(struct soap *soap) const
{
	if(this->ent__EnterpriseList::enterprise) {
		for(int i = 0; i < this->ent__EnterpriseList::__sizeenterprise; i++) {
			soap_serialize_PointerToent__Enterprise(soap, this->ent__EnterpriseList::enterprise + i);
		}
	}
	/* transient soap skipped */
}

int ent__EnterpriseList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__EnterpriseList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseList(struct soap *soap, const char *tag, int id, const ent__EnterpriseList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseList), "ent:EnterpriseList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__EnterpriseList::enterprise) {
		int i;
		for(i = 0; i < a->ent__EnterpriseList::__sizeenterprise; i++)
			if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, a->ent__EnterpriseList::enterprise + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__EnterpriseList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__EnterpriseList(soap, tag, this, type);
}

SOAP_FMAC3 ent__EnterpriseList * FASTCALL soap_in_ent__EnterpriseList(struct soap *soap, const char *tag, ent__EnterpriseList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__EnterpriseList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseList, sizeof(ent__EnterpriseList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__EnterpriseList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__EnterpriseList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_enterprise1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:enterprise", 1, NULL)) {
				if(a->ent__EnterpriseList::enterprise == NULL) {
					if(soap_blist_enterprise1 == NULL)
						soap_blist_enterprise1 = soap_new_block(soap);
					a->ent__EnterpriseList::enterprise = (ent__Enterprise **)soap_push_block(soap, soap_blist_enterprise1, sizeof(ent__Enterprise *));
					if(a->ent__EnterpriseList::enterprise == NULL)
						return NULL;
					*a->ent__EnterpriseList::enterprise = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", a->ent__EnterpriseList::enterprise, "ent:Enterprise"))
				{	a->ent__EnterpriseList::__sizeenterprise++;
					a->ent__EnterpriseList::enterprise = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__EnterpriseList::enterprise)
			soap_pop_block(soap, soap_blist_enterprise1);
		if(a->ent__EnterpriseList::__sizeenterprise)
			a->ent__EnterpriseList::enterprise = (ent__Enterprise **)soap_save_block(soap, soap_blist_enterprise1, NULL, 1);
		else
		{	a->ent__EnterpriseList::enterprise = NULL;
			if(soap_blist_enterprise1)
				soap_end_block(soap, soap_blist_enterprise1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__EnterpriseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseList, 0, sizeof(ent__EnterpriseList), 0, soap_copy_ent__EnterpriseList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__EnterpriseList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseList);
	return this->soap_out(soap, tag?tag:"ent:EnterpriseList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__EnterpriseList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__EnterpriseList(soap, this, tag, type);
}

SOAP_FMAC3 ent__EnterpriseList * SOAP_FMAC4 soap_get_ent__EnterpriseList(struct soap *soap, ent__EnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__EnterpriseList * FASTCALL soap_instantiate_ent__EnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__EnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__EnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseList);
		ASSIGN_PTR(size, sizeof(ent__EnterpriseList));
		((ent__EnterpriseList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__EnterpriseList));
		for(int i = 0; i < n; i++)
			((ent__EnterpriseList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__EnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__EnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__EnterpriseList %p -> %p\n", q, p));
	*(ent__EnterpriseList*)p = *(ent__EnterpriseList*)q;
}

void ent__EnterpriseNumberList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__EnterpriseNumberList::__sizeenterpriseNumber = 0;
	this->ent__EnterpriseNumberList::enterpriseNumber = NULL;
	/* transient soap skipped */
}

void ent__EnterpriseNumberList::soap_serialize(struct soap *soap) const
{
	if(this->ent__EnterpriseNumberList::enterpriseNumber) {
		for(int i = 0; i < this->ent__EnterpriseNumberList::__sizeenterpriseNumber; i++) {
			soap_serialize_base__String255(soap, this->ent__EnterpriseNumberList::enterpriseNumber + i);
		}
	}
	/* transient soap skipped */
}

int ent__EnterpriseNumberList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__EnterpriseNumberList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseNumberList(struct soap *soap, const char *tag, int id, const ent__EnterpriseNumberList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseNumberList), type))
		return soap->error;
	if(a->ent__EnterpriseNumberList::enterpriseNumber) {
		int i;
		for(i = 0; i < a->ent__EnterpriseNumberList::__sizeenterpriseNumber; i++)
			if(soap_out_base__String255(soap, "ent:enterpriseNumber", -1, a->ent__EnterpriseNumberList::enterpriseNumber + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__EnterpriseNumberList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__EnterpriseNumberList(soap, tag, this, type);
}

SOAP_FMAC3 ent__EnterpriseNumberList * FASTCALL soap_in_ent__EnterpriseNumberList(struct soap *soap, const char *tag, ent__EnterpriseNumberList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__EnterpriseNumberList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseNumberList, sizeof(ent__EnterpriseNumberList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__EnterpriseNumberList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__EnterpriseNumberList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_enterpriseNumber1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:enterpriseNumber", 1, NULL)) {
				if(a->ent__EnterpriseNumberList::enterpriseNumber == NULL) {
					if(soap_blist_enterpriseNumber1 == NULL)
						soap_blist_enterpriseNumber1 = soap_new_block(soap);
					a->ent__EnterpriseNumberList::enterpriseNumber = (char **)soap_push_block(soap, soap_blist_enterpriseNumber1, sizeof(char *));
					if(a->ent__EnterpriseNumberList::enterpriseNumber == NULL)
						return NULL;
					*a->ent__EnterpriseNumberList::enterpriseNumber = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__String255(soap, "ent:enterpriseNumber", a->ent__EnterpriseNumberList::enterpriseNumber, "base:String255"))
				{	a->ent__EnterpriseNumberList::__sizeenterpriseNumber++;
					a->ent__EnterpriseNumberList::enterpriseNumber = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__EnterpriseNumberList::enterpriseNumber)
			soap_pop_block(soap, soap_blist_enterpriseNumber1);
		if(a->ent__EnterpriseNumberList::__sizeenterpriseNumber)
			a->ent__EnterpriseNumberList::enterpriseNumber = (char **)soap_save_block(soap, soap_blist_enterpriseNumber1, NULL, 1);
		else
		{	a->ent__EnterpriseNumberList::enterpriseNumber = NULL;
			if(soap_blist_enterpriseNumber1)
				soap_end_block(soap, soap_blist_enterpriseNumber1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__EnterpriseNumberList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseNumberList, 0, sizeof(ent__EnterpriseNumberList), 0, soap_copy_ent__EnterpriseNumberList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__EnterpriseNumberList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseNumberList);
	return this->soap_out(soap, tag?tag:"ent:EnterpriseNumberList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__EnterpriseNumberList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__EnterpriseNumberList(soap, this, tag, type);
}

SOAP_FMAC3 ent__EnterpriseNumberList * SOAP_FMAC4 soap_get_ent__EnterpriseNumberList(struct soap *soap, ent__EnterpriseNumberList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseNumberList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__EnterpriseNumberList * FASTCALL soap_instantiate_ent__EnterpriseNumberList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__EnterpriseNumberList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__EnterpriseNumberList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseNumberList);
		ASSIGN_PTR(size, sizeof(ent__EnterpriseNumberList));
		((ent__EnterpriseNumberList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseNumberList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__EnterpriseNumberList));
		for(int i = 0; i < n; i++)
			((ent__EnterpriseNumberList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__EnterpriseNumberList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__EnterpriseNumberList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__EnterpriseNumberList %p -> %p\n", q, p));
	*(ent__EnterpriseNumberList*)p = *(ent__EnterpriseNumberList*)q;
}

void ent__ProducerList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__ProducerList::__sizeproducer = 0;
	this->ent__ProducerList::producer = NULL;
	/* transient soap skipped */
}

void ent__ProducerList::soap_serialize(struct soap *soap) const
{
	if(this->ent__ProducerList::producer) {
		for(int i = 0; i < this->ent__ProducerList::__sizeproducer; i++) {
			soap_serialize_PointerToent__Producer(soap, this->ent__ProducerList::producer + i);
		}
	}
	/* transient soap skipped */
}

int ent__ProducerList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__ProducerList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ProducerList(struct soap *soap, const char *tag, int id, const ent__ProducerList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__ProducerList), type))
		return soap->error;
	if(a->ent__ProducerList::producer) {
		int i;
		for(i = 0; i < a->ent__ProducerList::__sizeproducer; i++)
			if(soap_out_PointerToent__Producer(soap, "ent:producer", -1, a->ent__ProducerList::producer + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__ProducerList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__ProducerList(soap, tag, this, type);
}

SOAP_FMAC3 ent__ProducerList * FASTCALL soap_in_ent__ProducerList(struct soap *soap, const char *tag, ent__ProducerList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__ProducerList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__ProducerList, sizeof(ent__ProducerList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__ProducerList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__ProducerList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_producer1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:producer", 1, NULL)) {
				if(a->ent__ProducerList::producer == NULL) {
					if(soap_blist_producer1 == NULL)
						soap_blist_producer1 = soap_new_block(soap);
					a->ent__ProducerList::producer = (ent__Producer **)soap_push_block(soap, soap_blist_producer1, sizeof(ent__Producer *));
					if(a->ent__ProducerList::producer == NULL)
						return NULL;
					*a->ent__ProducerList::producer = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Producer(soap, "ent:producer", a->ent__ProducerList::producer, "ent:Producer"))
				{	a->ent__ProducerList::__sizeproducer++;
					a->ent__ProducerList::producer = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__ProducerList::producer)
			soap_pop_block(soap, soap_blist_producer1);
		if(a->ent__ProducerList::__sizeproducer)
			a->ent__ProducerList::producer = (ent__Producer **)soap_save_block(soap, soap_blist_producer1, NULL, 1);
		else
		{	a->ent__ProducerList::producer = NULL;
			if(soap_blist_producer1)
				soap_end_block(soap, soap_blist_producer1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__ProducerList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__ProducerList, 0, sizeof(ent__ProducerList), 0, soap_copy_ent__ProducerList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__ProducerList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__ProducerList);
	return this->soap_out(soap, tag?tag:"ent:ProducerList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__ProducerList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__ProducerList(soap, this, tag, type);
}

SOAP_FMAC3 ent__ProducerList * SOAP_FMAC4 soap_get_ent__ProducerList(struct soap *soap, ent__ProducerList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ProducerList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__ProducerList * FASTCALL soap_instantiate_ent__ProducerList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__ProducerList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__ProducerList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__ProducerList);
		ASSIGN_PTR(size, sizeof(ent__ProducerList));
		((ent__ProducerList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__ProducerList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__ProducerList));
		for(int i = 0; i < n; i++)
			((ent__ProducerList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__ProducerList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__ProducerList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__ProducerList %p -> %p\n", q, p));
	*(ent__ProducerList*)p = *(ent__ProducerList*)q;
}

void ent__Producer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__Producer::enterprise = NULL;
	this->ent__Producer::role = NULL;
	/* transient soap skipped */
}

void ent__Producer::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->ent__Producer::enterprise);
	soap_serialize_PointerToent__EnterpriseRole(soap, &this->ent__Producer::role);
	/* transient soap skipped */
}

int ent__Producer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Producer(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Producer(struct soap *soap, const char *tag, int id, const ent__Producer *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Producer), type))
		return soap->error;
	if(a->ent__Producer::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "ent:enterprise", -1, &a->ent__Producer::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterprise"))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseRole(soap, "ent:role", -1, &(a->ent__Producer::role), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Producer::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Producer(soap, tag, this, type);
}

SOAP_FMAC3 ent__Producer * FASTCALL soap_in_ent__Producer(struct soap *soap, const char *tag, ent__Producer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Producer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Producer, sizeof(ent__Producer), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Producer) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Producer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_role1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "ent:enterprise", &(a->ent__Producer::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseRole(soap, "ent:role", &(a->ent__Producer::role), "ent:EnterpriseRole"))
				{	soap_flag_role1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Producer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Producer, 0, sizeof(ent__Producer), 0, soap_copy_ent__Producer);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_enterprise1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ent__Producer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Producer);
	return this->soap_out(soap, tag?tag:"ent:Producer", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Producer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Producer(soap, this, tag, type);
}

SOAP_FMAC3 ent__Producer * SOAP_FMAC4 soap_get_ent__Producer(struct soap *soap, ent__Producer *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Producer * FASTCALL soap_instantiate_ent__Producer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Producer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Producer, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Producer);
		ASSIGN_PTR(size, sizeof(ent__Producer));
		((ent__Producer*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Producer[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Producer));
		for(int i = 0; i < n; i++)
			((ent__Producer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Producer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Producer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Producer %p -> %p\n", q, p));
	*(ent__Producer*)p = *(ent__Producer*)q;
}

void ent__EnterpriseActivity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__EnterpriseActivity::name = NULL;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__EnterpriseActivity::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__NText(soap, &this->ent__EnterpriseActivity::name);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__EnterpriseActivity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__EnterpriseActivity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseActivity(struct soap *soap, const char *tag, int id, const ent__EnterpriseActivity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseActivity), "ent:EnterpriseActivity"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_PointerTobase__NText(soap, "ent:name", -1, &(a->ent__EnterpriseActivity::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__EnterpriseActivity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__EnterpriseActivity(soap, tag, this, type);
}

SOAP_FMAC3 ent__EnterpriseActivity * FASTCALL soap_in_ent__EnterpriseActivity(struct soap *soap, const char *tag, ent__EnterpriseActivity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__EnterpriseActivity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseActivity, sizeof(ent__EnterpriseActivity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__EnterpriseActivity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__EnterpriseActivity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:name", &(a->ent__EnterpriseActivity::name), "base:NText"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__EnterpriseActivity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseActivity, 0, sizeof(ent__EnterpriseActivity), 0, soap_copy_ent__EnterpriseActivity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__EnterpriseActivity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseActivity);
	return this->soap_out(soap, tag?tag:"ent:EnterpriseActivity", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__EnterpriseActivity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__EnterpriseActivity(soap, this, tag, type);
}

SOAP_FMAC3 ent__EnterpriseActivity * SOAP_FMAC4 soap_get_ent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__EnterpriseActivity * FASTCALL soap_instantiate_ent__EnterpriseActivity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__EnterpriseActivity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__EnterpriseActivity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivity);
		ASSIGN_PTR(size, sizeof(ent__EnterpriseActivity));
		((ent__EnterpriseActivity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__EnterpriseActivity));
		for(int i = 0; i < n; i++)
			((ent__EnterpriseActivity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__EnterpriseActivity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__EnterpriseActivity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__EnterpriseActivity %p -> %p\n", q, p));
	*(ent__EnterpriseActivity*)p = *(ent__EnterpriseActivity*)q;
}

void ent__EnterpriseActivityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__EnterpriseActivityList::__sizeactivity = 0;
	this->ent__EnterpriseActivityList::activity = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__EnterpriseActivityList::soap_serialize(struct soap *soap) const
{
	if(this->ent__EnterpriseActivityList::activity) {
		for(int i = 0; i < this->ent__EnterpriseActivityList::__sizeactivity; i++) {
			soap_serialize_PointerToent__EnterpriseActivity(soap, this->ent__EnterpriseActivityList::activity + i);
		}
	}
	/* transient soap skipped */
}

int ent__EnterpriseActivityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__EnterpriseActivityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseActivityList(struct soap *soap, const char *tag, int id, const ent__EnterpriseActivityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__EnterpriseActivityList), "ent:EnterpriseActivityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__EnterpriseActivityList::activity) {
		int i;
		for(i = 0; i < a->ent__EnterpriseActivityList::__sizeactivity; i++)
			if(soap_out_PointerToent__EnterpriseActivity(soap, "ent:activity", -1, a->ent__EnterpriseActivityList::activity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__EnterpriseActivityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__EnterpriseActivityList(soap, tag, this, type);
}

SOAP_FMAC3 ent__EnterpriseActivityList * FASTCALL soap_in_ent__EnterpriseActivityList(struct soap *soap, const char *tag, ent__EnterpriseActivityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__EnterpriseActivityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__EnterpriseActivityList, sizeof(ent__EnterpriseActivityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__EnterpriseActivityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__EnterpriseActivityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_activity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:activity", 1, NULL)) {
				if(a->ent__EnterpriseActivityList::activity == NULL) {
					if(soap_blist_activity1 == NULL)
						soap_blist_activity1 = soap_new_block(soap);
					a->ent__EnterpriseActivityList::activity = (ent__EnterpriseActivity **)soap_push_block(soap, soap_blist_activity1, sizeof(ent__EnterpriseActivity *));
					if(a->ent__EnterpriseActivityList::activity == NULL)
						return NULL;
					*a->ent__EnterpriseActivityList::activity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__EnterpriseActivity(soap, "ent:activity", a->ent__EnterpriseActivityList::activity, "ent:EnterpriseActivity"))
				{	a->ent__EnterpriseActivityList::__sizeactivity++;
					a->ent__EnterpriseActivityList::activity = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__EnterpriseActivityList::activity)
			soap_pop_block(soap, soap_blist_activity1);
		if(a->ent__EnterpriseActivityList::__sizeactivity)
			a->ent__EnterpriseActivityList::activity = (ent__EnterpriseActivity **)soap_save_block(soap, soap_blist_activity1, NULL, 1);
		else
		{	a->ent__EnterpriseActivityList::activity = NULL;
			if(soap_blist_activity1)
				soap_end_block(soap, soap_blist_activity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__EnterpriseActivityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__EnterpriseActivityList, 0, sizeof(ent__EnterpriseActivityList), 0, soap_copy_ent__EnterpriseActivityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__EnterpriseActivityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseActivityList);
	return this->soap_out(soap, tag?tag:"ent:EnterpriseActivityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__EnterpriseActivityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__EnterpriseActivityList(soap, this, tag, type);
}

SOAP_FMAC3 ent__EnterpriseActivityList * SOAP_FMAC4 soap_get_ent__EnterpriseActivityList(struct soap *soap, ent__EnterpriseActivityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseActivityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__EnterpriseActivityList * FASTCALL soap_instantiate_ent__EnterpriseActivityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__EnterpriseActivityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__EnterpriseActivityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivityList);
		ASSIGN_PTR(size, sizeof(ent__EnterpriseActivityList));
		((ent__EnterpriseActivityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__EnterpriseActivityList));
		for(int i = 0; i < n; i++)
			((ent__EnterpriseActivityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__EnterpriseActivityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__EnterpriseActivityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__EnterpriseActivityList %p -> %p\n", q, p));
	*(ent__EnterpriseActivityList*)p = *(ent__EnterpriseActivityList*)q;
}

void ent__Enterprise::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Enterprise::name);
	soap_default_base__String255(soap, &this->ent__Enterprise::englishName);
	this->ent__Enterprise::type = NULL;
	this->ent__Enterprise::numberList = NULL;
	this->ent__Enterprise::address = NULL;
	this->ent__Enterprise::activityList = NULL;
	this->ent__Enterprise::owner = NULL;
	this->ent__Enterprise::__sizeofficialRegistration = 0;
	this->ent__Enterprise::officialRegistration = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Enterprise::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Enterprise::name);
	soap_serialize_base__String255(soap, &this->ent__Enterprise::englishName);
	soap_serialize_PointerToent__EnterpriseType(soap, &this->ent__Enterprise::type);
	soap_serialize_PointerToent__EnterpriseNumberList(soap, &this->ent__Enterprise::numberList);
	soap_serialize_PointerToent__Address(soap, &this->ent__Enterprise::address);
	soap_serialize_PointerToent__EnterpriseActivityList(soap, &this->ent__Enterprise::activityList);
	soap_serialize_PointerToent__BusinessEntity(soap, &this->ent__Enterprise::owner);
	if(this->ent__Enterprise::officialRegistration) {
		for(int i = 0; i < this->ent__Enterprise::__sizeofficialRegistration; i++) {
			soap_serialize_PointerToent__EnterpriseOfficialRegistration(soap, this->ent__Enterprise::officialRegistration + i);
		}
	}
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Enterprise::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Enterprise(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Enterprise(struct soap *soap, const char *tag, int id, const ent__Enterprise *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Enterprise), "ent:Enterprise"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Enterprise::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__Enterprise::englishName), ""))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseType(soap, "ent:type", -1, &(a->ent__Enterprise::type), ""))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseNumberList(soap, "ent:numberList", -1, &(a->ent__Enterprise::numberList), ""))
		return soap->error;
	if(soap_out_PointerToent__Address(soap, "ent:address", -1, &(a->ent__Enterprise::address), ""))
		return soap->error;
	if(soap_out_PointerToent__EnterpriseActivityList(soap, "ent:activityList", -1, &(a->ent__Enterprise::activityList), ""))
		return soap->error;
	if(soap_out_PointerToent__BusinessEntity(soap, "ent:owner", -1, &(a->ent__Enterprise::owner), ""))
		return soap->error;
	if(a->ent__Enterprise::officialRegistration) {
		int i;
		for(i = 0; i < a->ent__Enterprise::__sizeofficialRegistration; i++)
			if(soap_out_PointerToent__EnterpriseOfficialRegistration(soap, "ent:officialRegistration", -1, a->ent__Enterprise::officialRegistration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__Enterprise::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Enterprise(soap, tag, this, type);
}

SOAP_FMAC3 ent__Enterprise * FASTCALL soap_in_ent__Enterprise(struct soap *soap, const char *tag, ent__Enterprise *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Enterprise *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Enterprise, sizeof(ent__Enterprise), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Enterprise) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Enterprise *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_numberList1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_activityList1 = 1;
	size_t soap_flag_owner1 = 1;
	struct soap_blist *soap_blist_officialRegistration1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Enterprise::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__Enterprise::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseType(soap, "ent:type", &(a->ent__Enterprise::type), "ent:EnterpriseType"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_numberList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseNumberList(soap, "ent:numberList", &(a->ent__Enterprise::numberList), "ent:EnterpriseNumberList"))
				{	soap_flag_numberList1--;
					continue;
				}
			if(soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Address(soap, "ent:address", &(a->ent__Enterprise::address), "ent:Address"))
				{	soap_flag_address1--;
					continue;
				}
			if(soap_flag_activityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__EnterpriseActivityList(soap, "ent:activityList", &(a->ent__Enterprise::activityList), "ent:EnterpriseActivityList"))
				{	soap_flag_activityList1--;
					continue;
				}
			if(soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "ent:owner", &(a->ent__Enterprise::owner), "ent:BusinessEntity"))
				{	soap_flag_owner1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:officialRegistration", 1, NULL)) {
				if(a->ent__Enterprise::officialRegistration == NULL) {
					if(soap_blist_officialRegistration1 == NULL)
						soap_blist_officialRegistration1 = soap_new_block(soap);
					a->ent__Enterprise::officialRegistration = (ent__EnterpriseOfficialRegistration **)soap_push_block(soap, soap_blist_officialRegistration1, sizeof(ent__EnterpriseOfficialRegistration *));
					if(a->ent__Enterprise::officialRegistration == NULL)
						return NULL;
					*a->ent__Enterprise::officialRegistration = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__EnterpriseOfficialRegistration(soap, "ent:officialRegistration", a->ent__Enterprise::officialRegistration, "ent:EnterpriseOfficialRegistration"))
				{	a->ent__Enterprise::__sizeofficialRegistration++;
					a->ent__Enterprise::officialRegistration = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__Enterprise::officialRegistration)
			soap_pop_block(soap, soap_blist_officialRegistration1);
		if(a->ent__Enterprise::__sizeofficialRegistration)
			a->ent__Enterprise::officialRegistration = (ent__EnterpriseOfficialRegistration **)soap_save_block(soap, soap_blist_officialRegistration1, NULL, 1);
		else
		{	a->ent__Enterprise::officialRegistration = NULL;
			if(soap_blist_officialRegistration1)
				soap_end_block(soap, soap_blist_officialRegistration1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Enterprise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Enterprise, 0, sizeof(ent__Enterprise), 0, soap_copy_ent__Enterprise);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Enterprise::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Enterprise);
	return this->soap_out(soap, tag?tag:"ent:Enterprise", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Enterprise::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Enterprise(soap, this, tag, type);
}

SOAP_FMAC3 ent__Enterprise * SOAP_FMAC4 soap_get_ent__Enterprise(struct soap *soap, ent__Enterprise *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Enterprise * FASTCALL soap_instantiate_ent__Enterprise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Enterprise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Enterprise, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Enterprise);
		ASSIGN_PTR(size, sizeof(ent__Enterprise));
		((ent__Enterprise*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Enterprise[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Enterprise));
		for(int i = 0; i < n; i++)
			((ent__Enterprise*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Enterprise*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Enterprise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Enterprise %p -> %p\n", q, p));
	*(ent__Enterprise*)p = *(ent__Enterprise*)q;
}

void ent__StreetList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__StreetList::__sizestreet = 0;
	this->ent__StreetList::street = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__StreetList::soap_serialize(struct soap *soap) const
{
	if(this->ent__StreetList::street) {
		for(int i = 0; i < this->ent__StreetList::__sizestreet; i++) {
			soap_serialize_PointerToent__Street(soap, this->ent__StreetList::street + i);
		}
	}
	/* transient soap skipped */
}

int ent__StreetList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__StreetList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__StreetList(struct soap *soap, const char *tag, int id, const ent__StreetList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__StreetList), "ent:StreetList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__StreetList::street) {
		int i;
		for(i = 0; i < a->ent__StreetList::__sizestreet; i++)
			if(soap_out_PointerToent__Street(soap, "ent:street", -1, a->ent__StreetList::street + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__StreetList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__StreetList(soap, tag, this, type);
}

SOAP_FMAC3 ent__StreetList * FASTCALL soap_in_ent__StreetList(struct soap *soap, const char *tag, ent__StreetList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__StreetList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__StreetList, sizeof(ent__StreetList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__StreetList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__StreetList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_street1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:street", 1, NULL)) {
				if(a->ent__StreetList::street == NULL) {
					if(soap_blist_street1 == NULL)
						soap_blist_street1 = soap_new_block(soap);
					a->ent__StreetList::street = (ent__Street **)soap_push_block(soap, soap_blist_street1, sizeof(ent__Street *));
					if(a->ent__StreetList::street == NULL)
						return NULL;
					*a->ent__StreetList::street = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Street(soap, "ent:street", a->ent__StreetList::street, "ent:Street"))
				{	a->ent__StreetList::__sizestreet++;
					a->ent__StreetList::street = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__StreetList::street)
			soap_pop_block(soap, soap_blist_street1);
		if(a->ent__StreetList::__sizestreet)
			a->ent__StreetList::street = (ent__Street **)soap_save_block(soap, soap_blist_street1, NULL, 1);
		else
		{	a->ent__StreetList::street = NULL;
			if(soap_blist_street1)
				soap_end_block(soap, soap_blist_street1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__StreetList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__StreetList, 0, sizeof(ent__StreetList), 0, soap_copy_ent__StreetList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__StreetList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__StreetList);
	return this->soap_out(soap, tag?tag:"ent:StreetList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__StreetList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__StreetList(soap, this, tag, type);
}

SOAP_FMAC3 ent__StreetList * SOAP_FMAC4 soap_get_ent__StreetList(struct soap *soap, ent__StreetList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__StreetList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__StreetList * FASTCALL soap_instantiate_ent__StreetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__StreetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__StreetList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__StreetList);
		ASSIGN_PTR(size, sizeof(ent__StreetList));
		((ent__StreetList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__StreetList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__StreetList));
		for(int i = 0; i < n; i++)
			((ent__StreetList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__StreetList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__StreetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__StreetList %p -> %p\n", q, p));
	*(ent__StreetList*)p = *(ent__StreetList*)q;
}

void ent__LocalityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__LocalityList::__sizelocality = 0;
	this->ent__LocalityList::locality = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__LocalityList::soap_serialize(struct soap *soap) const
{
	if(this->ent__LocalityList::locality) {
		for(int i = 0; i < this->ent__LocalityList::__sizelocality; i++) {
			soap_serialize_PointerToent__Locality(soap, this->ent__LocalityList::locality + i);
		}
	}
	/* transient soap skipped */
}

int ent__LocalityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__LocalityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__LocalityList(struct soap *soap, const char *tag, int id, const ent__LocalityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__LocalityList), "ent:LocalityList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__LocalityList::locality) {
		int i;
		for(i = 0; i < a->ent__LocalityList::__sizelocality; i++)
			if(soap_out_PointerToent__Locality(soap, "ent:locality", -1, a->ent__LocalityList::locality + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__LocalityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__LocalityList(soap, tag, this, type);
}

SOAP_FMAC3 ent__LocalityList * FASTCALL soap_in_ent__LocalityList(struct soap *soap, const char *tag, ent__LocalityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__LocalityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__LocalityList, sizeof(ent__LocalityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__LocalityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__LocalityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_locality1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:locality", 1, NULL)) {
				if(a->ent__LocalityList::locality == NULL) {
					if(soap_blist_locality1 == NULL)
						soap_blist_locality1 = soap_new_block(soap);
					a->ent__LocalityList::locality = (ent__Locality **)soap_push_block(soap, soap_blist_locality1, sizeof(ent__Locality *));
					if(a->ent__LocalityList::locality == NULL)
						return NULL;
					*a->ent__LocalityList::locality = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Locality(soap, "ent:locality", a->ent__LocalityList::locality, "ent:Locality"))
				{	a->ent__LocalityList::__sizelocality++;
					a->ent__LocalityList::locality = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__LocalityList::locality)
			soap_pop_block(soap, soap_blist_locality1);
		if(a->ent__LocalityList::__sizelocality)
			a->ent__LocalityList::locality = (ent__Locality **)soap_save_block(soap, soap_blist_locality1, NULL, 1);
		else
		{	a->ent__LocalityList::locality = NULL;
			if(soap_blist_locality1)
				soap_end_block(soap, soap_blist_locality1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__LocalityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__LocalityList, 0, sizeof(ent__LocalityList), 0, soap_copy_ent__LocalityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__LocalityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__LocalityList);
	return this->soap_out(soap, tag?tag:"ent:LocalityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__LocalityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__LocalityList(soap, this, tag, type);
}

SOAP_FMAC3 ent__LocalityList * SOAP_FMAC4 soap_get_ent__LocalityList(struct soap *soap, ent__LocalityList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__LocalityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__LocalityList * FASTCALL soap_instantiate_ent__LocalityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__LocalityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__LocalityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__LocalityList);
		ASSIGN_PTR(size, sizeof(ent__LocalityList));
		((ent__LocalityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__LocalityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__LocalityList));
		for(int i = 0; i < n; i++)
			((ent__LocalityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__LocalityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__LocalityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__LocalityList %p -> %p\n", q, p));
	*(ent__LocalityList*)p = *(ent__LocalityList*)q;
}

void ent__DistrictList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__DistrictList::__sizedistrict = 0;
	this->ent__DistrictList::district = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__DistrictList::soap_serialize(struct soap *soap) const
{
	if(this->ent__DistrictList::district) {
		for(int i = 0; i < this->ent__DistrictList::__sizedistrict; i++) {
			soap_serialize_PointerToent__District(soap, this->ent__DistrictList::district + i);
		}
	}
	/* transient soap skipped */
}

int ent__DistrictList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__DistrictList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__DistrictList(struct soap *soap, const char *tag, int id, const ent__DistrictList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__DistrictList), "ent:DistrictList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__DistrictList::district) {
		int i;
		for(i = 0; i < a->ent__DistrictList::__sizedistrict; i++)
			if(soap_out_PointerToent__District(soap, "ent:district", -1, a->ent__DistrictList::district + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__DistrictList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__DistrictList(soap, tag, this, type);
}

SOAP_FMAC3 ent__DistrictList * FASTCALL soap_in_ent__DistrictList(struct soap *soap, const char *tag, ent__DistrictList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__DistrictList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__DistrictList, sizeof(ent__DistrictList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__DistrictList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__DistrictList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_district1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:district", 1, NULL)) {
				if(a->ent__DistrictList::district == NULL) {
					if(soap_blist_district1 == NULL)
						soap_blist_district1 = soap_new_block(soap);
					a->ent__DistrictList::district = (ent__District **)soap_push_block(soap, soap_blist_district1, sizeof(ent__District *));
					if(a->ent__DistrictList::district == NULL)
						return NULL;
					*a->ent__DistrictList::district = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__District(soap, "ent:district", a->ent__DistrictList::district, "ent:District"))
				{	a->ent__DistrictList::__sizedistrict++;
					a->ent__DistrictList::district = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__DistrictList::district)
			soap_pop_block(soap, soap_blist_district1);
		if(a->ent__DistrictList::__sizedistrict)
			a->ent__DistrictList::district = (ent__District **)soap_save_block(soap, soap_blist_district1, NULL, 1);
		else
		{	a->ent__DistrictList::district = NULL;
			if(soap_blist_district1)
				soap_end_block(soap, soap_blist_district1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__DistrictList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__DistrictList, 0, sizeof(ent__DistrictList), 0, soap_copy_ent__DistrictList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__DistrictList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__DistrictList);
	return this->soap_out(soap, tag?tag:"ent:DistrictList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__DistrictList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__DistrictList(soap, this, tag, type);
}

SOAP_FMAC3 ent__DistrictList * SOAP_FMAC4 soap_get_ent__DistrictList(struct soap *soap, ent__DistrictList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__DistrictList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__DistrictList * FASTCALL soap_instantiate_ent__DistrictList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__DistrictList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__DistrictList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__DistrictList);
		ASSIGN_PTR(size, sizeof(ent__DistrictList));
		((ent__DistrictList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__DistrictList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__DistrictList));
		for(int i = 0; i < n; i++)
			((ent__DistrictList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__DistrictList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__DistrictList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__DistrictList %p -> %p\n", q, p));
	*(ent__DistrictList*)p = *(ent__DistrictList*)q;
}

void ent__RegionList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__RegionList::__sizeregion = 0;
	this->ent__RegionList::region = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__RegionList::soap_serialize(struct soap *soap) const
{
	if(this->ent__RegionList::region) {
		for(int i = 0; i < this->ent__RegionList::__sizeregion; i++) {
			soap_serialize_PointerToent__Region(soap, this->ent__RegionList::region + i);
		}
	}
	/* transient soap skipped */
}

int ent__RegionList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__RegionList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__RegionList(struct soap *soap, const char *tag, int id, const ent__RegionList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__RegionList), "ent:RegionList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__RegionList::region) {
		int i;
		for(i = 0; i < a->ent__RegionList::__sizeregion; i++)
			if(soap_out_PointerToent__Region(soap, "ent:region", -1, a->ent__RegionList::region + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__RegionList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__RegionList(soap, tag, this, type);
}

SOAP_FMAC3 ent__RegionList * FASTCALL soap_in_ent__RegionList(struct soap *soap, const char *tag, ent__RegionList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__RegionList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__RegionList, sizeof(ent__RegionList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__RegionList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__RegionList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_region1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:region", 1, NULL)) {
				if(a->ent__RegionList::region == NULL) {
					if(soap_blist_region1 == NULL)
						soap_blist_region1 = soap_new_block(soap);
					a->ent__RegionList::region = (ent__Region **)soap_push_block(soap, soap_blist_region1, sizeof(ent__Region *));
					if(a->ent__RegionList::region == NULL)
						return NULL;
					*a->ent__RegionList::region = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Region(soap, "ent:region", a->ent__RegionList::region, "ent:Region"))
				{	a->ent__RegionList::__sizeregion++;
					a->ent__RegionList::region = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__RegionList::region)
			soap_pop_block(soap, soap_blist_region1);
		if(a->ent__RegionList::__sizeregion)
			a->ent__RegionList::region = (ent__Region **)soap_save_block(soap, soap_blist_region1, NULL, 1);
		else
		{	a->ent__RegionList::region = NULL;
			if(soap_blist_region1)
				soap_end_block(soap, soap_blist_region1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__RegionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__RegionList, 0, sizeof(ent__RegionList), 0, soap_copy_ent__RegionList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__RegionList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__RegionList);
	return this->soap_out(soap, tag?tag:"ent:RegionList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__RegionList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__RegionList(soap, this, tag, type);
}

SOAP_FMAC3 ent__RegionList * SOAP_FMAC4 soap_get_ent__RegionList(struct soap *soap, ent__RegionList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__RegionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__RegionList * FASTCALL soap_instantiate_ent__RegionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__RegionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__RegionList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__RegionList);
		ASSIGN_PTR(size, sizeof(ent__RegionList));
		((ent__RegionList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__RegionList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__RegionList));
		for(int i = 0; i < n; i++)
			((ent__RegionList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__RegionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__RegionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__RegionList %p -> %p\n", q, p));
	*(ent__RegionList*)p = *(ent__RegionList*)q;
}

void ent__CountryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__CountryList::__sizecountry = 0;
	this->ent__CountryList::country = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__CountryList::soap_serialize(struct soap *soap) const
{
	if(this->ent__CountryList::country) {
		for(int i = 0; i < this->ent__CountryList::__sizecountry; i++) {
			soap_serialize_PointerToent__Country(soap, this->ent__CountryList::country + i);
		}
	}
	/* transient soap skipped */
}

int ent__CountryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__CountryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__CountryList(struct soap *soap, const char *tag, int id, const ent__CountryList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__CountryList), "ent:CountryList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__CountryList::country) {
		int i;
		for(i = 0; i < a->ent__CountryList::__sizecountry; i++)
			if(soap_out_PointerToent__Country(soap, "ent:country", -1, a->ent__CountryList::country + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__CountryList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__CountryList(soap, tag, this, type);
}

SOAP_FMAC3 ent__CountryList * FASTCALL soap_in_ent__CountryList(struct soap *soap, const char *tag, ent__CountryList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__CountryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__CountryList, sizeof(ent__CountryList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__CountryList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__CountryList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_country1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:country", 1, NULL)) {
				if(a->ent__CountryList::country == NULL) {
					if(soap_blist_country1 == NULL)
						soap_blist_country1 = soap_new_block(soap);
					a->ent__CountryList::country = (ent__Country **)soap_push_block(soap, soap_blist_country1, sizeof(ent__Country *));
					if(a->ent__CountryList::country == NULL)
						return NULL;
					*a->ent__CountryList::country = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Country(soap, "ent:country", a->ent__CountryList::country, "ent:Country"))
				{	a->ent__CountryList::__sizecountry++;
					a->ent__CountryList::country = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__CountryList::country)
			soap_pop_block(soap, soap_blist_country1);
		if(a->ent__CountryList::__sizecountry)
			a->ent__CountryList::country = (ent__Country **)soap_save_block(soap, soap_blist_country1, NULL, 1);
		else
		{	a->ent__CountryList::country = NULL;
			if(soap_blist_country1)
				soap_end_block(soap, soap_blist_country1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__CountryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__CountryList, 0, sizeof(ent__CountryList), 0, soap_copy_ent__CountryList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__CountryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__CountryList);
	return this->soap_out(soap, tag?tag:"ent:CountryList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__CountryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__CountryList(soap, this, tag, type);
}

SOAP_FMAC3 ent__CountryList * SOAP_FMAC4 soap_get_ent__CountryList(struct soap *soap, ent__CountryList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__CountryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__CountryList * FASTCALL soap_instantiate_ent__CountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__CountryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__CountryList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__CountryList);
		ASSIGN_PTR(size, sizeof(ent__CountryList));
		((ent__CountryList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__CountryList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__CountryList));
		for(int i = 0; i < n; i++)
			((ent__CountryList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__CountryList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__CountryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__CountryList %p -> %p\n", q, p));
	*(ent__CountryList*)p = *(ent__CountryList*)q;
}

void ent__Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__Address::country = NULL;
	this->ent__Address::federalDistrict = NULL;
	this->ent__Address::region = NULL;
	this->ent__Address::district = NULL;
	this->ent__Address::locality = NULL;
	this->ent__Address::subLocality = NULL;
	this->ent__Address::street = NULL;
	soap_default_base__String255(soap, &this->ent__Address::house);
	soap_default_base__String255(soap, &this->ent__Address::building);
	soap_default_base__String255(soap, &this->ent__Address::room);
	soap_default_base__String255(soap, &this->ent__Address::postIndex);
	soap_default_base__String255(soap, &this->ent__Address::postBox);
	this->ent__Address::additionalInfo = NULL;
	this->ent__Address::addressView = NULL;
	this->ent__Address::enAddressView = NULL;
	/* transient soap skipped */
}

void ent__Address::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Country(soap, &this->ent__Address::country);
	soap_serialize_PointerToent__FederalDistrict(soap, &this->ent__Address::federalDistrict);
	soap_serialize_PointerToent__Region(soap, &this->ent__Address::region);
	soap_serialize_PointerToent__District(soap, &this->ent__Address::district);
	soap_serialize_PointerToent__Locality(soap, &this->ent__Address::locality);
	soap_serialize_PointerToent__Locality(soap, &this->ent__Address::subLocality);
	soap_serialize_PointerToent__Street(soap, &this->ent__Address::street);
	soap_serialize_base__String255(soap, &this->ent__Address::house);
	soap_serialize_base__String255(soap, &this->ent__Address::building);
	soap_serialize_base__String255(soap, &this->ent__Address::room);
	soap_serialize_base__String255(soap, &this->ent__Address::postIndex);
	soap_serialize_base__String255(soap, &this->ent__Address::postBox);
	soap_serialize_PointerTobase__NText(soap, &this->ent__Address::additionalInfo);
	soap_serialize_PointerTobase__NText(soap, &this->ent__Address::addressView);
	soap_serialize_PointerTobase__NText(soap, &this->ent__Address::enAddressView);
	/* transient soap skipped */
}

int ent__Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Address(struct soap *soap, const char *tag, int id, const ent__Address *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Address), type))
		return soap->error;
	if(soap_out_PointerToent__Country(soap, "ent:country", -1, &(a->ent__Address::country), ""))
		return soap->error;
	if(soap_out_PointerToent__FederalDistrict(soap, "ent:federalDistrict", -1, &(a->ent__Address::federalDistrict), ""))
		return soap->error;
	if(soap_out_PointerToent__Region(soap, "ent:region", -1, &(a->ent__Address::region), ""))
		return soap->error;
	if(soap_out_PointerToent__District(soap, "ent:district", -1, &(a->ent__Address::district), ""))
		return soap->error;
	if(soap_out_PointerToent__Locality(soap, "ent:locality", -1, &(a->ent__Address::locality), ""))
		return soap->error;
	if(soap_out_PointerToent__Locality(soap, "ent:subLocality", -1, &(a->ent__Address::subLocality), ""))
		return soap->error;
	if(soap_out_PointerToent__Street(soap, "ent:street", -1, &(a->ent__Address::street), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:house", -1, &(a->ent__Address::house), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:building", -1, &(a->ent__Address::building), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:room", -1, &(a->ent__Address::room), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:postIndex", -1, &(a->ent__Address::postIndex), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:postBox", -1, &(a->ent__Address::postBox), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "ent:additionalInfo", -1, &(a->ent__Address::additionalInfo), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "ent:addressView", -1, &(a->ent__Address::addressView), ""))
		return soap->error;
	if(soap_out_PointerTobase__NText(soap, "ent:enAddressView", -1, &(a->ent__Address::enAddressView), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ent__Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Address(soap, tag, this, type);
}

SOAP_FMAC3 ent__Address * FASTCALL soap_in_ent__Address(struct soap *soap, const char *tag, ent__Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Address, sizeof(ent__Address), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Address) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_country1 = 1;
	size_t soap_flag_federalDistrict1 = 1;
	size_t soap_flag_region1 = 1;
	size_t soap_flag_district1 = 1;
	size_t soap_flag_locality1 = 1;
	size_t soap_flag_subLocality1 = 1;
	size_t soap_flag_street1 = 1;
	size_t soap_flag_house1 = 1;
	size_t soap_flag_building1 = 1;
	size_t soap_flag_room1 = 1;
	size_t soap_flag_postIndex1 = 1;
	size_t soap_flag_postBox1 = 1;
	size_t soap_flag_additionalInfo1 = 1;
	size_t soap_flag_addressView1 = 1;
	size_t soap_flag_enAddressView1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Country(soap, "ent:country", &(a->ent__Address::country), "ent:Country"))
				{	soap_flag_country1--;
					continue;
				}
			if(soap_flag_federalDistrict1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__FederalDistrict(soap, "ent:federalDistrict", &(a->ent__Address::federalDistrict), "ent:FederalDistrict"))
				{	soap_flag_federalDistrict1--;
					continue;
				}
			if(soap_flag_region1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Region(soap, "ent:region", &(a->ent__Address::region), "ent:Region"))
				{	soap_flag_region1--;
					continue;
				}
			if(soap_flag_district1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__District(soap, "ent:district", &(a->ent__Address::district), "ent:District"))
				{	soap_flag_district1--;
					continue;
				}
			if(soap_flag_locality1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Locality(soap, "ent:locality", &(a->ent__Address::locality), "ent:Locality"))
				{	soap_flag_locality1--;
					continue;
				}
			if(soap_flag_subLocality1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Locality(soap, "ent:subLocality", &(a->ent__Address::subLocality), "ent:Locality"))
				{	soap_flag_subLocality1--;
					continue;
				}
			if(soap_flag_street1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Street(soap, "ent:street", &(a->ent__Address::street), "ent:Street"))
				{	soap_flag_street1--;
					continue;
				}
			if(soap_flag_house1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:house", &(a->ent__Address::house), "base:String255"))
				{	soap_flag_house1--;
					continue;
				}
			if(soap_flag_building1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:building", &(a->ent__Address::building), "base:String255"))
				{	soap_flag_building1--;
					continue;
				}
			if(soap_flag_room1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:room", &(a->ent__Address::room), "base:String255"))
				{	soap_flag_room1--;
					continue;
				}
			if(soap_flag_postIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:postIndex", &(a->ent__Address::postIndex), "base:String255"))
				{	soap_flag_postIndex1--;
					continue;
				}
			if(soap_flag_postBox1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:postBox", &(a->ent__Address::postBox), "base:String255"))
				{	soap_flag_postBox1--;
					continue;
				}
			if(soap_flag_additionalInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:additionalInfo", &(a->ent__Address::additionalInfo), "base:NText"))
				{	soap_flag_additionalInfo1--;
					continue;
				}
			if(soap_flag_addressView1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:addressView", &(a->ent__Address::addressView), "base:NText"))
				{	soap_flag_addressView1--;
					continue;
				}
			if(soap_flag_enAddressView1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__NText(soap, "ent:enAddressView", &(a->ent__Address::enAddressView), "base:NText"))
				{	soap_flag_enAddressView1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Address, 0, sizeof(ent__Address), 0, soap_copy_ent__Address);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Address);
	return this->soap_out(soap, tag?tag:"ent:Address", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Address(soap, this, tag, type);
}

SOAP_FMAC3 ent__Address * SOAP_FMAC4 soap_get_ent__Address(struct soap *soap, ent__Address *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Address(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Address * FASTCALL soap_instantiate_ent__Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Address, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ent:Area")) {
		cp->type = SOAP_TYPE_ent__Area;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Area);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Area));
			((ent__Area*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Area[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Area));
			for(int i = 0; i < n; i++)
				((ent__Area*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Area*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Address);
		ASSIGN_PTR(size, sizeof(ent__Address));
		((ent__Address*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Address[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Address));
		for(int i = 0; i < n; i++)
			((ent__Address*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Address*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Address %p -> %p\n", q, p));
	*(ent__Address*)p = *(ent__Address*)q;
}

void ent__Street::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->ent__Street::localityGuid);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_default_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	this->ent__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Street::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->ent__Street::localityGuid);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_serialize_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ent__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Street::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Street(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Street(struct soap *soap, const char *tag, int id, const ent__Street *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Street), "ent:Street"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:view", -1, &(a->ent__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ent:regionCode", -1, &(a->ent__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:type", -1, &(a->ent__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:countryGuid", -1, &(a->ent__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:hasStreets", -1, &(a->ent__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:localityGuid", -1, &(a->ent__Street::localityGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Street::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Street(soap, tag, this, type);
}

SOAP_FMAC3 ent__Street * FASTCALL soap_in_ent__Street(struct soap *soap, const char *tag, ent__Street *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Street *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Street, sizeof(ent__Street), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Street) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Street *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_localityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:view", &(a->ent__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ent:regionCode", &(a->ent__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:type", &(a->ent__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:countryGuid", &(a->ent__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:hasStreets", &(a->ent__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_localityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:localityGuid", &(a->ent__Street::localityGuid), "base:UUID"))
				{	soap_flag_localityGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Street *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Street, 0, sizeof(ent__Street), 0, soap_copy_ent__Street);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Street::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Street);
	return this->soap_out(soap, tag?tag:"ent:Street", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Street::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Street(soap, this, tag, type);
}

SOAP_FMAC3 ent__Street * SOAP_FMAC4 soap_get_ent__Street(struct soap *soap, ent__Street *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Street * FASTCALL soap_instantiate_ent__Street(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Street(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Street, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Street);
		ASSIGN_PTR(size, sizeof(ent__Street));
		((ent__Street*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Street[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Street));
		for(int i = 0; i < n; i++)
			((ent__Street*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Street*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Street(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Street %p -> %p\n", q, p));
	*(ent__Street*)p = *(ent__Street*)q;
}

void ent__Locality::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->ent__Locality::regionGuid);
	soap_default_base__UUID(soap, &this->ent__Locality::districtGuid);
	soap_default_base__UUID(soap, &this->ent__Locality::cityGuid);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_default_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	this->ent__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Locality::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->ent__Locality::regionGuid);
	soap_serialize_base__UUID(soap, &this->ent__Locality::districtGuid);
	soap_serialize_base__UUID(soap, &this->ent__Locality::cityGuid);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_serialize_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ent__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Locality::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Locality(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Locality(struct soap *soap, const char *tag, int id, const ent__Locality *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Locality), "ent:Locality"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:view", -1, &(a->ent__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ent:regionCode", -1, &(a->ent__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:type", -1, &(a->ent__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:countryGuid", -1, &(a->ent__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:hasStreets", -1, &(a->ent__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:regionGuid", -1, &(a->ent__Locality::regionGuid), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:districtGuid", -1, &(a->ent__Locality::districtGuid), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:cityGuid", -1, &(a->ent__Locality::cityGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Locality::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Locality(soap, tag, this, type);
}

SOAP_FMAC3 ent__Locality * FASTCALL soap_in_ent__Locality(struct soap *soap, const char *tag, ent__Locality *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Locality *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Locality, sizeof(ent__Locality), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Locality) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Locality *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_regionGuid1 = 1;
	size_t soap_flag_districtGuid1 = 1;
	size_t soap_flag_cityGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:view", &(a->ent__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ent:regionCode", &(a->ent__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:type", &(a->ent__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:countryGuid", &(a->ent__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:hasStreets", &(a->ent__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:regionGuid", &(a->ent__Locality::regionGuid), "base:UUID"))
				{	soap_flag_regionGuid1--;
					continue;
				}
			if(soap_flag_districtGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:districtGuid", &(a->ent__Locality::districtGuid), "base:UUID"))
				{	soap_flag_districtGuid1--;
					continue;
				}
			if(soap_flag_cityGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:cityGuid", &(a->ent__Locality::cityGuid), "base:UUID"))
				{	soap_flag_cityGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Locality *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Locality, 0, sizeof(ent__Locality), 0, soap_copy_ent__Locality);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Locality::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Locality);
	return this->soap_out(soap, tag?tag:"ent:Locality", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Locality::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Locality(soap, this, tag, type);
}

SOAP_FMAC3 ent__Locality * SOAP_FMAC4 soap_get_ent__Locality(struct soap *soap, ent__Locality *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Locality * FASTCALL soap_instantiate_ent__Locality(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Locality(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Locality, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Locality);
		ASSIGN_PTR(size, sizeof(ent__Locality));
		((ent__Locality*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Locality[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Locality));
		for(int i = 0; i < n; i++)
			((ent__Locality*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Locality*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Locality(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Locality %p -> %p\n", q, p));
	*(ent__Locality*)p = *(ent__Locality*)q;
}

void ent__District::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->ent__District::regionGuid);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_default_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	this->ent__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__District::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->ent__District::regionGuid);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_serialize_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ent__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__District::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__District(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__District(struct soap *soap, const char *tag, int id, const ent__District *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__District), "ent:District"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:view", -1, &(a->ent__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ent:regionCode", -1, &(a->ent__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:type", -1, &(a->ent__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:countryGuid", -1, &(a->ent__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:hasStreets", -1, &(a->ent__AddressObjectView::hasStreets), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:regionGuid", -1, &(a->ent__District::regionGuid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__District::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__District(soap, tag, this, type);
}

SOAP_FMAC3 ent__District * FASTCALL soap_in_ent__District(struct soap *soap, const char *tag, ent__District *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__District *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__District, sizeof(ent__District), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__District) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__District *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	size_t soap_flag_regionGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:view", &(a->ent__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ent:regionCode", &(a->ent__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:type", &(a->ent__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:countryGuid", &(a->ent__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:hasStreets", &(a->ent__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap_flag_regionGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:regionGuid", &(a->ent__District::regionGuid), "base:UUID"))
				{	soap_flag_regionGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__District *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__District, 0, sizeof(ent__District), 0, soap_copy_ent__District);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__District::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__District);
	return this->soap_out(soap, tag?tag:"ent:District", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__District::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__District(soap, this, tag, type);
}

SOAP_FMAC3 ent__District * SOAP_FMAC4 soap_get_ent__District(struct soap *soap, ent__District *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__District * FASTCALL soap_instantiate_ent__District(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__District(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__District, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__District);
		ASSIGN_PTR(size, sizeof(ent__District));
		((ent__District*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__District[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__District));
		for(int i = 0; i < n; i++)
			((ent__District*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__District*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__District(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__District %p -> %p\n", q, p));
	*(ent__District*)p = *(ent__District*)q;
}

void ent__Region::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_default_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	this->ent__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Region::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_serialize_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ent__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Region::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Region(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Region(struct soap *soap, const char *tag, int id, const ent__Region *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Region), "ent:Region"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:view", -1, &(a->ent__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ent:regionCode", -1, &(a->ent__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:type", -1, &(a->ent__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:countryGuid", -1, &(a->ent__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:hasStreets", -1, &(a->ent__AddressObjectView::hasStreets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Region::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Region(soap, tag, this, type);
}

SOAP_FMAC3 ent__Region * FASTCALL soap_in_ent__Region(struct soap *soap, const char *tag, ent__Region *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Region *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Region, sizeof(ent__Region), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Region) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Region *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid4 = 1;
	size_t soap_flag_guid3 = 1;
	size_t soap_flag_active3 = 1;
	size_t soap_flag_last3 = 1;
	size_t soap_flag_status3 = 1;
	size_t soap_flag_createDate3 = 1;
	size_t soap_flag_updateDate3 = 1;
	size_t soap_flag_previous3 = 1;
	size_t soap_flag_next3 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_englishName2 = 1;
	size_t soap_flag_view2 = 1;
	size_t soap_flag_regionCode2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_countryGuid2 = 1;
	size_t soap_flag_hasStreets2 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid4--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid3--;
					continue;
				}
			if(soap_flag_active3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active3--;
					continue;
				}
			if(soap_flag_last3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last3--;
					continue;
				}
			if(soap_flag_status3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status3--;
					continue;
				}
			if(soap_flag_createDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate3--;
					continue;
				}
			if(soap_flag_updateDate3 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate3--;
					continue;
				}
			if(soap_flag_previous3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous3--;
					continue;
				}
			if(soap_flag_next3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next3--;
					continue;
				}
			if(soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__AddressObjectView::name), "base:String255"))
				{	soap_flag_name2--;
					continue;
				}
			if(soap_flag_englishName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName2--;
					continue;
				}
			if(soap_flag_view2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:view", &(a->ent__AddressObjectView::view), "base:String255"))
				{	soap_flag_view2--;
					continue;
				}
			if(soap_flag_regionCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ent:regionCode", &(a->ent__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode2--;
					continue;
				}
			if(soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:type", &(a->ent__AddressObjectView::type), "base:String255"))
				{	soap_flag_type2--;
					continue;
				}
			if(soap_flag_countryGuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:countryGuid", &(a->ent__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid2--;
					continue;
				}
			if(soap_flag_hasStreets2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:hasStreets", &(a->ent__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Region *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Region, 0, sizeof(ent__Region), 0, soap_copy_ent__Region);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Region::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Region);
	return this->soap_out(soap, tag?tag:"ent:Region", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Region::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Region(soap, this, tag, type);
}

SOAP_FMAC3 ent__Region * SOAP_FMAC4 soap_get_ent__Region(struct soap *soap, ent__Region *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Region * FASTCALL soap_instantiate_ent__Region(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Region(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Region, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Region);
		ASSIGN_PTR(size, sizeof(ent__Region));
		((ent__Region*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Region[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Region));
		for(int i = 0; i < n; i++)
			((ent__Region*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Region*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Region(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Region %p -> %p\n", q, p));
	*(ent__Region*)p = *(ent__Region*)q;
}

void ent__AddressObjectView::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_default_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_default_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_default_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	this->ent__AddressObjectView::hasStreets = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__AddressObjectView::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::name);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::englishName);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::view);
	soap_serialize_string(soap, &this->ent__AddressObjectView::regionCode);
	soap_serialize_base__String255(soap, &this->ent__AddressObjectView::type);
	soap_serialize_base__UUID(soap, &this->ent__AddressObjectView::countryGuid);
	soap_serialize_PointerTobool(soap, &this->ent__AddressObjectView::hasStreets);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__AddressObjectView::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__AddressObjectView(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__AddressObjectView(struct soap *soap, const char *tag, int id, const ent__AddressObjectView *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__AddressObjectView), "ent:AddressObjectView"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__AddressObjectView::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__AddressObjectView::englishName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:view", -1, &(a->ent__AddressObjectView::view), ""))
		return soap->error;
	if(soap_out_string(soap, "ent:regionCode", -1, &(a->ent__AddressObjectView::regionCode), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:type", -1, &(a->ent__AddressObjectView::type), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:countryGuid", -1, &(a->ent__AddressObjectView::countryGuid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:hasStreets", -1, &(a->ent__AddressObjectView::hasStreets), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__AddressObjectView::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__AddressObjectView(soap, tag, this, type);
}

SOAP_FMAC3 ent__AddressObjectView * FASTCALL soap_in_ent__AddressObjectView(struct soap *soap, const char *tag, ent__AddressObjectView *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__AddressObjectView *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__AddressObjectView, sizeof(ent__AddressObjectView), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__AddressObjectView) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__AddressObjectView *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_view1 = 1;
	size_t soap_flag_regionCode1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_countryGuid1 = 1;
	size_t soap_flag_hasStreets1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__AddressObjectView::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__AddressObjectView::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_view1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:view", &(a->ent__AddressObjectView::view), "base:String255"))
				{	soap_flag_view1--;
					continue;
				}
			if(soap_flag_regionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "ent:regionCode", &(a->ent__AddressObjectView::regionCode), "xsd:string"))
				{	soap_flag_regionCode1--;
					continue;
				}
			if(soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:type", &(a->ent__AddressObjectView::type), "base:String255"))
				{	soap_flag_type1--;
					continue;
				}
			if(soap_flag_countryGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:countryGuid", &(a->ent__AddressObjectView::countryGuid), "base:UUID"))
				{	soap_flag_countryGuid1--;
					continue;
				}
			if(soap_flag_hasStreets1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:hasStreets", &(a->ent__AddressObjectView::hasStreets), "xsd:boolean"))
				{	soap_flag_hasStreets1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__AddressObjectView *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__AddressObjectView, 0, sizeof(ent__AddressObjectView), 0, soap_copy_ent__AddressObjectView);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__AddressObjectView::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__AddressObjectView);
	return this->soap_out(soap, tag?tag:"ent:AddressObjectView", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__AddressObjectView::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__AddressObjectView(soap, this, tag, type);
}

SOAP_FMAC3 ent__AddressObjectView * SOAP_FMAC4 soap_get_ent__AddressObjectView(struct soap *soap, ent__AddressObjectView *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__AddressObjectView(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__AddressObjectView * FASTCALL soap_instantiate_ent__AddressObjectView(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__AddressObjectView(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__AddressObjectView, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ent:Region")) {
		cp->type = SOAP_TYPE_ent__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Region));
			((ent__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Region[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Region));
			for(int i = 0; i < n; i++)
				((ent__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:District")) {
		cp->type = SOAP_TYPE_ent__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__District));
			((ent__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__District[n]);
			ASSIGN_PTR(size, n * sizeof(ent__District));
			for(int i = 0; i < n; i++)
				((ent__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Locality")) {
		cp->type = SOAP_TYPE_ent__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Locality));
			((ent__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Locality));
			for(int i = 0; i < n; i++)
				((ent__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Street")) {
		cp->type = SOAP_TYPE_ent__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Street));
			((ent__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Street[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Street));
			for(int i = 0; i < n; i++)
				((ent__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Street*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__AddressObjectView);
		ASSIGN_PTR(size, sizeof(ent__AddressObjectView));
		((ent__AddressObjectView*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__AddressObjectView[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__AddressObjectView));
		for(int i = 0; i < n; i++)
			((ent__AddressObjectView*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__AddressObjectView*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__AddressObjectView(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__AddressObjectView %p -> %p\n", q, p));
	*(ent__AddressObjectView*)p = *(ent__AddressObjectView*)q;
}

void ent__FederalDistrict::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__FederalDistrict::fullName);
	soap_default_base__String255(soap, &this->ent__FederalDistrict::shortName);
	soap_default_base__String255(soap, &this->ent__FederalDistrict::abbreviation);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__FederalDistrict::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__FederalDistrict::fullName);
	soap_serialize_base__String255(soap, &this->ent__FederalDistrict::shortName);
	soap_serialize_base__String255(soap, &this->ent__FederalDistrict::abbreviation);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__FederalDistrict::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__FederalDistrict(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__FederalDistrict(struct soap *soap, const char *tag, int id, const ent__FederalDistrict *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__FederalDistrict), "ent:FederalDistrict"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:fullName", -1, &(a->ent__FederalDistrict::fullName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:shortName", -1, &(a->ent__FederalDistrict::shortName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:abbreviation", -1, &(a->ent__FederalDistrict::abbreviation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__FederalDistrict::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__FederalDistrict(soap, tag, this, type);
}

SOAP_FMAC3 ent__FederalDistrict * FASTCALL soap_in_ent__FederalDistrict(struct soap *soap, const char *tag, ent__FederalDistrict *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__FederalDistrict *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__FederalDistrict, sizeof(ent__FederalDistrict), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__FederalDistrict) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__FederalDistrict *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_abbreviation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:fullName", &(a->ent__FederalDistrict::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:shortName", &(a->ent__FederalDistrict::shortName), "base:String255"))
				{	soap_flag_shortName1--;
					continue;
				}
			if(soap_flag_abbreviation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:abbreviation", &(a->ent__FederalDistrict::abbreviation), "base:String255"))
				{	soap_flag_abbreviation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__FederalDistrict *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__FederalDistrict, 0, sizeof(ent__FederalDistrict), 0, soap_copy_ent__FederalDistrict);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__FederalDistrict::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__FederalDistrict);
	return this->soap_out(soap, tag?tag:"ent:FederalDistrict", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__FederalDistrict::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__FederalDistrict(soap, this, tag, type);
}

SOAP_FMAC3 ent__FederalDistrict * SOAP_FMAC4 soap_get_ent__FederalDistrict(struct soap *soap, ent__FederalDistrict *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__FederalDistrict(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__FederalDistrict * FASTCALL soap_instantiate_ent__FederalDistrict(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__FederalDistrict(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__FederalDistrict, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__FederalDistrict);
		ASSIGN_PTR(size, sizeof(ent__FederalDistrict));
		((ent__FederalDistrict*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__FederalDistrict[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__FederalDistrict));
		for(int i = 0; i < n; i++)
			((ent__FederalDistrict*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__FederalDistrict*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__FederalDistrict(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__FederalDistrict %p -> %p\n", q, p));
	*(ent__FederalDistrict*)p = *(ent__FederalDistrict*)q;
}

void ent__Country::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Country::name);
	soap_default_base__String255(soap, &this->ent__Country::fullName);
	soap_default_base__String255(soap, &this->ent__Country::englishName);
	soap_default_ent__Code(soap, &this->ent__Country::code);
	soap_default_ent__Code3(soap, &this->ent__Country::code3);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Country::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Country::name);
	soap_serialize_base__String255(soap, &this->ent__Country::fullName);
	soap_serialize_base__String255(soap, &this->ent__Country::englishName);
	soap_serialize_ent__Code(soap, &this->ent__Country::code);
	soap_serialize_ent__Code3(soap, &this->ent__Country::code3);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Country::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Country(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Country(struct soap *soap, const char *tag, int id, const ent__Country *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Country), "ent:Country"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Country::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:fullName", -1, &(a->ent__Country::fullName), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:englishName", -1, &(a->ent__Country::englishName), ""))
		return soap->error;
	if(soap_out_ent__Code(soap, "ent:code", -1, &(a->ent__Country::code), ""))
		return soap->error;
	if(soap_out_ent__Code3(soap, "ent:code3", -1, &(a->ent__Country::code3), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Country::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Country(soap, tag, this, type);
}

SOAP_FMAC3 ent__Country * FASTCALL soap_in_ent__Country(struct soap *soap, const char *tag, ent__Country *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Country *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Country, sizeof(ent__Country), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Country) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Country *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_englishName1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_code31 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Country::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:fullName", &(a->ent__Country::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_englishName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:englishName", &(a->ent__Country::englishName), "base:String255"))
				{	soap_flag_englishName1--;
					continue;
				}
			if(soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__Code(soap, "ent:code", &(a->ent__Country::code), "ent:Code"))
				{	soap_flag_code1--;
					continue;
				}
			if(soap_flag_code31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_ent__Code3(soap, "ent:code3", &(a->ent__Country::code3), "ent:Code3"))
				{	soap_flag_code31--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Country *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Country, 0, sizeof(ent__Country), 0, soap_copy_ent__Country);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Country::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Country);
	return this->soap_out(soap, tag?tag:"ent:Country", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Country::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Country(soap, this, tag, type);
}

SOAP_FMAC3 ent__Country * SOAP_FMAC4 soap_get_ent__Country(struct soap *soap, ent__Country *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Country * FASTCALL soap_instantiate_ent__Country(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Country(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Country, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Country);
		ASSIGN_PTR(size, sizeof(ent__Country));
		((ent__Country*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Country[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Country));
		for(int i = 0; i < n; i++)
			((ent__Country*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Country*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Country(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Country %p -> %p\n", q, p));
	*(ent__Country*)p = *(ent__Country*)q;
}

void ent__UnitList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__UnitList::__sizeunit = 0;
	this->ent__UnitList::unit = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__UnitList::soap_serialize(struct soap *soap) const
{
	if(this->ent__UnitList::unit) {
		for(int i = 0; i < this->ent__UnitList::__sizeunit; i++) {
			soap_serialize_PointerToent__Unit(soap, this->ent__UnitList::unit + i);
		}
	}
	/* transient soap skipped */
}

int ent__UnitList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__UnitList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__UnitList(struct soap *soap, const char *tag, int id, const ent__UnitList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__UnitList), "ent:UnitList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__UnitList::unit) {
		int i;
		for(i = 0; i < a->ent__UnitList::__sizeunit; i++)
			if(soap_out_PointerToent__Unit(soap, "ent:unit", -1, a->ent__UnitList::unit + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__UnitList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__UnitList(soap, tag, this, type);
}

SOAP_FMAC3 ent__UnitList * FASTCALL soap_in_ent__UnitList(struct soap *soap, const char *tag, ent__UnitList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__UnitList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__UnitList, sizeof(ent__UnitList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__UnitList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__UnitList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_unit1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:unit", 1, NULL)) {
				if(a->ent__UnitList::unit == NULL) {
					if(soap_blist_unit1 == NULL)
						soap_blist_unit1 = soap_new_block(soap);
					a->ent__UnitList::unit = (ent__Unit **)soap_push_block(soap, soap_blist_unit1, sizeof(ent__Unit *));
					if(a->ent__UnitList::unit == NULL)
						return NULL;
					*a->ent__UnitList::unit = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Unit(soap, "ent:unit", a->ent__UnitList::unit, "ent:Unit"))
				{	a->ent__UnitList::__sizeunit++;
					a->ent__UnitList::unit = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__UnitList::unit)
			soap_pop_block(soap, soap_blist_unit1);
		if(a->ent__UnitList::__sizeunit)
			a->ent__UnitList::unit = (ent__Unit **)soap_save_block(soap, soap_blist_unit1, NULL, 1);
		else
		{	a->ent__UnitList::unit = NULL;
			if(soap_blist_unit1)
				soap_end_block(soap, soap_blist_unit1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__UnitList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__UnitList, 0, sizeof(ent__UnitList), 0, soap_copy_ent__UnitList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__UnitList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__UnitList);
	return this->soap_out(soap, tag?tag:"ent:UnitList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__UnitList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__UnitList(soap, this, tag, type);
}

SOAP_FMAC3 ent__UnitList * SOAP_FMAC4 soap_get_ent__UnitList(struct soap *soap, ent__UnitList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__UnitList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__UnitList * FASTCALL soap_instantiate_ent__UnitList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__UnitList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__UnitList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__UnitList);
		ASSIGN_PTR(size, sizeof(ent__UnitList));
		((ent__UnitList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__UnitList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__UnitList));
		for(int i = 0; i < n; i++)
			((ent__UnitList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__UnitList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__UnitList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__UnitList %p -> %p\n", q, p));
	*(ent__UnitList*)p = *(ent__UnitList*)q;
}

void ent__PurposeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__PurposeList::__sizepurpose = 0;
	this->ent__PurposeList::purpose = NULL;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void ent__PurposeList::soap_serialize(struct soap *soap) const
{
	if(this->ent__PurposeList::purpose) {
		for(int i = 0; i < this->ent__PurposeList::__sizepurpose; i++) {
			soap_serialize_PointerToent__Purpose(soap, this->ent__PurposeList::purpose + i);
		}
	}
	/* transient soap skipped */
}

int ent__PurposeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__PurposeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__PurposeList(struct soap *soap, const char *tag, int id, const ent__PurposeList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__PurposeList), "ent:PurposeList"))
		return soap->error;
	/* transient soap skipped */
	if(a->ent__PurposeList::purpose) {
		int i;
		for(i = 0; i < a->ent__PurposeList::__sizepurpose; i++)
			if(soap_out_PointerToent__Purpose(soap, "ent:purpose", -1, a->ent__PurposeList::purpose + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ent__PurposeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__PurposeList(soap, tag, this, type);
}

SOAP_FMAC3 ent__PurposeList * FASTCALL soap_in_ent__PurposeList(struct soap *soap, const char *tag, ent__PurposeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__PurposeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__PurposeList, sizeof(ent__PurposeList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__PurposeList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__PurposeList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist_purpose1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:purpose", 1, NULL)) {
				if(a->ent__PurposeList::purpose == NULL) {
					if(soap_blist_purpose1 == NULL)
						soap_blist_purpose1 = soap_new_block(soap);
					a->ent__PurposeList::purpose = (ent__Purpose **)soap_push_block(soap, soap_blist_purpose1, sizeof(ent__Purpose *));
					if(a->ent__PurposeList::purpose == NULL)
						return NULL;
					*a->ent__PurposeList::purpose = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Purpose(soap, "ent:purpose", a->ent__PurposeList::purpose, "ent:Purpose"))
				{	a->ent__PurposeList::__sizepurpose++;
					a->ent__PurposeList::purpose = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->ent__PurposeList::purpose)
			soap_pop_block(soap, soap_blist_purpose1);
		if(a->ent__PurposeList::__sizepurpose)
			a->ent__PurposeList::purpose = (ent__Purpose **)soap_save_block(soap, soap_blist_purpose1, NULL, 1);
		else
		{	a->ent__PurposeList::purpose = NULL;
			if(soap_blist_purpose1)
				soap_end_block(soap, soap_blist_purpose1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__PurposeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__PurposeList, 0, sizeof(ent__PurposeList), 0, soap_copy_ent__PurposeList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__PurposeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__PurposeList);
	return this->soap_out(soap, tag?tag:"ent:PurposeList", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__PurposeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__PurposeList(soap, this, tag, type);
}

SOAP_FMAC3 ent__PurposeList * SOAP_FMAC4 soap_get_ent__PurposeList(struct soap *soap, ent__PurposeList *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__PurposeList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__PurposeList * FASTCALL soap_instantiate_ent__PurposeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__PurposeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__PurposeList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__PurposeList);
		ASSIGN_PTR(size, sizeof(ent__PurposeList));
		((ent__PurposeList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__PurposeList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__PurposeList));
		for(int i = 0; i < n; i++)
			((ent__PurposeList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__PurposeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__PurposeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__PurposeList %p -> %p\n", q, p));
	*(ent__PurposeList*)p = *(ent__PurposeList*)q;
}

void ent__PackingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ent__PackingType::globalID = NULL;
	soap_default_base__String255(soap, &this->ent__PackingType::name);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__PackingType::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__PackingCodeType(soap, &this->ent__PackingType::globalID);
	soap_serialize_base__String255(soap, &this->ent__PackingType::name);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__PackingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__PackingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__PackingType(struct soap *soap, const char *tag, int id, const ent__PackingType *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__PackingType), "ent:PackingType"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_PointerToent__PackingCodeType(soap, "ent:globalID", -1, &(a->ent__PackingType::globalID), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__PackingType::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__PackingType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__PackingType(soap, tag, this, type);
}

SOAP_FMAC3 ent__PackingType * FASTCALL soap_in_ent__PackingType(struct soap *soap, const char *tag, ent__PackingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__PackingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__PackingType, sizeof(ent__PackingType), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__PackingType) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__PackingType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_globalID1 = 1;
	size_t soap_flag_name1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_globalID1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__PackingCodeType(soap, "ent:globalID", &(a->ent__PackingType::globalID), "ent:PackingCodeType"))
				{	soap_flag_globalID1--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__PackingType::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__PackingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__PackingType, 0, sizeof(ent__PackingType), 0, soap_copy_ent__PackingType);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__PackingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__PackingType);
	return this->soap_out(soap, tag?tag:"ent:PackingType", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__PackingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__PackingType(soap, this, tag, type);
}

SOAP_FMAC3 ent__PackingType * SOAP_FMAC4 soap_get_ent__PackingType(struct soap *soap, ent__PackingType *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__PackingType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__PackingType * FASTCALL soap_instantiate_ent__PackingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__PackingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__PackingType, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__PackingType);
		ASSIGN_PTR(size, sizeof(ent__PackingType));
		((ent__PackingType*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__PackingType[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__PackingType));
		for(int i = 0; i < n; i++)
			((ent__PackingType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__PackingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__PackingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__PackingType %p -> %p\n", q, p));
	*(ent__PackingType*)p = *(ent__PackingType*)q;
}

void ent__Unit::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Unit::name);
	soap_default_base__String255(soap, &this->ent__Unit::fullName);
	soap_default_base__UUID(soap, &this->ent__Unit::commonUnitGuid);
	soap_default_xsd__integer(soap, &this->ent__Unit::factor);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Unit::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Unit::name);
	soap_serialize_base__String255(soap, &this->ent__Unit::fullName);
	soap_serialize_base__UUID(soap, &this->ent__Unit::commonUnitGuid);
	soap_serialize_xsd__integer(soap, &this->ent__Unit::factor);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Unit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Unit(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Unit(struct soap *soap, const char *tag, int id, const ent__Unit *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Unit), "ent:Unit"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Unit::name), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:fullName", -1, &(a->ent__Unit::fullName), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "ent:commonUnitGuid", -1, &(a->ent__Unit::commonUnitGuid), ""))
		return soap->error;
	if(soap_out_xsd__integer(soap, "ent:factor", -1, &(a->ent__Unit::factor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Unit::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Unit(soap, tag, this, type);
}

SOAP_FMAC3 ent__Unit * FASTCALL soap_in_ent__Unit(struct soap *soap, const char *tag, ent__Unit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Unit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Unit, sizeof(ent__Unit), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Unit) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Unit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_commonUnitGuid1 = 1;
	size_t soap_flag_factor1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Unit::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:fullName", &(a->ent__Unit::fullName), "base:String255"))
				{	soap_flag_fullName1--;
					continue;
				}
			if(soap_flag_commonUnitGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:commonUnitGuid", &(a->ent__Unit::commonUnitGuid), "base:UUID"))
				{	soap_flag_commonUnitGuid1--;
					continue;
				}
			if(soap_flag_factor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__integer(soap, "ent:factor", &(a->ent__Unit::factor), "xsd:integer"))
				{	soap_flag_factor1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Unit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Unit, 0, sizeof(ent__Unit), 0, soap_copy_ent__Unit);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Unit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Unit);
	return this->soap_out(soap, tag?tag:"ent:Unit", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Unit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Unit(soap, this, tag, type);
}

SOAP_FMAC3 ent__Unit * SOAP_FMAC4 soap_get_ent__Unit(struct soap *soap, ent__Unit *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Unit * FASTCALL soap_instantiate_ent__Unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Unit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Unit, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Unit);
		ASSIGN_PTR(size, sizeof(ent__Unit));
		((ent__Unit*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Unit[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Unit));
		for(int i = 0; i < n; i++)
			((ent__Unit*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Unit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Unit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Unit %p -> %p\n", q, p));
	*(ent__Unit*)p = *(ent__Unit*)q;
}

void ent__Purpose::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__String255(soap, &this->ent__Purpose::name);
	this->ent__Purpose::forSubstandard = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void ent__Purpose::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__String255(soap, &this->ent__Purpose::name);
	soap_serialize_PointerTobool(soap, &this->ent__Purpose::forSubstandard);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int ent__Purpose::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ent__Purpose(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Purpose(struct soap *soap, const char *tag, int id, const ent__Purpose *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__Purpose), "ent:Purpose"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	if(soap_out_base__String255(soap, "ent:name", -1, &(a->ent__Purpose::name), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "ent:forSubstandard", -1, &(a->ent__Purpose::forSubstandard), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ent__Purpose::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ent__Purpose(soap, tag, this, type);
}

SOAP_FMAC3 ent__Purpose * FASTCALL soap_in_ent__Purpose(struct soap *soap, const char *tag, ent__Purpose *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ent__Purpose *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ent__Purpose, sizeof(ent__Purpose), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_ent__Purpose) {
			soap_revert(soap);
			*soap->id = '\0';
			return (ent__Purpose *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid3 = 1;
	size_t soap_flag_guid2 = 1;
	size_t soap_flag_active2 = 1;
	size_t soap_flag_last2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_updateDate2 = 1;
	size_t soap_flag_previous2 = 1;
	size_t soap_flag_next2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_forSubstandard1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid3--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid2--;
					continue;
				}
			if(soap_flag_active2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active2--;
					continue;
				}
			if(soap_flag_last2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last2--;
					continue;
				}
			if(soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status2--;
					continue;
				}
			if(soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if(soap_flag_updateDate2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate2--;
					continue;
				}
			if(soap_flag_previous2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous2--;
					continue;
				}
			if(soap_flag_next2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next2--;
					continue;
				}
			if(soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__String255(soap, "ent:name", &(a->ent__Purpose::name), "base:String255"))
				{	soap_flag_name1--;
					continue;
				}
			if(soap_flag_forSubstandard1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "ent:forSubstandard", &(a->ent__Purpose::forSubstandard), "xsd:boolean"))
				{	soap_flag_forSubstandard1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (ent__Purpose *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__Purpose, 0, sizeof(ent__Purpose), 0, soap_copy_ent__Purpose);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ent__Purpose::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ent__Purpose);
	return this->soap_out(soap, tag?tag:"ent:Purpose", id, type) ? soap->error : soap_putindependent(soap);
}

void *ent__Purpose::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ent__Purpose(soap, this, tag, type);
}

SOAP_FMAC3 ent__Purpose * SOAP_FMAC4 soap_get_ent__Purpose(struct soap *soap, ent__Purpose *p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ent__Purpose * FASTCALL soap_instantiate_ent__Purpose(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ent__Purpose(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ent__Purpose, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(ent__Purpose);
		ASSIGN_PTR(size, sizeof(ent__Purpose));
		((ent__Purpose*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(ent__Purpose[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(ent__Purpose));
		for(int i = 0; i < n; i++)
			((ent__Purpose*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ent__Purpose*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ent__Purpose(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ent__Purpose %p -> %p\n", q, p));
	*(ent__Purpose*)p = *(ent__Purpose*)q;
}

void merc__GetAppliedUserAuthorityListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetAppliedUserAuthorityListResponse::vd__authorityList = NULL;
	/* transient soap skipped */
}

void merc__GetAppliedUserAuthorityListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__AuthorityList(soap, &this->merc__GetAppliedUserAuthorityListResponse::vd__authorityList);
	/* transient soap skipped */
}

int merc__GetAppliedUserAuthorityListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetAppliedUserAuthorityListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, int id, const merc__GetAppliedUserAuthorityListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse), "merc:GetAppliedUserAuthorityListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__authorityList)
		soap_element_result(soap, "vd:authorityList");
	if(soap_out_PointerTovd__AuthorityList(soap, "vd:authorityList", -1, &(a->merc__GetAppliedUserAuthorityListResponse::vd__authorityList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetAppliedUserAuthorityListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetAppliedUserAuthorityListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListResponse * FASTCALL soap_in_merc__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, merc__GetAppliedUserAuthorityListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetAppliedUserAuthorityListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse, sizeof(merc__GetAppliedUserAuthorityListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetAppliedUserAuthorityListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__authorityList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__authorityList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__AuthorityList(soap, "vd:authorityList", &(a->merc__GetAppliedUserAuthorityListResponse::vd__authorityList), "vd:AuthorityList"))
				{	soap_flag_vd__authorityList1--;
					continue;
				}
			soap_check_result(soap, "vd:authorityList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetAppliedUserAuthorityListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse, 0, sizeof(merc__GetAppliedUserAuthorityListResponse), 0, soap_copy_merc__GetAppliedUserAuthorityListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__GetAppliedUserAuthorityListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetAppliedUserAuthorityListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetAppliedUserAuthorityListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetAppliedUserAuthorityListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListResponse * SOAP_FMAC4 soap_get_merc__GetAppliedUserAuthorityListResponse(struct soap *soap, merc__GetAppliedUserAuthorityListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetAppliedUserAuthorityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetAppliedUserAuthorityListResponse * FASTCALL soap_instantiate_merc__GetAppliedUserAuthorityListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetAppliedUserAuthorityListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetAppliedUserAuthorityListResponse));
		((merc__GetAppliedUserAuthorityListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetAppliedUserAuthorityListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetAppliedUserAuthorityListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetAppliedUserAuthorityListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetAppliedUserAuthorityListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetAppliedUserAuthorityListResponse %p -> %p\n", q, p));
	*(merc__GetAppliedUserAuthorityListResponse*)p = *(merc__GetAppliedUserAuthorityListResponse*)q;
}

void merc__GetAppliedUserAuthorityListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetAppliedUserAuthorityListRequest::base__listOptions = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetAppliedUserAuthorityListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetAppliedUserAuthorityListRequest::base__listOptions);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetAppliedUserAuthorityListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetAppliedUserAuthorityListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, int id, const merc__GetAppliedUserAuthorityListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest), "merc:GetAppliedUserAuthorityListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetAppliedUserAuthorityListRequest::base__listOptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetAppliedUserAuthorityListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetAppliedUserAuthorityListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListRequest * FASTCALL soap_in_merc__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, merc__GetAppliedUserAuthorityListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetAppliedUserAuthorityListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest, sizeof(merc__GetAppliedUserAuthorityListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetAppliedUserAuthorityListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetAppliedUserAuthorityListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetAppliedUserAuthorityListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest, 0, sizeof(merc__GetAppliedUserAuthorityListRequest), 0, soap_copy_merc__GetAppliedUserAuthorityListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetAppliedUserAuthorityListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetAppliedUserAuthorityListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetAppliedUserAuthorityListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetAppliedUserAuthorityListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListRequest * SOAP_FMAC4 soap_get_merc__GetAppliedUserAuthorityListRequest(struct soap *soap, merc__GetAppliedUserAuthorityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetAppliedUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetAppliedUserAuthorityListRequest * FASTCALL soap_instantiate_merc__GetAppliedUserAuthorityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetAppliedUserAuthorityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetAppliedUserAuthorityListRequest));
		((merc__GetAppliedUserAuthorityListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetAppliedUserAuthorityListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetAppliedUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetAppliedUserAuthorityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetAppliedUserAuthorityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetAppliedUserAuthorityListRequest %p -> %p\n", q, p));
	*(merc__GetAppliedUserAuthorityListRequest*)p = *(merc__GetAppliedUserAuthorityListRequest*)q;
}

void merc__UnbindBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UnbindBusinessEntityUserResponse::__sizeuser = 0;
	this->merc__UnbindBusinessEntityUserResponse::vd__user = NULL;
	/* transient soap skipped */
}

void merc__UnbindBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__UnbindBusinessEntityUserResponse::vd__user) {
		for(int i = 0; i < this->merc__UnbindBusinessEntityUserResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__UnbindBusinessEntityUserResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int merc__UnbindBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UnbindBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const merc__UnbindBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse), "merc:UnbindBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->merc__UnbindBusinessEntityUserResponse::vd__user) {
		int i;
		for(i = 0; i < a->merc__UnbindBusinessEntityUserResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__UnbindBusinessEntityUserResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UnbindBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UnbindBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserResponse * FASTCALL soap_in_merc__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, merc__UnbindBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UnbindBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse, sizeof(merc__UnbindBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UnbindBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UnbindBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__UnbindBusinessEntityUserResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__UnbindBusinessEntityUserResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__UnbindBusinessEntityUserResponse::vd__user == NULL)
						return NULL;
					*a->merc__UnbindBusinessEntityUserResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__UnbindBusinessEntityUserResponse::vd__user, "vd:User"))
				{	a->merc__UnbindBusinessEntityUserResponse::__sizeuser++;
					a->merc__UnbindBusinessEntityUserResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UnbindBusinessEntityUserResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__UnbindBusinessEntityUserResponse::__sizeuser)
			a->merc__UnbindBusinessEntityUserResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__UnbindBusinessEntityUserResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UnbindBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse, 0, sizeof(merc__UnbindBusinessEntityUserResponse), 0, soap_copy_merc__UnbindBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__UnbindBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"merc:UnbindBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UnbindBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UnbindBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserResponse * SOAP_FMAC4 soap_get_merc__UnbindBusinessEntityUserResponse(struct soap *soap, merc__UnbindBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UnbindBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UnbindBusinessEntityUserResponse * FASTCALL soap_instantiate_merc__UnbindBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UnbindBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(merc__UnbindBusinessEntityUserResponse));
		((merc__UnbindBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UnbindBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((merc__UnbindBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UnbindBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UnbindBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UnbindBusinessEntityUserResponse %p -> %p\n", q, p));
	*(merc__UnbindBusinessEntityUserResponse*)p = *(merc__UnbindBusinessEntityUserResponse*)q;
}

void merc__UnbindBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UnbindBusinessEntityUserRequest::__sizeuser = 0;
	this->merc__UnbindBusinessEntityUserRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__UnbindBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	if(this->merc__UnbindBusinessEntityUserRequest::vd__user) {
		for(int i = 0; i < this->merc__UnbindBusinessEntityUserRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__UnbindBusinessEntityUserRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__UnbindBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UnbindBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const merc__UnbindBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest), "merc:UnbindBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__UnbindBusinessEntityUserRequest::vd__user) {
		int i;
		for(i = 0; i < a->merc__UnbindBusinessEntityUserRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__UnbindBusinessEntityUserRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UnbindBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UnbindBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserRequest * FASTCALL soap_in_merc__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, merc__UnbindBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UnbindBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest, sizeof(merc__UnbindBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UnbindBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UnbindBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__UnbindBusinessEntityUserRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__UnbindBusinessEntityUserRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__UnbindBusinessEntityUserRequest::vd__user == NULL)
						return NULL;
					*a->merc__UnbindBusinessEntityUserRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__UnbindBusinessEntityUserRequest::vd__user, "vd:User"))
				{	a->merc__UnbindBusinessEntityUserRequest::__sizeuser++;
					a->merc__UnbindBusinessEntityUserRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UnbindBusinessEntityUserRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__UnbindBusinessEntityUserRequest::__sizeuser)
			a->merc__UnbindBusinessEntityUserRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__UnbindBusinessEntityUserRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UnbindBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest, 0, sizeof(merc__UnbindBusinessEntityUserRequest), 0, soap_copy_merc__UnbindBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->merc__UnbindBusinessEntityUserRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__UnbindBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"merc:UnbindBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UnbindBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UnbindBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserRequest * SOAP_FMAC4 soap_get_merc__UnbindBusinessEntityUserRequest(struct soap *soap, merc__UnbindBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UnbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UnbindBusinessEntityUserRequest * FASTCALL soap_instantiate_merc__UnbindBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UnbindBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(merc__UnbindBusinessEntityUserRequest));
		((merc__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UnbindBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((merc__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UnbindBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UnbindBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UnbindBusinessEntityUserRequest %p -> %p\n", q, p));
	*(merc__UnbindBusinessEntityUserRequest*)p = *(merc__UnbindBusinessEntityUserRequest*)q;
}

void merc__UpdateUserWorkingAreasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateUserWorkingAreasResponse::__sizeuser = 0;
	this->merc__UpdateUserWorkingAreasResponse::vd__user = NULL;
	/* transient soap skipped */
}

void merc__UpdateUserWorkingAreasResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__UpdateUserWorkingAreasResponse::vd__user) {
		for(int i = 0; i < this->merc__UpdateUserWorkingAreasResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__UpdateUserWorkingAreasResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int merc__UpdateUserWorkingAreasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateUserWorkingAreasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, int id, const merc__UpdateUserWorkingAreasResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse), "merc:UpdateUserWorkingAreasResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->merc__UpdateUserWorkingAreasResponse::vd__user) {
		int i;
		for(i = 0; i < a->merc__UpdateUserWorkingAreasResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__UpdateUserWorkingAreasResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateUserWorkingAreasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateUserWorkingAreasResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasResponse * FASTCALL soap_in_merc__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, merc__UpdateUserWorkingAreasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateUserWorkingAreasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse, sizeof(merc__UpdateUserWorkingAreasResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateUserWorkingAreasResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateUserWorkingAreasResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__UpdateUserWorkingAreasResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__UpdateUserWorkingAreasResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__UpdateUserWorkingAreasResponse::vd__user == NULL)
						return NULL;
					*a->merc__UpdateUserWorkingAreasResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__UpdateUserWorkingAreasResponse::vd__user, "vd:User"))
				{	a->merc__UpdateUserWorkingAreasResponse::__sizeuser++;
					a->merc__UpdateUserWorkingAreasResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateUserWorkingAreasResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__UpdateUserWorkingAreasResponse::__sizeuser)
			a->merc__UpdateUserWorkingAreasResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__UpdateUserWorkingAreasResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateUserWorkingAreasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse, 0, sizeof(merc__UpdateUserWorkingAreasResponse), 0, soap_copy_merc__UpdateUserWorkingAreasResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__UpdateUserWorkingAreasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse);
	return this->soap_out(soap, tag?tag:"merc:UpdateUserWorkingAreasResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateUserWorkingAreasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateUserWorkingAreasResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasResponse * SOAP_FMAC4 soap_get_merc__UpdateUserWorkingAreasResponse(struct soap *soap, merc__UpdateUserWorkingAreasResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateUserWorkingAreasResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateUserWorkingAreasResponse * FASTCALL soap_instantiate_merc__UpdateUserWorkingAreasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateUserWorkingAreasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasResponse);
		ASSIGN_PTR(size, sizeof(merc__UpdateUserWorkingAreasResponse));
		((merc__UpdateUserWorkingAreasResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateUserWorkingAreasResponse));
		for(int i = 0; i < n; i++)
			((merc__UpdateUserWorkingAreasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateUserWorkingAreasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateUserWorkingAreasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateUserWorkingAreasResponse %p -> %p\n", q, p));
	*(merc__UpdateUserWorkingAreasResponse*)p = *(merc__UpdateUserWorkingAreasResponse*)q;
}

void merc__UpdateUserWorkingAreasRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateUserWorkingAreasRequest::__sizeuser = 0;
	this->merc__UpdateUserWorkingAreasRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__UpdateUserWorkingAreasRequest::soap_serialize(struct soap *soap) const
{
	if(this->merc__UpdateUserWorkingAreasRequest::vd__user) {
		for(int i = 0; i < this->merc__UpdateUserWorkingAreasRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__UpdateUserWorkingAreasRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__UpdateUserWorkingAreasRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateUserWorkingAreasRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, const merc__UpdateUserWorkingAreasRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest), "merc:UpdateUserWorkingAreasRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__UpdateUserWorkingAreasRequest::vd__user) {
		int i;
		for(i = 0; i < a->merc__UpdateUserWorkingAreasRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__UpdateUserWorkingAreasRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateUserWorkingAreasRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateUserWorkingAreasRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasRequest * FASTCALL soap_in_merc__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, merc__UpdateUserWorkingAreasRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateUserWorkingAreasRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest, sizeof(merc__UpdateUserWorkingAreasRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateUserWorkingAreasRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateUserWorkingAreasRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__UpdateUserWorkingAreasRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__UpdateUserWorkingAreasRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__UpdateUserWorkingAreasRequest::vd__user == NULL)
						return NULL;
					*a->merc__UpdateUserWorkingAreasRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__UpdateUserWorkingAreasRequest::vd__user, "vd:User"))
				{	a->merc__UpdateUserWorkingAreasRequest::__sizeuser++;
					a->merc__UpdateUserWorkingAreasRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateUserWorkingAreasRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__UpdateUserWorkingAreasRequest::__sizeuser)
			a->merc__UpdateUserWorkingAreasRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__UpdateUserWorkingAreasRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateUserWorkingAreasRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest, 0, sizeof(merc__UpdateUserWorkingAreasRequest), 0, soap_copy_merc__UpdateUserWorkingAreasRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->merc__UpdateUserWorkingAreasRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__UpdateUserWorkingAreasRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest);
	return this->soap_out(soap, tag?tag:"merc:UpdateUserWorkingAreasRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateUserWorkingAreasRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateUserWorkingAreasRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasRequest * SOAP_FMAC4 soap_get_merc__UpdateUserWorkingAreasRequest(struct soap *soap, merc__UpdateUserWorkingAreasRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateUserWorkingAreasRequest * FASTCALL soap_instantiate_merc__UpdateUserWorkingAreasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateUserWorkingAreasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasRequest);
		ASSIGN_PTR(size, sizeof(merc__UpdateUserWorkingAreasRequest));
		((merc__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateUserWorkingAreasRequest));
		for(int i = 0; i < n; i++)
			((merc__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateUserWorkingAreasRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateUserWorkingAreasRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateUserWorkingAreasRequest %p -> %p\n", q, p));
	*(merc__UpdateUserWorkingAreasRequest*)p = *(merc__UpdateUserWorkingAreasRequest*)q;
}

void merc__UpdateUserAuthoritiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateUserAuthoritiesResponse::__sizeuser = 0;
	this->merc__UpdateUserAuthoritiesResponse::vd__user = NULL;
	/* transient soap skipped */
}

void merc__UpdateUserAuthoritiesResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__UpdateUserAuthoritiesResponse::vd__user) {
		for(int i = 0; i < this->merc__UpdateUserAuthoritiesResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__UpdateUserAuthoritiesResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int merc__UpdateUserAuthoritiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateUserAuthoritiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, int id, const merc__UpdateUserAuthoritiesResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse), "merc:UpdateUserAuthoritiesResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->merc__UpdateUserAuthoritiesResponse::vd__user) {
		int i;
		for(i = 0; i < a->merc__UpdateUserAuthoritiesResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__UpdateUserAuthoritiesResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateUserAuthoritiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateUserAuthoritiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesResponse * FASTCALL soap_in_merc__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, merc__UpdateUserAuthoritiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateUserAuthoritiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse, sizeof(merc__UpdateUserAuthoritiesResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateUserAuthoritiesResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateUserAuthoritiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__UpdateUserAuthoritiesResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__UpdateUserAuthoritiesResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__UpdateUserAuthoritiesResponse::vd__user == NULL)
						return NULL;
					*a->merc__UpdateUserAuthoritiesResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__UpdateUserAuthoritiesResponse::vd__user, "vd:User"))
				{	a->merc__UpdateUserAuthoritiesResponse::__sizeuser++;
					a->merc__UpdateUserAuthoritiesResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateUserAuthoritiesResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__UpdateUserAuthoritiesResponse::__sizeuser)
			a->merc__UpdateUserAuthoritiesResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__UpdateUserAuthoritiesResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateUserAuthoritiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse, 0, sizeof(merc__UpdateUserAuthoritiesResponse), 0, soap_copy_merc__UpdateUserAuthoritiesResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__UpdateUserAuthoritiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse);
	return this->soap_out(soap, tag?tag:"merc:UpdateUserAuthoritiesResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateUserAuthoritiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateUserAuthoritiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesResponse * SOAP_FMAC4 soap_get_merc__UpdateUserAuthoritiesResponse(struct soap *soap, merc__UpdateUserAuthoritiesResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateUserAuthoritiesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateUserAuthoritiesResponse * FASTCALL soap_instantiate_merc__UpdateUserAuthoritiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateUserAuthoritiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesResponse);
		ASSIGN_PTR(size, sizeof(merc__UpdateUserAuthoritiesResponse));
		((merc__UpdateUserAuthoritiesResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateUserAuthoritiesResponse));
		for(int i = 0; i < n; i++)
			((merc__UpdateUserAuthoritiesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateUserAuthoritiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateUserAuthoritiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateUserAuthoritiesResponse %p -> %p\n", q, p));
	*(merc__UpdateUserAuthoritiesResponse*)p = *(merc__UpdateUserAuthoritiesResponse*)q;
}

void merc__UpdateUserAuthoritiesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateUserAuthoritiesRequest::__sizeuser = 0;
	this->merc__UpdateUserAuthoritiesRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__UpdateUserAuthoritiesRequest::soap_serialize(struct soap *soap) const
{
	if(this->merc__UpdateUserAuthoritiesRequest::vd__user) {
		for(int i = 0; i < this->merc__UpdateUserAuthoritiesRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__UpdateUserAuthoritiesRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__UpdateUserAuthoritiesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateUserAuthoritiesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, const merc__UpdateUserAuthoritiesRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest), "merc:UpdateUserAuthoritiesRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__UpdateUserAuthoritiesRequest::vd__user) {
		int i;
		for(i = 0; i < a->merc__UpdateUserAuthoritiesRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__UpdateUserAuthoritiesRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateUserAuthoritiesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateUserAuthoritiesRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesRequest * FASTCALL soap_in_merc__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, merc__UpdateUserAuthoritiesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateUserAuthoritiesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest, sizeof(merc__UpdateUserAuthoritiesRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateUserAuthoritiesRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateUserAuthoritiesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__UpdateUserAuthoritiesRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__UpdateUserAuthoritiesRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__UpdateUserAuthoritiesRequest::vd__user == NULL)
						return NULL;
					*a->merc__UpdateUserAuthoritiesRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__UpdateUserAuthoritiesRequest::vd__user, "vd:User"))
				{	a->merc__UpdateUserAuthoritiesRequest::__sizeuser++;
					a->merc__UpdateUserAuthoritiesRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateUserAuthoritiesRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__UpdateUserAuthoritiesRequest::__sizeuser)
			a->merc__UpdateUserAuthoritiesRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__UpdateUserAuthoritiesRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateUserAuthoritiesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest, 0, sizeof(merc__UpdateUserAuthoritiesRequest), 0, soap_copy_merc__UpdateUserAuthoritiesRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->merc__UpdateUserAuthoritiesRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__UpdateUserAuthoritiesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest);
	return this->soap_out(soap, tag?tag:"merc:UpdateUserAuthoritiesRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateUserAuthoritiesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateUserAuthoritiesRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesRequest * SOAP_FMAC4 soap_get_merc__UpdateUserAuthoritiesRequest(struct soap *soap, merc__UpdateUserAuthoritiesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateUserAuthoritiesRequest * FASTCALL soap_instantiate_merc__UpdateUserAuthoritiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateUserAuthoritiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesRequest);
		ASSIGN_PTR(size, sizeof(merc__UpdateUserAuthoritiesRequest));
		((merc__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateUserAuthoritiesRequest));
		for(int i = 0; i < n; i++)
			((merc__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateUserAuthoritiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateUserAuthoritiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateUserAuthoritiesRequest %p -> %p\n", q, p));
	*(merc__UpdateUserAuthoritiesRequest*)p = *(merc__UpdateUserAuthoritiesRequest*)q;
}

void merc__GetBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetBusinessEntityUserResponse::vd__user = NULL;
	/* transient soap skipped */
}

void merc__GetBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__User(soap, &this->merc__GetBusinessEntityUserResponse::vd__user);
	/* transient soap skipped */
}

int merc__GetBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const merc__GetBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetBusinessEntityUserResponse), "merc:GetBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__user)
		soap_element_result(soap, "vd:user");
	if(soap_out_PointerTovd__User(soap, "vd:user", -1, &(a->merc__GetBusinessEntityUserResponse::vd__user), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserResponse * FASTCALL soap_in_merc__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, merc__GetBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetBusinessEntityUserResponse, sizeof(merc__GetBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__user1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__user1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:user", &(a->merc__GetBusinessEntityUserResponse::vd__user), "vd:User"))
				{	soap_flag_vd__user1--;
					continue;
				}
			soap_check_result(soap, "vd:user");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetBusinessEntityUserResponse, 0, sizeof(merc__GetBusinessEntityUserResponse), 0, soap_copy_merc__GetBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__GetBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"merc:GetBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserResponse * SOAP_FMAC4 soap_get_merc__GetBusinessEntityUserResponse(struct soap *soap, merc__GetBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetBusinessEntityUserResponse * FASTCALL soap_instantiate_merc__GetBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserResponse));
		((merc__GetBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((merc__GetBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetBusinessEntityUserResponse %p -> %p\n", q, p));
	*(merc__GetBusinessEntityUserResponse*)p = *(merc__GetBusinessEntityUserResponse*)q;
}

void merc__GetBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetBusinessEntityUserRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__User(soap, &this->merc__GetBusinessEntityUserRequest::vd__user);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const merc__GetBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetBusinessEntityUserRequest), "merc:GetBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__GetBusinessEntityUserRequest::vd__user) {
		if(soap_out_PointerTovd__User(soap, "vd:user", -1, &a->merc__GetBusinessEntityUserRequest::vd__user, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:user"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserRequest * FASTCALL soap_in_merc__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, merc__GetBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetBusinessEntityUserRequest, sizeof(merc__GetBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vd__user1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vd__user1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "vd:user", &(a->merc__GetBusinessEntityUserRequest::vd__user), "vd:User"))
				{	soap_flag_vd__user1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetBusinessEntityUserRequest, 0, sizeof(merc__GetBusinessEntityUserRequest), 0, soap_copy_merc__GetBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vd__user1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"merc:GetBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserRequest * SOAP_FMAC4 soap_get_merc__GetBusinessEntityUserRequest(struct soap *soap, merc__GetBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetBusinessEntityUserRequest * FASTCALL soap_instantiate_merc__GetBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserRequest));
		((merc__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((merc__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetBusinessEntityUserRequest %p -> %p\n", q, p));
	*(merc__GetBusinessEntityUserRequest*)p = *(merc__GetBusinessEntityUserRequest*)q;
}

void merc__GetBusinessEntityUserListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetBusinessEntityUserListResponse::vd__userList = NULL;
	/* transient soap skipped */
}

void merc__GetBusinessEntityUserListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__UserList(soap, &this->merc__GetBusinessEntityUserListResponse::vd__userList);
	/* transient soap skipped */
}

int merc__GetBusinessEntityUserListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetBusinessEntityUserListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, int id, const merc__GetBusinessEntityUserListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetBusinessEntityUserListResponse), "merc:GetBusinessEntityUserListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__userList)
		soap_element_result(soap, "vd:userList");
	if(soap_out_PointerTovd__UserList(soap, "vd:userList", -1, &(a->merc__GetBusinessEntityUserListResponse::vd__userList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetBusinessEntityUserListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetBusinessEntityUserListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListResponse * FASTCALL soap_in_merc__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, merc__GetBusinessEntityUserListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetBusinessEntityUserListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetBusinessEntityUserListResponse, sizeof(merc__GetBusinessEntityUserListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetBusinessEntityUserListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetBusinessEntityUserListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__userList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__userList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__UserList(soap, "vd:userList", &(a->merc__GetBusinessEntityUserListResponse::vd__userList), "vd:UserList"))
				{	soap_flag_vd__userList1--;
					continue;
				}
			soap_check_result(soap, "vd:userList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetBusinessEntityUserListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetBusinessEntityUserListResponse, 0, sizeof(merc__GetBusinessEntityUserListResponse), 0, soap_copy_merc__GetBusinessEntityUserListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__GetBusinessEntityUserListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetBusinessEntityUserListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetBusinessEntityUserListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetBusinessEntityUserListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetBusinessEntityUserListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListResponse * SOAP_FMAC4 soap_get_merc__GetBusinessEntityUserListResponse(struct soap *soap, merc__GetBusinessEntityUserListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetBusinessEntityUserListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetBusinessEntityUserListResponse * FASTCALL soap_instantiate_merc__GetBusinessEntityUserListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetBusinessEntityUserListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetBusinessEntityUserListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserListResponse));
		((merc__GetBusinessEntityUserListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetBusinessEntityUserListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetBusinessEntityUserListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetBusinessEntityUserListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetBusinessEntityUserListResponse %p -> %p\n", q, p));
	*(merc__GetBusinessEntityUserListResponse*)p = *(merc__GetBusinessEntityUserListResponse*)q;
}

void merc__GetBusinessEntityUserListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetBusinessEntityUserListRequest::base__listOptions = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetBusinessEntityUserListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetBusinessEntityUserListRequest::base__listOptions);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetBusinessEntityUserListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetBusinessEntityUserListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, const merc__GetBusinessEntityUserListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetBusinessEntityUserListRequest), "merc:GetBusinessEntityUserListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetBusinessEntityUserListRequest::base__listOptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetBusinessEntityUserListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetBusinessEntityUserListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListRequest * FASTCALL soap_in_merc__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, merc__GetBusinessEntityUserListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetBusinessEntityUserListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetBusinessEntityUserListRequest, sizeof(merc__GetBusinessEntityUserListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetBusinessEntityUserListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetBusinessEntityUserListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetBusinessEntityUserListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetBusinessEntityUserListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetBusinessEntityUserListRequest, 0, sizeof(merc__GetBusinessEntityUserListRequest), 0, soap_copy_merc__GetBusinessEntityUserListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetBusinessEntityUserListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetBusinessEntityUserListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetBusinessEntityUserListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetBusinessEntityUserListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetBusinessEntityUserListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListRequest * SOAP_FMAC4 soap_get_merc__GetBusinessEntityUserListRequest(struct soap *soap, merc__GetBusinessEntityUserListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetBusinessEntityUserListRequest * FASTCALL soap_instantiate_merc__GetBusinessEntityUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetBusinessEntityUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetBusinessEntityUserListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserListRequest));
		((merc__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetBusinessEntityUserListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetBusinessEntityUserListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetBusinessEntityUserListRequest %p -> %p\n", q, p));
	*(merc__GetBusinessEntityUserListRequest*)p = *(merc__GetBusinessEntityUserListRequest*)q;
}

void merc__AddBusinessEntityUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__AddBusinessEntityUserResponse::__sizeuser = 0;
	this->merc__AddBusinessEntityUserResponse::vd__user = NULL;
	/* transient soap skipped */
}

void merc__AddBusinessEntityUserResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__AddBusinessEntityUserResponse::vd__user) {
		for(int i = 0; i < this->merc__AddBusinessEntityUserResponse::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__AddBusinessEntityUserResponse::vd__user + i);
		}
	}
	/* transient soap skipped */
}

int merc__AddBusinessEntityUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__AddBusinessEntityUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, const merc__AddBusinessEntityUserResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__AddBusinessEntityUserResponse), "merc:AddBusinessEntityUserResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeuser");
	if(a->merc__AddBusinessEntityUserResponse::vd__user) {
		int i;
		for(i = 0; i < a->merc__AddBusinessEntityUserResponse::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__AddBusinessEntityUserResponse::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__AddBusinessEntityUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__AddBusinessEntityUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__AddBusinessEntityUserResponse * FASTCALL soap_in_merc__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, merc__AddBusinessEntityUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__AddBusinessEntityUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__AddBusinessEntityUserResponse, sizeof(merc__AddBusinessEntityUserResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__AddBusinessEntityUserResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__AddBusinessEntityUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__AddBusinessEntityUserResponse::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__AddBusinessEntityUserResponse::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__AddBusinessEntityUserResponse::vd__user == NULL)
						return NULL;
					*a->merc__AddBusinessEntityUserResponse::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__AddBusinessEntityUserResponse::vd__user, "vd:User"))
				{	a->merc__AddBusinessEntityUserResponse::__sizeuser++;
					a->merc__AddBusinessEntityUserResponse::vd__user = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeuser");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__AddBusinessEntityUserResponse::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__AddBusinessEntityUserResponse::__sizeuser)
			a->merc__AddBusinessEntityUserResponse::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__AddBusinessEntityUserResponse::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__AddBusinessEntityUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__AddBusinessEntityUserResponse, 0, sizeof(merc__AddBusinessEntityUserResponse), 0, soap_copy_merc__AddBusinessEntityUserResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__AddBusinessEntityUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__AddBusinessEntityUserResponse);
	return this->soap_out(soap, tag?tag:"merc:AddBusinessEntityUserResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__AddBusinessEntityUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__AddBusinessEntityUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__AddBusinessEntityUserResponse * SOAP_FMAC4 soap_get_merc__AddBusinessEntityUserResponse(struct soap *soap, merc__AddBusinessEntityUserResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__AddBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__AddBusinessEntityUserResponse * FASTCALL soap_instantiate_merc__AddBusinessEntityUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__AddBusinessEntityUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__AddBusinessEntityUserResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserResponse);
		ASSIGN_PTR(size, sizeof(merc__AddBusinessEntityUserResponse));
		((merc__AddBusinessEntityUserResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__AddBusinessEntityUserResponse));
		for(int i = 0; i < n; i++)
			((merc__AddBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__AddBusinessEntityUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__AddBusinessEntityUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__AddBusinessEntityUserResponse %p -> %p\n", q, p));
	*(merc__AddBusinessEntityUserResponse*)p = *(merc__AddBusinessEntityUserResponse*)q;
}

void merc__AddBusinessEntityUserRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__AddBusinessEntityUserRequest::__sizeuser = 0;
	this->merc__AddBusinessEntityUserRequest::vd__user = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__AddBusinessEntityUserRequest::soap_serialize(struct soap *soap) const
{
	if(this->merc__AddBusinessEntityUserRequest::vd__user) {
		for(int i = 0; i < this->merc__AddBusinessEntityUserRequest::__sizeuser; i++) {
			soap_serialize_PointerTovd__User(soap, this->merc__AddBusinessEntityUserRequest::vd__user + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__AddBusinessEntityUserRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__AddBusinessEntityUserRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const merc__AddBusinessEntityUserRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__AddBusinessEntityUserRequest), "merc:AddBusinessEntityUserRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__AddBusinessEntityUserRequest::vd__user) {
		int i;
		for(i = 0; i < a->merc__AddBusinessEntityUserRequest::__sizeuser; i++)
			if(soap_out_PointerTovd__User(soap, "vd:user", -1, a->merc__AddBusinessEntityUserRequest::vd__user + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__AddBusinessEntityUserRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__AddBusinessEntityUserRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__AddBusinessEntityUserRequest * FASTCALL soap_in_merc__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, merc__AddBusinessEntityUserRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__AddBusinessEntityUserRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__AddBusinessEntityUserRequest, sizeof(merc__AddBusinessEntityUserRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__AddBusinessEntityUserRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__AddBusinessEntityUserRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_vd__user1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:user", 1, NULL)) {
				if(a->merc__AddBusinessEntityUserRequest::vd__user == NULL) {
					if(soap_blist_vd__user1 == NULL)
						soap_blist_vd__user1 = soap_new_block(soap);
					a->merc__AddBusinessEntityUserRequest::vd__user = (vd__User **)soap_push_block(soap, soap_blist_vd__user1, sizeof(vd__User *));
					if(a->merc__AddBusinessEntityUserRequest::vd__user == NULL)
						return NULL;
					*a->merc__AddBusinessEntityUserRequest::vd__user = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__User(soap, "vd:user", a->merc__AddBusinessEntityUserRequest::vd__user, "vd:User"))
				{	a->merc__AddBusinessEntityUserRequest::__sizeuser++;
					a->merc__AddBusinessEntityUserRequest::vd__user = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__AddBusinessEntityUserRequest::vd__user)
			soap_pop_block(soap, soap_blist_vd__user1);
		if(a->merc__AddBusinessEntityUserRequest::__sizeuser)
			a->merc__AddBusinessEntityUserRequest::vd__user = (vd__User **)soap_save_block(soap, soap_blist_vd__user1, NULL, 1);
		else
		{	a->merc__AddBusinessEntityUserRequest::vd__user = NULL;
			if(soap_blist_vd__user1)
				soap_end_block(soap, soap_blist_vd__user1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__AddBusinessEntityUserRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__AddBusinessEntityUserRequest, 0, sizeof(merc__AddBusinessEntityUserRequest), 0, soap_copy_merc__AddBusinessEntityUserRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->merc__AddBusinessEntityUserRequest::__sizeuser < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__AddBusinessEntityUserRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__AddBusinessEntityUserRequest);
	return this->soap_out(soap, tag?tag:"merc:AddBusinessEntityUserRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__AddBusinessEntityUserRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__AddBusinessEntityUserRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__AddBusinessEntityUserRequest * SOAP_FMAC4 soap_get_merc__AddBusinessEntityUserRequest(struct soap *soap, merc__AddBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__AddBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__AddBusinessEntityUserRequest * FASTCALL soap_instantiate_merc__AddBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__AddBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__AddBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(merc__AddBusinessEntityUserRequest));
		((merc__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__AddBusinessEntityUserRequest));
		for(int i = 0; i < n; i++)
			((merc__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__AddBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__AddBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__AddBusinessEntityUserRequest %p -> %p\n", q, p));
	*(merc__AddBusinessEntityUserRequest*)p = *(merc__AddBusinessEntityUserRequest*)q;
}

void merc__CheckShipmentRegionalizationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__CheckShipmentRegionalizationResponse::__sizer13nRouteSection = 0;
	this->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
	/* transient soap skipped */
}

void merc__CheckShipmentRegionalizationResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection) {
		for(int i = 0; i < this->merc__CheckShipmentRegionalizationResponse::__sizer13nRouteSection; i++) {
			soap_serialize_PointerTovd__RouteSectionR13nRules(soap, this->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection + i);
		}
	}
	/* transient soap skipped */
}

int merc__CheckShipmentRegionalizationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__CheckShipmentRegionalizationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, int id, const merc__CheckShipmentRegionalizationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse), "merc:CheckShipmentRegionalizationResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizer13nRouteSection");
	if(a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection) {
		int i;
		for(i = 0; i < a->merc__CheckShipmentRegionalizationResponse::__sizer13nRouteSection; i++)
			if(soap_out_PointerTovd__RouteSectionR13nRules(soap, "vd:r13nRouteSection", -1, a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__CheckShipmentRegionalizationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__CheckShipmentRegionalizationResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationResponse * FASTCALL soap_in_merc__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, merc__CheckShipmentRegionalizationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__CheckShipmentRegionalizationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse, sizeof(merc__CheckShipmentRegionalizationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__CheckShipmentRegionalizationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__CheckShipmentRegionalizationResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__r13nRouteSection1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:r13nRouteSection", 1, NULL)) {
				if(a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection == NULL) {
					if(soap_blist_vd__r13nRouteSection1 == NULL)
						soap_blist_vd__r13nRouteSection1 = soap_new_block(soap);
					a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = (vd__RouteSectionR13nRules **)soap_push_block(soap, soap_blist_vd__r13nRouteSection1, sizeof(vd__RouteSectionR13nRules *));
					if(a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection == NULL)
						return NULL;
					*a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__RouteSectionR13nRules(soap, "vd:r13nRouteSection", a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection, "vd:RouteSectionR13nRules"))
				{	a->merc__CheckShipmentRegionalizationResponse::__sizer13nRouteSection++;
					a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizer13nRouteSection");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection)
			soap_pop_block(soap, soap_blist_vd__r13nRouteSection1);
		if(a->merc__CheckShipmentRegionalizationResponse::__sizer13nRouteSection)
			a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = (vd__RouteSectionR13nRules **)soap_save_block(soap, soap_blist_vd__r13nRouteSection1, NULL, 1);
		else
		{	a->merc__CheckShipmentRegionalizationResponse::vd__r13nRouteSection = NULL;
			if(soap_blist_vd__r13nRouteSection1)
				soap_end_block(soap, soap_blist_vd__r13nRouteSection1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__CheckShipmentRegionalizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse, 0, sizeof(merc__CheckShipmentRegionalizationResponse), 0, soap_copy_merc__CheckShipmentRegionalizationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__CheckShipmentRegionalizationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse);
	return this->soap_out(soap, tag?tag:"merc:CheckShipmentRegionalizationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__CheckShipmentRegionalizationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__CheckShipmentRegionalizationResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationResponse * SOAP_FMAC4 soap_get_merc__CheckShipmentRegionalizationResponse(struct soap *soap, merc__CheckShipmentRegionalizationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__CheckShipmentRegionalizationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__CheckShipmentRegionalizationResponse * FASTCALL soap_instantiate_merc__CheckShipmentRegionalizationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__CheckShipmentRegionalizationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationResponse);
		ASSIGN_PTR(size, sizeof(merc__CheckShipmentRegionalizationResponse));
		((merc__CheckShipmentRegionalizationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__CheckShipmentRegionalizationResponse));
		for(int i = 0; i < n; i++)
			((merc__CheckShipmentRegionalizationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__CheckShipmentRegionalizationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__CheckShipmentRegionalizationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__CheckShipmentRegionalizationResponse %p -> %p\n", q, p));
	*(merc__CheckShipmentRegionalizationResponse*)p = *(merc__CheckShipmentRegionalizationResponse*)q;
}

void merc__CheckShipmentRegionalizationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__CheckShipmentRegionalizationRequest::__sizecargoType = 0;
	this->merc__CheckShipmentRegionalizationRequest::ent__cargoType = NULL;
	this->merc__CheckShipmentRegionalizationRequest::vd__shipmentRoute = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__CheckShipmentRegionalizationRequest::soap_serialize(struct soap *soap) const
{
	if(this->merc__CheckShipmentRegionalizationRequest::ent__cargoType) {
		for(int i = 0; i < this->merc__CheckShipmentRegionalizationRequest::__sizecargoType; i++) {
			soap_serialize_PointerToent__SubProduct(soap, this->merc__CheckShipmentRegionalizationRequest::ent__cargoType + i);
		}
	}
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->merc__CheckShipmentRegionalizationRequest::vd__shipmentRoute);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__CheckShipmentRegionalizationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__CheckShipmentRegionalizationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, const merc__CheckShipmentRegionalizationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest), "merc:CheckShipmentRegionalizationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__CheckShipmentRegionalizationRequest::ent__cargoType) {
		int i;
		for(i = 0; i < a->merc__CheckShipmentRegionalizationRequest::__sizecargoType; i++)
			if(soap_out_PointerToent__SubProduct(soap, "ent:cargoType", -1, a->merc__CheckShipmentRegionalizationRequest::ent__cargoType + i, ""))
				return soap->error;
	}
	if(a->merc__CheckShipmentRegionalizationRequest::vd__shipmentRoute) {
		if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &a->merc__CheckShipmentRegionalizationRequest::vd__shipmentRoute, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:shipmentRoute"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__CheckShipmentRegionalizationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__CheckShipmentRegionalizationRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationRequest * FASTCALL soap_in_merc__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, merc__CheckShipmentRegionalizationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__CheckShipmentRegionalizationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest, sizeof(merc__CheckShipmentRegionalizationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__CheckShipmentRegionalizationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__CheckShipmentRegionalizationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_ent__cargoType1 = NULL;
	size_t soap_flag_vd__shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ent:cargoType", 1, NULL)) {
				if(a->merc__CheckShipmentRegionalizationRequest::ent__cargoType == NULL) {
					if(soap_blist_ent__cargoType1 == NULL)
						soap_blist_ent__cargoType1 = soap_new_block(soap);
					a->merc__CheckShipmentRegionalizationRequest::ent__cargoType = (ent__SubProduct **)soap_push_block(soap, soap_blist_ent__cargoType1, sizeof(ent__SubProduct *));
					if(a->merc__CheckShipmentRegionalizationRequest::ent__cargoType == NULL)
						return NULL;
					*a->merc__CheckShipmentRegionalizationRequest::ent__cargoType = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__SubProduct(soap, "ent:cargoType", a->merc__CheckShipmentRegionalizationRequest::ent__cargoType, "ent:SubProduct"))
				{	a->merc__CheckShipmentRegionalizationRequest::__sizecargoType++;
					a->merc__CheckShipmentRegionalizationRequest::ent__cargoType = NULL;
					continue;
				}
			}
			if(soap_flag_vd__shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->merc__CheckShipmentRegionalizationRequest::vd__shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_vd__shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__CheckShipmentRegionalizationRequest::ent__cargoType)
			soap_pop_block(soap, soap_blist_ent__cargoType1);
		if(a->merc__CheckShipmentRegionalizationRequest::__sizecargoType)
			a->merc__CheckShipmentRegionalizationRequest::ent__cargoType = (ent__SubProduct **)soap_save_block(soap, soap_blist_ent__cargoType1, NULL, 1);
		else
		{	a->merc__CheckShipmentRegionalizationRequest::ent__cargoType = NULL;
			if(soap_blist_ent__cargoType1)
				soap_end_block(soap, soap_blist_ent__cargoType1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__CheckShipmentRegionalizationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest, 0, sizeof(merc__CheckShipmentRegionalizationRequest), 0, soap_copy_merc__CheckShipmentRegionalizationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->merc__CheckShipmentRegionalizationRequest::__sizecargoType < 1 || soap_flag_vd__shipmentRoute1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__CheckShipmentRegionalizationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest);
	return this->soap_out(soap, tag?tag:"merc:CheckShipmentRegionalizationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__CheckShipmentRegionalizationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__CheckShipmentRegionalizationRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationRequest * SOAP_FMAC4 soap_get_merc__CheckShipmentRegionalizationRequest(struct soap *soap, merc__CheckShipmentRegionalizationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__CheckShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__CheckShipmentRegionalizationRequest * FASTCALL soap_instantiate_merc__CheckShipmentRegionalizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__CheckShipmentRegionalizationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationRequest);
		ASSIGN_PTR(size, sizeof(merc__CheckShipmentRegionalizationRequest));
		((merc__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__CheckShipmentRegionalizationRequest));
		for(int i = 0; i < n; i++)
			((merc__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__CheckShipmentRegionalizationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__CheckShipmentRegionalizationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__CheckShipmentRegionalizationRequest %p -> %p\n", q, p));
	*(merc__CheckShipmentRegionalizationRequest*)p = *(merc__CheckShipmentRegionalizationRequest*)q;
}

void merc__UpdateVeterinaryEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateVeterinaryEventsResponse::__sizestockEntry = 0;
	this->merc__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
	/* transient soap skipped */
}

void merc__UpdateVeterinaryEventsResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__UpdateVeterinaryEventsResponse::vd__stockEntry) {
		for(int i = 0; i < this->merc__UpdateVeterinaryEventsResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->merc__UpdateVeterinaryEventsResponse::vd__stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int merc__UpdateVeterinaryEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateVeterinaryEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, int id, const merc__UpdateVeterinaryEventsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse), "merc:UpdateVeterinaryEventsResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry) {
		int i;
		for(i = 0; i < a->merc__UpdateVeterinaryEventsResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateVeterinaryEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateVeterinaryEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsResponse * FASTCALL soap_in_merc__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, merc__UpdateVeterinaryEventsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateVeterinaryEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse, sizeof(merc__UpdateVeterinaryEventsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateVeterinaryEventsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateVeterinaryEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:stockEntry", 1, NULL)) {
				if(a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry == NULL) {
					if(soap_blist_vd__stockEntry1 == NULL)
						soap_blist_vd__stockEntry1 = soap_new_block(soap);
					a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_vd__stockEntry1, sizeof(vd__StockEntry *));
					if(a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry == NULL)
						return NULL;
					*a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry, "vd:StockEntry"))
				{	a->merc__UpdateVeterinaryEventsResponse::__sizestockEntry++;
					a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry)
			soap_pop_block(soap, soap_blist_vd__stockEntry1);
		if(a->merc__UpdateVeterinaryEventsResponse::__sizestockEntry)
			a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_vd__stockEntry1, NULL, 1);
		else
		{	a->merc__UpdateVeterinaryEventsResponse::vd__stockEntry = NULL;
			if(soap_blist_vd__stockEntry1)
				soap_end_block(soap, soap_blist_vd__stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateVeterinaryEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse, 0, sizeof(merc__UpdateVeterinaryEventsResponse), 0, soap_copy_merc__UpdateVeterinaryEventsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__UpdateVeterinaryEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse);
	return this->soap_out(soap, tag?tag:"merc:UpdateVeterinaryEventsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateVeterinaryEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateVeterinaryEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsResponse * SOAP_FMAC4 soap_get_merc__UpdateVeterinaryEventsResponse(struct soap *soap, merc__UpdateVeterinaryEventsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateVeterinaryEventsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateVeterinaryEventsResponse * FASTCALL soap_instantiate_merc__UpdateVeterinaryEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateVeterinaryEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsResponse);
		ASSIGN_PTR(size, sizeof(merc__UpdateVeterinaryEventsResponse));
		((merc__UpdateVeterinaryEventsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateVeterinaryEventsResponse));
		for(int i = 0; i < n; i++)
			((merc__UpdateVeterinaryEventsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateVeterinaryEventsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateVeterinaryEventsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateVeterinaryEventsResponse %p -> %p\n", q, p));
	*(merc__UpdateVeterinaryEventsResponse*)p = *(merc__UpdateVeterinaryEventsResponse*)q;
}

void merc__UpdateVeterinaryEventsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateVeterinaryEventsRequest::enterprise = NULL;
	this->merc__UpdateVeterinaryEventsRequest::__sizestockEntry = 0;
	this->merc__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__UpdateVeterinaryEventsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->merc__UpdateVeterinaryEventsRequest::enterprise);
	if(this->merc__UpdateVeterinaryEventsRequest::vd__stockEntry) {
		for(int i = 0; i < this->merc__UpdateVeterinaryEventsRequest::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->merc__UpdateVeterinaryEventsRequest::vd__stockEntry + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__UpdateVeterinaryEventsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateVeterinaryEventsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, const merc__UpdateVeterinaryEventsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest), "merc:UpdateVeterinaryEventsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__UpdateVeterinaryEventsRequest::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "merc:enterprise", -1, &a->merc__UpdateVeterinaryEventsRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:enterprise"))
		return soap->error;
	if(a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry) {
		int i;
		for(i = 0; i < a->merc__UpdateVeterinaryEventsRequest::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateVeterinaryEventsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateVeterinaryEventsRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsRequest * FASTCALL soap_in_merc__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, merc__UpdateVeterinaryEventsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateVeterinaryEventsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest, sizeof(merc__UpdateVeterinaryEventsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateVeterinaryEventsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateVeterinaryEventsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	struct soap_blist *soap_blist_vd__stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "merc:enterprise", &(a->merc__UpdateVeterinaryEventsRequest::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:stockEntry", 1, NULL)) {
				if(a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry == NULL) {
					if(soap_blist_vd__stockEntry1 == NULL)
						soap_blist_vd__stockEntry1 = soap_new_block(soap);
					a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_vd__stockEntry1, sizeof(vd__StockEntry *));
					if(a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry == NULL)
						return NULL;
					*a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry, "vd:StockEntry"))
				{	a->merc__UpdateVeterinaryEventsRequest::__sizestockEntry++;
					a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry)
			soap_pop_block(soap, soap_blist_vd__stockEntry1);
		if(a->merc__UpdateVeterinaryEventsRequest::__sizestockEntry)
			a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_vd__stockEntry1, NULL, 1);
		else
		{	a->merc__UpdateVeterinaryEventsRequest::vd__stockEntry = NULL;
			if(soap_blist_vd__stockEntry1)
				soap_end_block(soap, soap_blist_vd__stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateVeterinaryEventsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest, 0, sizeof(merc__UpdateVeterinaryEventsRequest), 0, soap_copy_merc__UpdateVeterinaryEventsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || a->merc__UpdateVeterinaryEventsRequest::__sizestockEntry < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__UpdateVeterinaryEventsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest);
	return this->soap_out(soap, tag?tag:"merc:UpdateVeterinaryEventsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateVeterinaryEventsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateVeterinaryEventsRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsRequest * SOAP_FMAC4 soap_get_merc__UpdateVeterinaryEventsRequest(struct soap *soap, merc__UpdateVeterinaryEventsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateVeterinaryEventsRequest * FASTCALL soap_instantiate_merc__UpdateVeterinaryEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateVeterinaryEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsRequest);
		ASSIGN_PTR(size, sizeof(merc__UpdateVeterinaryEventsRequest));
		((merc__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateVeterinaryEventsRequest));
		for(int i = 0; i < n; i++)
			((merc__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateVeterinaryEventsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateVeterinaryEventsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateVeterinaryEventsRequest %p -> %p\n", q, p));
	*(merc__UpdateVeterinaryEventsRequest*)p = *(merc__UpdateVeterinaryEventsRequest*)q;
}

void merc__UpdateTransportMovementDetailsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateTransportMovementDetailsResponse::__sizevetDocument = 0;
	this->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
	/* transient soap skipped */
}

void merc__UpdateTransportMovementDetailsResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument) {
		for(int i = 0; i < this->merc__UpdateTransportMovementDetailsResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int merc__UpdateTransportMovementDetailsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateTransportMovementDetailsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, int id, const merc__UpdateTransportMovementDetailsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse), "merc:UpdateTransportMovementDetailsResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizevetDocument");
	if(a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument) {
		int i;
		for(i = 0; i < a->merc__UpdateTransportMovementDetailsResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateTransportMovementDetailsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateTransportMovementDetailsResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsResponse * FASTCALL soap_in_merc__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, merc__UpdateTransportMovementDetailsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateTransportMovementDetailsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse, sizeof(merc__UpdateTransportMovementDetailsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateTransportMovementDetailsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_vd__vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocument", 1, NULL)) {
				if(a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument == NULL) {
					if(soap_blist_vd__vetDocument1 == NULL)
						soap_blist_vd__vetDocument1 = soap_new_block(soap);
					a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vd__vetDocument1, sizeof(vd__VetDocument *));
					if(a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument == NULL)
						return NULL;
					*a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument, "vd:VetDocument"))
				{	a->merc__UpdateTransportMovementDetailsResponse::__sizevetDocument++;
					a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizevetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument)
			soap_pop_block(soap, soap_blist_vd__vetDocument1);
		if(a->merc__UpdateTransportMovementDetailsResponse::__sizevetDocument)
			a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vd__vetDocument1, NULL, 1);
		else
		{	a->merc__UpdateTransportMovementDetailsResponse::vd__vetDocument = NULL;
			if(soap_blist_vd__vetDocument1)
				soap_end_block(soap, soap_blist_vd__vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateTransportMovementDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse, 0, sizeof(merc__UpdateTransportMovementDetailsResponse), 0, soap_copy_merc__UpdateTransportMovementDetailsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__UpdateTransportMovementDetailsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse);
	return this->soap_out(soap, tag?tag:"merc:UpdateTransportMovementDetailsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateTransportMovementDetailsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateTransportMovementDetailsResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsResponse * SOAP_FMAC4 soap_get_merc__UpdateTransportMovementDetailsResponse(struct soap *soap, merc__UpdateTransportMovementDetailsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateTransportMovementDetailsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateTransportMovementDetailsResponse * FASTCALL soap_instantiate_merc__UpdateTransportMovementDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateTransportMovementDetailsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsResponse);
		ASSIGN_PTR(size, sizeof(merc__UpdateTransportMovementDetailsResponse));
		((merc__UpdateTransportMovementDetailsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateTransportMovementDetailsResponse));
		for(int i = 0; i < n; i++)
			((merc__UpdateTransportMovementDetailsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateTransportMovementDetailsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateTransportMovementDetailsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateTransportMovementDetailsResponse %p -> %p\n", q, p));
	*(merc__UpdateTransportMovementDetailsResponse*)p = *(merc__UpdateTransportMovementDetailsResponse*)q;
}

void merc__UpdateTransportMovementDetailsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant = NULL;
	this->merc__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid = 0;
	this->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
	this->merc__UpdateTransportMovementDetailsRequest::vd__shipmentRoute = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__UpdateTransportMovementDetailsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessMember(soap, &this->merc__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant);
	if(this->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid) {
		for(int i = 0; i < this->merc__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid; i++) {
			soap_serialize_base__UUID(soap, this->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid + i);
		}
	}
	soap_serialize_PointerTovd__ShipmentRoute(soap, &this->merc__UpdateTransportMovementDetailsRequest::vd__shipmentRoute);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__UpdateTransportMovementDetailsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__UpdateTransportMovementDetailsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, const merc__UpdateTransportMovementDetailsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest), "merc:UpdateTransportMovementDetailsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant) {
		if(soap_out_PointerToent__BusinessMember(soap, "vd:deliveryParticipant", -1, &a->merc__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:deliveryParticipant"))
		return soap->error;
	if(a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid) {
		int i;
		for(i = 0; i < a->merc__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid; i++)
			if(soap_out_base__UUID(soap, "vd:vetDocumentUuid", -1, a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid + i, ""))
				return soap->error;
	}
	if(a->merc__UpdateTransportMovementDetailsRequest::vd__shipmentRoute) {
		if(soap_out_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", -1, &a->merc__UpdateTransportMovementDetailsRequest::vd__shipmentRoute, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:shipmentRoute"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__UpdateTransportMovementDetailsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__UpdateTransportMovementDetailsRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsRequest * FASTCALL soap_in_merc__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, merc__UpdateTransportMovementDetailsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__UpdateTransportMovementDetailsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest, sizeof(merc__UpdateTransportMovementDetailsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__UpdateTransportMovementDetailsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vd__deliveryParticipant1 = 1;
	struct soap_blist *soap_blist_vd__vetDocumentUuid1 = NULL;
	size_t soap_flag_vd__shipmentRoute1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vd__deliveryParticipant1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessMember(soap, "vd:deliveryParticipant", &(a->merc__UpdateTransportMovementDetailsRequest::vd__deliveryParticipant), "ent:BusinessMember"))
				{	soap_flag_vd__deliveryParticipant1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "vd:vetDocumentUuid", 1, NULL)) {
				if(a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid == NULL) {
					if(soap_blist_vd__vetDocumentUuid1 == NULL)
						soap_blist_vd__vetDocumentUuid1 = soap_new_block(soap);
					a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = (char **)soap_push_block(soap, soap_blist_vd__vetDocumentUuid1, sizeof(char *));
					if(a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid == NULL)
						return NULL;
					*a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
				}
				soap_revert(soap);
				if(soap_in_base__UUID(soap, "vd:vetDocumentUuid", a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid, "base:UUID"))
				{	a->merc__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid++;
					a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
					continue;
				}
			}
			if(soap_flag_vd__shipmentRoute1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ShipmentRoute(soap, "vd:shipmentRoute", &(a->merc__UpdateTransportMovementDetailsRequest::vd__shipmentRoute), "vd:ShipmentRoute"))
				{	soap_flag_vd__shipmentRoute1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid)
			soap_pop_block(soap, soap_blist_vd__vetDocumentUuid1);
		if(a->merc__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid)
			a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = (char **)soap_save_block(soap, soap_blist_vd__vetDocumentUuid1, NULL, 1);
		else
		{	a->merc__UpdateTransportMovementDetailsRequest::vd__vetDocumentUuid = NULL;
			if(soap_blist_vd__vetDocumentUuid1)
				soap_end_block(soap, soap_blist_vd__vetDocumentUuid1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__UpdateTransportMovementDetailsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest, 0, sizeof(merc__UpdateTransportMovementDetailsRequest), 0, soap_copy_merc__UpdateTransportMovementDetailsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vd__deliveryParticipant1 > 0 || a->merc__UpdateTransportMovementDetailsRequest::__sizevetDocumentUuid < 1 || soap_flag_vd__shipmentRoute1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__UpdateTransportMovementDetailsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest);
	return this->soap_out(soap, tag?tag:"merc:UpdateTransportMovementDetailsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__UpdateTransportMovementDetailsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__UpdateTransportMovementDetailsRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsRequest * SOAP_FMAC4 soap_get_merc__UpdateTransportMovementDetailsRequest(struct soap *soap, merc__UpdateTransportMovementDetailsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__UpdateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__UpdateTransportMovementDetailsRequest * FASTCALL soap_instantiate_merc__UpdateTransportMovementDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__UpdateTransportMovementDetailsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsRequest);
		ASSIGN_PTR(size, sizeof(merc__UpdateTransportMovementDetailsRequest));
		((merc__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__UpdateTransportMovementDetailsRequest));
		for(int i = 0; i < n; i++)
			((merc__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__UpdateTransportMovementDetailsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__UpdateTransportMovementDetailsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__UpdateTransportMovementDetailsRequest %p -> %p\n", q, p));
	*(merc__UpdateTransportMovementDetailsRequest*)p = *(merc__UpdateTransportMovementDetailsRequest*)q;
}

void merc__GetStockEntryVersionListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryVersionListResponse::vd__stockEntryList = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryVersionListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->merc__GetStockEntryVersionListResponse::vd__stockEntryList);
	/* transient soap skipped */
}

int merc__GetStockEntryVersionListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryVersionListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, int id, const merc__GetStockEntryVersionListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryVersionListResponse), "merc:GetStockEntryVersionListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntryList)
		soap_element_result(soap, "vd:stockEntryList");
	if(a->merc__GetStockEntryVersionListResponse::vd__stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "vd:stockEntryList", -1, &a->merc__GetStockEntryVersionListResponse::vd__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryVersionListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryVersionListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryVersionListResponse * FASTCALL soap_in_merc__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, merc__GetStockEntryVersionListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryVersionListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryVersionListResponse, sizeof(merc__GetStockEntryVersionListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryVersionListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryVersionListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:stockEntryList", &(a->merc__GetStockEntryVersionListResponse::vd__stockEntryList), "vd:StockEntryList"))
				{	soap_flag_vd__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryVersionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryVersionListResponse, 0, sizeof(merc__GetStockEntryVersionListResponse), 0, soap_copy_merc__GetStockEntryVersionListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryVersionListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryVersionListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryVersionListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryVersionListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryVersionListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryVersionListResponse * SOAP_FMAC4 soap_get_merc__GetStockEntryVersionListResponse(struct soap *soap, merc__GetStockEntryVersionListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryVersionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryVersionListResponse * FASTCALL soap_instantiate_merc__GetStockEntryVersionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryVersionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryVersionListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryVersionListResponse));
		((merc__GetStockEntryVersionListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryVersionListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryVersionListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryVersionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryVersionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryVersionListResponse %p -> %p\n", q, p));
	*(merc__GetStockEntryVersionListResponse*)p = *(merc__GetStockEntryVersionListResponse*)q;
}

void merc__GetStockEntryVersionListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryVersionListRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->merc__GetStockEntryVersionListRequest::base__guid);
	soap_default_base__UUID(soap, &this->merc__GetStockEntryVersionListRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryVersionListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetStockEntryVersionListRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryVersionListRequest::base__guid);
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryVersionListRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetStockEntryVersionListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryVersionListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, const merc__GetStockEntryVersionListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryVersionListRequest), "merc:GetStockEntryVersionListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetStockEntryVersionListRequest::base__listOptions), ""))
		return soap->error;
	if(a->merc__GetStockEntryVersionListRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->merc__GetStockEntryVersionListRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	if(a->merc__GetStockEntryVersionListRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetStockEntryVersionListRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryVersionListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryVersionListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryVersionListRequest * FASTCALL soap_in_merc__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, merc__GetStockEntryVersionListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryVersionListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryVersionListRequest, sizeof(merc__GetStockEntryVersionListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryVersionListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryVersionListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__guid1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetStockEntryVersionListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->merc__GetStockEntryVersionListRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetStockEntryVersionListRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryVersionListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryVersionListRequest, 0, sizeof(merc__GetStockEntryVersionListRequest), 0, soap_copy_merc__GetStockEntryVersionListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__guid1 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryVersionListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryVersionListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryVersionListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryVersionListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryVersionListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryVersionListRequest * SOAP_FMAC4 soap_get_merc__GetStockEntryVersionListRequest(struct soap *soap, merc__GetStockEntryVersionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryVersionListRequest * FASTCALL soap_instantiate_merc__GetStockEntryVersionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryVersionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryVersionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryVersionListRequest));
		((merc__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryVersionListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryVersionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryVersionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryVersionListRequest %p -> %p\n", q, p));
	*(merc__GetStockEntryVersionListRequest*)p = *(merc__GetStockEntryVersionListRequest*)q;
}

void merc__GetStockEntryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryListResponse::vd__stockEntryList = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->merc__GetStockEntryListResponse::vd__stockEntryList);
	/* transient soap skipped */
}

int merc__GetStockEntryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryListResponse(struct soap *soap, const char *tag, int id, const merc__GetStockEntryListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryListResponse), "merc:GetStockEntryListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntryList)
		soap_element_result(soap, "vd:stockEntryList");
	if(a->merc__GetStockEntryListResponse::vd__stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "vd:stockEntryList", -1, &a->merc__GetStockEntryListResponse::vd__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryListResponse * FASTCALL soap_in_merc__GetStockEntryListResponse(struct soap *soap, const char *tag, merc__GetStockEntryListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryListResponse, sizeof(merc__GetStockEntryListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:stockEntryList", &(a->merc__GetStockEntryListResponse::vd__stockEntryList), "vd:StockEntryList"))
				{	soap_flag_vd__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryListResponse, 0, sizeof(merc__GetStockEntryListResponse), 0, soap_copy_merc__GetStockEntryListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryListResponse * SOAP_FMAC4 soap_get_merc__GetStockEntryListResponse(struct soap *soap, merc__GetStockEntryListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryListResponse * FASTCALL soap_instantiate_merc__GetStockEntryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryListResponse));
		((merc__GetStockEntryListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryListResponse %p -> %p\n", q, p));
	*(merc__GetStockEntryListResponse*)p = *(merc__GetStockEntryListResponse*)q;
}

void merc__GetStockEntryListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryListRequest::base__listOptions = NULL;
	soap_default_base__UUID(soap, &this->merc__GetStockEntryListRequest::ent__enterpriseGuid);
	this->merc__GetStockEntryListRequest::searchPattern = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetStockEntryListRequest::base__listOptions);
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryListRequest::ent__enterpriseGuid);
	soap_serialize_PointerTovd__StockEntrySearchPattern(soap, &this->merc__GetStockEntryListRequest::searchPattern);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetStockEntryListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryListRequest(struct soap *soap, const char *tag, int id, const merc__GetStockEntryListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryListRequest), "merc:GetStockEntryListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetStockEntryListRequest::base__listOptions), ""))
		return soap->error;
	if(a->merc__GetStockEntryListRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetStockEntryListRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	if(soap_out_PointerTovd__StockEntrySearchPattern(soap, "merc:searchPattern", -1, &(a->merc__GetStockEntryListRequest::searchPattern), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryListRequest * FASTCALL soap_in_merc__GetStockEntryListRequest(struct soap *soap, const char *tag, merc__GetStockEntryListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryListRequest, sizeof(merc__GetStockEntryListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	size_t soap_flag_searchPattern1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetStockEntryListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetStockEntryListRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap_flag_searchPattern1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntrySearchPattern(soap, "merc:searchPattern", &(a->merc__GetStockEntryListRequest::searchPattern), "vd:StockEntrySearchPattern"))
				{	soap_flag_searchPattern1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryListRequest, 0, sizeof(merc__GetStockEntryListRequest), 0, soap_copy_merc__GetStockEntryListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryListRequest * SOAP_FMAC4 soap_get_merc__GetStockEntryListRequest(struct soap *soap, merc__GetStockEntryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryListRequest * FASTCALL soap_instantiate_merc__GetStockEntryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryListRequest));
		((merc__GetStockEntryListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryListRequest %p -> %p\n", q, p));
	*(merc__GetStockEntryListRequest*)p = *(merc__GetStockEntryListRequest*)q;
}

void merc__GetStockEntryChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryChangesListResponse::vd__stockEntryList = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->merc__GetStockEntryChangesListResponse::vd__stockEntryList);
	/* transient soap skipped */
}

int merc__GetStockEntryChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, int id, const merc__GetStockEntryChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryChangesListResponse), "merc:GetStockEntryChangesListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntryList)
		soap_element_result(soap, "vd:stockEntryList");
	if(a->merc__GetStockEntryChangesListResponse::vd__stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "vd:stockEntryList", -1, &a->merc__GetStockEntryChangesListResponse::vd__stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryChangesListResponse * FASTCALL soap_in_merc__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, merc__GetStockEntryChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryChangesListResponse, sizeof(merc__GetStockEntryChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "vd:stockEntryList", &(a->merc__GetStockEntryChangesListResponse::vd__stockEntryList), "vd:StockEntryList"))
				{	soap_flag_vd__stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryChangesListResponse, 0, sizeof(merc__GetStockEntryChangesListResponse), 0, soap_copy_merc__GetStockEntryChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryChangesListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryChangesListResponse * SOAP_FMAC4 soap_get_merc__GetStockEntryChangesListResponse(struct soap *soap, merc__GetStockEntryChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryChangesListResponse * FASTCALL soap_instantiate_merc__GetStockEntryChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryChangesListResponse));
		((merc__GetStockEntryChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryChangesListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryChangesListResponse %p -> %p\n", q, p));
	*(merc__GetStockEntryChangesListResponse*)p = *(merc__GetStockEntryChangesListResponse*)q;
}

void merc__GetStockEntryChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryChangesListRequest::base__listOptions = NULL;
	this->merc__GetStockEntryChangesListRequest::base__updateDateInterval = NULL;
	soap_default_base__UUID(soap, &this->merc__GetStockEntryChangesListRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetStockEntryChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->merc__GetStockEntryChangesListRequest::base__updateDateInterval);
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryChangesListRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetStockEntryChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, const merc__GetStockEntryChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryChangesListRequest), "merc:GetStockEntryChangesListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetStockEntryChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->merc__GetStockEntryChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->merc__GetStockEntryChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	if(a->merc__GetStockEntryChangesListRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetStockEntryChangesListRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryChangesListRequest * FASTCALL soap_in_merc__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, merc__GetStockEntryChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryChangesListRequest, sizeof(merc__GetStockEntryChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetStockEntryChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->merc__GetStockEntryChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetStockEntryChangesListRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryChangesListRequest, 0, sizeof(merc__GetStockEntryChangesListRequest), 0, soap_copy_merc__GetStockEntryChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__updateDateInterval1 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryChangesListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryChangesListRequest * SOAP_FMAC4 soap_get_merc__GetStockEntryChangesListRequest(struct soap *soap, merc__GetStockEntryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryChangesListRequest * FASTCALL soap_instantiate_merc__GetStockEntryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryChangesListRequest));
		((merc__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryChangesListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryChangesListRequest %p -> %p\n", q, p));
	*(merc__GetStockEntryChangesListRequest*)p = *(merc__GetStockEntryChangesListRequest*)q;
}

void merc__GetStockEntryByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryByUuidResponse::vd__stockEntry = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->merc__GetStockEntryByUuidResponse::vd__stockEntry);
	/* transient soap skipped */
}

int merc__GetStockEntryByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, int id, const merc__GetStockEntryByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryByUuidResponse), "merc:GetStockEntryByUuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntry)
		soap_element_result(soap, "vd:stockEntry");
	if(a->merc__GetStockEntryByUuidResponse::vd__stockEntry) {
		if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, &a->merc__GetStockEntryByUuidResponse::vd__stockEntry, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntry"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryByUuidResponse * FASTCALL soap_in_merc__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, merc__GetStockEntryByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryByUuidResponse, sizeof(merc__GetStockEntryByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", &(a->merc__GetStockEntryByUuidResponse::vd__stockEntry), "vd:StockEntry"))
				{	soap_flag_vd__stockEntry1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryByUuidResponse, 0, sizeof(merc__GetStockEntryByUuidResponse), 0, soap_copy_merc__GetStockEntryByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntry1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryByUuidResponse);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryByUuidResponse * SOAP_FMAC4 soap_get_merc__GetStockEntryByUuidResponse(struct soap *soap, merc__GetStockEntryByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryByUuidResponse * FASTCALL soap_instantiate_merc__GetStockEntryByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidResponse);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryByUuidResponse));
		((merc__GetStockEntryByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByUuidResponse));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryByUuidResponse %p -> %p\n", q, p));
	*(merc__GetStockEntryByUuidResponse*)p = *(merc__GetStockEntryByUuidResponse*)q;
}

void merc__GetStockEntryByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->merc__GetStockEntryByUuidRequest::base__uuid);
	soap_default_base__UUID(soap, &this->merc__GetStockEntryByUuidRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryByUuidRequest::base__uuid);
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryByUuidRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetStockEntryByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, const merc__GetStockEntryByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryByUuidRequest), "merc:GetStockEntryByUuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__GetStockEntryByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->merc__GetStockEntryByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	if(a->merc__GetStockEntryByUuidRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetStockEntryByUuidRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryByUuidRequest * FASTCALL soap_in_merc__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, merc__GetStockEntryByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryByUuidRequest, sizeof(merc__GetStockEntryByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__uuid1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->merc__GetStockEntryByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetStockEntryByUuidRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryByUuidRequest, 0, sizeof(merc__GetStockEntryByUuidRequest), 0, soap_copy_merc__GetStockEntryByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__uuid1 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryByUuidRequest);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryByUuidRequest * SOAP_FMAC4 soap_get_merc__GetStockEntryByUuidRequest(struct soap *soap, merc__GetStockEntryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryByUuidRequest * FASTCALL soap_instantiate_merc__GetStockEntryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidRequest);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryByUuidRequest));
		((merc__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByUuidRequest));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryByUuidRequest %p -> %p\n", q, p));
	*(merc__GetStockEntryByUuidRequest*)p = *(merc__GetStockEntryByUuidRequest*)q;
}

void merc__GetStockEntryByGuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetStockEntryByGuidResponse::vd__stockEntry = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryByGuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntry(soap, &this->merc__GetStockEntryByGuidResponse::vd__stockEntry);
	/* transient soap skipped */
}

int merc__GetStockEntryByGuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryByGuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, int id, const merc__GetStockEntryByGuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryByGuidResponse), "merc:GetStockEntryByGuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__stockEntry)
		soap_element_result(soap, "vd:stockEntry");
	if(a->merc__GetStockEntryByGuidResponse::vd__stockEntry) {
		if(soap_out_PointerTovd__StockEntry(soap, "vd:stockEntry", -1, &a->merc__GetStockEntryByGuidResponse::vd__stockEntry, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:stockEntry"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryByGuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryByGuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryByGuidResponse * FASTCALL soap_in_merc__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, merc__GetStockEntryByGuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryByGuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryByGuidResponse, sizeof(merc__GetStockEntryByGuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryByGuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryByGuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__stockEntry1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__stockEntry1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntry(soap, "vd:stockEntry", &(a->merc__GetStockEntryByGuidResponse::vd__stockEntry), "vd:StockEntry"))
				{	soap_flag_vd__stockEntry1--;
					continue;
				}
			soap_check_result(soap, "vd:stockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryByGuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryByGuidResponse, 0, sizeof(merc__GetStockEntryByGuidResponse), 0, soap_copy_merc__GetStockEntryByGuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__stockEntry1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryByGuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryByGuidResponse);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryByGuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryByGuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryByGuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryByGuidResponse * SOAP_FMAC4 soap_get_merc__GetStockEntryByGuidResponse(struct soap *soap, merc__GetStockEntryByGuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryByGuidResponse * FASTCALL soap_instantiate_merc__GetStockEntryByGuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryByGuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryByGuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidResponse);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryByGuidResponse));
		((merc__GetStockEntryByGuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByGuidResponse));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryByGuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryByGuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryByGuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryByGuidResponse %p -> %p\n", q, p));
	*(merc__GetStockEntryByGuidResponse*)p = *(merc__GetStockEntryByGuidResponse*)q;
}

void merc__GetStockEntryByGuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->merc__GetStockEntryByGuidRequest::base__guid);
	soap_default_base__UUID(soap, &this->merc__GetStockEntryByGuidRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetStockEntryByGuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryByGuidRequest::base__guid);
	soap_serialize_base__UUID(soap, &this->merc__GetStockEntryByGuidRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetStockEntryByGuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetStockEntryByGuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, const merc__GetStockEntryByGuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetStockEntryByGuidRequest), "merc:GetStockEntryByGuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__GetStockEntryByGuidRequest::base__guid) {
		if(soap_out_base__UUID(soap, "base:guid", -1, &a->merc__GetStockEntryByGuidRequest::base__guid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:guid"))
		return soap->error;
	if(a->merc__GetStockEntryByGuidRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetStockEntryByGuidRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetStockEntryByGuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetStockEntryByGuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetStockEntryByGuidRequest * FASTCALL soap_in_merc__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, merc__GetStockEntryByGuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetStockEntryByGuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetStockEntryByGuidRequest, sizeof(merc__GetStockEntryByGuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetStockEntryByGuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetStockEntryByGuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__guid1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->merc__GetStockEntryByGuidRequest::base__guid), "base:UUID"))
				{	soap_flag_base__guid1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetStockEntryByGuidRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetStockEntryByGuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetStockEntryByGuidRequest, 0, sizeof(merc__GetStockEntryByGuidRequest), 0, soap_copy_merc__GetStockEntryByGuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__guid1 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetStockEntryByGuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetStockEntryByGuidRequest);
	return this->soap_out(soap, tag?tag:"merc:GetStockEntryByGuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetStockEntryByGuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetStockEntryByGuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetStockEntryByGuidRequest * SOAP_FMAC4 soap_get_merc__GetStockEntryByGuidRequest(struct soap *soap, merc__GetStockEntryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetStockEntryByGuidRequest * FASTCALL soap_instantiate_merc__GetStockEntryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetStockEntryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetStockEntryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidRequest);
		ASSIGN_PTR(size, sizeof(merc__GetStockEntryByGuidRequest));
		((merc__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByGuidRequest));
		for(int i = 0; i < n; i++)
			((merc__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetStockEntryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetStockEntryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetStockEntryByGuidRequest %p -> %p\n", q, p));
	*(merc__GetStockEntryByGuidRequest*)p = *(merc__GetStockEntryByGuidRequest*)q;
}

void merc__GetVetDocumentChangesListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetVetDocumentChangesListResponse::vd__vetDocumentList = NULL;
	/* transient soap skipped */
}

void merc__GetVetDocumentChangesListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocumentList(soap, &this->merc__GetVetDocumentChangesListResponse::vd__vetDocumentList);
	/* transient soap skipped */
}

int merc__GetVetDocumentChangesListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetVetDocumentChangesListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, int id, const merc__GetVetDocumentChangesListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetVetDocumentChangesListResponse), "merc:GetVetDocumentChangesListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__vetDocumentList)
		soap_element_result(soap, "vd:vetDocumentList");
	if(a->merc__GetVetDocumentChangesListResponse::vd__vetDocumentList) {
		if(soap_out_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", -1, &a->merc__GetVetDocumentChangesListResponse::vd__vetDocumentList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetDocumentList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetVetDocumentChangesListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetVetDocumentChangesListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListResponse * FASTCALL soap_in_merc__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, merc__GetVetDocumentChangesListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetVetDocumentChangesListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetVetDocumentChangesListResponse, sizeof(merc__GetVetDocumentChangesListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetVetDocumentChangesListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetVetDocumentChangesListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__vetDocumentList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__vetDocumentList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", &(a->merc__GetVetDocumentChangesListResponse::vd__vetDocumentList), "vd:VetDocumentList"))
				{	soap_flag_vd__vetDocumentList1--;
					continue;
				}
			soap_check_result(soap, "vd:vetDocumentList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetVetDocumentChangesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetVetDocumentChangesListResponse, 0, sizeof(merc__GetVetDocumentChangesListResponse), 0, soap_copy_merc__GetVetDocumentChangesListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__vetDocumentList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetVetDocumentChangesListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetVetDocumentChangesListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetVetDocumentChangesListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetVetDocumentChangesListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetVetDocumentChangesListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListResponse * SOAP_FMAC4 soap_get_merc__GetVetDocumentChangesListResponse(struct soap *soap, merc__GetVetDocumentChangesListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetVetDocumentChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetVetDocumentChangesListResponse * FASTCALL soap_instantiate_merc__GetVetDocumentChangesListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetVetDocumentChangesListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetVetDocumentChangesListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetVetDocumentChangesListResponse));
		((merc__GetVetDocumentChangesListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentChangesListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetVetDocumentChangesListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetVetDocumentChangesListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetVetDocumentChangesListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetVetDocumentChangesListResponse %p -> %p\n", q, p));
	*(merc__GetVetDocumentChangesListResponse*)p = *(merc__GetVetDocumentChangesListResponse*)q;
}

void merc__GetVetDocumentChangesListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetVetDocumentChangesListRequest::base__listOptions = NULL;
	this->merc__GetVetDocumentChangesListRequest::base__updateDateInterval = NULL;
	soap_default_base__UUID(soap, &this->merc__GetVetDocumentChangesListRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetVetDocumentChangesListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetVetDocumentChangesListRequest::base__listOptions);
	soap_serialize_PointerTobase__DateInterval(soap, &this->merc__GetVetDocumentChangesListRequest::base__updateDateInterval);
	soap_serialize_base__UUID(soap, &this->merc__GetVetDocumentChangesListRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetVetDocumentChangesListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetVetDocumentChangesListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, const merc__GetVetDocumentChangesListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetVetDocumentChangesListRequest), "merc:GetVetDocumentChangesListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetVetDocumentChangesListRequest::base__listOptions), ""))
		return soap->error;
	if(a->merc__GetVetDocumentChangesListRequest::base__updateDateInterval) {
		if(soap_out_PointerTobase__DateInterval(soap, "base:updateDateInterval", -1, &a->merc__GetVetDocumentChangesListRequest::base__updateDateInterval, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:updateDateInterval"))
		return soap->error;
	if(a->merc__GetVetDocumentChangesListRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetVetDocumentChangesListRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetVetDocumentChangesListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetVetDocumentChangesListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListRequest * FASTCALL soap_in_merc__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, merc__GetVetDocumentChangesListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetVetDocumentChangesListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetVetDocumentChangesListRequest, sizeof(merc__GetVetDocumentChangesListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetVetDocumentChangesListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetVetDocumentChangesListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_base__updateDateInterval1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetVetDocumentChangesListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_base__updateDateInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__DateInterval(soap, "base:updateDateInterval", &(a->merc__GetVetDocumentChangesListRequest::base__updateDateInterval), "base:DateInterval"))
				{	soap_flag_base__updateDateInterval1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetVetDocumentChangesListRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetVetDocumentChangesListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetVetDocumentChangesListRequest, 0, sizeof(merc__GetVetDocumentChangesListRequest), 0, soap_copy_merc__GetVetDocumentChangesListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__updateDateInterval1 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetVetDocumentChangesListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetVetDocumentChangesListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetVetDocumentChangesListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetVetDocumentChangesListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetVetDocumentChangesListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListRequest * SOAP_FMAC4 soap_get_merc__GetVetDocumentChangesListRequest(struct soap *soap, merc__GetVetDocumentChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetVetDocumentChangesListRequest * FASTCALL soap_instantiate_merc__GetVetDocumentChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetVetDocumentChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetVetDocumentChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetVetDocumentChangesListRequest));
		((merc__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentChangesListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetVetDocumentChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetVetDocumentChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetVetDocumentChangesListRequest %p -> %p\n", q, p));
	*(merc__GetVetDocumentChangesListRequest*)p = *(merc__GetVetDocumentChangesListRequest*)q;
}

void merc__GetVetDocumentListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetVetDocumentListResponse::vd__vetDocumentList = NULL;
	/* transient soap skipped */
}

void merc__GetVetDocumentListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocumentList(soap, &this->merc__GetVetDocumentListResponse::vd__vetDocumentList);
	/* transient soap skipped */
}

int merc__GetVetDocumentListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetVetDocumentListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetVetDocumentListResponse(struct soap *soap, const char *tag, int id, const merc__GetVetDocumentListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetVetDocumentListResponse), "merc:GetVetDocumentListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__vetDocumentList)
		soap_element_result(soap, "vd:vetDocumentList");
	if(a->merc__GetVetDocumentListResponse::vd__vetDocumentList) {
		if(soap_out_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", -1, &a->merc__GetVetDocumentListResponse::vd__vetDocumentList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetDocumentList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetVetDocumentListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetVetDocumentListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetVetDocumentListResponse * FASTCALL soap_in_merc__GetVetDocumentListResponse(struct soap *soap, const char *tag, merc__GetVetDocumentListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetVetDocumentListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetVetDocumentListResponse, sizeof(merc__GetVetDocumentListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetVetDocumentListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetVetDocumentListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__vetDocumentList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__vetDocumentList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentList(soap, "vd:vetDocumentList", &(a->merc__GetVetDocumentListResponse::vd__vetDocumentList), "vd:VetDocumentList"))
				{	soap_flag_vd__vetDocumentList1--;
					continue;
				}
			soap_check_result(soap, "vd:vetDocumentList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetVetDocumentListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetVetDocumentListResponse, 0, sizeof(merc__GetVetDocumentListResponse), 0, soap_copy_merc__GetVetDocumentListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__vetDocumentList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetVetDocumentListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetVetDocumentListResponse);
	return this->soap_out(soap, tag?tag:"merc:GetVetDocumentListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetVetDocumentListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetVetDocumentListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetVetDocumentListResponse * SOAP_FMAC4 soap_get_merc__GetVetDocumentListResponse(struct soap *soap, merc__GetVetDocumentListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetVetDocumentListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetVetDocumentListResponse * FASTCALL soap_instantiate_merc__GetVetDocumentListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetVetDocumentListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetVetDocumentListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListResponse);
		ASSIGN_PTR(size, sizeof(merc__GetVetDocumentListResponse));
		((merc__GetVetDocumentListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentListResponse));
		for(int i = 0; i < n; i++)
			((merc__GetVetDocumentListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetVetDocumentListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetVetDocumentListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetVetDocumentListResponse %p -> %p\n", q, p));
	*(merc__GetVetDocumentListResponse*)p = *(merc__GetVetDocumentListResponse*)q;
}

void merc__GetVetDocumentListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetVetDocumentListRequest::base__listOptions = NULL;
	this->merc__GetVetDocumentListRequest::vd__vetDocumentType = NULL;
	this->merc__GetVetDocumentListRequest::vd__vetDocumentStatus = NULL;
	soap_default_base__UUID(soap, &this->merc__GetVetDocumentListRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetVetDocumentListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTobase__ListOptions(soap, &this->merc__GetVetDocumentListRequest::base__listOptions);
	soap_serialize_PointerTovd__VetDocumentType(soap, &this->merc__GetVetDocumentListRequest::vd__vetDocumentType);
	soap_serialize_PointerTovd__VetDocumentStatus(soap, &this->merc__GetVetDocumentListRequest::vd__vetDocumentStatus);
	soap_serialize_base__UUID(soap, &this->merc__GetVetDocumentListRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetVetDocumentListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetVetDocumentListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetVetDocumentListRequest(struct soap *soap, const char *tag, int id, const merc__GetVetDocumentListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetVetDocumentListRequest), "merc:GetVetDocumentListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(soap_out_PointerTobase__ListOptions(soap, "base:listOptions", -1, &(a->merc__GetVetDocumentListRequest::base__listOptions), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentType(soap, "vd:vetDocumentType", -1, &(a->merc__GetVetDocumentListRequest::vd__vetDocumentType), ""))
		return soap->error;
	if(soap_out_PointerTovd__VetDocumentStatus(soap, "vd:vetDocumentStatus", -1, &(a->merc__GetVetDocumentListRequest::vd__vetDocumentStatus), ""))
		return soap->error;
	if(a->merc__GetVetDocumentListRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetVetDocumentListRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetVetDocumentListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetVetDocumentListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetVetDocumentListRequest * FASTCALL soap_in_merc__GetVetDocumentListRequest(struct soap *soap, const char *tag, merc__GetVetDocumentListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetVetDocumentListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetVetDocumentListRequest, sizeof(merc__GetVetDocumentListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetVetDocumentListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetVetDocumentListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__listOptions1 = 1;
	size_t soap_flag_vd__vetDocumentType1 = 1;
	size_t soap_flag_vd__vetDocumentStatus1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__listOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__ListOptions(soap, "base:listOptions", &(a->merc__GetVetDocumentListRequest::base__listOptions), "base:ListOptions"))
				{	soap_flag_base__listOptions1--;
					continue;
				}
			if(soap_flag_vd__vetDocumentType1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentType(soap, "vd:vetDocumentType", &(a->merc__GetVetDocumentListRequest::vd__vetDocumentType), "vd:VetDocumentType"))
				{	soap_flag_vd__vetDocumentType1--;
					continue;
				}
			if(soap_flag_vd__vetDocumentStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocumentStatus(soap, "vd:vetDocumentStatus", &(a->merc__GetVetDocumentListRequest::vd__vetDocumentStatus), "vd:VetDocumentStatus"))
				{	soap_flag_vd__vetDocumentStatus1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetVetDocumentListRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetVetDocumentListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetVetDocumentListRequest, 0, sizeof(merc__GetVetDocumentListRequest), 0, soap_copy_merc__GetVetDocumentListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetVetDocumentListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetVetDocumentListRequest);
	return this->soap_out(soap, tag?tag:"merc:GetVetDocumentListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetVetDocumentListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetVetDocumentListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetVetDocumentListRequest * SOAP_FMAC4 soap_get_merc__GetVetDocumentListRequest(struct soap *soap, merc__GetVetDocumentListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetVetDocumentListRequest * FASTCALL soap_instantiate_merc__GetVetDocumentListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetVetDocumentListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetVetDocumentListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListRequest);
		ASSIGN_PTR(size, sizeof(merc__GetVetDocumentListRequest));
		((merc__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentListRequest));
		for(int i = 0; i < n; i++)
			((merc__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetVetDocumentListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetVetDocumentListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetVetDocumentListRequest %p -> %p\n", q, p));
	*(merc__GetVetDocumentListRequest*)p = *(merc__GetVetDocumentListRequest*)q;
}

void merc__GetVetDocumentByUuidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__GetVetDocumentByUuidResponse::vd__vetDocument = NULL;
	/* transient soap skipped */
}

void merc__GetVetDocumentByUuidResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocument(soap, &this->merc__GetVetDocumentByUuidResponse::vd__vetDocument);
	/* transient soap skipped */
}

int merc__GetVetDocumentByUuidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetVetDocumentByUuidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, int id, const merc__GetVetDocumentByUuidResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetVetDocumentByUuidResponse), "merc:GetVetDocumentByUuidResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vd__vetDocument)
		soap_element_result(soap, "vd:vetDocument");
	if(a->merc__GetVetDocumentByUuidResponse::vd__vetDocument) {
		if(soap_out_PointerTovd__VetDocument(soap, "vd:vetDocument", -1, &a->merc__GetVetDocumentByUuidResponse::vd__vetDocument, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "vd:vetDocument"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetVetDocumentByUuidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetVetDocumentByUuidResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidResponse * FASTCALL soap_in_merc__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, merc__GetVetDocumentByUuidResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetVetDocumentByUuidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetVetDocumentByUuidResponse, sizeof(merc__GetVetDocumentByUuidResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetVetDocumentByUuidResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetVetDocumentByUuidResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vd__vetDocument1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vd__vetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocument(soap, "vd:vetDocument", &(a->merc__GetVetDocumentByUuidResponse::vd__vetDocument), "vd:VetDocument"))
				{	soap_flag_vd__vetDocument1--;
					continue;
				}
			soap_check_result(soap, "vd:vetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetVetDocumentByUuidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetVetDocumentByUuidResponse, 0, sizeof(merc__GetVetDocumentByUuidResponse), 0, soap_copy_merc__GetVetDocumentByUuidResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_vd__vetDocument1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetVetDocumentByUuidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetVetDocumentByUuidResponse);
	return this->soap_out(soap, tag?tag:"merc:GetVetDocumentByUuidResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetVetDocumentByUuidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetVetDocumentByUuidResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidResponse * SOAP_FMAC4 soap_get_merc__GetVetDocumentByUuidResponse(struct soap *soap, merc__GetVetDocumentByUuidResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetVetDocumentByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetVetDocumentByUuidResponse * FASTCALL soap_instantiate_merc__GetVetDocumentByUuidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetVetDocumentByUuidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetVetDocumentByUuidResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidResponse);
		ASSIGN_PTR(size, sizeof(merc__GetVetDocumentByUuidResponse));
		((merc__GetVetDocumentByUuidResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentByUuidResponse));
		for(int i = 0; i < n; i++)
			((merc__GetVetDocumentByUuidResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetVetDocumentByUuidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetVetDocumentByUuidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetVetDocumentByUuidResponse %p -> %p\n", q, p));
	*(merc__GetVetDocumentByUuidResponse*)p = *(merc__GetVetDocumentByUuidResponse*)q;
}

void merc__GetVetDocumentByUuidRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->merc__GetVetDocumentByUuidRequest::base__uuid);
	soap_default_base__UUID(soap, &this->merc__GetVetDocumentByUuidRequest::ent__enterpriseGuid);
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__GetVetDocumentByUuidRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->merc__GetVetDocumentByUuidRequest::base__uuid);
	soap_serialize_base__UUID(soap, &this->merc__GetVetDocumentByUuidRequest::ent__enterpriseGuid);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__GetVetDocumentByUuidRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__GetVetDocumentByUuidRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, const merc__GetVetDocumentByUuidRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__GetVetDocumentByUuidRequest), "merc:GetVetDocumentByUuidRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__GetVetDocumentByUuidRequest::base__uuid) {
		if(soap_out_base__UUID(soap, "base:uuid", -1, &a->merc__GetVetDocumentByUuidRequest::base__uuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:uuid"))
		return soap->error;
	if(a->merc__GetVetDocumentByUuidRequest::ent__enterpriseGuid) {
		if(soap_out_base__UUID(soap, "ent:enterpriseGuid", -1, &a->merc__GetVetDocumentByUuidRequest::ent__enterpriseGuid, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ent:enterpriseGuid"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__GetVetDocumentByUuidRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__GetVetDocumentByUuidRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidRequest * FASTCALL soap_in_merc__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, merc__GetVetDocumentByUuidRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__GetVetDocumentByUuidRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__GetVetDocumentByUuidRequest, sizeof(merc__GetVetDocumentByUuidRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__GetVetDocumentByUuidRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__GetVetDocumentByUuidRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_base__uuid1 = 1;
	size_t soap_flag_ent__enterpriseGuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_base__uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->merc__GetVetDocumentByUuidRequest::base__uuid), "base:UUID"))
				{	soap_flag_base__uuid1--;
					continue;
				}
			if(soap_flag_ent__enterpriseGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ent:enterpriseGuid", &(a->merc__GetVetDocumentByUuidRequest::ent__enterpriseGuid), "base:UUID"))
				{	soap_flag_ent__enterpriseGuid1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__GetVetDocumentByUuidRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__GetVetDocumentByUuidRequest, 0, sizeof(merc__GetVetDocumentByUuidRequest), 0, soap_copy_merc__GetVetDocumentByUuidRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_base__uuid1 > 0 || soap_flag_ent__enterpriseGuid1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__GetVetDocumentByUuidRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__GetVetDocumentByUuidRequest);
	return this->soap_out(soap, tag?tag:"merc:GetVetDocumentByUuidRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__GetVetDocumentByUuidRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__GetVetDocumentByUuidRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidRequest * SOAP_FMAC4 soap_get_merc__GetVetDocumentByUuidRequest(struct soap *soap, merc__GetVetDocumentByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__GetVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__GetVetDocumentByUuidRequest * FASTCALL soap_instantiate_merc__GetVetDocumentByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__GetVetDocumentByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__GetVetDocumentByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidRequest);
		ASSIGN_PTR(size, sizeof(merc__GetVetDocumentByUuidRequest));
		((merc__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentByUuidRequest));
		for(int i = 0; i < n; i++)
			((merc__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__GetVetDocumentByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__GetVetDocumentByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__GetVetDocumentByUuidRequest %p -> %p\n", q, p));
	*(merc__GetVetDocumentByUuidRequest*)p = *(merc__GetVetDocumentByUuidRequest*)q;
}

void merc__ModifyProducerStockListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyProducerStockListResponse::productItemList = NULL;
	/* transient soap skipped */
}

void merc__ModifyProducerStockListResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__ProductItemList(soap, &this->merc__ModifyProducerStockListResponse::productItemList);
	/* transient soap skipped */
}

int merc__ModifyProducerStockListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyProducerStockListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyProducerStockListResponse(struct soap *soap, const char *tag, int id, const merc__ModifyProducerStockListResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyProducerStockListResponse), "merc:ModifyProducerStockListResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->productItemList)
		soap_element_result(soap, "merc:productItemList");
	if(a->merc__ModifyProducerStockListResponse::productItemList) {
		if(soap_out_PointerToent__ProductItemList(soap, "merc:productItemList", -1, &a->merc__ModifyProducerStockListResponse::productItemList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:productItemList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyProducerStockListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyProducerStockListResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyProducerStockListResponse * FASTCALL soap_in_merc__ModifyProducerStockListResponse(struct soap *soap, const char *tag, merc__ModifyProducerStockListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyProducerStockListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyProducerStockListResponse, sizeof(merc__ModifyProducerStockListResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyProducerStockListResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyProducerStockListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_productItemList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_productItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__ProductItemList(soap, "merc:productItemList", &(a->merc__ModifyProducerStockListResponse::productItemList), "ent:ProductItemList"))
				{	soap_flag_productItemList1--;
					continue;
				}
			soap_check_result(soap, "merc:productItemList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyProducerStockListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyProducerStockListResponse, 0, sizeof(merc__ModifyProducerStockListResponse), 0, soap_copy_merc__ModifyProducerStockListResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_productItemList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ModifyProducerStockListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyProducerStockListResponse);
	return this->soap_out(soap, tag?tag:"merc:ModifyProducerStockListResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyProducerStockListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyProducerStockListResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyProducerStockListResponse * SOAP_FMAC4 soap_get_merc__ModifyProducerStockListResponse(struct soap *soap, merc__ModifyProducerStockListResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyProducerStockListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyProducerStockListResponse * FASTCALL soap_instantiate_merc__ModifyProducerStockListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyProducerStockListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyProducerStockListResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListResponse);
		ASSIGN_PTR(size, sizeof(merc__ModifyProducerStockListResponse));
		((merc__ModifyProducerStockListResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyProducerStockListResponse));
		for(int i = 0; i < n; i++)
			((merc__ModifyProducerStockListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyProducerStockListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyProducerStockListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyProducerStockListResponse %p -> %p\n", q, p));
	*(merc__ModifyProducerStockListResponse*)p = *(merc__ModifyProducerStockListResponse*)q;
}

void merc__ModifyProducerStockListRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyProducerStockListRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__ModifyProducerStockListRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__PSLModificationOperation(soap, &this->merc__ModifyProducerStockListRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__ModifyProducerStockListRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyProducerStockListRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyProducerStockListRequest(struct soap *soap, const char *tag, int id, const merc__ModifyProducerStockListRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyProducerStockListRequest), "merc:ModifyProducerStockListRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__ModifyProducerStockListRequest::modificationOperation) {
		if(soap_out_PointerTovd__PSLModificationOperation(soap, "merc:modificationOperation", -1, &a->merc__ModifyProducerStockListRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyProducerStockListRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyProducerStockListRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyProducerStockListRequest * FASTCALL soap_in_merc__ModifyProducerStockListRequest(struct soap *soap, const char *tag, merc__ModifyProducerStockListRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyProducerStockListRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyProducerStockListRequest, sizeof(merc__ModifyProducerStockListRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyProducerStockListRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyProducerStockListRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__PSLModificationOperation(soap, "merc:modificationOperation", &(a->merc__ModifyProducerStockListRequest::modificationOperation), "vd:PSLModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyProducerStockListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyProducerStockListRequest, 0, sizeof(merc__ModifyProducerStockListRequest), 0, soap_copy_merc__ModifyProducerStockListRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ModifyProducerStockListRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyProducerStockListRequest);
	return this->soap_out(soap, tag?tag:"merc:ModifyProducerStockListRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyProducerStockListRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyProducerStockListRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyProducerStockListRequest * SOAP_FMAC4 soap_get_merc__ModifyProducerStockListRequest(struct soap *soap, merc__ModifyProducerStockListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyProducerStockListRequest * FASTCALL soap_instantiate_merc__ModifyProducerStockListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyProducerStockListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyProducerStockListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListRequest);
		ASSIGN_PTR(size, sizeof(merc__ModifyProducerStockListRequest));
		((merc__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyProducerStockListRequest));
		for(int i = 0; i < n; i++)
			((merc__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyProducerStockListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyProducerStockListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyProducerStockListRequest %p -> %p\n", q, p));
	*(merc__ModifyProducerStockListRequest*)p = *(merc__ModifyProducerStockListRequest*)q;
}

void merc__ResolveDiscrepancyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ResolveDiscrepancyResponse::stockEntryList = NULL;
	/* transient soap skipped */
}

void merc__ResolveDiscrepancyResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->merc__ResolveDiscrepancyResponse::stockEntryList);
	/* transient soap skipped */
}

int merc__ResolveDiscrepancyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ResolveDiscrepancyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, int id, const merc__ResolveDiscrepancyResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ResolveDiscrepancyResponse), "merc:ResolveDiscrepancyResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "merc:stockEntryList");
	if(a->merc__ResolveDiscrepancyResponse::stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "merc:stockEntryList", -1, &a->merc__ResolveDiscrepancyResponse::stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ResolveDiscrepancyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ResolveDiscrepancyResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__ResolveDiscrepancyResponse * FASTCALL soap_in_merc__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, merc__ResolveDiscrepancyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ResolveDiscrepancyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ResolveDiscrepancyResponse, sizeof(merc__ResolveDiscrepancyResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ResolveDiscrepancyResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ResolveDiscrepancyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "merc:stockEntryList", &(a->merc__ResolveDiscrepancyResponse::stockEntryList), "vd:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "merc:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ResolveDiscrepancyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ResolveDiscrepancyResponse, 0, sizeof(merc__ResolveDiscrepancyResponse), 0, soap_copy_merc__ResolveDiscrepancyResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ResolveDiscrepancyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ResolveDiscrepancyResponse);
	return this->soap_out(soap, tag?tag:"merc:ResolveDiscrepancyResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ResolveDiscrepancyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ResolveDiscrepancyResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__ResolveDiscrepancyResponse * SOAP_FMAC4 soap_get_merc__ResolveDiscrepancyResponse(struct soap *soap, merc__ResolveDiscrepancyResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ResolveDiscrepancyResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ResolveDiscrepancyResponse * FASTCALL soap_instantiate_merc__ResolveDiscrepancyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ResolveDiscrepancyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ResolveDiscrepancyResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyResponse);
		ASSIGN_PTR(size, sizeof(merc__ResolveDiscrepancyResponse));
		((merc__ResolveDiscrepancyResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ResolveDiscrepancyResponse));
		for(int i = 0; i < n; i++)
			((merc__ResolveDiscrepancyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ResolveDiscrepancyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ResolveDiscrepancyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ResolveDiscrepancyResponse %p -> %p\n", q, p));
	*(merc__ResolveDiscrepancyResponse*)p = *(merc__ResolveDiscrepancyResponse*)q;
}

void merc__ResolveDiscrepancyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ResolveDiscrepancyRequest::enterprise = NULL;
	soap_default_time(soap, &this->merc__ResolveDiscrepancyRequest::inventoryDate);
	this->merc__ResolveDiscrepancyRequest::responsible = NULL;
	this->merc__ResolveDiscrepancyRequest::__sizestockDiscrepancy = 0;
	this->merc__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
	this->merc__ResolveDiscrepancyRequest::__sizediscrepancyReport = 0;
	this->merc__ResolveDiscrepancyRequest::discrepancyReport = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__ResolveDiscrepancyRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->merc__ResolveDiscrepancyRequest::enterprise);
	soap_embedded(soap, &this->merc__ResolveDiscrepancyRequest::inventoryDate, SOAP_TYPE_time);
	soap_serialize_PointerTovd__User(soap, &this->merc__ResolveDiscrepancyRequest::responsible);
	if(this->merc__ResolveDiscrepancyRequest::stockDiscrepancy) {
		for(int i = 0; i < this->merc__ResolveDiscrepancyRequest::__sizestockDiscrepancy; i++) {
			soap_serialize_PointerTovd__StockDiscrepancy(soap, this->merc__ResolveDiscrepancyRequest::stockDiscrepancy + i);
		}
	}
	if(this->merc__ResolveDiscrepancyRequest::discrepancyReport) {
		for(int i = 0; i < this->merc__ResolveDiscrepancyRequest::__sizediscrepancyReport; i++) {
			soap_serialize_PointerTovd__DiscrepancyReport(soap, this->merc__ResolveDiscrepancyRequest::discrepancyReport + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__ResolveDiscrepancyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ResolveDiscrepancyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, const merc__ResolveDiscrepancyRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ResolveDiscrepancyRequest), "merc:ResolveDiscrepancyRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__ResolveDiscrepancyRequest::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "merc:enterprise", -1, &a->merc__ResolveDiscrepancyRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:enterprise"))
		return soap->error;
	if(soap_out_time(soap, "merc:inventoryDate", -1, &(a->merc__ResolveDiscrepancyRequest::inventoryDate), ""))
		return soap->error;
	if(a->merc__ResolveDiscrepancyRequest::responsible) {
		if(soap_out_PointerTovd__User(soap, "merc:responsible", -1, &a->merc__ResolveDiscrepancyRequest::responsible, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:responsible"))
		return soap->error;
	if(a->merc__ResolveDiscrepancyRequest::stockDiscrepancy) {
		int i;
		for(i = 0; i < a->merc__ResolveDiscrepancyRequest::__sizestockDiscrepancy; i++)
			if(soap_out_PointerTovd__StockDiscrepancy(soap, "merc:stockDiscrepancy", -1, a->merc__ResolveDiscrepancyRequest::stockDiscrepancy + i, ""))
				return soap->error;
	}
	if(a->merc__ResolveDiscrepancyRequest::discrepancyReport) {
		int i;
		for(i = 0; i < a->merc__ResolveDiscrepancyRequest::__sizediscrepancyReport; i++)
			if(soap_out_PointerTovd__DiscrepancyReport(soap, "merc:discrepancyReport", -1, a->merc__ResolveDiscrepancyRequest::discrepancyReport + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__ResolveDiscrepancyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ResolveDiscrepancyRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__ResolveDiscrepancyRequest * FASTCALL soap_in_merc__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, merc__ResolveDiscrepancyRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ResolveDiscrepancyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ResolveDiscrepancyRequest, sizeof(merc__ResolveDiscrepancyRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ResolveDiscrepancyRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ResolveDiscrepancyRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_inventoryDate1 = 1;
	size_t soap_flag_responsible1 = 1;
	struct soap_blist *soap_blist_stockDiscrepancy1 = NULL;
	struct soap_blist *soap_blist_discrepancyReport1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "merc:enterprise", &(a->merc__ResolveDiscrepancyRequest::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_inventoryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "merc:inventoryDate", &(a->merc__ResolveDiscrepancyRequest::inventoryDate), "xsd:dateTime"))
				{	soap_flag_inventoryDate1--;
					continue;
				}
			if(soap_flag_responsible1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:responsible", &(a->merc__ResolveDiscrepancyRequest::responsible), "vd:User"))
				{	soap_flag_responsible1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:stockDiscrepancy", 1, NULL)) {
				if(a->merc__ResolveDiscrepancyRequest::stockDiscrepancy == NULL) {
					if(soap_blist_stockDiscrepancy1 == NULL)
						soap_blist_stockDiscrepancy1 = soap_new_block(soap);
					a->merc__ResolveDiscrepancyRequest::stockDiscrepancy = (vd__StockDiscrepancy **)soap_push_block(soap, soap_blist_stockDiscrepancy1, sizeof(vd__StockDiscrepancy *));
					if(a->merc__ResolveDiscrepancyRequest::stockDiscrepancy == NULL)
						return NULL;
					*a->merc__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockDiscrepancy(soap, "merc:stockDiscrepancy", a->merc__ResolveDiscrepancyRequest::stockDiscrepancy, "vd:StockDiscrepancy"))
				{	a->merc__ResolveDiscrepancyRequest::__sizestockDiscrepancy++;
					a->merc__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:discrepancyReport", 1, NULL)) {
				if(a->merc__ResolveDiscrepancyRequest::discrepancyReport == NULL) {
					if(soap_blist_discrepancyReport1 == NULL)
						soap_blist_discrepancyReport1 = soap_new_block(soap);
					a->merc__ResolveDiscrepancyRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_push_block(soap, soap_blist_discrepancyReport1, sizeof(vd__DiscrepancyReport *));
					if(a->merc__ResolveDiscrepancyRequest::discrepancyReport == NULL)
						return NULL;
					*a->merc__ResolveDiscrepancyRequest::discrepancyReport = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__DiscrepancyReport(soap, "merc:discrepancyReport", a->merc__ResolveDiscrepancyRequest::discrepancyReport, "vd:DiscrepancyReport"))
				{	a->merc__ResolveDiscrepancyRequest::__sizediscrepancyReport++;
					a->merc__ResolveDiscrepancyRequest::discrepancyReport = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__ResolveDiscrepancyRequest::stockDiscrepancy)
			soap_pop_block(soap, soap_blist_stockDiscrepancy1);
		if(a->merc__ResolveDiscrepancyRequest::__sizestockDiscrepancy)
			a->merc__ResolveDiscrepancyRequest::stockDiscrepancy = (vd__StockDiscrepancy **)soap_save_block(soap, soap_blist_stockDiscrepancy1, NULL, 1);
		else
		{	a->merc__ResolveDiscrepancyRequest::stockDiscrepancy = NULL;
			if(soap_blist_stockDiscrepancy1)
				soap_end_block(soap, soap_blist_stockDiscrepancy1);
		}
		if(a->merc__ResolveDiscrepancyRequest::discrepancyReport)
			soap_pop_block(soap, soap_blist_discrepancyReport1);
		if(a->merc__ResolveDiscrepancyRequest::__sizediscrepancyReport)
			a->merc__ResolveDiscrepancyRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_save_block(soap, soap_blist_discrepancyReport1, NULL, 1);
		else
		{	a->merc__ResolveDiscrepancyRequest::discrepancyReport = NULL;
			if(soap_blist_discrepancyReport1)
				soap_end_block(soap, soap_blist_discrepancyReport1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ResolveDiscrepancyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ResolveDiscrepancyRequest, 0, sizeof(merc__ResolveDiscrepancyRequest), 0, soap_copy_merc__ResolveDiscrepancyRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_inventoryDate1 > 0 || soap_flag_responsible1 > 0 || a->merc__ResolveDiscrepancyRequest::__sizestockDiscrepancy < 1 || a->merc__ResolveDiscrepancyRequest::__sizediscrepancyReport < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ResolveDiscrepancyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ResolveDiscrepancyRequest);
	return this->soap_out(soap, tag?tag:"merc:ResolveDiscrepancyRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ResolveDiscrepancyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ResolveDiscrepancyRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__ResolveDiscrepancyRequest * SOAP_FMAC4 soap_get_merc__ResolveDiscrepancyRequest(struct soap *soap, merc__ResolveDiscrepancyRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ResolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ResolveDiscrepancyRequest * FASTCALL soap_instantiate_merc__ResolveDiscrepancyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ResolveDiscrepancyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ResolveDiscrepancyRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyRequest);
		ASSIGN_PTR(size, sizeof(merc__ResolveDiscrepancyRequest));
		((merc__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ResolveDiscrepancyRequest));
		for(int i = 0; i < n; i++)
			((merc__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ResolveDiscrepancyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ResolveDiscrepancyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ResolveDiscrepancyRequest %p -> %p\n", q, p));
	*(merc__ResolveDiscrepancyRequest*)p = *(merc__ResolveDiscrepancyRequest*)q;
}

void merc__ModifyActivityLocationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyActivityLocationsResponse::businessEntity = NULL;
	/* transient soap skipped */
}

void merc__ModifyActivityLocationsResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__BusinessEntity(soap, &this->merc__ModifyActivityLocationsResponse::businessEntity);
	/* transient soap skipped */
}

int merc__ModifyActivityLocationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyActivityLocationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, int id, const merc__ModifyActivityLocationsResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyActivityLocationsResponse), "merc:ModifyActivityLocationsResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->businessEntity)
		soap_element_result(soap, "merc:businessEntity");
	if(soap_out_PointerToent__BusinessEntity(soap, "merc:businessEntity", -1, &(a->merc__ModifyActivityLocationsResponse::businessEntity), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyActivityLocationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyActivityLocationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyActivityLocationsResponse * FASTCALL soap_in_merc__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, merc__ModifyActivityLocationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyActivityLocationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyActivityLocationsResponse, sizeof(merc__ModifyActivityLocationsResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyActivityLocationsResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyActivityLocationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessEntity1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_businessEntity1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__BusinessEntity(soap, "merc:businessEntity", &(a->merc__ModifyActivityLocationsResponse::businessEntity), "ent:BusinessEntity"))
				{	soap_flag_businessEntity1--;
					continue;
				}
			soap_check_result(soap, "merc:businessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyActivityLocationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyActivityLocationsResponse, 0, sizeof(merc__ModifyActivityLocationsResponse), 0, soap_copy_merc__ModifyActivityLocationsResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__ModifyActivityLocationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyActivityLocationsResponse);
	return this->soap_out(soap, tag?tag:"merc:ModifyActivityLocationsResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyActivityLocationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyActivityLocationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyActivityLocationsResponse * SOAP_FMAC4 soap_get_merc__ModifyActivityLocationsResponse(struct soap *soap, merc__ModifyActivityLocationsResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyActivityLocationsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyActivityLocationsResponse * FASTCALL soap_instantiate_merc__ModifyActivityLocationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyActivityLocationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyActivityLocationsResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsResponse);
		ASSIGN_PTR(size, sizeof(merc__ModifyActivityLocationsResponse));
		((merc__ModifyActivityLocationsResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyActivityLocationsResponse));
		for(int i = 0; i < n; i++)
			((merc__ModifyActivityLocationsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyActivityLocationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyActivityLocationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyActivityLocationsResponse %p -> %p\n", q, p));
	*(merc__ModifyActivityLocationsResponse*)p = *(merc__ModifyActivityLocationsResponse*)q;
}

void merc__ModifyActivityLocationsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyActivityLocationsRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__ModifyActivityLocationsRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__BEActivityLocationsModificationOperation(soap, &this->merc__ModifyActivityLocationsRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__ModifyActivityLocationsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyActivityLocationsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, const merc__ModifyActivityLocationsRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyActivityLocationsRequest), "merc:ModifyActivityLocationsRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__ModifyActivityLocationsRequest::modificationOperation) {
		if(soap_out_PointerTovd__BEActivityLocationsModificationOperation(soap, "merc:modificationOperation", -1, &a->merc__ModifyActivityLocationsRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyActivityLocationsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyActivityLocationsRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyActivityLocationsRequest * FASTCALL soap_in_merc__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, merc__ModifyActivityLocationsRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyActivityLocationsRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyActivityLocationsRequest, sizeof(merc__ModifyActivityLocationsRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyActivityLocationsRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyActivityLocationsRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BEActivityLocationsModificationOperation(soap, "merc:modificationOperation", &(a->merc__ModifyActivityLocationsRequest::modificationOperation), "vd:BEActivityLocationsModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyActivityLocationsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyActivityLocationsRequest, 0, sizeof(merc__ModifyActivityLocationsRequest), 0, soap_copy_merc__ModifyActivityLocationsRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ModifyActivityLocationsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyActivityLocationsRequest);
	return this->soap_out(soap, tag?tag:"merc:ModifyActivityLocationsRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyActivityLocationsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyActivityLocationsRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyActivityLocationsRequest * SOAP_FMAC4 soap_get_merc__ModifyActivityLocationsRequest(struct soap *soap, merc__ModifyActivityLocationsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyActivityLocationsRequest * FASTCALL soap_instantiate_merc__ModifyActivityLocationsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyActivityLocationsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyActivityLocationsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsRequest);
		ASSIGN_PTR(size, sizeof(merc__ModifyActivityLocationsRequest));
		((merc__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyActivityLocationsRequest));
		for(int i = 0; i < n; i++)
			((merc__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyActivityLocationsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyActivityLocationsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyActivityLocationsRequest %p -> %p\n", q, p));
	*(merc__ModifyActivityLocationsRequest*)p = *(merc__ModifyActivityLocationsRequest*)q;
}

void merc__ModifyEnterpriseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyEnterpriseResponse::__sizeenterprise = 0;
	this->merc__ModifyEnterpriseResponse::enterprise = NULL;
	/* transient soap skipped */
}

void merc__ModifyEnterpriseResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__ModifyEnterpriseResponse::enterprise) {
		for(int i = 0; i < this->merc__ModifyEnterpriseResponse::__sizeenterprise; i++) {
			soap_serialize_PointerToent__Enterprise(soap, this->merc__ModifyEnterpriseResponse::enterprise + i);
		}
	}
	/* transient soap skipped */
}

int merc__ModifyEnterpriseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyEnterpriseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyEnterpriseResponse(struct soap *soap, const char *tag, int id, const merc__ModifyEnterpriseResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyEnterpriseResponse), "merc:ModifyEnterpriseResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizeenterprise");
	if(a->merc__ModifyEnterpriseResponse::enterprise) {
		int i;
		for(i = 0; i < a->merc__ModifyEnterpriseResponse::__sizeenterprise; i++)
			if(soap_out_PointerToent__Enterprise(soap, "merc:enterprise", -1, a->merc__ModifyEnterpriseResponse::enterprise + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyEnterpriseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyEnterpriseResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyEnterpriseResponse * FASTCALL soap_in_merc__ModifyEnterpriseResponse(struct soap *soap, const char *tag, merc__ModifyEnterpriseResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyEnterpriseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyEnterpriseResponse, sizeof(merc__ModifyEnterpriseResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyEnterpriseResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyEnterpriseResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_enterprise1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:enterprise", 1, NULL)) {
				if(a->merc__ModifyEnterpriseResponse::enterprise == NULL) {
					if(soap_blist_enterprise1 == NULL)
						soap_blist_enterprise1 = soap_new_block(soap);
					a->merc__ModifyEnterpriseResponse::enterprise = (ent__Enterprise **)soap_push_block(soap, soap_blist_enterprise1, sizeof(ent__Enterprise *));
					if(a->merc__ModifyEnterpriseResponse::enterprise == NULL)
						return NULL;
					*a->merc__ModifyEnterpriseResponse::enterprise = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__Enterprise(soap, "merc:enterprise", a->merc__ModifyEnterpriseResponse::enterprise, "ent:Enterprise"))
				{	a->merc__ModifyEnterpriseResponse::__sizeenterprise++;
					a->merc__ModifyEnterpriseResponse::enterprise = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeenterprise");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__ModifyEnterpriseResponse::enterprise)
			soap_pop_block(soap, soap_blist_enterprise1);
		if(a->merc__ModifyEnterpriseResponse::__sizeenterprise)
			a->merc__ModifyEnterpriseResponse::enterprise = (ent__Enterprise **)soap_save_block(soap, soap_blist_enterprise1, NULL, 1);
		else
		{	a->merc__ModifyEnterpriseResponse::enterprise = NULL;
			if(soap_blist_enterprise1)
				soap_end_block(soap, soap_blist_enterprise1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyEnterpriseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyEnterpriseResponse, 0, sizeof(merc__ModifyEnterpriseResponse), 0, soap_copy_merc__ModifyEnterpriseResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__ModifyEnterpriseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyEnterpriseResponse);
	return this->soap_out(soap, tag?tag:"merc:ModifyEnterpriseResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyEnterpriseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyEnterpriseResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyEnterpriseResponse * SOAP_FMAC4 soap_get_merc__ModifyEnterpriseResponse(struct soap *soap, merc__ModifyEnterpriseResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyEnterpriseResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyEnterpriseResponse * FASTCALL soap_instantiate_merc__ModifyEnterpriseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyEnterpriseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyEnterpriseResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseResponse);
		ASSIGN_PTR(size, sizeof(merc__ModifyEnterpriseResponse));
		((merc__ModifyEnterpriseResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyEnterpriseResponse));
		for(int i = 0; i < n; i++)
			((merc__ModifyEnterpriseResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyEnterpriseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyEnterpriseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyEnterpriseResponse %p -> %p\n", q, p));
	*(merc__ModifyEnterpriseResponse*)p = *(merc__ModifyEnterpriseResponse*)q;
}

void merc__ModifyEnterpriseRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyEnterpriseRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__ModifyEnterpriseRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__ENTModificationOperation(soap, &this->merc__ModifyEnterpriseRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__ModifyEnterpriseRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyEnterpriseRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyEnterpriseRequest(struct soap *soap, const char *tag, int id, const merc__ModifyEnterpriseRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyEnterpriseRequest), "merc:ModifyEnterpriseRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__ModifyEnterpriseRequest::modificationOperation) {
		if(soap_out_PointerTovd__ENTModificationOperation(soap, "merc:modificationOperation", -1, &a->merc__ModifyEnterpriseRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyEnterpriseRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyEnterpriseRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyEnterpriseRequest * FASTCALL soap_in_merc__ModifyEnterpriseRequest(struct soap *soap, const char *tag, merc__ModifyEnterpriseRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyEnterpriseRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyEnterpriseRequest, sizeof(merc__ModifyEnterpriseRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyEnterpriseRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyEnterpriseRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ENTModificationOperation(soap, "merc:modificationOperation", &(a->merc__ModifyEnterpriseRequest::modificationOperation), "vd:ENTModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyEnterpriseRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyEnterpriseRequest, 0, sizeof(merc__ModifyEnterpriseRequest), 0, soap_copy_merc__ModifyEnterpriseRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ModifyEnterpriseRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyEnterpriseRequest);
	return this->soap_out(soap, tag?tag:"merc:ModifyEnterpriseRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyEnterpriseRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyEnterpriseRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyEnterpriseRequest * SOAP_FMAC4 soap_get_merc__ModifyEnterpriseRequest(struct soap *soap, merc__ModifyEnterpriseRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyEnterpriseRequest * FASTCALL soap_instantiate_merc__ModifyEnterpriseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyEnterpriseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyEnterpriseRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseRequest);
		ASSIGN_PTR(size, sizeof(merc__ModifyEnterpriseRequest));
		((merc__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyEnterpriseRequest));
		for(int i = 0; i < n; i++)
			((merc__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyEnterpriseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyEnterpriseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyEnterpriseRequest %p -> %p\n", q, p));
	*(merc__ModifyEnterpriseRequest*)p = *(merc__ModifyEnterpriseRequest*)q;
}

void merc__ModifyBusinessEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyBusinessEntityResponse::__sizebusinessEntity = 0;
	this->merc__ModifyBusinessEntityResponse::businessEntity = NULL;
	/* transient soap skipped */
}

void merc__ModifyBusinessEntityResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__ModifyBusinessEntityResponse::businessEntity) {
		for(int i = 0; i < this->merc__ModifyBusinessEntityResponse::__sizebusinessEntity; i++) {
			soap_serialize_PointerToent__BusinessEntity(soap, this->merc__ModifyBusinessEntityResponse::businessEntity + i);
		}
	}
	/* transient soap skipped */
}

int merc__ModifyBusinessEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyBusinessEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, int id, const merc__ModifyBusinessEntityResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyBusinessEntityResponse), "merc:ModifyBusinessEntityResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizebusinessEntity");
	if(a->merc__ModifyBusinessEntityResponse::businessEntity) {
		int i;
		for(i = 0; i < a->merc__ModifyBusinessEntityResponse::__sizebusinessEntity; i++)
			if(soap_out_PointerToent__BusinessEntity(soap, "merc:businessEntity", -1, a->merc__ModifyBusinessEntityResponse::businessEntity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyBusinessEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyBusinessEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyBusinessEntityResponse * FASTCALL soap_in_merc__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, merc__ModifyBusinessEntityResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyBusinessEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyBusinessEntityResponse, sizeof(merc__ModifyBusinessEntityResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyBusinessEntityResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyBusinessEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_businessEntity1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:businessEntity", 1, NULL)) {
				if(a->merc__ModifyBusinessEntityResponse::businessEntity == NULL) {
					if(soap_blist_businessEntity1 == NULL)
						soap_blist_businessEntity1 = soap_new_block(soap);
					a->merc__ModifyBusinessEntityResponse::businessEntity = (ent__BusinessEntity **)soap_push_block(soap, soap_blist_businessEntity1, sizeof(ent__BusinessEntity *));
					if(a->merc__ModifyBusinessEntityResponse::businessEntity == NULL)
						return NULL;
					*a->merc__ModifyBusinessEntityResponse::businessEntity = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToent__BusinessEntity(soap, "merc:businessEntity", a->merc__ModifyBusinessEntityResponse::businessEntity, "ent:BusinessEntity"))
				{	a->merc__ModifyBusinessEntityResponse::__sizebusinessEntity++;
					a->merc__ModifyBusinessEntityResponse::businessEntity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizebusinessEntity");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__ModifyBusinessEntityResponse::businessEntity)
			soap_pop_block(soap, soap_blist_businessEntity1);
		if(a->merc__ModifyBusinessEntityResponse::__sizebusinessEntity)
			a->merc__ModifyBusinessEntityResponse::businessEntity = (ent__BusinessEntity **)soap_save_block(soap, soap_blist_businessEntity1, NULL, 1);
		else
		{	a->merc__ModifyBusinessEntityResponse::businessEntity = NULL;
			if(soap_blist_businessEntity1)
				soap_end_block(soap, soap_blist_businessEntity1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyBusinessEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyBusinessEntityResponse, 0, sizeof(merc__ModifyBusinessEntityResponse), 0, soap_copy_merc__ModifyBusinessEntityResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__ModifyBusinessEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyBusinessEntityResponse);
	return this->soap_out(soap, tag?tag:"merc:ModifyBusinessEntityResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyBusinessEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyBusinessEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyBusinessEntityResponse * SOAP_FMAC4 soap_get_merc__ModifyBusinessEntityResponse(struct soap *soap, merc__ModifyBusinessEntityResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyBusinessEntityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyBusinessEntityResponse * FASTCALL soap_instantiate_merc__ModifyBusinessEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyBusinessEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyBusinessEntityResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityResponse);
		ASSIGN_PTR(size, sizeof(merc__ModifyBusinessEntityResponse));
		((merc__ModifyBusinessEntityResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyBusinessEntityResponse));
		for(int i = 0; i < n; i++)
			((merc__ModifyBusinessEntityResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyBusinessEntityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyBusinessEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyBusinessEntityResponse %p -> %p\n", q, p));
	*(merc__ModifyBusinessEntityResponse*)p = *(merc__ModifyBusinessEntityResponse*)q;
}

void merc__ModifyBusinessEntityRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ModifyBusinessEntityRequest::modificationOperation = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__ModifyBusinessEntityRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__BEModificationOperation(soap, &this->merc__ModifyBusinessEntityRequest::modificationOperation);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__ModifyBusinessEntityRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ModifyBusinessEntityRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, const merc__ModifyBusinessEntityRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ModifyBusinessEntityRequest), "merc:ModifyBusinessEntityRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__ModifyBusinessEntityRequest::modificationOperation) {
		if(soap_out_PointerTovd__BEModificationOperation(soap, "merc:modificationOperation", -1, &a->merc__ModifyBusinessEntityRequest::modificationOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:modificationOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ModifyBusinessEntityRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ModifyBusinessEntityRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__ModifyBusinessEntityRequest * FASTCALL soap_in_merc__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, merc__ModifyBusinessEntityRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ModifyBusinessEntityRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ModifyBusinessEntityRequest, sizeof(merc__ModifyBusinessEntityRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ModifyBusinessEntityRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ModifyBusinessEntityRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_modificationOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_modificationOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__BEModificationOperation(soap, "merc:modificationOperation", &(a->merc__ModifyBusinessEntityRequest::modificationOperation), "vd:BEModificationOperation"))
				{	soap_flag_modificationOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ModifyBusinessEntityRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ModifyBusinessEntityRequest, 0, sizeof(merc__ModifyBusinessEntityRequest), 0, soap_copy_merc__ModifyBusinessEntityRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_modificationOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ModifyBusinessEntityRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ModifyBusinessEntityRequest);
	return this->soap_out(soap, tag?tag:"merc:ModifyBusinessEntityRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ModifyBusinessEntityRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ModifyBusinessEntityRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__ModifyBusinessEntityRequest * SOAP_FMAC4 soap_get_merc__ModifyBusinessEntityRequest(struct soap *soap, merc__ModifyBusinessEntityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ModifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ModifyBusinessEntityRequest * FASTCALL soap_instantiate_merc__ModifyBusinessEntityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ModifyBusinessEntityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ModifyBusinessEntityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityRequest);
		ASSIGN_PTR(size, sizeof(merc__ModifyBusinessEntityRequest));
		((merc__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ModifyBusinessEntityRequest));
		for(int i = 0; i < n; i++)
			((merc__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ModifyBusinessEntityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ModifyBusinessEntityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ModifyBusinessEntityRequest %p -> %p\n", q, p));
	*(merc__ModifyBusinessEntityRequest*)p = *(merc__ModifyBusinessEntityRequest*)q;
}

void merc__WithdrawVetDocumentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__WithdrawVetDocumentResponse::vetDocument = NULL;
	this->merc__WithdrawVetDocumentResponse::__sizestockEntry = 0;
	this->merc__WithdrawVetDocumentResponse::stockEntry = NULL;
	/* transient soap skipped */
}

void merc__WithdrawVetDocumentResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__VetDocument(soap, &this->merc__WithdrawVetDocumentResponse::vetDocument);
	if(this->merc__WithdrawVetDocumentResponse::stockEntry) {
		for(int i = 0; i < this->merc__WithdrawVetDocumentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->merc__WithdrawVetDocumentResponse::stockEntry + i);
		}
	}
	/* transient soap skipped */
}

int merc__WithdrawVetDocumentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__WithdrawVetDocumentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, int id, const merc__WithdrawVetDocumentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__WithdrawVetDocumentResponse), "merc:WithdrawVetDocumentResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->vetDocument)
		soap_element_result(soap, "merc:vetDocument");
	if(soap_out_PointerTovd__VetDocument(soap, "merc:vetDocument", -1, &(a->merc__WithdrawVetDocumentResponse::vetDocument), ""))
		return soap->error;
	if(a->merc__WithdrawVetDocumentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->merc__WithdrawVetDocumentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "merc:stockEntry", -1, a->merc__WithdrawVetDocumentResponse::stockEntry + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__WithdrawVetDocumentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__WithdrawVetDocumentResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__WithdrawVetDocumentResponse * FASTCALL soap_in_merc__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, merc__WithdrawVetDocumentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__WithdrawVetDocumentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__WithdrawVetDocumentResponse, sizeof(merc__WithdrawVetDocumentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__WithdrawVetDocumentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__WithdrawVetDocumentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_vetDocument1 = 1;
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_vetDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__VetDocument(soap, "merc:vetDocument", &(a->merc__WithdrawVetDocumentResponse::vetDocument), "vd:VetDocument"))
				{	soap_flag_vetDocument1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:stockEntry", 1, NULL)) {
				if(a->merc__WithdrawVetDocumentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->merc__WithdrawVetDocumentResponse::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->merc__WithdrawVetDocumentResponse::stockEntry == NULL)
						return NULL;
					*a->merc__WithdrawVetDocumentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "merc:stockEntry", a->merc__WithdrawVetDocumentResponse::stockEntry, "vd:StockEntry"))
				{	a->merc__WithdrawVetDocumentResponse::__sizestockEntry++;
					a->merc__WithdrawVetDocumentResponse::stockEntry = NULL;
					continue;
				}
			}
			soap_check_result(soap, "merc:vetDocument");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__WithdrawVetDocumentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->merc__WithdrawVetDocumentResponse::__sizestockEntry)
			a->merc__WithdrawVetDocumentResponse::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->merc__WithdrawVetDocumentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__WithdrawVetDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__WithdrawVetDocumentResponse, 0, sizeof(merc__WithdrawVetDocumentResponse), 0, soap_copy_merc__WithdrawVetDocumentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__WithdrawVetDocumentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__WithdrawVetDocumentResponse);
	return this->soap_out(soap, tag?tag:"merc:WithdrawVetDocumentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__WithdrawVetDocumentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__WithdrawVetDocumentResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__WithdrawVetDocumentResponse * SOAP_FMAC4 soap_get_merc__WithdrawVetDocumentResponse(struct soap *soap, merc__WithdrawVetDocumentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__WithdrawVetDocumentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__WithdrawVetDocumentResponse * FASTCALL soap_instantiate_merc__WithdrawVetDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__WithdrawVetDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__WithdrawVetDocumentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentResponse);
		ASSIGN_PTR(size, sizeof(merc__WithdrawVetDocumentResponse));
		((merc__WithdrawVetDocumentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__WithdrawVetDocumentResponse));
		for(int i = 0; i < n; i++)
			((merc__WithdrawVetDocumentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__WithdrawVetDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__WithdrawVetDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__WithdrawVetDocumentResponse %p -> %p\n", q, p));
	*(merc__WithdrawVetDocumentResponse*)p = *(merc__WithdrawVetDocumentResponse*)q;
}

void merc__WithdrawVetDocumentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->merc__WithdrawVetDocumentRequest::vetDocumentId);
	soap_default_vd__VetDocumentStatusChangeReason(soap, &this->merc__WithdrawVetDocumentRequest::withdrawReason);
	soap_default_time(soap, &this->merc__WithdrawVetDocumentRequest::withdrawDate);
	this->merc__WithdrawVetDocumentRequest::specifiedPerson = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__WithdrawVetDocumentRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->merc__WithdrawVetDocumentRequest::vetDocumentId);
	soap_serialize_vd__VetDocumentStatusChangeReason(soap, &this->merc__WithdrawVetDocumentRequest::withdrawReason);
	soap_embedded(soap, &this->merc__WithdrawVetDocumentRequest::withdrawDate, SOAP_TYPE_time);
	soap_serialize_PointerTovd__User(soap, &this->merc__WithdrawVetDocumentRequest::specifiedPerson);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__WithdrawVetDocumentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__WithdrawVetDocumentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, const merc__WithdrawVetDocumentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__WithdrawVetDocumentRequest), "merc:WithdrawVetDocumentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__WithdrawVetDocumentRequest::vetDocumentId) {
		if(soap_out_base__UUID(soap, "merc:vetDocumentId", -1, &a->merc__WithdrawVetDocumentRequest::vetDocumentId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:vetDocumentId"))
		return soap->error;
	if(a->merc__WithdrawVetDocumentRequest::withdrawReason) {
		if(soap_out_vd__VetDocumentStatusChangeReason(soap, "merc:withdrawReason", -1, &a->merc__WithdrawVetDocumentRequest::withdrawReason, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:withdrawReason"))
		return soap->error;
	if(soap_out_time(soap, "merc:withdrawDate", -1, &(a->merc__WithdrawVetDocumentRequest::withdrawDate), ""))
		return soap->error;
	if(soap_out_PointerTovd__User(soap, "merc:specifiedPerson", -1, &(a->merc__WithdrawVetDocumentRequest::specifiedPerson), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__WithdrawVetDocumentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__WithdrawVetDocumentRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__WithdrawVetDocumentRequest * FASTCALL soap_in_merc__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, merc__WithdrawVetDocumentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__WithdrawVetDocumentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__WithdrawVetDocumentRequest, sizeof(merc__WithdrawVetDocumentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__WithdrawVetDocumentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__WithdrawVetDocumentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_vetDocumentId1 = 1;
	size_t soap_flag_withdrawReason1 = 1;
	size_t soap_flag_withdrawDate1 = 1;
	size_t soap_flag_specifiedPerson1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_vetDocumentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "merc:vetDocumentId", &(a->merc__WithdrawVetDocumentRequest::vetDocumentId), "base:UUID"))
				{	soap_flag_vetDocumentId1--;
					continue;
				}
			if(soap_flag_withdrawReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_vd__VetDocumentStatusChangeReason(soap, "merc:withdrawReason", &(a->merc__WithdrawVetDocumentRequest::withdrawReason), "vd:VetDocumentStatusChangeReason"))
				{	soap_flag_withdrawReason1--;
					continue;
				}
			if(soap_flag_withdrawDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_time(soap, "merc:withdrawDate", &(a->merc__WithdrawVetDocumentRequest::withdrawDate), "xsd:dateTime"))
				{	soap_flag_withdrawDate1--;
					continue;
				}
			if(soap_flag_specifiedPerson1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:specifiedPerson", &(a->merc__WithdrawVetDocumentRequest::specifiedPerson), "vd:User"))
				{	soap_flag_specifiedPerson1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__WithdrawVetDocumentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__WithdrawVetDocumentRequest, 0, sizeof(merc__WithdrawVetDocumentRequest), 0, soap_copy_merc__WithdrawVetDocumentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_vetDocumentId1 > 0 || soap_flag_withdrawReason1 > 0 || soap_flag_withdrawDate1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__WithdrawVetDocumentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__WithdrawVetDocumentRequest);
	return this->soap_out(soap, tag?tag:"merc:WithdrawVetDocumentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__WithdrawVetDocumentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__WithdrawVetDocumentRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__WithdrawVetDocumentRequest * SOAP_FMAC4 soap_get_merc__WithdrawVetDocumentRequest(struct soap *soap, merc__WithdrawVetDocumentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__WithdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__WithdrawVetDocumentRequest * FASTCALL soap_instantiate_merc__WithdrawVetDocumentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__WithdrawVetDocumentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__WithdrawVetDocumentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentRequest);
		ASSIGN_PTR(size, sizeof(merc__WithdrawVetDocumentRequest));
		((merc__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__WithdrawVetDocumentRequest));
		for(int i = 0; i < n; i++)
			((merc__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__WithdrawVetDocumentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__WithdrawVetDocumentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__WithdrawVetDocumentRequest %p -> %p\n", q, p));
	*(merc__WithdrawVetDocumentRequest*)p = *(merc__WithdrawVetDocumentRequest*)q;
}

void merc__MergeStockEntriesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__MergeStockEntriesResponse::stockEntryList = NULL;
	/* transient soap skipped */
}

void merc__MergeStockEntriesResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->merc__MergeStockEntriesResponse::stockEntryList);
	/* transient soap skipped */
}

int merc__MergeStockEntriesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__MergeStockEntriesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__MergeStockEntriesResponse(struct soap *soap, const char *tag, int id, const merc__MergeStockEntriesResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__MergeStockEntriesResponse), "merc:MergeStockEntriesResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "merc:stockEntryList");
	if(a->merc__MergeStockEntriesResponse::stockEntryList) {
		if(soap_out_PointerTovd__StockEntryList(soap, "merc:stockEntryList", -1, &a->merc__MergeStockEntriesResponse::stockEntryList, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:stockEntryList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__MergeStockEntriesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__MergeStockEntriesResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__MergeStockEntriesResponse * FASTCALL soap_in_merc__MergeStockEntriesResponse(struct soap *soap, const char *tag, merc__MergeStockEntriesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__MergeStockEntriesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__MergeStockEntriesResponse, sizeof(merc__MergeStockEntriesResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__MergeStockEntriesResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__MergeStockEntriesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "merc:stockEntryList", &(a->merc__MergeStockEntriesResponse::stockEntryList), "vd:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			soap_check_result(soap, "merc:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__MergeStockEntriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__MergeStockEntriesResponse, 0, sizeof(merc__MergeStockEntriesResponse), 0, soap_copy_merc__MergeStockEntriesResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockEntryList1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__MergeStockEntriesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__MergeStockEntriesResponse);
	return this->soap_out(soap, tag?tag:"merc:MergeStockEntriesResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__MergeStockEntriesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__MergeStockEntriesResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__MergeStockEntriesResponse * SOAP_FMAC4 soap_get_merc__MergeStockEntriesResponse(struct soap *soap, merc__MergeStockEntriesResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__MergeStockEntriesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__MergeStockEntriesResponse * FASTCALL soap_instantiate_merc__MergeStockEntriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__MergeStockEntriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__MergeStockEntriesResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesResponse);
		ASSIGN_PTR(size, sizeof(merc__MergeStockEntriesResponse));
		((merc__MergeStockEntriesResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__MergeStockEntriesResponse));
		for(int i = 0; i < n; i++)
			((merc__MergeStockEntriesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__MergeStockEntriesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__MergeStockEntriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__MergeStockEntriesResponse %p -> %p\n", q, p));
	*(merc__MergeStockEntriesResponse*)p = *(merc__MergeStockEntriesResponse*)q;
}

void merc__MergeStockEntriesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__MergeStockEntriesRequest::enterprise = NULL;
	this->merc__MergeStockEntriesRequest::mergeOperation = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__MergeStockEntriesRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->merc__MergeStockEntriesRequest::enterprise);
	soap_serialize_PointerTovd__MergeStockEntriesOperation(soap, &this->merc__MergeStockEntriesRequest::mergeOperation);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__MergeStockEntriesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__MergeStockEntriesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__MergeStockEntriesRequest(struct soap *soap, const char *tag, int id, const merc__MergeStockEntriesRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__MergeStockEntriesRequest), "merc:MergeStockEntriesRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__MergeStockEntriesRequest::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "merc:enterprise", -1, &a->merc__MergeStockEntriesRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:enterprise"))
		return soap->error;
	if(a->merc__MergeStockEntriesRequest::mergeOperation) {
		if(soap_out_PointerTovd__MergeStockEntriesOperation(soap, "merc:mergeOperation", -1, &a->merc__MergeStockEntriesRequest::mergeOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:mergeOperation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__MergeStockEntriesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__MergeStockEntriesRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__MergeStockEntriesRequest * FASTCALL soap_in_merc__MergeStockEntriesRequest(struct soap *soap, const char *tag, merc__MergeStockEntriesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__MergeStockEntriesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__MergeStockEntriesRequest, sizeof(merc__MergeStockEntriesRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__MergeStockEntriesRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__MergeStockEntriesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_mergeOperation1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "merc:enterprise", &(a->merc__MergeStockEntriesRequest::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_mergeOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__MergeStockEntriesOperation(soap, "merc:mergeOperation", &(a->merc__MergeStockEntriesRequest::mergeOperation), "vd:MergeStockEntriesOperation"))
				{	soap_flag_mergeOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__MergeStockEntriesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__MergeStockEntriesRequest, 0, sizeof(merc__MergeStockEntriesRequest), 0, soap_copy_merc__MergeStockEntriesRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_mergeOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__MergeStockEntriesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__MergeStockEntriesRequest);
	return this->soap_out(soap, tag?tag:"merc:MergeStockEntriesRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__MergeStockEntriesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__MergeStockEntriesRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__MergeStockEntriesRequest * SOAP_FMAC4 soap_get_merc__MergeStockEntriesRequest(struct soap *soap, merc__MergeStockEntriesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__MergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__MergeStockEntriesRequest * FASTCALL soap_instantiate_merc__MergeStockEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__MergeStockEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__MergeStockEntriesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesRequest);
		ASSIGN_PTR(size, sizeof(merc__MergeStockEntriesRequest));
		((merc__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__MergeStockEntriesRequest));
		for(int i = 0; i < n; i++)
			((merc__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__MergeStockEntriesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__MergeStockEntriesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__MergeStockEntriesRequest %p -> %p\n", q, p));
	*(merc__MergeStockEntriesRequest*)p = *(merc__MergeStockEntriesRequest*)q;
}

void merc__RegisterProductionOperationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__RegisterProductionOperationResponse::stockEntryList = NULL;
	this->merc__RegisterProductionOperationResponse::__sizevetDocument = 0;
	this->merc__RegisterProductionOperationResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void merc__RegisterProductionOperationResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__StockEntryList(soap, &this->merc__RegisterProductionOperationResponse::stockEntryList);
	if(this->merc__RegisterProductionOperationResponse::vetDocument) {
		for(int i = 0; i < this->merc__RegisterProductionOperationResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->merc__RegisterProductionOperationResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int merc__RegisterProductionOperationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__RegisterProductionOperationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__RegisterProductionOperationResponse(struct soap *soap, const char *tag, int id, const merc__RegisterProductionOperationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__RegisterProductionOperationResponse), "merc:RegisterProductionOperationResponse"))
		return soap->error;
	/* transient soap skipped */
	if(a->stockEntryList)
		soap_element_result(soap, "merc:stockEntryList");
	if(soap_out_PointerTovd__StockEntryList(soap, "merc:stockEntryList", -1, &(a->merc__RegisterProductionOperationResponse::stockEntryList), ""))
		return soap->error;
	if(a->merc__RegisterProductionOperationResponse::vetDocument) {
		int i;
		for(i = 0; i < a->merc__RegisterProductionOperationResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "merc:vetDocument", -1, a->merc__RegisterProductionOperationResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__RegisterProductionOperationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__RegisterProductionOperationResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__RegisterProductionOperationResponse * FASTCALL soap_in_merc__RegisterProductionOperationResponse(struct soap *soap, const char *tag, merc__RegisterProductionOperationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__RegisterProductionOperationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__RegisterProductionOperationResponse, sizeof(merc__RegisterProductionOperationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__RegisterProductionOperationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__RegisterProductionOperationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockEntryList1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_stockEntryList1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__StockEntryList(soap, "merc:stockEntryList", &(a->merc__RegisterProductionOperationResponse::stockEntryList), "vd:StockEntryList"))
				{	soap_flag_stockEntryList1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:vetDocument", 1, NULL)) {
				if(a->merc__RegisterProductionOperationResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->merc__RegisterProductionOperationResponse::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->merc__RegisterProductionOperationResponse::vetDocument == NULL)
						return NULL;
					*a->merc__RegisterProductionOperationResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "merc:vetDocument", a->merc__RegisterProductionOperationResponse::vetDocument, "vd:VetDocument"))
				{	a->merc__RegisterProductionOperationResponse::__sizevetDocument++;
					a->merc__RegisterProductionOperationResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "merc:stockEntryList");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__RegisterProductionOperationResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->merc__RegisterProductionOperationResponse::__sizevetDocument)
			a->merc__RegisterProductionOperationResponse::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->merc__RegisterProductionOperationResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__RegisterProductionOperationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__RegisterProductionOperationResponse, 0, sizeof(merc__RegisterProductionOperationResponse), 0, soap_copy_merc__RegisterProductionOperationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__RegisterProductionOperationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__RegisterProductionOperationResponse);
	return this->soap_out(soap, tag?tag:"merc:RegisterProductionOperationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__RegisterProductionOperationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__RegisterProductionOperationResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__RegisterProductionOperationResponse * SOAP_FMAC4 soap_get_merc__RegisterProductionOperationResponse(struct soap *soap, merc__RegisterProductionOperationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__RegisterProductionOperationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__RegisterProductionOperationResponse * FASTCALL soap_instantiate_merc__RegisterProductionOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__RegisterProductionOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__RegisterProductionOperationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationResponse);
		ASSIGN_PTR(size, sizeof(merc__RegisterProductionOperationResponse));
		((merc__RegisterProductionOperationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__RegisterProductionOperationResponse));
		for(int i = 0; i < n; i++)
			((merc__RegisterProductionOperationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__RegisterProductionOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__RegisterProductionOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__RegisterProductionOperationResponse %p -> %p\n", q, p));
	*(merc__RegisterProductionOperationResponse*)p = *(merc__RegisterProductionOperationResponse*)q;
}

void merc__RegisterProductionOperationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__RegisterProductionOperationRequest::enterprise = NULL;
	this->merc__RegisterProductionOperationRequest::productionOperation = NULL;
	this->merc__RegisterProductionOperationRequest::__sizevetDocument = 0;
	this->merc__RegisterProductionOperationRequest::vetDocument = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__RegisterProductionOperationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToent__Enterprise(soap, &this->merc__RegisterProductionOperationRequest::enterprise);
	soap_serialize_PointerTovd__ProductionOperation(soap, &this->merc__RegisterProductionOperationRequest::productionOperation);
	if(this->merc__RegisterProductionOperationRequest::vetDocument) {
		for(int i = 0; i < this->merc__RegisterProductionOperationRequest::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->merc__RegisterProductionOperationRequest::vetDocument + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__RegisterProductionOperationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__RegisterProductionOperationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__RegisterProductionOperationRequest(struct soap *soap, const char *tag, int id, const merc__RegisterProductionOperationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__RegisterProductionOperationRequest), "merc:RegisterProductionOperationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__RegisterProductionOperationRequest::enterprise) {
		if(soap_out_PointerToent__Enterprise(soap, "merc:enterprise", -1, &a->merc__RegisterProductionOperationRequest::enterprise, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:enterprise"))
		return soap->error;
	if(a->merc__RegisterProductionOperationRequest::productionOperation) {
		if(soap_out_PointerTovd__ProductionOperation(soap, "merc:productionOperation", -1, &a->merc__RegisterProductionOperationRequest::productionOperation, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:productionOperation"))
		return soap->error;
	if(a->merc__RegisterProductionOperationRequest::vetDocument) {
		int i;
		for(i = 0; i < a->merc__RegisterProductionOperationRequest::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "merc:vetDocument", -1, a->merc__RegisterProductionOperationRequest::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__RegisterProductionOperationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__RegisterProductionOperationRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__RegisterProductionOperationRequest * FASTCALL soap_in_merc__RegisterProductionOperationRequest(struct soap *soap, const char *tag, merc__RegisterProductionOperationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__RegisterProductionOperationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__RegisterProductionOperationRequest, sizeof(merc__RegisterProductionOperationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__RegisterProductionOperationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__RegisterProductionOperationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_enterprise1 = 1;
	size_t soap_flag_productionOperation1 = 1;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_enterprise1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__Enterprise(soap, "merc:enterprise", &(a->merc__RegisterProductionOperationRequest::enterprise), "ent:Enterprise"))
				{	soap_flag_enterprise1--;
					continue;
				}
			if(soap_flag_productionOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__ProductionOperation(soap, "merc:productionOperation", &(a->merc__RegisterProductionOperationRequest::productionOperation), "vd:ProductionOperation"))
				{	soap_flag_productionOperation1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:vetDocument", 1, NULL)) {
				if(a->merc__RegisterProductionOperationRequest::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->merc__RegisterProductionOperationRequest::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->merc__RegisterProductionOperationRequest::vetDocument == NULL)
						return NULL;
					*a->merc__RegisterProductionOperationRequest::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "merc:vetDocument", a->merc__RegisterProductionOperationRequest::vetDocument, "vd:VetDocument"))
				{	a->merc__RegisterProductionOperationRequest::__sizevetDocument++;
					a->merc__RegisterProductionOperationRequest::vetDocument = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__RegisterProductionOperationRequest::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->merc__RegisterProductionOperationRequest::__sizevetDocument)
			a->merc__RegisterProductionOperationRequest::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->merc__RegisterProductionOperationRequest::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__RegisterProductionOperationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__RegisterProductionOperationRequest, 0, sizeof(merc__RegisterProductionOperationRequest), 0, soap_copy_merc__RegisterProductionOperationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_enterprise1 > 0 || soap_flag_productionOperation1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__RegisterProductionOperationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__RegisterProductionOperationRequest);
	return this->soap_out(soap, tag?tag:"merc:RegisterProductionOperationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__RegisterProductionOperationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__RegisterProductionOperationRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__RegisterProductionOperationRequest * SOAP_FMAC4 soap_get_merc__RegisterProductionOperationRequest(struct soap *soap, merc__RegisterProductionOperationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__RegisterProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__RegisterProductionOperationRequest * FASTCALL soap_instantiate_merc__RegisterProductionOperationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__RegisterProductionOperationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__RegisterProductionOperationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationRequest);
		ASSIGN_PTR(size, sizeof(merc__RegisterProductionOperationRequest));
		((merc__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__RegisterProductionOperationRequest));
		for(int i = 0; i < n; i++)
			((merc__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__RegisterProductionOperationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__RegisterProductionOperationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__RegisterProductionOperationRequest %p -> %p\n", q, p));
	*(merc__RegisterProductionOperationRequest*)p = *(merc__RegisterProductionOperationRequest*)q;
}

void merc__PrepareOutgoingConsignmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__PrepareOutgoingConsignmentResponse::__sizestockEntry = 0;
	this->merc__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
	this->merc__PrepareOutgoingConsignmentResponse::__sizevetDocument = 0;
	this->merc__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void merc__PrepareOutgoingConsignmentResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__PrepareOutgoingConsignmentResponse::stockEntry) {
		for(int i = 0; i < this->merc__PrepareOutgoingConsignmentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->merc__PrepareOutgoingConsignmentResponse::stockEntry + i);
		}
	}
	if(this->merc__PrepareOutgoingConsignmentResponse::vetDocument) {
		for(int i = 0; i < this->merc__PrepareOutgoingConsignmentResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->merc__PrepareOutgoingConsignmentResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int merc__PrepareOutgoingConsignmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__PrepareOutgoingConsignmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, int id, const merc__PrepareOutgoingConsignmentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse), "merc:PrepareOutgoingConsignmentResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->merc__PrepareOutgoingConsignmentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->merc__PrepareOutgoingConsignmentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "merc:stockEntry", -1, a->merc__PrepareOutgoingConsignmentResponse::stockEntry + i, ""))
				return soap->error;
	}
	if(a->merc__PrepareOutgoingConsignmentResponse::vetDocument) {
		int i;
		for(i = 0; i < a->merc__PrepareOutgoingConsignmentResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "merc:vetDocument", -1, a->merc__PrepareOutgoingConsignmentResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__PrepareOutgoingConsignmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__PrepareOutgoingConsignmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentResponse * FASTCALL soap_in_merc__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, merc__PrepareOutgoingConsignmentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__PrepareOutgoingConsignmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse, sizeof(merc__PrepareOutgoingConsignmentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__PrepareOutgoingConsignmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:stockEntry", 1, NULL)) {
				if(a->merc__PrepareOutgoingConsignmentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->merc__PrepareOutgoingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->merc__PrepareOutgoingConsignmentResponse::stockEntry == NULL)
						return NULL;
					*a->merc__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "merc:stockEntry", a->merc__PrepareOutgoingConsignmentResponse::stockEntry, "vd:StockEntry"))
				{	a->merc__PrepareOutgoingConsignmentResponse::__sizestockEntry++;
					a->merc__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:vetDocument", 1, NULL)) {
				if(a->merc__PrepareOutgoingConsignmentResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->merc__PrepareOutgoingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->merc__PrepareOutgoingConsignmentResponse::vetDocument == NULL)
						return NULL;
					*a->merc__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "merc:vetDocument", a->merc__PrepareOutgoingConsignmentResponse::vetDocument, "vd:VetDocument"))
				{	a->merc__PrepareOutgoingConsignmentResponse::__sizevetDocument++;
					a->merc__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__PrepareOutgoingConsignmentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->merc__PrepareOutgoingConsignmentResponse::__sizestockEntry)
			a->merc__PrepareOutgoingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->merc__PrepareOutgoingConsignmentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(a->merc__PrepareOutgoingConsignmentResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->merc__PrepareOutgoingConsignmentResponse::__sizevetDocument)
			a->merc__PrepareOutgoingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->merc__PrepareOutgoingConsignmentResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__PrepareOutgoingConsignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse, 0, sizeof(merc__PrepareOutgoingConsignmentResponse), 0, soap_copy_merc__PrepareOutgoingConsignmentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__PrepareOutgoingConsignmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse);
	return this->soap_out(soap, tag?tag:"merc:PrepareOutgoingConsignmentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__PrepareOutgoingConsignmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__PrepareOutgoingConsignmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentResponse * SOAP_FMAC4 soap_get_merc__PrepareOutgoingConsignmentResponse(struct soap *soap, merc__PrepareOutgoingConsignmentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__PrepareOutgoingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__PrepareOutgoingConsignmentResponse * FASTCALL soap_instantiate_merc__PrepareOutgoingConsignmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__PrepareOutgoingConsignmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentResponse);
		ASSIGN_PTR(size, sizeof(merc__PrepareOutgoingConsignmentResponse));
		((merc__PrepareOutgoingConsignmentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__PrepareOutgoingConsignmentResponse));
		for(int i = 0; i < n; i++)
			((merc__PrepareOutgoingConsignmentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__PrepareOutgoingConsignmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__PrepareOutgoingConsignmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__PrepareOutgoingConsignmentResponse %p -> %p\n", q, p));
	*(merc__PrepareOutgoingConsignmentResponse*)p = *(merc__PrepareOutgoingConsignmentResponse*)q;
}

void merc__PrepareOutgoingConsignmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__PrepareOutgoingConsignmentRequest::__sizedelivery = 0;
	this->merc__PrepareOutgoingConsignmentRequest::delivery = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__PrepareOutgoingConsignmentRequest::soap_serialize(struct soap *soap) const
{
	if(this->merc__PrepareOutgoingConsignmentRequest::delivery) {
		for(int i = 0; i < this->merc__PrepareOutgoingConsignmentRequest::__sizedelivery; i++) {
			soap_serialize_PointerTovd__Delivery(soap, this->merc__PrepareOutgoingConsignmentRequest::delivery + i);
		}
	}
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__PrepareOutgoingConsignmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__PrepareOutgoingConsignmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, const merc__PrepareOutgoingConsignmentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest), "merc:PrepareOutgoingConsignmentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__PrepareOutgoingConsignmentRequest::delivery) {
		int i;
		for(i = 0; i < a->merc__PrepareOutgoingConsignmentRequest::__sizedelivery; i++)
			if(soap_out_PointerTovd__Delivery(soap, "merc:delivery", -1, a->merc__PrepareOutgoingConsignmentRequest::delivery + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__PrepareOutgoingConsignmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__PrepareOutgoingConsignmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentRequest * FASTCALL soap_in_merc__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, merc__PrepareOutgoingConsignmentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__PrepareOutgoingConsignmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest, sizeof(merc__PrepareOutgoingConsignmentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__PrepareOutgoingConsignmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	struct soap_blist *soap_blist_delivery1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:delivery", 1, NULL)) {
				if(a->merc__PrepareOutgoingConsignmentRequest::delivery == NULL) {
					if(soap_blist_delivery1 == NULL)
						soap_blist_delivery1 = soap_new_block(soap);
					a->merc__PrepareOutgoingConsignmentRequest::delivery = (vd__Delivery **)soap_push_block(soap, soap_blist_delivery1, sizeof(vd__Delivery *));
					if(a->merc__PrepareOutgoingConsignmentRequest::delivery == NULL)
						return NULL;
					*a->merc__PrepareOutgoingConsignmentRequest::delivery = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__Delivery(soap, "merc:delivery", a->merc__PrepareOutgoingConsignmentRequest::delivery, "vd:Delivery"))
				{	a->merc__PrepareOutgoingConsignmentRequest::__sizedelivery++;
					a->merc__PrepareOutgoingConsignmentRequest::delivery = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__PrepareOutgoingConsignmentRequest::delivery)
			soap_pop_block(soap, soap_blist_delivery1);
		if(a->merc__PrepareOutgoingConsignmentRequest::__sizedelivery)
			a->merc__PrepareOutgoingConsignmentRequest::delivery = (vd__Delivery **)soap_save_block(soap, soap_blist_delivery1, NULL, 1);
		else
		{	a->merc__PrepareOutgoingConsignmentRequest::delivery = NULL;
			if(soap_blist_delivery1)
				soap_end_block(soap, soap_blist_delivery1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__PrepareOutgoingConsignmentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest, 0, sizeof(merc__PrepareOutgoingConsignmentRequest), 0, soap_copy_merc__PrepareOutgoingConsignmentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || a->merc__PrepareOutgoingConsignmentRequest::__sizedelivery < 1)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__PrepareOutgoingConsignmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest);
	return this->soap_out(soap, tag?tag:"merc:PrepareOutgoingConsignmentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__PrepareOutgoingConsignmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__PrepareOutgoingConsignmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentRequest * SOAP_FMAC4 soap_get_merc__PrepareOutgoingConsignmentRequest(struct soap *soap, merc__PrepareOutgoingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__PrepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__PrepareOutgoingConsignmentRequest * FASTCALL soap_instantiate_merc__PrepareOutgoingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__PrepareOutgoingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(merc__PrepareOutgoingConsignmentRequest));
		((merc__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__PrepareOutgoingConsignmentRequest));
		for(int i = 0; i < n; i++)
			((merc__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__PrepareOutgoingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__PrepareOutgoingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__PrepareOutgoingConsignmentRequest %p -> %p\n", q, p));
	*(merc__PrepareOutgoingConsignmentRequest*)p = *(merc__PrepareOutgoingConsignmentRequest*)q;
}

void merc__ProcessIncomingConsignmentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ProcessIncomingConsignmentResponse::__sizestockEntry = 0;
	this->merc__ProcessIncomingConsignmentResponse::stockEntry = NULL;
	this->merc__ProcessIncomingConsignmentResponse::__sizevetDocument = 0;
	this->merc__ProcessIncomingConsignmentResponse::vetDocument = NULL;
	/* transient soap skipped */
}

void merc__ProcessIncomingConsignmentResponse::soap_serialize(struct soap *soap) const
{
	if(this->merc__ProcessIncomingConsignmentResponse::stockEntry) {
		for(int i = 0; i < this->merc__ProcessIncomingConsignmentResponse::__sizestockEntry; i++) {
			soap_serialize_PointerTovd__StockEntry(soap, this->merc__ProcessIncomingConsignmentResponse::stockEntry + i);
		}
	}
	if(this->merc__ProcessIncomingConsignmentResponse::vetDocument) {
		for(int i = 0; i < this->merc__ProcessIncomingConsignmentResponse::__sizevetDocument; i++) {
			soap_serialize_PointerTovd__VetDocument(soap, this->merc__ProcessIncomingConsignmentResponse::vetDocument + i);
		}
	}
	/* transient soap skipped */
}

int merc__ProcessIncomingConsignmentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ProcessIncomingConsignmentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, int id, const merc__ProcessIncomingConsignmentResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse), "merc:ProcessIncomingConsignmentResponse"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "-sizestockEntry");
	if(a->merc__ProcessIncomingConsignmentResponse::stockEntry) {
		int i;
		for(i = 0; i < a->merc__ProcessIncomingConsignmentResponse::__sizestockEntry; i++)
			if(soap_out_PointerTovd__StockEntry(soap, "merc:stockEntry", -1, a->merc__ProcessIncomingConsignmentResponse::stockEntry + i, ""))
				return soap->error;
	}
	if(a->merc__ProcessIncomingConsignmentResponse::vetDocument) {
		int i;
		for(i = 0; i < a->merc__ProcessIncomingConsignmentResponse::__sizevetDocument; i++)
			if(soap_out_PointerTovd__VetDocument(soap, "merc:vetDocument", -1, a->merc__ProcessIncomingConsignmentResponse::vetDocument + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *merc__ProcessIncomingConsignmentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ProcessIncomingConsignmentResponse(soap, tag, this, type);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentResponse * FASTCALL soap_in_merc__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, merc__ProcessIncomingConsignmentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ProcessIncomingConsignmentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse, sizeof(merc__ProcessIncomingConsignmentResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ProcessIncomingConsignmentResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ProcessIncomingConsignmentResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_stockEntry1 = NULL;
	struct soap_blist *soap_blist_vetDocument1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:stockEntry", 1, NULL)) {
				if(a->merc__ProcessIncomingConsignmentResponse::stockEntry == NULL) {
					if(soap_blist_stockEntry1 == NULL)
						soap_blist_stockEntry1 = soap_new_block(soap);
					a->merc__ProcessIncomingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_push_block(soap, soap_blist_stockEntry1, sizeof(vd__StockEntry *));
					if(a->merc__ProcessIncomingConsignmentResponse::stockEntry == NULL)
						return NULL;
					*a->merc__ProcessIncomingConsignmentResponse::stockEntry = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__StockEntry(soap, "merc:stockEntry", a->merc__ProcessIncomingConsignmentResponse::stockEntry, "vd:StockEntry"))
				{	a->merc__ProcessIncomingConsignmentResponse::__sizestockEntry++;
					a->merc__ProcessIncomingConsignmentResponse::stockEntry = NULL;
					continue;
				}
			}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:vetDocument", 1, NULL)) {
				if(a->merc__ProcessIncomingConsignmentResponse::vetDocument == NULL) {
					if(soap_blist_vetDocument1 == NULL)
						soap_blist_vetDocument1 = soap_new_block(soap);
					a->merc__ProcessIncomingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_push_block(soap, soap_blist_vetDocument1, sizeof(vd__VetDocument *));
					if(a->merc__ProcessIncomingConsignmentResponse::vetDocument == NULL)
						return NULL;
					*a->merc__ProcessIncomingConsignmentResponse::vetDocument = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__VetDocument(soap, "merc:vetDocument", a->merc__ProcessIncomingConsignmentResponse::vetDocument, "vd:VetDocument"))
				{	a->merc__ProcessIncomingConsignmentResponse::__sizevetDocument++;
					a->merc__ProcessIncomingConsignmentResponse::vetDocument = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizestockEntry");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__ProcessIncomingConsignmentResponse::stockEntry)
			soap_pop_block(soap, soap_blist_stockEntry1);
		if(a->merc__ProcessIncomingConsignmentResponse::__sizestockEntry)
			a->merc__ProcessIncomingConsignmentResponse::stockEntry = (vd__StockEntry **)soap_save_block(soap, soap_blist_stockEntry1, NULL, 1);
		else
		{	a->merc__ProcessIncomingConsignmentResponse::stockEntry = NULL;
			if(soap_blist_stockEntry1)
				soap_end_block(soap, soap_blist_stockEntry1);
		}
		if(a->merc__ProcessIncomingConsignmentResponse::vetDocument)
			soap_pop_block(soap, soap_blist_vetDocument1);
		if(a->merc__ProcessIncomingConsignmentResponse::__sizevetDocument)
			a->merc__ProcessIncomingConsignmentResponse::vetDocument = (vd__VetDocument **)soap_save_block(soap, soap_blist_vetDocument1, NULL, 1);
		else
		{	a->merc__ProcessIncomingConsignmentResponse::vetDocument = NULL;
			if(soap_blist_vetDocument1)
				soap_end_block(soap, soap_blist_vetDocument1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ProcessIncomingConsignmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse, 0, sizeof(merc__ProcessIncomingConsignmentResponse), 0, soap_copy_merc__ProcessIncomingConsignmentResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int merc__ProcessIncomingConsignmentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse);
	return this->soap_out(soap, tag?tag:"merc:ProcessIncomingConsignmentResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ProcessIncomingConsignmentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ProcessIncomingConsignmentResponse(soap, this, tag, type);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentResponse * SOAP_FMAC4 soap_get_merc__ProcessIncomingConsignmentResponse(struct soap *soap, merc__ProcessIncomingConsignmentResponse *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ProcessIncomingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ProcessIncomingConsignmentResponse * FASTCALL soap_instantiate_merc__ProcessIncomingConsignmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ProcessIncomingConsignmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentResponse);
		ASSIGN_PTR(size, sizeof(merc__ProcessIncomingConsignmentResponse));
		((merc__ProcessIncomingConsignmentResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ProcessIncomingConsignmentResponse));
		for(int i = 0; i < n; i++)
			((merc__ProcessIncomingConsignmentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ProcessIncomingConsignmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ProcessIncomingConsignmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ProcessIncomingConsignmentResponse %p -> %p\n", q, p));
	*(merc__ProcessIncomingConsignmentResponse*)p = *(merc__ProcessIncomingConsignmentResponse*)q;
}

void merc__ProcessIncomingConsignmentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->merc__ProcessIncomingConsignmentRequest::delivery = NULL;
	this->merc__ProcessIncomingConsignmentRequest::deliveryFacts = NULL;
	this->merc__ProcessIncomingConsignmentRequest::__sizediscrepancyReport = 0;
	this->merc__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
	this->merc__ProcessIncomingConsignmentRequest::returnedDelivery = NULL;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__ProcessIncomingConsignmentRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTovd__Delivery(soap, &this->merc__ProcessIncomingConsignmentRequest::delivery);
	soap_serialize_PointerTovd__DeliveryFactList(soap, &this->merc__ProcessIncomingConsignmentRequest::deliveryFacts);
	if(this->merc__ProcessIncomingConsignmentRequest::discrepancyReport) {
		for(int i = 0; i < this->merc__ProcessIncomingConsignmentRequest::__sizediscrepancyReport; i++) {
			soap_serialize_PointerTovd__DiscrepancyReport(soap, this->merc__ProcessIncomingConsignmentRequest::discrepancyReport + i);
		}
	}
	soap_serialize_PointerTovd__Delivery(soap, &this->merc__ProcessIncomingConsignmentRequest::returnedDelivery);
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__ProcessIncomingConsignmentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__ProcessIncomingConsignmentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, const merc__ProcessIncomingConsignmentRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest), "merc:ProcessIncomingConsignmentRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	if(a->merc__ProcessIncomingConsignmentRequest::delivery) {
		if(soap_out_PointerTovd__Delivery(soap, "merc:delivery", -1, &a->merc__ProcessIncomingConsignmentRequest::delivery, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:delivery"))
		return soap->error;
	if(a->merc__ProcessIncomingConsignmentRequest::deliveryFacts) {
		if(soap_out_PointerTovd__DeliveryFactList(soap, "merc:deliveryFacts", -1, &a->merc__ProcessIncomingConsignmentRequest::deliveryFacts, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:deliveryFacts"))
		return soap->error;
	if(a->merc__ProcessIncomingConsignmentRequest::discrepancyReport) {
		int i;
		for(i = 0; i < a->merc__ProcessIncomingConsignmentRequest::__sizediscrepancyReport; i++)
			if(soap_out_PointerTovd__DiscrepancyReport(soap, "merc:discrepancyReport", -1, a->merc__ProcessIncomingConsignmentRequest::discrepancyReport + i, ""))
				return soap->error;
	}
	if(soap_out_PointerTovd__Delivery(soap, "merc:returnedDelivery", -1, &(a->merc__ProcessIncomingConsignmentRequest::returnedDelivery), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__ProcessIncomingConsignmentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__ProcessIncomingConsignmentRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentRequest * FASTCALL soap_in_merc__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, merc__ProcessIncomingConsignmentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__ProcessIncomingConsignmentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest, sizeof(merc__ProcessIncomingConsignmentRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__ProcessIncomingConsignmentRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__ProcessIncomingConsignmentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId2 = 1;
	size_t soap_flag_initiator2 = 1;
	size_t soap_flag_sessionToken2 = 1;
	size_t soap_flag_delivery1 = 1;
	size_t soap_flag_deliveryFacts1 = 1;
	struct soap_blist *soap_blist_discrepancyReport1 = NULL;
	size_t soap_flag_returnedDelivery1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId2--;
					continue;
				}
			if(soap_flag_initiator2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator2--;
					continue;
				}
			if(soap_flag_sessionToken2 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken2--;
					continue;
				}
			if(soap_flag_delivery1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Delivery(soap, "merc:delivery", &(a->merc__ProcessIncomingConsignmentRequest::delivery), "vd:Delivery"))
				{	soap_flag_delivery1--;
					continue;
				}
			if(soap_flag_deliveryFacts1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__DeliveryFactList(soap, "merc:deliveryFacts", &(a->merc__ProcessIncomingConsignmentRequest::deliveryFacts), "vd:DeliveryFactList"))
				{	soap_flag_deliveryFacts1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "merc:discrepancyReport", 1, NULL)) {
				if(a->merc__ProcessIncomingConsignmentRequest::discrepancyReport == NULL) {
					if(soap_blist_discrepancyReport1 == NULL)
						soap_blist_discrepancyReport1 = soap_new_block(soap);
					a->merc__ProcessIncomingConsignmentRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_push_block(soap, soap_blist_discrepancyReport1, sizeof(vd__DiscrepancyReport *));
					if(a->merc__ProcessIncomingConsignmentRequest::discrepancyReport == NULL)
						return NULL;
					*a->merc__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTovd__DiscrepancyReport(soap, "merc:discrepancyReport", a->merc__ProcessIncomingConsignmentRequest::discrepancyReport, "vd:DiscrepancyReport"))
				{	a->merc__ProcessIncomingConsignmentRequest::__sizediscrepancyReport++;
					a->merc__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
					continue;
				}
			}
			if(soap_flag_returnedDelivery1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__Delivery(soap, "merc:returnedDelivery", &(a->merc__ProcessIncomingConsignmentRequest::returnedDelivery), "vd:Delivery"))
				{	soap_flag_returnedDelivery1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->merc__ProcessIncomingConsignmentRequest::discrepancyReport)
			soap_pop_block(soap, soap_blist_discrepancyReport1);
		if(a->merc__ProcessIncomingConsignmentRequest::__sizediscrepancyReport)
			a->merc__ProcessIncomingConsignmentRequest::discrepancyReport = (vd__DiscrepancyReport **)soap_save_block(soap, soap_blist_discrepancyReport1, NULL, 1);
		else
		{	a->merc__ProcessIncomingConsignmentRequest::discrepancyReport = NULL;
			if(soap_blist_discrepancyReport1)
				soap_end_block(soap, soap_blist_discrepancyReport1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__ProcessIncomingConsignmentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest, 0, sizeof(merc__ProcessIncomingConsignmentRequest), 0, soap_copy_merc__ProcessIncomingConsignmentRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId2 > 0 || soap_flag_initiator2 > 0 || soap_flag_delivery1 > 0 || soap_flag_deliveryFacts1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__ProcessIncomingConsignmentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest);
	return this->soap_out(soap, tag?tag:"merc:ProcessIncomingConsignmentRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__ProcessIncomingConsignmentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__ProcessIncomingConsignmentRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentRequest * SOAP_FMAC4 soap_get_merc__ProcessIncomingConsignmentRequest(struct soap *soap, merc__ProcessIncomingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__ProcessIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__ProcessIncomingConsignmentRequest * FASTCALL soap_instantiate_merc__ProcessIncomingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__ProcessIncomingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(merc__ProcessIncomingConsignmentRequest));
		((merc__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__ProcessIncomingConsignmentRequest));
		for(int i = 0; i < n; i++)
			((merc__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__ProcessIncomingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__ProcessIncomingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__ProcessIncomingConsignmentRequest %p -> %p\n", q, p));
	*(merc__ProcessIncomingConsignmentRequest*)p = *(merc__ProcessIncomingConsignmentRequest*)q;
}

void merc__MercuryApplicationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	this->merc__MercuryApplicationRequest::initiator = NULL;
	this->merc__MercuryApplicationRequest::sessionToken = NULL;
	/* transient soap skipped */
}

void merc__MercuryApplicationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__Identifier(soap, &this->merc__MercuryApplicationRequest::localTransactionId);
	soap_serialize_PointerTovd__User(soap, &this->merc__MercuryApplicationRequest::initiator);
	soap_serialize_PointerToent__OTPToken(soap, &this->merc__MercuryApplicationRequest::sessionToken);
	/* transient soap skipped */
}

int merc__MercuryApplicationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_merc__MercuryApplicationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_merc__MercuryApplicationRequest(struct soap *soap, const char *tag, int id, const merc__MercuryApplicationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_merc__MercuryApplicationRequest), "merc:MercuryApplicationRequest"))
		return soap->error;
	/* transient soap skipped */
	if(a->merc__MercuryApplicationRequest::localTransactionId) {
		if(soap_out_base__Identifier(soap, "merc:localTransactionId", -1, &a->merc__MercuryApplicationRequest::localTransactionId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:localTransactionId"))
		return soap->error;
	if(a->merc__MercuryApplicationRequest::initiator) {
		if(soap_out_PointerTovd__User(soap, "merc:initiator", -1, &a->merc__MercuryApplicationRequest::initiator, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "merc:initiator"))
		return soap->error;
	if(soap_out_PointerToent__OTPToken(soap, "merc:sessionToken", -1, &(a->merc__MercuryApplicationRequest::sessionToken), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *merc__MercuryApplicationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_merc__MercuryApplicationRequest(soap, tag, this, type);
}

SOAP_FMAC3 merc__MercuryApplicationRequest * FASTCALL soap_in_merc__MercuryApplicationRequest(struct soap *soap, const char *tag, merc__MercuryApplicationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (merc__MercuryApplicationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_merc__MercuryApplicationRequest, sizeof(merc__MercuryApplicationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_merc__MercuryApplicationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (merc__MercuryApplicationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_localTransactionId1 = 1;
	size_t soap_flag_initiator1 = 1;
	size_t soap_flag_sessionToken1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag_localTransactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__Identifier(soap, "merc:localTransactionId", &(a->merc__MercuryApplicationRequest::localTransactionId), "base:Identifier"))
				{	soap_flag_localTransactionId1--;
					continue;
				}
			if(soap_flag_initiator1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTovd__User(soap, "merc:initiator", &(a->merc__MercuryApplicationRequest::initiator), "vd:User"))
				{	soap_flag_initiator1--;
					continue;
				}
			if(soap_flag_sessionToken1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToent__OTPToken(soap, "merc:sessionToken", &(a->merc__MercuryApplicationRequest::sessionToken), "ent:OTPToken"))
				{	soap_flag_sessionToken1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (merc__MercuryApplicationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_merc__MercuryApplicationRequest, 0, sizeof(merc__MercuryApplicationRequest), 0, soap_copy_merc__MercuryApplicationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_localTransactionId1 > 0 || soap_flag_initiator1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int merc__MercuryApplicationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_merc__MercuryApplicationRequest);
	return this->soap_out(soap, tag?tag:"merc:MercuryApplicationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *merc__MercuryApplicationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_merc__MercuryApplicationRequest(soap, this, tag, type);
}

SOAP_FMAC3 merc__MercuryApplicationRequest * SOAP_FMAC4 soap_get_merc__MercuryApplicationRequest(struct soap *soap, merc__MercuryApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in_merc__MercuryApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 merc__MercuryApplicationRequest * FASTCALL soap_instantiate_merc__MercuryApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_merc__MercuryApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_merc__MercuryApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "merc:ProcessIncomingConsignmentRequest")) {
		cp->type = SOAP_TYPE_merc__ProcessIncomingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ProcessIncomingConsignmentRequest));
			((merc__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ProcessIncomingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((merc__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ProcessIncomingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:PrepareOutgoingConsignmentRequest")) {
		cp->type = SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__PrepareOutgoingConsignmentRequest));
			((merc__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__PrepareOutgoingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((merc__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__PrepareOutgoingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:RegisterProductionOperationRequest")) {
		cp->type = SOAP_TYPE_merc__RegisterProductionOperationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__RegisterProductionOperationRequest));
			((merc__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__RegisterProductionOperationRequest));
			for(int i = 0; i < n; i++)
				((merc__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__RegisterProductionOperationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:MergeStockEntriesRequest")) {
		cp->type = SOAP_TYPE_merc__MergeStockEntriesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__MergeStockEntriesRequest));
			((merc__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__MergeStockEntriesRequest));
			for(int i = 0; i < n; i++)
				((merc__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__MergeStockEntriesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:WithdrawVetDocumentRequest")) {
		cp->type = SOAP_TYPE_merc__WithdrawVetDocumentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__WithdrawVetDocumentRequest));
			((merc__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__WithdrawVetDocumentRequest));
			for(int i = 0; i < n; i++)
				((merc__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__WithdrawVetDocumentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyBusinessEntityRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyBusinessEntityRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyBusinessEntityRequest));
			((merc__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyBusinessEntityRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyBusinessEntityRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyEnterpriseRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyEnterpriseRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyEnterpriseRequest));
			((merc__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyEnterpriseRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyEnterpriseRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyActivityLocationsRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyActivityLocationsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyActivityLocationsRequest));
			((merc__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyActivityLocationsRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyActivityLocationsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ResolveDiscrepancyRequest")) {
		cp->type = SOAP_TYPE_merc__ResolveDiscrepancyRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ResolveDiscrepancyRequest));
			((merc__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ResolveDiscrepancyRequest));
			for(int i = 0; i < n; i++)
				((merc__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ResolveDiscrepancyRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyProducerStockListRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyProducerStockListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyProducerStockListRequest));
			((merc__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyProducerStockListRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyProducerStockListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentByUuidRequest")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentByUuidRequest));
			((merc__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentByUuidRequest));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentListRequest")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentListRequest));
			((merc__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentChangesListRequest")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentChangesListRequest));
			((merc__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentChangesListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryByGuidRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryByGuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryByGuidRequest));
			((merc__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByGuidRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryByGuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryByUuidRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryByUuidRequest));
			((merc__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByUuidRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryChangesListRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryChangesListRequest));
			((merc__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryChangesListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryListRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryListRequest));
			((merc__GetStockEntryListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryVersionListRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryVersionListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryVersionListRequest));
			((merc__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryVersionListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryVersionListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateTransportMovementDetailsRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateTransportMovementDetailsRequest));
			((merc__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateTransportMovementDetailsRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateTransportMovementDetailsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateVeterinaryEventsRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateVeterinaryEventsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateVeterinaryEventsRequest));
			((merc__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateVeterinaryEventsRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateVeterinaryEventsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:CheckShipmentRegionalizationRequest")) {
		cp->type = SOAP_TYPE_merc__CheckShipmentRegionalizationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__CheckShipmentRegionalizationRequest));
			((merc__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__CheckShipmentRegionalizationRequest));
			for(int i = 0; i < n; i++)
				((merc__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__CheckShipmentRegionalizationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:AddBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_merc__AddBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__AddBusinessEntityUserRequest));
			((merc__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__AddBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((merc__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__AddBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetBusinessEntityUserListRequest")) {
		cp->type = SOAP_TYPE_merc__GetBusinessEntityUserListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserListRequest));
			((merc__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetBusinessEntityUserListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_merc__GetBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserRequest));
			((merc__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((merc__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateUserAuthoritiesRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateUserAuthoritiesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateUserAuthoritiesRequest));
			((merc__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateUserAuthoritiesRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateUserAuthoritiesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateUserWorkingAreasRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateUserWorkingAreasRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateUserWorkingAreasRequest));
			((merc__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateUserWorkingAreasRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateUserWorkingAreasRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UnbindBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_merc__UnbindBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UnbindBusinessEntityUserRequest));
			((merc__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UnbindBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((merc__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UnbindBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetAppliedUserAuthorityListRequest")) {
		cp->type = SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetAppliedUserAuthorityListRequest));
			((merc__GetAppliedUserAuthorityListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetAppliedUserAuthorityListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetAppliedUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetAppliedUserAuthorityListRequest*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(merc__MercuryApplicationRequest);
		ASSIGN_PTR(size, sizeof(merc__MercuryApplicationRequest));
		((merc__MercuryApplicationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(merc__MercuryApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(merc__MercuryApplicationRequest));
		for(int i = 0; i < n; i++)
			((merc__MercuryApplicationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (merc__MercuryApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_merc__MercuryApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying merc__MercuryApplicationRequest %p -> %p\n", q, p));
	*(merc__MercuryApplicationRequest*)p = *(merc__MercuryApplicationRequest*)q;
}

void app__BusinessError::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->base__Error::__item);
	soap_default_xsd__NCName(soap, &this->base__Error::code);
	this->base__Error::qualifier = NULL;
	/* transient soap skipped */
}

void app__BusinessError::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->base__Error::__item);
	/* transient soap skipped */
}

int app__BusinessError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__BusinessError(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__BusinessError(struct soap *soap, const char *tag, int id, const app__BusinessError *a, const char *type)
{
	if(((base__Error*)a)->code)
		soap_set_attr(soap, "code", ((base__Error*)a)->code, 1);
	if(((base__Error*)a)->qualifier)
		if(*((base__Error*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((base__Error*)a)->qualifier, 1);
	return soap_out_string(soap, tag, id, &(a->base__Error::__item), "app:BusinessError");
}

void *app__BusinessError::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__BusinessError(soap, tag, this, type);
}

SOAP_FMAC3 app__BusinessError * FASTCALL soap_in_app__BusinessError(struct soap *soap, const char *tag, app__BusinessError *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (app__BusinessError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__BusinessError, sizeof(app__BusinessError), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__BusinessError)
			return (app__BusinessError *)a->soap_in(soap, tag, type);
	}
	if(soap_s2string(soap, soap_attr_value(soap, "code", 1), &((base__Error*)a)->code, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((base__Error*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((base__Error*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(!soap_in_string(soap, tag, &(a->base__Error::__item), "app:BusinessError"))
		return NULL;
	return a;
}

int app__BusinessError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__BusinessError);
	return this->soap_out(soap, tag?tag:"app:BusinessError", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__BusinessError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__BusinessError(soap, this, tag, type);
}

SOAP_FMAC3 app__BusinessError * SOAP_FMAC4 soap_get_app__BusinessError(struct soap *soap, app__BusinessError *p, const char *tag, const char *type)
{
	if((p = soap_in_app__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__BusinessError * FASTCALL soap_instantiate_app__BusinessError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__BusinessError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__BusinessError, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__BusinessError);
		ASSIGN_PTR(size, sizeof(app__BusinessError));
		((app__BusinessError*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__BusinessError[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__BusinessError));
		for(int i = 0; i < n; i++)
			((app__BusinessError*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__BusinessError*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__BusinessError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__BusinessError %p -> %p\n", q, p));
	*(app__BusinessError*)p = *(app__BusinessError*)q;
}

void app__BusinessErrorList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->app__BusinessErrorList::__sizeerror = 0;
	this->app__BusinessErrorList::error = NULL;
	/* transient soap skipped */
}

void app__BusinessErrorList::soap_serialize(struct soap *soap) const
{
	if(this->app__BusinessErrorList::error) {
		for(int i = 0; i < this->app__BusinessErrorList::__sizeerror; i++) {
			soap_serialize_PointerToapp__BusinessError(soap, this->app__BusinessErrorList::error + i);
		}
	}
	/* transient soap skipped */
}

int app__BusinessErrorList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__BusinessErrorList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__BusinessErrorList(struct soap *soap, const char *tag, int id, const app__BusinessErrorList *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__BusinessErrorList), type))
		return soap->error;
	if(a->app__BusinessErrorList::error) {
		int i;
		for(i = 0; i < a->app__BusinessErrorList::__sizeerror; i++)
			if(soap_out_PointerToapp__BusinessError(soap, "app:error", -1, a->app__BusinessErrorList::error + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__BusinessErrorList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__BusinessErrorList(soap, tag, this, type);
}

SOAP_FMAC3 app__BusinessErrorList * FASTCALL soap_in_app__BusinessErrorList(struct soap *soap, const char *tag, app__BusinessErrorList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__BusinessErrorList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__BusinessErrorList, sizeof(app__BusinessErrorList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__BusinessErrorList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__BusinessErrorList *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_error1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "app:error", 1, NULL)) {
				if(a->app__BusinessErrorList::error == NULL) {
					if(soap_blist_error1 == NULL)
						soap_blist_error1 = soap_new_block(soap);
					a->app__BusinessErrorList::error = (app__BusinessError **)soap_push_block(soap, soap_blist_error1, sizeof(app__BusinessError *));
					if(a->app__BusinessErrorList::error == NULL)
						return NULL;
					*a->app__BusinessErrorList::error = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerToapp__BusinessError(soap, "app:error", a->app__BusinessErrorList::error, "app:BusinessError"))
				{	a->app__BusinessErrorList::__sizeerror++;
					a->app__BusinessErrorList::error = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->app__BusinessErrorList::error)
			soap_pop_block(soap, soap_blist_error1);
		if(a->app__BusinessErrorList::__sizeerror)
			a->app__BusinessErrorList::error = (app__BusinessError **)soap_save_block(soap, soap_blist_error1, NULL, 1);
		else
		{	a->app__BusinessErrorList::error = NULL;
			if(soap_blist_error1)
				soap_end_block(soap, soap_blist_error1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__BusinessErrorList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__BusinessErrorList, 0, sizeof(app__BusinessErrorList), 0, soap_copy_app__BusinessErrorList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__BusinessErrorList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__BusinessErrorList);
	return this->soap_out(soap, tag?tag:"app:BusinessErrorList", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__BusinessErrorList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__BusinessErrorList(soap, this, tag, type);
}

SOAP_FMAC3 app__BusinessErrorList * SOAP_FMAC4 soap_get_app__BusinessErrorList(struct soap *soap, app__BusinessErrorList *p, const char *tag, const char *type)
{
	if((p = soap_in_app__BusinessErrorList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__BusinessErrorList * FASTCALL soap_instantiate_app__BusinessErrorList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__BusinessErrorList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__BusinessErrorList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__BusinessErrorList);
		ASSIGN_PTR(size, sizeof(app__BusinessErrorList));
		((app__BusinessErrorList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__BusinessErrorList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__BusinessErrorList));
		for(int i = 0; i < n; i++)
			((app__BusinessErrorList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__BusinessErrorList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__BusinessErrorList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__BusinessErrorList %p -> %p\n", q, p));
	*(app__BusinessErrorList*)p = *(app__BusinessErrorList*)q;
}

void app__ApplicationResultData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void app__ApplicationResultData::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationResultData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationResultData(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationResultData(struct soap *soap, const char *tag, int id, const app__ApplicationResultData *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationResultData), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationResultData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationResultData(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationResultData * FASTCALL soap_in_app__ApplicationResultData(struct soap *soap, const char *tag, app__ApplicationResultData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationResultData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationResultData, sizeof(app__ApplicationResultData), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationResultData) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationResultData *)a->soap_in(soap, tag, type);
		}
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationResultData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationResultData, 0, sizeof(app__ApplicationResultData), 0, soap_copy_app__ApplicationResultData);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationResultData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationResultData);
	return this->soap_out(soap, tag?tag:"app:ApplicationResultData", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationResultData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationResultData(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationResultData * SOAP_FMAC4 soap_get_app__ApplicationResultData(struct soap *soap, app__ApplicationResultData *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationResultData(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationResultData * FASTCALL soap_instantiate_app__ApplicationResultData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationResultData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationResultData, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "merc:ProcessIncomingConsignmentResponse")) {
		cp->type = SOAP_TYPE_merc__ProcessIncomingConsignmentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ProcessIncomingConsignmentResponse));
			((merc__ProcessIncomingConsignmentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ProcessIncomingConsignmentResponse));
			for(int i = 0; i < n; i++)
				((merc__ProcessIncomingConsignmentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ProcessIncomingConsignmentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:PrepareOutgoingConsignmentResponse")) {
		cp->type = SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__PrepareOutgoingConsignmentResponse));
			((merc__PrepareOutgoingConsignmentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__PrepareOutgoingConsignmentResponse));
			for(int i = 0; i < n; i++)
				((merc__PrepareOutgoingConsignmentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__PrepareOutgoingConsignmentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:RegisterProductionOperationResponse")) {
		cp->type = SOAP_TYPE_merc__RegisterProductionOperationResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__RegisterProductionOperationResponse));
			((merc__RegisterProductionOperationResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__RegisterProductionOperationResponse));
			for(int i = 0; i < n; i++)
				((merc__RegisterProductionOperationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__RegisterProductionOperationResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:MergeStockEntriesResponse")) {
		cp->type = SOAP_TYPE_merc__MergeStockEntriesResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__MergeStockEntriesResponse));
			((merc__MergeStockEntriesResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__MergeStockEntriesResponse));
			for(int i = 0; i < n; i++)
				((merc__MergeStockEntriesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__MergeStockEntriesResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:WithdrawVetDocumentResponse")) {
		cp->type = SOAP_TYPE_merc__WithdrawVetDocumentResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__WithdrawVetDocumentResponse));
			((merc__WithdrawVetDocumentResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__WithdrawVetDocumentResponse));
			for(int i = 0; i < n; i++)
				((merc__WithdrawVetDocumentResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__WithdrawVetDocumentResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyBusinessEntityResponse")) {
		cp->type = SOAP_TYPE_merc__ModifyBusinessEntityResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyBusinessEntityResponse));
			((merc__ModifyBusinessEntityResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyBusinessEntityResponse));
			for(int i = 0; i < n; i++)
				((merc__ModifyBusinessEntityResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyBusinessEntityResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyEnterpriseResponse")) {
		cp->type = SOAP_TYPE_merc__ModifyEnterpriseResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyEnterpriseResponse));
			((merc__ModifyEnterpriseResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyEnterpriseResponse));
			for(int i = 0; i < n; i++)
				((merc__ModifyEnterpriseResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyEnterpriseResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyActivityLocationsResponse")) {
		cp->type = SOAP_TYPE_merc__ModifyActivityLocationsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyActivityLocationsResponse));
			((merc__ModifyActivityLocationsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyActivityLocationsResponse));
			for(int i = 0; i < n; i++)
				((merc__ModifyActivityLocationsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyActivityLocationsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ResolveDiscrepancyResponse")) {
		cp->type = SOAP_TYPE_merc__ResolveDiscrepancyResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ResolveDiscrepancyResponse));
			((merc__ResolveDiscrepancyResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ResolveDiscrepancyResponse));
			for(int i = 0; i < n; i++)
				((merc__ResolveDiscrepancyResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ResolveDiscrepancyResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyProducerStockListResponse")) {
		cp->type = SOAP_TYPE_merc__ModifyProducerStockListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyProducerStockListResponse));
			((merc__ModifyProducerStockListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyProducerStockListResponse));
			for(int i = 0; i < n; i++)
				((merc__ModifyProducerStockListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyProducerStockListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentByUuidResponse")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentByUuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentByUuidResponse));
			((merc__GetVetDocumentByUuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentByUuidResponse));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentByUuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentByUuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentListResponse")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentListResponse));
			((merc__GetVetDocumentListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentChangesListResponse")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentChangesListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentChangesListResponse));
			((merc__GetVetDocumentChangesListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentChangesListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentChangesListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentChangesListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryByGuidResponse")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryByGuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryByGuidResponse));
			((merc__GetStockEntryByGuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByGuidResponse));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryByGuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryByGuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryByUuidResponse")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryByUuidResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryByUuidResponse));
			((merc__GetStockEntryByUuidResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByUuidResponse));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryByUuidResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryByUuidResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryChangesListResponse")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryChangesListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryChangesListResponse));
			((merc__GetStockEntryChangesListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryChangesListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryChangesListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryChangesListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryListResponse")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryListResponse));
			((merc__GetStockEntryListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryVersionListResponse")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryVersionListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryVersionListResponse));
			((merc__GetStockEntryVersionListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryVersionListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryVersionListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryVersionListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateTransportMovementDetailsResponse")) {
		cp->type = SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateTransportMovementDetailsResponse));
			((merc__UpdateTransportMovementDetailsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateTransportMovementDetailsResponse));
			for(int i = 0; i < n; i++)
				((merc__UpdateTransportMovementDetailsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateTransportMovementDetailsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateVeterinaryEventsResponse")) {
		cp->type = SOAP_TYPE_merc__UpdateVeterinaryEventsResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateVeterinaryEventsResponse));
			((merc__UpdateVeterinaryEventsResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateVeterinaryEventsResponse));
			for(int i = 0; i < n; i++)
				((merc__UpdateVeterinaryEventsResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateVeterinaryEventsResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:CheckShipmentRegionalizationResponse")) {
		cp->type = SOAP_TYPE_merc__CheckShipmentRegionalizationResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__CheckShipmentRegionalizationResponse));
			((merc__CheckShipmentRegionalizationResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__CheckShipmentRegionalizationResponse));
			for(int i = 0; i < n; i++)
				((merc__CheckShipmentRegionalizationResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__CheckShipmentRegionalizationResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:AddBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_merc__AddBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__AddBusinessEntityUserResponse));
			((merc__AddBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__AddBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((merc__AddBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__AddBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetBusinessEntityUserListResponse")) {
		cp->type = SOAP_TYPE_merc__GetBusinessEntityUserListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserListResponse));
			((merc__GetBusinessEntityUserListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetBusinessEntityUserListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetBusinessEntityUserListResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_merc__GetBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserResponse));
			((merc__GetBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((merc__GetBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateUserAuthoritiesResponse")) {
		cp->type = SOAP_TYPE_merc__UpdateUserAuthoritiesResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateUserAuthoritiesResponse));
			((merc__UpdateUserAuthoritiesResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateUserAuthoritiesResponse));
			for(int i = 0; i < n; i++)
				((merc__UpdateUserAuthoritiesResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateUserAuthoritiesResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateUserWorkingAreasResponse")) {
		cp->type = SOAP_TYPE_merc__UpdateUserWorkingAreasResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateUserWorkingAreasResponse));
			((merc__UpdateUserWorkingAreasResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateUserWorkingAreasResponse));
			for(int i = 0; i < n; i++)
				((merc__UpdateUserWorkingAreasResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateUserWorkingAreasResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UnbindBusinessEntityUserResponse")) {
		cp->type = SOAP_TYPE_merc__UnbindBusinessEntityUserResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UnbindBusinessEntityUserResponse));
			((merc__UnbindBusinessEntityUserResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UnbindBusinessEntityUserResponse));
			for(int i = 0; i < n; i++)
				((merc__UnbindBusinessEntityUserResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UnbindBusinessEntityUserResponse*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetAppliedUserAuthorityListResponse")) {
		cp->type = SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListResponse);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetAppliedUserAuthorityListResponse));
			((merc__GetAppliedUserAuthorityListResponse*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListResponse[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetAppliedUserAuthorityListResponse));
			for(int i = 0; i < n; i++)
				((merc__GetAppliedUserAuthorityListResponse*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetAppliedUserAuthorityListResponse*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultData);
		ASSIGN_PTR(size, sizeof(app__ApplicationResultData));
		((app__ApplicationResultData*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultData[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationResultData));
		for(int i = 0; i < n; i++)
			((app__ApplicationResultData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationResultData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationResultData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationResultData %p -> %p\n", q, p));
	*(app__ApplicationResultData*)p = *(app__ApplicationResultData*)q;
}

void app__ApplicationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void app__ApplicationData::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationData(struct soap *soap, const char *tag, int id, const app__ApplicationData *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationData), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationData(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationData * FASTCALL soap_in_app__ApplicationData(struct soap *soap, const char *tag, app__ApplicationData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationData, sizeof(app__ApplicationData), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationData) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationData *)a->soap_in(soap, tag, type);
		}
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationData, 0, sizeof(app__ApplicationData), 0, soap_copy_app__ApplicationData);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationData);
	return this->soap_out(soap, tag?tag:"app:ApplicationData", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationData(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationData * SOAP_FMAC4 soap_get_app__ApplicationData(struct soap *soap, app__ApplicationData *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationData(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationData * FASTCALL soap_instantiate_app__ApplicationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationData, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "merc:MercuryApplicationRequest")) {
		cp->type = SOAP_TYPE_merc__MercuryApplicationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__MercuryApplicationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__MercuryApplicationRequest));
			((merc__MercuryApplicationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__MercuryApplicationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__MercuryApplicationRequest));
			for(int i = 0; i < n; i++)
				((merc__MercuryApplicationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__MercuryApplicationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ProcessIncomingConsignmentRequest")) {
		cp->type = SOAP_TYPE_merc__ProcessIncomingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ProcessIncomingConsignmentRequest));
			((merc__ProcessIncomingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ProcessIncomingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ProcessIncomingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((merc__ProcessIncomingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ProcessIncomingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:PrepareOutgoingConsignmentRequest")) {
		cp->type = SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__PrepareOutgoingConsignmentRequest));
			((merc__PrepareOutgoingConsignmentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__PrepareOutgoingConsignmentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__PrepareOutgoingConsignmentRequest));
			for(int i = 0; i < n; i++)
				((merc__PrepareOutgoingConsignmentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__PrepareOutgoingConsignmentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:RegisterProductionOperationRequest")) {
		cp->type = SOAP_TYPE_merc__RegisterProductionOperationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__RegisterProductionOperationRequest));
			((merc__RegisterProductionOperationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__RegisterProductionOperationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__RegisterProductionOperationRequest));
			for(int i = 0; i < n; i++)
				((merc__RegisterProductionOperationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__RegisterProductionOperationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:MergeStockEntriesRequest")) {
		cp->type = SOAP_TYPE_merc__MergeStockEntriesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__MergeStockEntriesRequest));
			((merc__MergeStockEntriesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__MergeStockEntriesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__MergeStockEntriesRequest));
			for(int i = 0; i < n; i++)
				((merc__MergeStockEntriesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__MergeStockEntriesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:WithdrawVetDocumentRequest")) {
		cp->type = SOAP_TYPE_merc__WithdrawVetDocumentRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__WithdrawVetDocumentRequest));
			((merc__WithdrawVetDocumentRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__WithdrawVetDocumentRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__WithdrawVetDocumentRequest));
			for(int i = 0; i < n; i++)
				((merc__WithdrawVetDocumentRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__WithdrawVetDocumentRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyBusinessEntityRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyBusinessEntityRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyBusinessEntityRequest));
			((merc__ModifyBusinessEntityRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyBusinessEntityRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyBusinessEntityRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyBusinessEntityRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyBusinessEntityRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyEnterpriseRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyEnterpriseRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyEnterpriseRequest));
			((merc__ModifyEnterpriseRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyEnterpriseRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyEnterpriseRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyEnterpriseRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyEnterpriseRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyActivityLocationsRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyActivityLocationsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyActivityLocationsRequest));
			((merc__ModifyActivityLocationsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyActivityLocationsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyActivityLocationsRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyActivityLocationsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyActivityLocationsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ResolveDiscrepancyRequest")) {
		cp->type = SOAP_TYPE_merc__ResolveDiscrepancyRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ResolveDiscrepancyRequest));
			((merc__ResolveDiscrepancyRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ResolveDiscrepancyRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ResolveDiscrepancyRequest));
			for(int i = 0; i < n; i++)
				((merc__ResolveDiscrepancyRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ResolveDiscrepancyRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:ModifyProducerStockListRequest")) {
		cp->type = SOAP_TYPE_merc__ModifyProducerStockListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__ModifyProducerStockListRequest));
			((merc__ModifyProducerStockListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__ModifyProducerStockListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__ModifyProducerStockListRequest));
			for(int i = 0; i < n; i++)
				((merc__ModifyProducerStockListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__ModifyProducerStockListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentByUuidRequest")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentByUuidRequest));
			((merc__GetVetDocumentByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentByUuidRequest));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentListRequest")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentListRequest));
			((merc__GetVetDocumentListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetVetDocumentChangesListRequest")) {
		cp->type = SOAP_TYPE_merc__GetVetDocumentChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetVetDocumentChangesListRequest));
			((merc__GetVetDocumentChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetVetDocumentChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetVetDocumentChangesListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetVetDocumentChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetVetDocumentChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryByGuidRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryByGuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryByGuidRequest));
			((merc__GetStockEntryByGuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByGuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByGuidRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryByGuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryByGuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryByUuidRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryByUuidRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryByUuidRequest));
			((merc__GetStockEntryByUuidRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryByUuidRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryByUuidRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryByUuidRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryByUuidRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryChangesListRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryChangesListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryChangesListRequest));
			((merc__GetStockEntryChangesListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryChangesListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryChangesListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryChangesListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryChangesListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryListRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryListRequest));
			((merc__GetStockEntryListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetStockEntryVersionListRequest")) {
		cp->type = SOAP_TYPE_merc__GetStockEntryVersionListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetStockEntryVersionListRequest));
			((merc__GetStockEntryVersionListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetStockEntryVersionListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetStockEntryVersionListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetStockEntryVersionListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetStockEntryVersionListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateTransportMovementDetailsRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateTransportMovementDetailsRequest));
			((merc__UpdateTransportMovementDetailsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateTransportMovementDetailsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateTransportMovementDetailsRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateTransportMovementDetailsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateTransportMovementDetailsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateVeterinaryEventsRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateVeterinaryEventsRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateVeterinaryEventsRequest));
			((merc__UpdateVeterinaryEventsRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateVeterinaryEventsRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateVeterinaryEventsRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateVeterinaryEventsRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateVeterinaryEventsRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:CheckShipmentRegionalizationRequest")) {
		cp->type = SOAP_TYPE_merc__CheckShipmentRegionalizationRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__CheckShipmentRegionalizationRequest));
			((merc__CheckShipmentRegionalizationRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__CheckShipmentRegionalizationRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__CheckShipmentRegionalizationRequest));
			for(int i = 0; i < n; i++)
				((merc__CheckShipmentRegionalizationRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__CheckShipmentRegionalizationRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:AddBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_merc__AddBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__AddBusinessEntityUserRequest));
			((merc__AddBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__AddBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__AddBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((merc__AddBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__AddBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetBusinessEntityUserListRequest")) {
		cp->type = SOAP_TYPE_merc__GetBusinessEntityUserListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserListRequest));
			((merc__GetBusinessEntityUserListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetBusinessEntityUserListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetBusinessEntityUserListRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_merc__GetBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetBusinessEntityUserRequest));
			((merc__GetBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((merc__GetBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateUserAuthoritiesRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateUserAuthoritiesRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateUserAuthoritiesRequest));
			((merc__UpdateUserAuthoritiesRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserAuthoritiesRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateUserAuthoritiesRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateUserAuthoritiesRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateUserAuthoritiesRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UpdateUserWorkingAreasRequest")) {
		cp->type = SOAP_TYPE_merc__UpdateUserWorkingAreasRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UpdateUserWorkingAreasRequest));
			((merc__UpdateUserWorkingAreasRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UpdateUserWorkingAreasRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UpdateUserWorkingAreasRequest));
			for(int i = 0; i < n; i++)
				((merc__UpdateUserWorkingAreasRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UpdateUserWorkingAreasRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:UnbindBusinessEntityUserRequest")) {
		cp->type = SOAP_TYPE_merc__UnbindBusinessEntityUserRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__UnbindBusinessEntityUserRequest));
			((merc__UnbindBusinessEntityUserRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__UnbindBusinessEntityUserRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__UnbindBusinessEntityUserRequest));
			for(int i = 0; i < n; i++)
				((merc__UnbindBusinessEntityUserRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__UnbindBusinessEntityUserRequest*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "merc:GetAppliedUserAuthorityListRequest")) {
		cp->type = SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListRequest);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(merc__GetAppliedUserAuthorityListRequest));
			((merc__GetAppliedUserAuthorityListRequest*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(merc__GetAppliedUserAuthorityListRequest[n]);
			ASSIGN_PTR(size, n * sizeof(merc__GetAppliedUserAuthorityListRequest));
			for(int i = 0; i < n; i++)
				((merc__GetAppliedUserAuthorityListRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (merc__GetAppliedUserAuthorityListRequest*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationData);
		ASSIGN_PTR(size, sizeof(app__ApplicationData));
		((app__ApplicationData*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationData[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationData));
		for(int i = 0; i < n; i++)
			((app__ApplicationData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationData %p -> %p\n", q, p));
	*(app__ApplicationData*)p = *(app__ApplicationData*)q;
}

void app__ApplicationResultWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->app__ApplicationResultWrapper::__any = NULL;
	this->app__ApplicationResultWrapper::encoding = NULL;
	/* transient soap skipped */
}

void app__ApplicationResultWrapper::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationResultWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationResultWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationResultWrapper(struct soap *soap, const char *tag, int id, const app__ApplicationResultWrapper *a, const char *type)
{
	if(((app__ApplicationResultWrapper*)a)->encoding)
		soap_set_attr(soap, "encoding", soap_app__ContentEncoding2s(soap, *((app__ApplicationResultWrapper*)a)->encoding), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationResultWrapper), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->app__ApplicationResultWrapper::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationResultWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationResultWrapper(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationResultWrapper * FASTCALL soap_in_app__ApplicationResultWrapper(struct soap *soap, const char *tag, app__ApplicationResultWrapper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationResultWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationResultWrapper, sizeof(app__ApplicationResultWrapper), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationResultWrapper) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationResultWrapper *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "encoding", 0);
		if(t)
		{
			if(!(((app__ApplicationResultWrapper*)a)->encoding = (enum app__ContentEncoding *)soap_malloc(soap, sizeof(enum app__ContentEncoding))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2app__ContentEncoding(soap, t, ((app__ApplicationResultWrapper*)a)->encoding))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &(a->app__ApplicationResultWrapper::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationResultWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationResultWrapper, 0, sizeof(app__ApplicationResultWrapper), 0, soap_copy_app__ApplicationResultWrapper);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationResultWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationResultWrapper);
	return this->soap_out(soap, tag?tag:"app:ApplicationResultWrapper", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationResultWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationResultWrapper(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationResultWrapper * SOAP_FMAC4 soap_get_app__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationResultWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationResultWrapper * FASTCALL soap_instantiate_app__ApplicationResultWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationResultWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationResultWrapper, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultWrapper);
		ASSIGN_PTR(size, sizeof(app__ApplicationResultWrapper));
		((app__ApplicationResultWrapper*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationResultWrapper[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationResultWrapper));
		for(int i = 0; i < n; i++)
			((app__ApplicationResultWrapper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationResultWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationResultWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationResultWrapper %p -> %p\n", q, p));
	*(app__ApplicationResultWrapper*)p = *(app__ApplicationResultWrapper*)q;
}

void app__ApplicationDataWrapper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->app__ApplicationDataWrapper::__any = NULL;
	this->app__ApplicationDataWrapper::encoding = NULL;
	/* transient soap skipped */
}

void app__ApplicationDataWrapper::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int app__ApplicationDataWrapper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__ApplicationDataWrapper(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__ApplicationDataWrapper(struct soap *soap, const char *tag, int id, const app__ApplicationDataWrapper *a, const char *type)
{
	if(((app__ApplicationDataWrapper*)a)->encoding)
		soap_set_attr(soap, "encoding", soap_app__ContentEncoding2s(soap, *((app__ApplicationDataWrapper*)a)->encoding), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__ApplicationDataWrapper), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->app__ApplicationDataWrapper::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__ApplicationDataWrapper::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__ApplicationDataWrapper(soap, tag, this, type);
}

SOAP_FMAC3 app__ApplicationDataWrapper * FASTCALL soap_in_app__ApplicationDataWrapper(struct soap *soap, const char *tag, app__ApplicationDataWrapper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__ApplicationDataWrapper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__ApplicationDataWrapper, sizeof(app__ApplicationDataWrapper), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__ApplicationDataWrapper) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__ApplicationDataWrapper *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "encoding", 0);
		if(t)
		{
			if(!(((app__ApplicationDataWrapper*)a)->encoding = (enum app__ContentEncoding *)soap_malloc(soap, sizeof(enum app__ContentEncoding))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2app__ContentEncoding(soap, t, ((app__ApplicationDataWrapper*)a)->encoding))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &(a->app__ApplicationDataWrapper::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__ApplicationDataWrapper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__ApplicationDataWrapper, 0, sizeof(app__ApplicationDataWrapper), 0, soap_copy_app__ApplicationDataWrapper);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__ApplicationDataWrapper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__ApplicationDataWrapper);
	return this->soap_out(soap, tag?tag:"app:ApplicationDataWrapper", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__ApplicationDataWrapper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__ApplicationDataWrapper(soap, this, tag, type);
}

SOAP_FMAC3 app__ApplicationDataWrapper * SOAP_FMAC4 soap_get_app__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper *p, const char *tag, const char *type)
{
	if((p = soap_in_app__ApplicationDataWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__ApplicationDataWrapper * FASTCALL soap_instantiate_app__ApplicationDataWrapper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__ApplicationDataWrapper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__ApplicationDataWrapper, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationDataWrapper);
		ASSIGN_PTR(size, sizeof(app__ApplicationDataWrapper));
		((app__ApplicationDataWrapper*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__ApplicationDataWrapper[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__ApplicationDataWrapper));
		for(int i = 0; i < n; i++)
			((app__ApplicationDataWrapper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__ApplicationDataWrapper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__ApplicationDataWrapper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__ApplicationDataWrapper %p -> %p\n", q, p));
	*(app__ApplicationDataWrapper*)p = *(app__ApplicationDataWrapper*)q;
}

void app__Application::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->app__Application::applicationId);
	this->app__Application::status = NULL;
	soap_default_xsd__Name(soap, &this->app__Application::serviceId);
	soap_default_base__UUID(soap, &this->app__Application::issuerId);
	this->app__Application::issueDate = NULL;
	this->app__Application::rcvDate = NULL;
	this->app__Application::prdcRsltDate = NULL;
	this->app__Application::data = NULL;
	this->app__Application::result = NULL;
	this->app__Application::errors = NULL;
	/* transient soap skipped */
}

void app__Application::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->app__Application::applicationId);
	soap_serialize_PointerToapp__ApplicationStatus(soap, &this->app__Application::status);
	soap_serialize_xsd__Name(soap, &this->app__Application::serviceId);
	soap_serialize_base__UUID(soap, &this->app__Application::issuerId);
	soap_serialize_PointerTotime(soap, &this->app__Application::issueDate);
	soap_serialize_PointerTotime(soap, &this->app__Application::rcvDate);
	soap_serialize_PointerTotime(soap, &this->app__Application::prdcRsltDate);
	soap_serialize_PointerToapp__ApplicationDataWrapper(soap, &this->app__Application::data);
	soap_serialize_PointerToapp__ApplicationResultWrapper(soap, &this->app__Application::result);
	soap_serialize_PointerToapp__BusinessErrorList(soap, &this->app__Application::errors);
	/* transient soap skipped */
}

int app__Application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_app__Application(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_app__Application(struct soap *soap, const char *tag, int id, const app__Application *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__Application), type))
		return soap->error;
	if(soap_out_base__UUID(soap, "app:applicationId", -1, &(a->app__Application::applicationId), ""))
		return soap->error;
	if(soap_out_PointerToapp__ApplicationStatus(soap, "app:status", -1, &(a->app__Application::status), ""))
		return soap->error;
	if(soap_out_xsd__Name(soap, "app:serviceId", -1, &(a->app__Application::serviceId), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "app:issuerId", -1, &(a->app__Application::issuerId), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "app:issueDate", -1, &(a->app__Application::issueDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "app:rcvDate", -1, &(a->app__Application::rcvDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "app:prdcRsltDate", -1, &(a->app__Application::prdcRsltDate), ""))
		return soap->error;
	if(soap_out_PointerToapp__ApplicationDataWrapper(soap, "app:data", -1, &(a->app__Application::data), ""))
		return soap->error;
	if(soap_out_PointerToapp__ApplicationResultWrapper(soap, "app:result", -1, &(a->app__Application::result), ""))
		return soap->error;
	if(soap_out_PointerToapp__BusinessErrorList(soap, "app:errors", -1, &(a->app__Application::errors), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *app__Application::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_app__Application(soap, tag, this, type);
}

SOAP_FMAC3 app__Application * FASTCALL soap_in_app__Application(struct soap *soap, const char *tag, app__Application *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (app__Application *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_app__Application, sizeof(app__Application), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_app__Application) {
			soap_revert(soap);
			*soap->id = '\0';
			return (app__Application *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_serviceId1 = 1;
	size_t soap_flag_issuerId1 = 1;
	size_t soap_flag_issueDate1 = 1;
	size_t soap_flag_rcvDate1 = 1;
	size_t soap_flag_prdcRsltDate1 = 1;
	size_t soap_flag_data1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_errors1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "app:applicationId", &(a->app__Application::applicationId), "base:UUID"))
				{	soap_flag_applicationId1--;
					continue;
				}
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__ApplicationStatus(soap, "app:status", &(a->app__Application::status), "app:ApplicationStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_serviceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__Name(soap, "app:serviceId", &(a->app__Application::serviceId), "xsd:Name"))
				{	soap_flag_serviceId1--;
					continue;
				}
			if(soap_flag_issuerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "app:issuerId", &(a->app__Application::issuerId), "base:UUID"))
				{	soap_flag_issuerId1--;
					continue;
				}
			if(soap_flag_issueDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "app:issueDate", &(a->app__Application::issueDate), "xsd:dateTime"))
				{	soap_flag_issueDate1--;
					continue;
				}
			if(soap_flag_rcvDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "app:rcvDate", &(a->app__Application::rcvDate), "xsd:dateTime"))
				{	soap_flag_rcvDate1--;
					continue;
				}
			if(soap_flag_prdcRsltDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "app:prdcRsltDate", &(a->app__Application::prdcRsltDate), "xsd:dateTime"))
				{	soap_flag_prdcRsltDate1--;
					continue;
				}
			if(soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__ApplicationDataWrapper(soap, "app:data", &(a->app__Application::data), "app:ApplicationDataWrapper"))
				{	soap_flag_data1--;
					continue;
				}
			if(soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__ApplicationResultWrapper(soap, "app:result", &(a->app__Application::result), "app:ApplicationResultWrapper"))
				{	soap_flag_result1--;
					continue;
				}
			if(soap_flag_errors1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__BusinessErrorList(soap, "app:errors", &(a->app__Application::errors), "app:BusinessErrorList"))
				{	soap_flag_errors1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (app__Application *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__Application, 0, sizeof(app__Application), 0, soap_copy_app__Application);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int app__Application::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_app__Application);
	return this->soap_out(soap, tag?tag:"app:Application", id, type) ? soap->error : soap_putindependent(soap);
}

void *app__Application::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_app__Application(soap, this, tag, type);
}

SOAP_FMAC3 app__Application * SOAP_FMAC4 soap_get_app__Application(struct soap *soap, app__Application *p, const char *tag, const char *type)
{
	if((p = soap_in_app__Application(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 app__Application * FASTCALL soap_instantiate_app__Application(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_app__Application(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_app__Application, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(app__Application);
		ASSIGN_PTR(size, sizeof(app__Application));
		((app__Application*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(app__Application[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(app__Application));
		for(int i = 0; i < n; i++)
			((app__Application*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (app__Application*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_app__Application(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying app__Application %p -> %p\n", q, p));
	*(app__Application*)p = *(app__Application*)q;
}

void base__Error::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->base__Error::__item);
	soap_default_xsd__NCName(soap, &this->base__Error::code);
	this->base__Error::qualifier = NULL;
	/* transient soap skipped */
}

void base__Error::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->base__Error::__item);
	/* transient soap skipped */
}

int base__Error::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__Error(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__Error(struct soap *soap, const char *tag, int id, const base__Error *a, const char *type)
{
	if(((base__Error*)a)->code)
		soap_set_attr(soap, "code", ((base__Error*)a)->code, 1);
	if(((base__Error*)a)->qualifier)
		if(*((base__Error*)a)->qualifier)
			soap_set_attr(soap, "qualifier", *((base__Error*)a)->qualifier, 1);
	return soap_out_string(soap, tag, id, &a->base__Error::__item, "");
}

void *base__Error::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__Error(soap, tag, this, type);
}

SOAP_FMAC3 base__Error * FASTCALL soap_in_base__Error(struct soap *soap, const char *tag, base__Error *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!(a = (base__Error *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__Error, sizeof(base__Error), soap->type, soap->arrayType))) {
		soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__Error)
			return (base__Error *)a->soap_in(soap, tag, type);
	}
	if(soap_s2string(soap, soap_attr_value(soap, "code", 1), &((base__Error*)a)->code, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "qualifier", 0);
		if(t)
		{
			if(!(((base__Error*)a)->qualifier = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2string(soap, t, ((base__Error*)a)->qualifier, 0, 100))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(!soap_in_string(soap, tag, &(a->base__Error::__item), "base:Error"))
		return NULL;
	return a;
}

int base__Error::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__Error);
	return this->soap_out(soap, tag?tag:"base:Error", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__Error::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__Error(soap, this, tag, type);
}

SOAP_FMAC3 base__Error * SOAP_FMAC4 soap_get_base__Error(struct soap *soap, base__Error *p, const char *tag, const char *type)
{
	if((p = soap_in_base__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__Error * FASTCALL soap_instantiate_base__Error(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__Error(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__Error, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "app:BusinessError")) {
		cp->type = SOAP_TYPE_app__BusinessError;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(app__BusinessError);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(app__BusinessError));
			((app__BusinessError*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(app__BusinessError[n]);
			ASSIGN_PTR(size, n * sizeof(app__BusinessError));
			for(int i = 0; i < n; i++)
				((app__BusinessError*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (app__BusinessError*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__Error);
		ASSIGN_PTR(size, sizeof(base__Error));
		((base__Error*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__Error[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__Error));
		for(int i = 0; i < n; i++)
			((base__Error*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__Error*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__Error(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__Error %p -> %p\n", q, p));
	*(base__Error*)p = *(base__Error*)q;
}

void base__FaultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->base__FaultInfo::message);
	this->base__FaultInfo::__sizeerror = 0;
	this->base__FaultInfo::error = NULL;
	/* transient soap skipped */
}

void base__FaultInfo::soap_serialize(struct soap *soap) const
{
	soap_serialize_string(soap, &this->base__FaultInfo::message);
	if(this->base__FaultInfo::error) {
		for(int i = 0; i < this->base__FaultInfo::__sizeerror; i++) {
			soap_serialize_PointerTobase__Error(soap, this->base__FaultInfo::error + i);
		}
	}
	/* transient soap skipped */
}

int base__FaultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__FaultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__FaultInfo(struct soap *soap, const char *tag, int id, const base__FaultInfo *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__FaultInfo), type))
		return soap->error;
	if(a->base__FaultInfo::message) {
		if(soap_out_string(soap, "base:message", -1, &a->base__FaultInfo::message, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "base:message"))
		return soap->error;
	if(a->base__FaultInfo::error) {
		int i;
		for(i = 0; i < a->base__FaultInfo::__sizeerror; i++)
			if(soap_out_PointerTobase__Error(soap, "base:error", -1, a->base__FaultInfo::error + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__FaultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__FaultInfo(soap, tag, this, type);
}

SOAP_FMAC3 base__FaultInfo * FASTCALL soap_in_base__FaultInfo(struct soap *soap, const char *tag, base__FaultInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__FaultInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__FaultInfo, sizeof(base__FaultInfo), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__FaultInfo) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__FaultInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	struct soap_blist *soap_blist_error1 = NULL;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "base:message", &(a->base__FaultInfo::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "base:error", 1, NULL)) {
				if(a->base__FaultInfo::error == NULL) {
					if(soap_blist_error1 == NULL)
						soap_blist_error1 = soap_new_block(soap);
					a->base__FaultInfo::error = (base__Error **)soap_push_block(soap, soap_blist_error1, sizeof(base__Error *));
					if(a->base__FaultInfo::error == NULL)
						return NULL;
					*a->base__FaultInfo::error = NULL;
				}
				soap_revert(soap);
				if(soap_in_PointerTobase__Error(soap, "base:error", a->base__FaultInfo::error, "base:Error"))
				{	a->base__FaultInfo::__sizeerror++;
					a->base__FaultInfo::error = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(a->base__FaultInfo::error)
			soap_pop_block(soap, soap_blist_error1);
		if(a->base__FaultInfo::__sizeerror)
			a->base__FaultInfo::error = (base__Error **)soap_save_block(soap, soap_blist_error1, NULL, 1);
		else
		{	a->base__FaultInfo::error = NULL;
			if(soap_blist_error1)
				soap_end_block(soap, soap_blist_error1);
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__FaultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__FaultInfo, 0, sizeof(base__FaultInfo), 0, soap_copy_base__FaultInfo);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_message1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int base__FaultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__FaultInfo);
	return this->soap_out(soap, tag?tag:"base:FaultInfo", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__FaultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__FaultInfo(soap, this, tag, type);
}

SOAP_FMAC3 base__FaultInfo * SOAP_FMAC4 soap_get_base__FaultInfo(struct soap *soap, base__FaultInfo *p, const char *tag, const char *type)
{
	if((p = soap_in_base__FaultInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__FaultInfo * FASTCALL soap_instantiate_base__FaultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__FaultInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__FaultInfo, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__FaultInfo);
		ASSIGN_PTR(size, sizeof(base__FaultInfo));
		((base__FaultInfo*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__FaultInfo[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__FaultInfo));
		for(int i = 0; i < n; i++)
			((base__FaultInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__FaultInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__FaultInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__FaultInfo %p -> %p\n", q, p));
	*(base__FaultInfo*)p = *(base__FaultInfo*)q;
}

void base__EntityList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->base__EntityList::count = NULL;
	this->base__EntityList::total = NULL;
	this->base__EntityList::offset = NULL;
	this->base__EntityList::hasMore = NULL;
	/* transient soap skipped */
}

void base__EntityList::soap_serialize(struct soap *soap) const
{
	/* transient soap skipped */
}

int base__EntityList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__EntityList(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__EntityList(struct soap *soap, const char *tag, int id, const base__EntityList *a, const char *type)
{
	if(((base__EntityList*)a)->count)
		soap_set_attr(soap, "count", soap_int2s(soap, *((base__EntityList*)a)->count), 1);
	if(((base__EntityList*)a)->total)
		soap_set_attr(soap, "total", soap_LONG642s(soap, *((base__EntityList*)a)->total), 1);
	if(((base__EntityList*)a)->offset)
		soap_set_attr(soap, "offset", soap_int2s(soap, *((base__EntityList*)a)->offset), 1);
	if(((base__EntityList*)a)->hasMore)
		soap_set_attr(soap, "hasMore", soap_bool2s(soap, *((base__EntityList*)a)->hasMore), 1);
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__EntityList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__EntityList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__EntityList(soap, tag, this, type);
}

SOAP_FMAC3 base__EntityList * FASTCALL soap_in_base__EntityList(struct soap *soap, const char *tag, base__EntityList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__EntityList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__EntityList, sizeof(base__EntityList), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__EntityList) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__EntityList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->count))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "total", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->total = (LONG64 *)soap_malloc(soap, sizeof(LONG64))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2LONG64(soap, t, ((base__EntityList*)a)->total))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "offset", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->offset = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2int(soap, t, ((base__EntityList*)a)->offset))
				return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "hasMore", 0);
		if(t)
		{
			if(!(((base__EntityList*)a)->hasMore = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if(soap_s2bool(soap, t, ((base__EntityList*)a)->hasMore))
			return NULL;
		}
		else if(soap->error)
			return NULL;
	}
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__EntityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__EntityList, 0, sizeof(base__EntityList), 0, soap_copy_base__EntityList);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__EntityList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__EntityList);
	return this->soap_out(soap, tag?tag:"base:EntityList", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__EntityList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__EntityList(soap, this, tag, type);
}

SOAP_FMAC3 base__EntityList * SOAP_FMAC4 soap_get_base__EntityList(struct soap *soap, base__EntityList *p, const char *tag, const char *type)
{
	if((p = soap_in_base__EntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__EntityList * FASTCALL soap_instantiate_base__EntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__EntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__EntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ent:PurposeList")) {
		cp->type = SOAP_TYPE_ent__PurposeList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__PurposeList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__PurposeList));
			((ent__PurposeList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__PurposeList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__PurposeList));
			for(int i = 0; i < n; i++)
				((ent__PurposeList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__PurposeList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:UnitList")) {
		cp->type = SOAP_TYPE_ent__UnitList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__UnitList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__UnitList));
			((ent__UnitList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__UnitList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__UnitList));
			for(int i = 0; i < n; i++)
				((ent__UnitList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__UnitList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:CountryList")) {
		cp->type = SOAP_TYPE_ent__CountryList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__CountryList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__CountryList));
			((ent__CountryList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__CountryList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__CountryList));
			for(int i = 0; i < n; i++)
				((ent__CountryList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__CountryList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionList")) {
		cp->type = SOAP_TYPE_ent__RegionList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionList));
			((ent__RegionList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionList));
			for(int i = 0; i < n; i++)
				((ent__RegionList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:DistrictList")) {
		cp->type = SOAP_TYPE_ent__DistrictList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__DistrictList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__DistrictList));
			((ent__DistrictList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__DistrictList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__DistrictList));
			for(int i = 0; i < n; i++)
				((ent__DistrictList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__DistrictList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:LocalityList")) {
		cp->type = SOAP_TYPE_ent__LocalityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__LocalityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__LocalityList));
			((ent__LocalityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__LocalityList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__LocalityList));
			for(int i = 0; i < n; i++)
				((ent__LocalityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__LocalityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:StreetList")) {
		cp->type = SOAP_TYPE_ent__StreetList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__StreetList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__StreetList));
			((ent__StreetList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__StreetList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__StreetList));
			for(int i = 0; i < n; i++)
				((ent__StreetList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__StreetList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:EnterpriseActivityList")) {
		cp->type = SOAP_TYPE_ent__EnterpriseActivityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__EnterpriseActivityList));
			((ent__EnterpriseActivityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivityList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__EnterpriseActivityList));
			for(int i = 0; i < n; i++)
				((ent__EnterpriseActivityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__EnterpriseActivityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:EnterpriseList")) {
		cp->type = SOAP_TYPE_ent__EnterpriseList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__EnterpriseList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__EnterpriseList));
			((ent__EnterpriseList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__EnterpriseList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__EnterpriseList));
			for(int i = 0; i < n; i++)
				((ent__EnterpriseList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__EnterpriseList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:BusinessEntityList")) {
		cp->type = SOAP_TYPE_ent__BusinessEntityList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__BusinessEntityList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__BusinessEntityList));
			((ent__BusinessEntityList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__BusinessEntityList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__BusinessEntityList));
			for(int i = 0; i < n; i++)
				((ent__BusinessEntityList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__BusinessEntityList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ProductList")) {
		cp->type = SOAP_TYPE_ent__ProductList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ProductList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ProductList));
			((ent__ProductList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ProductList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ProductList));
			for(int i = 0; i < n; i++)
				((ent__ProductList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ProductList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:SubProductList")) {
		cp->type = SOAP_TYPE_ent__SubProductList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__SubProductList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__SubProductList));
			((ent__SubProductList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__SubProductList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__SubProductList));
			for(int i = 0; i < n; i++)
				((ent__SubProductList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__SubProductList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ProductItemList")) {
		cp->type = SOAP_TYPE_ent__ProductItemList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ProductItemList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ProductItemList));
			((ent__ProductItemList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ProductItemList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ProductItemList));
			for(int i = 0; i < n; i++)
				((ent__ProductItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ProductItemList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationConditionList")) {
		cp->type = SOAP_TYPE_ent__RegionalizationConditionList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationConditionList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationConditionList));
			((ent__RegionalizationConditionList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationConditionList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationConditionList));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationConditionList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationConditionList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationRegionStatusList")) {
		cp->type = SOAP_TYPE_ent__RegionalizationRegionStatusList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatusList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationRegionStatusList));
			((ent__RegionalizationRegionStatusList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatusList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationRegionStatusList));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationRegionStatusList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationRegionStatusList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationShippingRuleList")) {
		cp->type = SOAP_TYPE_ent__RegionalizationShippingRuleList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRuleList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationShippingRuleList));
			((ent__RegionalizationShippingRuleList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRuleList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationShippingRuleList));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationShippingRuleList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationShippingRuleList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:AnimalDiseaseList")) {
		cp->type = SOAP_TYPE_ent__AnimalDiseaseList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__AnimalDiseaseList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__AnimalDiseaseList));
			((ent__AnimalDiseaseList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__AnimalDiseaseList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__AnimalDiseaseList));
			for(int i = 0; i < n; i++)
				((ent__AnimalDiseaseList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__AnimalDiseaseList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ResearchMethodList")) {
		cp->type = SOAP_TYPE_ent__ResearchMethodList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ResearchMethodList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ResearchMethodList));
			((ent__ResearchMethodList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ResearchMethodList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ResearchMethodList));
			for(int i = 0; i < n; i++)
				((ent__ResearchMethodList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ResearchMethodList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ActivityLocationList")) {
		cp->type = SOAP_TYPE_ent__ActivityLocationList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ActivityLocationList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ActivityLocationList));
			((ent__ActivityLocationList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ActivityLocationList[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ActivityLocationList));
			for(int i = 0; i < n; i++)
				((ent__ActivityLocationList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ActivityLocationList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:VetDocumentList")) {
		cp->type = SOAP_TYPE_vd__VetDocumentList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__VetDocumentList));
			((vd__VetDocumentList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__VetDocumentList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__VetDocumentList));
			for(int i = 0; i < n; i++)
				((vd__VetDocumentList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__VetDocumentList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntryList")) {
		cp->type = SOAP_TYPE_vd__StockEntryList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntryList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntryList));
			((vd__StockEntryList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntryList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntryList));
			for(int i = 0; i < n; i++)
				((vd__StockEntryList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntryList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:UserList")) {
		cp->type = SOAP_TYPE_vd__UserList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__UserList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__UserList));
			((vd__UserList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__UserList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__UserList));
			for(int i = 0; i < n; i++)
				((vd__UserList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__UserList*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:WorkingAreaList")) {
		cp->type = SOAP_TYPE_vd__WorkingAreaList;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__WorkingAreaList));
			((vd__WorkingAreaList*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__WorkingAreaList[n]);
			ASSIGN_PTR(size, n * sizeof(vd__WorkingAreaList));
			for(int i = 0; i < n; i++)
				((vd__WorkingAreaList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__WorkingAreaList*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__EntityList);
		ASSIGN_PTR(size, sizeof(base__EntityList));
		((base__EntityList*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__EntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__EntityList));
		for(int i = 0; i < n; i++)
			((base__EntityList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__EntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__EntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__EntityList %p -> %p\n", q, p));
	*(base__EntityList*)p = *(base__EntityList*)q;
}

void base__DateInterval::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->base__DateInterval::beginDate = NULL;
	this->base__DateInterval::endDate = NULL;
	/* transient soap skipped */
}

void base__DateInterval::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerTotime(soap, &this->base__DateInterval::beginDate);
	soap_serialize_PointerTotime(soap, &this->base__DateInterval::endDate);
	/* transient soap skipped */
}

int base__DateInterval::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__DateInterval(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__DateInterval(struct soap *soap, const char *tag, int id, const base__DateInterval *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__DateInterval), type))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:beginDate", -1, &(a->base__DateInterval::beginDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:endDate", -1, &(a->base__DateInterval::endDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__DateInterval::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__DateInterval(soap, tag, this, type);
}

SOAP_FMAC3 base__DateInterval * FASTCALL soap_in_base__DateInterval(struct soap *soap, const char *tag, base__DateInterval *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__DateInterval *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__DateInterval, sizeof(base__DateInterval), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__DateInterval) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__DateInterval *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_beginDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_beginDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:beginDate", &(a->base__DateInterval::beginDate), "xsd:dateTime"))
				{	soap_flag_beginDate1--;
					continue;
				}
			if(soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:endDate", &(a->base__DateInterval::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__DateInterval *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__DateInterval, 0, sizeof(base__DateInterval), 0, soap_copy_base__DateInterval);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__DateInterval::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__DateInterval);
	return this->soap_out(soap, tag?tag:"base:DateInterval", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__DateInterval::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__DateInterval(soap, this, tag, type);
}

SOAP_FMAC3 base__DateInterval * SOAP_FMAC4 soap_get_base__DateInterval(struct soap *soap, base__DateInterval *p, const char *tag, const char *type)
{
	if((p = soap_in_base__DateInterval(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__DateInterval * FASTCALL soap_instantiate_base__DateInterval(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__DateInterval(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__DateInterval, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__DateInterval);
		ASSIGN_PTR(size, sizeof(base__DateInterval));
		((base__DateInterval*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__DateInterval[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__DateInterval));
		for(int i = 0; i < n; i++)
			((base__DateInterval*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__DateInterval*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__DateInterval(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__DateInterval %p -> %p\n", q, p));
	*(base__DateInterval*)p = *(base__DateInterval*)q;
}

void base__ListOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->base__ListOptions::count);
	soap_default_xsd__nonNegativeInteger(soap, &this->base__ListOptions::offset);
	/* transient soap skipped */
}

void base__ListOptions::soap_serialize(struct soap *soap) const
{
	soap_serialize_xsd__nonNegativeInteger(soap, &this->base__ListOptions::count);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->base__ListOptions::offset);
	/* transient soap skipped */
}

int base__ListOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__ListOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__ListOptions(struct soap *soap, const char *tag, int id, const base__ListOptions *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__ListOptions), type))
		return soap->error;
	if(soap_out_xsd__nonNegativeInteger(soap, "base:count", -1, &(a->base__ListOptions::count), ""))
		return soap->error;
	if(soap_out_xsd__nonNegativeInteger(soap, "base:offset", -1, &(a->base__ListOptions::offset), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__ListOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__ListOptions(soap, tag, this, type);
}

SOAP_FMAC3 base__ListOptions * FASTCALL soap_in_base__ListOptions(struct soap *soap, const char *tag, base__ListOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__ListOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__ListOptions, sizeof(base__ListOptions), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__ListOptions) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__ListOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_count1 = 1;
	size_t soap_flag_offset1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__nonNegativeInteger(soap, "base:count", &(a->base__ListOptions::count), "xsd:nonNegativeInteger"))
				{	soap_flag_count1--;
					continue;
				}
			if(soap_flag_offset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_xsd__nonNegativeInteger(soap, "base:offset", &(a->base__ListOptions::offset), "xsd:nonNegativeInteger"))
				{	soap_flag_offset1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__ListOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__ListOptions, 0, sizeof(base__ListOptions), 0, soap_copy_base__ListOptions);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__ListOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__ListOptions);
	return this->soap_out(soap, tag?tag:"base:ListOptions", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__ListOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__ListOptions(soap, this, tag, type);
}

SOAP_FMAC3 base__ListOptions * SOAP_FMAC4 soap_get_base__ListOptions(struct soap *soap, base__ListOptions *p, const char *tag, const char *type)
{
	if((p = soap_in_base__ListOptions(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__ListOptions * FASTCALL soap_instantiate_base__ListOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__ListOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__ListOptions, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__ListOptions);
		ASSIGN_PTR(size, sizeof(base__ListOptions));
		((base__ListOptions*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__ListOptions[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__ListOptions));
		for(int i = 0; i < n; i++)
			((base__ListOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__ListOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__ListOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__ListOptions %p -> %p\n", q, p));
	*(base__ListOptions*)p = *(base__ListOptions*)q;
}

void base__GenericVersioningEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	this->base__GenericVersioningEntity::active = NULL;
	this->base__GenericVersioningEntity::last = NULL;
	this->base__GenericVersioningEntity::status = NULL;
	this->base__GenericVersioningEntity::createDate = NULL;
	this->base__GenericVersioningEntity::updateDate = NULL;
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_default_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void base__GenericVersioningEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::guid);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::active);
	soap_serialize_PointerTobool(soap, &this->base__GenericVersioningEntity::last);
	soap_serialize_PointerTobase__VersionStatus(soap, &this->base__GenericVersioningEntity::status);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::createDate);
	soap_serialize_PointerTotime(soap, &this->base__GenericVersioningEntity::updateDate);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::previous);
	soap_serialize_base__UUID(soap, &this->base__GenericVersioningEntity::next);
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int base__GenericVersioningEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__GenericVersioningEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__GenericVersioningEntity(struct soap *soap, const char *tag, int id, const base__GenericVersioningEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__GenericVersioningEntity), "base:GenericVersioningEntity"))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if(soap_out_base__UUID(soap, "base:guid", -1, &(a->base__GenericVersioningEntity::guid), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:active", -1, &(a->base__GenericVersioningEntity::active), ""))
		return soap->error;
	if(soap_out_PointerTobool(soap, "base:last", -1, &(a->base__GenericVersioningEntity::last), ""))
		return soap->error;
	if(soap_out_PointerTobase__VersionStatus(soap, "base:status", -1, &(a->base__GenericVersioningEntity::status), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:createDate", -1, &(a->base__GenericVersioningEntity::createDate), ""))
		return soap->error;
	if(soap_out_PointerTotime(soap, "base:updateDate", -1, &(a->base__GenericVersioningEntity::updateDate), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:previous", -1, &(a->base__GenericVersioningEntity::previous), ""))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:next", -1, &(a->base__GenericVersioningEntity::next), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *base__GenericVersioningEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__GenericVersioningEntity(soap, tag, this, type);
}

SOAP_FMAC3 base__GenericVersioningEntity * FASTCALL soap_in_base__GenericVersioningEntity(struct soap *soap, const char *tag, base__GenericVersioningEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__GenericVersioningEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__GenericVersioningEntity, sizeof(base__GenericVersioningEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__GenericVersioningEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__GenericVersioningEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_guid1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_last1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_createDate1 = 1;
	size_t soap_flag_updateDate1 = 1;
	size_t soap_flag_previous1 = 1;
	size_t soap_flag_next1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if(soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:guid", &(a->base__GenericVersioningEntity::guid), "base:UUID"))
				{	soap_flag_guid1--;
					continue;
				}
			if(soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:active", &(a->base__GenericVersioningEntity::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if(soap_flag_last1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobool(soap, "base:last", &(a->base__GenericVersioningEntity::last), "xsd:boolean"))
				{	soap_flag_last1--;
					continue;
				}
			if(soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__VersionStatus(soap, "base:status", &(a->base__GenericVersioningEntity::status), "base:VersionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if(soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:createDate", &(a->base__GenericVersioningEntity::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if(soap_flag_updateDate1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTotime(soap, "base:updateDate", &(a->base__GenericVersioningEntity::updateDate), "xsd:dateTime"))
				{	soap_flag_updateDate1--;
					continue;
				}
			if(soap_flag_previous1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:previous", &(a->base__GenericVersioningEntity::previous), "base:UUID"))
				{	soap_flag_previous1--;
					continue;
				}
			if(soap_flag_next1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:next", &(a->base__GenericVersioningEntity::next), "base:UUID"))
				{	soap_flag_next1--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__GenericVersioningEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__GenericVersioningEntity, 0, sizeof(base__GenericVersioningEntity), 0, soap_copy_base__GenericVersioningEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__GenericVersioningEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__GenericVersioningEntity);
	return this->soap_out(soap, tag?tag:"base:GenericVersioningEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__GenericVersioningEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__GenericVersioningEntity(soap, this, tag, type);
}

SOAP_FMAC3 base__GenericVersioningEntity * SOAP_FMAC4 soap_get_base__GenericVersioningEntity(struct soap *soap, base__GenericVersioningEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_base__GenericVersioningEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__GenericVersioningEntity * FASTCALL soap_instantiate_base__GenericVersioningEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__GenericVersioningEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__GenericVersioningEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "ent:Purpose")) {
		cp->type = SOAP_TYPE_ent__Purpose;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Purpose);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Purpose));
			((ent__Purpose*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Purpose[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Purpose));
			for(int i = 0; i < n; i++)
				((ent__Purpose*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Purpose*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Unit")) {
		cp->type = SOAP_TYPE_ent__Unit;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Unit);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Unit));
			((ent__Unit*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Unit[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Unit));
			for(int i = 0; i < n; i++)
				((ent__Unit*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Unit*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:PackingType")) {
		cp->type = SOAP_TYPE_ent__PackingType;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__PackingType);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__PackingType));
			((ent__PackingType*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__PackingType[n]);
			ASSIGN_PTR(size, n * sizeof(ent__PackingType));
			for(int i = 0; i < n; i++)
				((ent__PackingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__PackingType*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Country")) {
		cp->type = SOAP_TYPE_ent__Country;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Country);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Country));
			((ent__Country*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Country[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Country));
			for(int i = 0; i < n; i++)
				((ent__Country*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Country*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:FederalDistrict")) {
		cp->type = SOAP_TYPE_ent__FederalDistrict;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__FederalDistrict);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__FederalDistrict));
			((ent__FederalDistrict*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__FederalDistrict[n]);
			ASSIGN_PTR(size, n * sizeof(ent__FederalDistrict));
			for(int i = 0; i < n; i++)
				((ent__FederalDistrict*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__FederalDistrict*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:AddressObjectView")) {
		cp->type = SOAP_TYPE_ent__AddressObjectView;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__AddressObjectView);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__AddressObjectView));
			((ent__AddressObjectView*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__AddressObjectView[n]);
			ASSIGN_PTR(size, n * sizeof(ent__AddressObjectView));
			for(int i = 0; i < n; i++)
				((ent__AddressObjectView*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__AddressObjectView*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Enterprise")) {
		cp->type = SOAP_TYPE_ent__Enterprise;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Enterprise);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Enterprise));
			((ent__Enterprise*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Enterprise[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Enterprise));
			for(int i = 0; i < n; i++)
				((ent__Enterprise*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Enterprise*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:BusinessEntity")) {
		cp->type = SOAP_TYPE_ent__BusinessEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__BusinessEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__BusinessEntity));
			((ent__BusinessEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__BusinessEntity[n]);
			ASSIGN_PTR(size, n * sizeof(ent__BusinessEntity));
			for(int i = 0; i < n; i++)
				((ent__BusinessEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__BusinessEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ProductItem")) {
		cp->type = SOAP_TYPE_ent__ProductItem;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ProductItem);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ProductItem));
			((ent__ProductItem*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ProductItem[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ProductItem));
			for(int i = 0; i < n; i++)
				((ent__ProductItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ProductItem*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Product")) {
		cp->type = SOAP_TYPE_ent__Product;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Product);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Product));
			((ent__Product*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Product[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Product));
			for(int i = 0; i < n; i++)
				((ent__Product*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Product*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:SubProduct")) {
		cp->type = SOAP_TYPE_ent__SubProduct;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__SubProduct);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__SubProduct));
			((ent__SubProduct*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__SubProduct[n]);
			ASSIGN_PTR(size, n * sizeof(ent__SubProduct));
			for(int i = 0; i < n; i++)
				((ent__SubProduct*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__SubProduct*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Indicator")) {
		cp->type = SOAP_TYPE_ent__Indicator;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Indicator);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Indicator));
			((ent__Indicator*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Indicator[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Indicator));
			for(int i = 0; i < n; i++)
				((ent__Indicator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Indicator*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:AnimalDisease")) {
		cp->type = SOAP_TYPE_ent__AnimalDisease;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__AnimalDisease);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__AnimalDisease));
			((ent__AnimalDisease*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__AnimalDisease[n]);
			ASSIGN_PTR(size, n * sizeof(ent__AnimalDisease));
			for(int i = 0; i < n; i++)
				((ent__AnimalDisease*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__AnimalDisease*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ResearchMethod")) {
		cp->type = SOAP_TYPE_ent__ResearchMethod;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ResearchMethod);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ResearchMethod));
			((ent__ResearchMethod*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ResearchMethod[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ResearchMethod));
			for(int i = 0; i < n; i++)
				((ent__ResearchMethod*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ResearchMethod*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationCondition")) {
		cp->type = SOAP_TYPE_ent__RegionalizationCondition;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationCondition);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationCondition));
			((ent__RegionalizationCondition*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationCondition[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationCondition));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationCondition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationCondition*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationShippingRule")) {
		cp->type = SOAP_TYPE_ent__RegionalizationShippingRule;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRule);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationShippingRule));
			((ent__RegionalizationShippingRule*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRule[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationShippingRule));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationShippingRule*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationRegionStatus")) {
		cp->type = SOAP_TYPE_ent__RegionalizationRegionStatus;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatus);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationRegionStatus));
			((ent__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatus[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationRegionStatus));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationRegionStatus*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntry")) {
		cp->type = SOAP_TYPE_vd__StockEntry;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntry);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntry));
			((vd__StockEntry*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntry[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntry));
			for(int i = 0; i < n; i++)
				((vd__StockEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntry*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Region")) {
		cp->type = SOAP_TYPE_ent__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Region));
			((ent__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Region[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Region));
			for(int i = 0; i < n; i++)
				((ent__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:District")) {
		cp->type = SOAP_TYPE_ent__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__District));
			((ent__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__District[n]);
			ASSIGN_PTR(size, n * sizeof(ent__District));
			for(int i = 0; i < n; i++)
				((ent__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Locality")) {
		cp->type = SOAP_TYPE_ent__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Locality));
			((ent__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Locality));
			for(int i = 0; i < n; i++)
				((ent__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Street")) {
		cp->type = SOAP_TYPE_ent__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Street));
			((ent__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Street[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Street));
			for(int i = 0; i < n; i++)
				((ent__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Street*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_vd__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
			((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity);
		ASSIGN_PTR(size, sizeof(base__GenericVersioningEntity));
		((base__GenericVersioningEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__GenericVersioningEntity));
		for(int i = 0; i < n; i++)
			((base__GenericVersioningEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__GenericVersioningEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__GenericVersioningEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__GenericVersioningEntity %p -> %p\n", q, p));
	*(base__GenericVersioningEntity*)p = *(base__GenericVersioningEntity*)q;
}

void base__GenericEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

void base__GenericEntity::soap_serialize(struct soap *soap) const
{
	soap_serialize_base__UUID(soap, &this->base__GenericEntity::uuid);
	/* transient soap skipped */
}

int base__GenericEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_base__GenericEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_base__GenericEntity(struct soap *soap, const char *tag, int id, const base__GenericEntity *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_base__GenericEntity), type))
		return soap->error;
	if(soap_out_base__UUID(soap, "base:uuid", -1, &(a->base__GenericEntity::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *base__GenericEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_base__GenericEntity(soap, tag, this, type);
}

SOAP_FMAC3 base__GenericEntity * FASTCALL soap_in_base__GenericEntity(struct soap *soap, const char *tag, base__GenericEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (base__GenericEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_base__GenericEntity, sizeof(base__GenericEntity), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE_base__GenericEntity) {
			soap_revert(soap);
			*soap->id = '\0';
			return (base__GenericEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "base:uuid", &(a->base__GenericEntity::uuid), "base:UUID"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (base__GenericEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_base__GenericEntity, 0, sizeof(base__GenericEntity), 0, soap_copy_base__GenericEntity);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int base__GenericEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_base__GenericEntity);
	return this->soap_out(soap, tag?tag:"base:GenericEntity", id, type) ? soap->error : soap_putindependent(soap);
}

void *base__GenericEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_base__GenericEntity(soap, this, tag, type);
}

SOAP_FMAC3 base__GenericEntity * SOAP_FMAC4 soap_get_base__GenericEntity(struct soap *soap, base__GenericEntity *p, const char *tag, const char *type)
{
	if((p = soap_in_base__GenericEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 base__GenericEntity * FASTCALL soap_instantiate_base__GenericEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_base__GenericEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_base__GenericEntity, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(type && !soap_match_tag(soap, type, "base:GenericVersioningEntity")) {
		cp->type = SOAP_TYPE_base__GenericVersioningEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(base__GenericVersioningEntity));
			((base__GenericVersioningEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(base__GenericVersioningEntity[n]);
			ASSIGN_PTR(size, n * sizeof(base__GenericVersioningEntity));
			for(int i = 0; i < n; i++)
				((base__GenericVersioningEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (base__GenericVersioningEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:EnterpriseActivity")) {
		cp->type = SOAP_TYPE_ent__EnterpriseActivity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__EnterpriseActivity));
			((ent__EnterpriseActivity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__EnterpriseActivity[n]);
			ASSIGN_PTR(size, n * sizeof(ent__EnterpriseActivity));
			for(int i = 0; i < n; i++)
				((ent__EnterpriseActivity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__EnterpriseActivity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:IncorporationForm")) {
		cp->type = SOAP_TYPE_ent__IncorporationForm;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__IncorporationForm);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__IncorporationForm));
			((ent__IncorporationForm*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__IncorporationForm[n]);
			ASSIGN_PTR(size, n * sizeof(ent__IncorporationForm));
			for(int i = 0; i < n; i++)
				((ent__IncorporationForm*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__IncorporationForm*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Delivery")) {
		cp->type = SOAP_TYPE_vd__Delivery;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Delivery);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Delivery));
			((vd__Delivery*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Delivery[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Delivery));
			for(int i = 0; i < n; i++)
				((vd__Delivery*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Delivery*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:DiscrepancyReason")) {
		cp->type = SOAP_TYPE_vd__DiscrepancyReason;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__DiscrepancyReason));
			((vd__DiscrepancyReason*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReason[n]);
			ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReason));
			for(int i = 0; i < n; i++)
				((vd__DiscrepancyReason*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__DiscrepancyReason*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Document")) {
		cp->type = SOAP_TYPE_vd__Document;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Document);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Document));
			((vd__Document*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Document[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Document));
			for(int i = 0; i < n; i++)
				((vd__Document*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Document*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ShipmentRoutePoint")) {
		cp->type = SOAP_TYPE_vd__ShipmentRoutePoint;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ShipmentRoutePoint));
			((vd__ShipmentRoutePoint*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ShipmentRoutePoint[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ShipmentRoutePoint));
			for(int i = 0; i < n; i++)
				((vd__ShipmentRoutePoint*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ShipmentRoutePoint*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:User")) {
		cp->type = SOAP_TYPE_vd__User;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__User);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__User));
			((vd__User*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__User[n]);
			ASSIGN_PTR(size, n * sizeof(vd__User));
			for(int i = 0; i < n; i++)
				((vd__User*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__User*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Purpose")) {
		cp->type = SOAP_TYPE_ent__Purpose;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Purpose);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Purpose));
			((ent__Purpose*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Purpose[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Purpose));
			for(int i = 0; i < n; i++)
				((ent__Purpose*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Purpose*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Unit")) {
		cp->type = SOAP_TYPE_ent__Unit;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Unit);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Unit));
			((ent__Unit*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Unit[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Unit));
			for(int i = 0; i < n; i++)
				((ent__Unit*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Unit*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:PackingType")) {
		cp->type = SOAP_TYPE_ent__PackingType;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__PackingType);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__PackingType));
			((ent__PackingType*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__PackingType[n]);
			ASSIGN_PTR(size, n * sizeof(ent__PackingType));
			for(int i = 0; i < n; i++)
				((ent__PackingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__PackingType*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Country")) {
		cp->type = SOAP_TYPE_ent__Country;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Country);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Country));
			((ent__Country*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Country[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Country));
			for(int i = 0; i < n; i++)
				((ent__Country*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Country*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:FederalDistrict")) {
		cp->type = SOAP_TYPE_ent__FederalDistrict;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__FederalDistrict);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__FederalDistrict));
			((ent__FederalDistrict*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__FederalDistrict[n]);
			ASSIGN_PTR(size, n * sizeof(ent__FederalDistrict));
			for(int i = 0; i < n; i++)
				((ent__FederalDistrict*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__FederalDistrict*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:AddressObjectView")) {
		cp->type = SOAP_TYPE_ent__AddressObjectView;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__AddressObjectView);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__AddressObjectView));
			((ent__AddressObjectView*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__AddressObjectView[n]);
			ASSIGN_PTR(size, n * sizeof(ent__AddressObjectView));
			for(int i = 0; i < n; i++)
				((ent__AddressObjectView*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__AddressObjectView*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Enterprise")) {
		cp->type = SOAP_TYPE_ent__Enterprise;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Enterprise);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Enterprise));
			((ent__Enterprise*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Enterprise[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Enterprise));
			for(int i = 0; i < n; i++)
				((ent__Enterprise*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Enterprise*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:BusinessEntity")) {
		cp->type = SOAP_TYPE_ent__BusinessEntity;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__BusinessEntity);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__BusinessEntity));
			((ent__BusinessEntity*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__BusinessEntity[n]);
			ASSIGN_PTR(size, n * sizeof(ent__BusinessEntity));
			for(int i = 0; i < n; i++)
				((ent__BusinessEntity*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__BusinessEntity*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ProductItem")) {
		cp->type = SOAP_TYPE_ent__ProductItem;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ProductItem);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ProductItem));
			((ent__ProductItem*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ProductItem[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ProductItem));
			for(int i = 0; i < n; i++)
				((ent__ProductItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ProductItem*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Product")) {
		cp->type = SOAP_TYPE_ent__Product;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Product);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Product));
			((ent__Product*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Product[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Product));
			for(int i = 0; i < n; i++)
				((ent__Product*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Product*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:SubProduct")) {
		cp->type = SOAP_TYPE_ent__SubProduct;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__SubProduct);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__SubProduct));
			((ent__SubProduct*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__SubProduct[n]);
			ASSIGN_PTR(size, n * sizeof(ent__SubProduct));
			for(int i = 0; i < n; i++)
				((ent__SubProduct*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__SubProduct*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Indicator")) {
		cp->type = SOAP_TYPE_ent__Indicator;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Indicator);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Indicator));
			((ent__Indicator*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Indicator[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Indicator));
			for(int i = 0; i < n; i++)
				((ent__Indicator*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Indicator*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:AnimalDisease")) {
		cp->type = SOAP_TYPE_ent__AnimalDisease;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__AnimalDisease);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__AnimalDisease));
			((ent__AnimalDisease*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__AnimalDisease[n]);
			ASSIGN_PTR(size, n * sizeof(ent__AnimalDisease));
			for(int i = 0; i < n; i++)
				((ent__AnimalDisease*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__AnimalDisease*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:ResearchMethod")) {
		cp->type = SOAP_TYPE_ent__ResearchMethod;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__ResearchMethod);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__ResearchMethod));
			((ent__ResearchMethod*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__ResearchMethod[n]);
			ASSIGN_PTR(size, n * sizeof(ent__ResearchMethod));
			for(int i = 0; i < n; i++)
				((ent__ResearchMethod*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__ResearchMethod*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationCondition")) {
		cp->type = SOAP_TYPE_ent__RegionalizationCondition;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationCondition);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationCondition));
			((ent__RegionalizationCondition*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationCondition[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationCondition));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationCondition*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationCondition*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationShippingRule")) {
		cp->type = SOAP_TYPE_ent__RegionalizationShippingRule;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRule);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationShippingRule));
			((ent__RegionalizationShippingRule*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationShippingRule[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationShippingRule));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationShippingRule*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationShippingRule*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:RegionalizationRegionStatus")) {
		cp->type = SOAP_TYPE_ent__RegionalizationRegionStatus;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatus);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__RegionalizationRegionStatus));
			((ent__RegionalizationRegionStatus*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__RegionalizationRegionStatus[n]);
			ASSIGN_PTR(size, n * sizeof(ent__RegionalizationRegionStatus));
			for(int i = 0; i < n; i++)
				((ent__RegionalizationRegionStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__RegionalizationRegionStatus*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:VetDocument")) {
		cp->type = SOAP_TYPE_vd__VetDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__VetDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__VetDocument));
			((vd__VetDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__VetDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__VetDocument));
			for(int i = 0; i < n; i++)
				((vd__VetDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__VetDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:DiscrepancyReport")) {
		cp->type = SOAP_TYPE_vd__DiscrepancyReport;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__DiscrepancyReport));
			((vd__DiscrepancyReport*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__DiscrepancyReport[n]);
			ASSIGN_PTR(size, n * sizeof(vd__DiscrepancyReport));
			for(int i = 0; i < n; i++)
				((vd__DiscrepancyReport*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__DiscrepancyReport*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntry")) {
		cp->type = SOAP_TYPE_vd__StockEntry;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntry);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntry));
			((vd__StockEntry*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntry[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntry));
			for(int i = 0; i < n; i++)
				((vd__StockEntry*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntry*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:Waybill")) {
		cp->type = SOAP_TYPE_vd__Waybill;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__Waybill);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__Waybill));
			((vd__Waybill*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__Waybill[n]);
			ASSIGN_PTR(size, n * sizeof(vd__Waybill));
			for(int i = 0; i < n; i++)
				((vd__Waybill*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__Waybill*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:ReferencedDocument")) {
		cp->type = SOAP_TYPE_vd__ReferencedDocument;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__ReferencedDocument));
			((vd__ReferencedDocument*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__ReferencedDocument[n]);
			ASSIGN_PTR(size, n * sizeof(vd__ReferencedDocument));
			for(int i = 0; i < n; i++)
				((vd__ReferencedDocument*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__ReferencedDocument*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Region")) {
		cp->type = SOAP_TYPE_ent__Region;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Region);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Region));
			((ent__Region*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Region[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Region));
			for(int i = 0; i < n; i++)
				((ent__Region*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Region*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:District")) {
		cp->type = SOAP_TYPE_ent__District;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__District);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__District));
			((ent__District*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__District[n]);
			ASSIGN_PTR(size, n * sizeof(ent__District));
			for(int i = 0; i < n; i++)
				((ent__District*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__District*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Locality")) {
		cp->type = SOAP_TYPE_ent__Locality;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Locality);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Locality));
			((ent__Locality*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Locality[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Locality));
			for(int i = 0; i < n; i++)
				((ent__Locality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Locality*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "ent:Street")) {
		cp->type = SOAP_TYPE_ent__Street;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(ent__Street);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(ent__Street));
			((ent__Street*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(ent__Street[n]);
			ASSIGN_PTR(size, n * sizeof(ent__Street));
			for(int i = 0; i < n; i++)
				((ent__Street*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ent__Street*)cp->ptr;
	}
	if(type && !soap_match_tag(soap, type, "vd:StockEntrySearchPattern")) {
		cp->type = SOAP_TYPE_vd__StockEntrySearchPattern;
		if(n < 0) {			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern);
			if(!cp->ptr) {
				soap->error = SOAP_EOM;
				return NULL;
			}
			ASSIGN_PTR(size, sizeof(vd__StockEntrySearchPattern));
			((vd__StockEntrySearchPattern*)cp->ptr)->soap = soap;
		}
		else {
			cp->ptr = (void*)SOAP_NEW(vd__StockEntrySearchPattern[n]);
			ASSIGN_PTR(size, n * sizeof(vd__StockEntrySearchPattern));
			for(int i = 0; i < n; i++)
				((vd__StockEntrySearchPattern*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (vd__StockEntrySearchPattern*)cp->ptr;
	}
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(base__GenericEntity);
		ASSIGN_PTR(size, sizeof(base__GenericEntity));
		((base__GenericEntity*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(base__GenericEntity[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(base__GenericEntity));
		for(int i = 0; i < n; i++)
			((base__GenericEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (base__GenericEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_base__GenericEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying base__GenericEntity %p -> %p\n", q, p));
	*(base__GenericEntity*)p = *(base__GenericEntity*)q;
}

void _ws__receiveApplicationResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ws__receiveApplicationResultResponse::app__application = NULL;
	/* transient soap skipped */
}

void _ws__receiveApplicationResultResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToapp__Application(soap, &this->_ws__receiveApplicationResultResponse::app__application);
	/* transient soap skipped */
}

int _ws__receiveApplicationResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__receiveApplicationResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, int id, const _ws__receiveApplicationResultResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__receiveApplicationResultResponse), type))
		return soap->error;
	if(a->app__application)
		soap_element_result(soap, "app:application");
	if(a->_ws__receiveApplicationResultResponse::app__application) {
		if(soap_out_PointerToapp__Application(soap, "app:application", -1, &a->_ws__receiveApplicationResultResponse::app__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "app:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__receiveApplicationResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__receiveApplicationResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse * FASTCALL soap_in__ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, _ws__receiveApplicationResultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__receiveApplicationResultResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__receiveApplicationResultResponse, sizeof(_ws__receiveApplicationResultResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__receiveApplicationResultResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__receiveApplicationResultResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_app__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_app__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__Application(soap, "app:application", &(a->_ws__receiveApplicationResultResponse::app__application), "app:Application"))
				{	soap_flag_app__application1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "app:application");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__receiveApplicationResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__receiveApplicationResultResponse, 0, sizeof(_ws__receiveApplicationResultResponse), 0, soap_copy__ws__receiveApplicationResultResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_app__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__receiveApplicationResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__receiveApplicationResultResponse);
	return this->soap_out(soap, tag?tag:"ws:receiveApplicationResultResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__receiveApplicationResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__receiveApplicationResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse * SOAP_FMAC4 soap_get__ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__receiveApplicationResultResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__receiveApplicationResultResponse * FASTCALL soap_instantiate__ws__receiveApplicationResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__receiveApplicationResultResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__receiveApplicationResultResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultResponse);
		ASSIGN_PTR(size, sizeof(_ws__receiveApplicationResultResponse));
		((_ws__receiveApplicationResultResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__receiveApplicationResultResponse));
		for(int i = 0; i < n; i++)
			((_ws__receiveApplicationResultResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__receiveApplicationResultResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__receiveApplicationResultResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__receiveApplicationResultResponse %p -> %p\n", q, p));
	*(_ws__receiveApplicationResultResponse*)p = *(_ws__receiveApplicationResultResponse*)q;
}

void _ws__receiveApplicationResultRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_app__APIKey(soap, &this->_ws__receiveApplicationResultRequest::apiKey);
	soap_default_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::issuerId);
	soap_default_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::applicationId);
	/* transient soap skipped */
}

void _ws__receiveApplicationResultRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_app__APIKey(soap, &this->_ws__receiveApplicationResultRequest::apiKey);
	soap_serialize_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::issuerId);
	soap_serialize_base__UUID(soap, &this->_ws__receiveApplicationResultRequest::applicationId);
	/* transient soap skipped */
}

int _ws__receiveApplicationResultRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__receiveApplicationResultRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, int id, const _ws__receiveApplicationResultRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__receiveApplicationResultRequest), type))
		return soap->error;
	if(a->_ws__receiveApplicationResultRequest::apiKey) {
		if(soap_out_app__APIKey(soap, "ws:apiKey", -1, &a->_ws__receiveApplicationResultRequest::apiKey, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:apiKey"))
		return soap->error;
	if(a->_ws__receiveApplicationResultRequest::issuerId) {
		if(soap_out_base__UUID(soap, "ws:issuerId", -1, &a->_ws__receiveApplicationResultRequest::issuerId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:issuerId"))
		return soap->error;
	if(a->_ws__receiveApplicationResultRequest::applicationId) {
		if(soap_out_base__UUID(soap, "ws:applicationId", -1, &a->_ws__receiveApplicationResultRequest::applicationId, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:applicationId"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__receiveApplicationResultRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__receiveApplicationResultRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest * FASTCALL soap_in__ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, _ws__receiveApplicationResultRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__receiveApplicationResultRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__receiveApplicationResultRequest, sizeof(_ws__receiveApplicationResultRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__receiveApplicationResultRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__receiveApplicationResultRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_apiKey1 = 1;
	size_t soap_flag_issuerId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_apiKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_app__APIKey(soap, "ws:apiKey", &(a->_ws__receiveApplicationResultRequest::apiKey), "app:APIKey"))
				{	soap_flag_apiKey1--;
					continue;
				}
			if(soap_flag_issuerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ws:issuerId", &(a->_ws__receiveApplicationResultRequest::issuerId), "base:UUID"))
				{	soap_flag_issuerId1--;
					continue;
				}
			if(soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_base__UUID(soap, "ws:applicationId", &(a->_ws__receiveApplicationResultRequest::applicationId), "base:UUID"))
				{	soap_flag_applicationId1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__receiveApplicationResultRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__receiveApplicationResultRequest, 0, sizeof(_ws__receiveApplicationResultRequest), 0, soap_copy__ws__receiveApplicationResultRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiKey1 > 0 || soap_flag_issuerId1 > 0 || soap_flag_applicationId1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__receiveApplicationResultRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__receiveApplicationResultRequest);
	return this->soap_out(soap, tag?tag:"ws:receiveApplicationResultRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__receiveApplicationResultRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__receiveApplicationResultRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest * SOAP_FMAC4 soap_get__ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__receiveApplicationResultRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__receiveApplicationResultRequest * FASTCALL soap_instantiate__ws__receiveApplicationResultRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__receiveApplicationResultRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__receiveApplicationResultRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultRequest);
		ASSIGN_PTR(size, sizeof(_ws__receiveApplicationResultRequest));
		((_ws__receiveApplicationResultRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__receiveApplicationResultRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__receiveApplicationResultRequest));
		for(int i = 0; i < n; i++)
			((_ws__receiveApplicationResultRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__receiveApplicationResultRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__receiveApplicationResultRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__receiveApplicationResultRequest %p -> %p\n", q, p));
	*(_ws__receiveApplicationResultRequest*)p = *(_ws__receiveApplicationResultRequest*)q;
}

void _ws__submitApplicationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ws__submitApplicationResponse::app__application = NULL;
	/* transient soap skipped */
}

void _ws__submitApplicationResponse::soap_serialize(struct soap *soap) const
{
	soap_serialize_PointerToapp__Application(soap, &this->_ws__submitApplicationResponse::app__application);
	/* transient soap skipped */
}

int _ws__submitApplicationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__submitApplicationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__submitApplicationResponse(struct soap *soap, const char *tag, int id, const _ws__submitApplicationResponse *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__submitApplicationResponse), type))
		return soap->error;
	if(a->app__application)
		soap_element_result(soap, "app:application");
	if(a->_ws__submitApplicationResponse::app__application) {
		if(soap_out_PointerToapp__Application(soap, "app:application", -1, &a->_ws__submitApplicationResponse::app__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "app:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__submitApplicationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__submitApplicationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ws__submitApplicationResponse * FASTCALL soap_in__ws__submitApplicationResponse(struct soap *soap, const char *tag, _ws__submitApplicationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__submitApplicationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__submitApplicationResponse, sizeof(_ws__submitApplicationResponse), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__submitApplicationResponse) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__submitApplicationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_app__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_app__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__Application(soap, "app:application", &(a->_ws__submitApplicationResponse::app__application), "app:Application"))
				{	soap_flag_app__application1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "app:application");
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__submitApplicationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__submitApplicationResponse, 0, sizeof(_ws__submitApplicationResponse), 0, soap_copy__ws__submitApplicationResponse);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_app__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__submitApplicationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__submitApplicationResponse);
	return this->soap_out(soap, tag?tag:"ws:submitApplicationResponse", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__submitApplicationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__submitApplicationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ws__submitApplicationResponse * SOAP_FMAC4 soap_get__ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__submitApplicationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__submitApplicationResponse * FASTCALL soap_instantiate__ws__submitApplicationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__submitApplicationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__submitApplicationResponse, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationResponse);
		ASSIGN_PTR(size, sizeof(_ws__submitApplicationResponse));
		((_ws__submitApplicationResponse*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationResponse[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__submitApplicationResponse));
		for(int i = 0; i < n; i++)
			((_ws__submitApplicationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__submitApplicationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__submitApplicationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__submitApplicationResponse %p -> %p\n", q, p));
	*(_ws__submitApplicationResponse*)p = *(_ws__submitApplicationResponse*)q;
}

void _ws__submitApplicationRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_app__APIKey(soap, &this->_ws__submitApplicationRequest::apiKey);
	this->_ws__submitApplicationRequest::app__application = NULL;
	/* transient soap skipped */
}

void _ws__submitApplicationRequest::soap_serialize(struct soap *soap) const
{
	soap_serialize_app__APIKey(soap, &this->_ws__submitApplicationRequest::apiKey);
	soap_serialize_PointerToapp__Application(soap, &this->_ws__submitApplicationRequest::app__application);
	/* transient soap skipped */
}

int _ws__submitApplicationRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ws__submitApplicationRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out__ws__submitApplicationRequest(struct soap *soap, const char *tag, int id, const _ws__submitApplicationRequest *a, const char *type)
{
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ws__submitApplicationRequest), type))
		return soap->error;
	if(a->_ws__submitApplicationRequest::apiKey) {
		if(soap_out_app__APIKey(soap, "ws:apiKey", -1, &a->_ws__submitApplicationRequest::apiKey, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "ws:apiKey"))
		return soap->error;
	if(a->_ws__submitApplicationRequest::app__application) {
		if(soap_out_PointerToapp__Application(soap, "app:application", -1, &a->_ws__submitApplicationRequest::app__application, ""))
			return soap->error;
	}
	else if(soap_element_nil(soap, "app:application"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ws__submitApplicationRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ws__submitApplicationRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ws__submitApplicationRequest * FASTCALL soap_in__ws__submitApplicationRequest(struct soap *soap, const char *tag, _ws__submitApplicationRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ws__submitApplicationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ws__submitApplicationRequest, sizeof(_ws__submitApplicationRequest), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced) {
		a->soap_default(soap);
		if(soap->clist->type != SOAP_TYPE__ws__submitApplicationRequest) {
			soap_revert(soap);
			*soap->id = '\0';
			return (_ws__submitApplicationRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_apiKey1 = 1;
	size_t soap_flag_app__application1 = 1;
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_apiKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_app__APIKey(soap, "ws:apiKey", &(a->_ws__submitApplicationRequest::apiKey), "app:APIKey"))
				{	soap_flag_apiKey1--;
					continue;
				}
			if(soap_flag_app__application1 && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToapp__Application(soap, "app:application", &(a->_ws__submitApplicationRequest::app__application), "app:Application"))
				{	soap_flag_app__application1--;
					continue;
				}
			/* transient soap skipped */
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (_ws__submitApplicationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ws__submitApplicationRequest, 0, sizeof(_ws__submitApplicationRequest), 0, soap_copy__ws__submitApplicationRequest);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_apiKey1 > 0 || soap_flag_app__application1 > 0)) {
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ws__submitApplicationRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ws__submitApplicationRequest);
	return this->soap_out(soap, tag?tag:"ws:submitApplicationRequest", id, type) ? soap->error : soap_putindependent(soap);
}

void *_ws__submitApplicationRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ws__submitApplicationRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ws__submitApplicationRequest * SOAP_FMAC4 soap_get__ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in__ws__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ws__submitApplicationRequest * FASTCALL soap_instantiate__ws__submitApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ws__submitApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ws__submitApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationRequest);
		ASSIGN_PTR(size, sizeof(_ws__submitApplicationRequest));
		((_ws__submitApplicationRequest*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(_ws__submitApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(_ws__submitApplicationRequest));
		for(int i = 0; i < n; i++)
			((_ws__submitApplicationRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ws__submitApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ws__submitApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ws__submitApplicationRequest %p -> %p\n", q, p));
	*(_ws__submitApplicationRequest*)p = *(_ws__submitApplicationRequest*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if(this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if(this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if(id < 0)
		return soap->error;
	if(soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if(soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * FASTCALL soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64")) {
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if(!a)
		return NULL;
	if(soap->alloced)
		a->soap_default(soap);
	if(soap->body && !*soap->href) {	
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if(soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		
#ifndef WITH_LEANER
		if(*soap->href != '#')
		{	if(soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	return this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type) ? soap->error : soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * FASTCALL soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		ASSIGN_PTR(size, sizeof(xsd__base64Binary));
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else {
		cp->ptr = (void*)SOAP_NEW(xsd__base64Binary[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(xsd__base64Binary));
		for(int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if(soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if(soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if(soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if(soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if(soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * FASTCALL soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if(soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if(soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if(soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	return soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * FASTCALL soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Fault));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Fault));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if(soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if(soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * FASTCALL soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	return soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * FASTCALL soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Reason));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Reason));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if(soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if(soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * FASTCALL soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if(soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	return soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * FASTCALL soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Code));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Code));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * FASTCALL soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	return soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * FASTCALL soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Header));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Header));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, struct __ns4__getAppliedUserAuthorityListRequest *a)
{
	a->merc__getAppliedUserAuthorityListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, const struct __ns4__getAppliedUserAuthorityListRequest *a)
{
	soap_serialize_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, &a->merc__getAppliedUserAuthorityListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getAppliedUserAuthorityListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, "merc:getAppliedUserAuthorityListRequest", -1, &a->merc__getAppliedUserAuthorityListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getAppliedUserAuthorityListRequest * FASTCALL soap_in___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, struct __ns4__getAppliedUserAuthorityListRequest *a, const char *type)
{
	size_t soap_flag_merc__getAppliedUserAuthorityListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getAppliedUserAuthorityListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getAppliedUserAuthorityListRequest, sizeof(struct __ns4__getAppliedUserAuthorityListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getAppliedUserAuthorityListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getAppliedUserAuthorityListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, "merc:getAppliedUserAuthorityListRequest", &a->merc__getAppliedUserAuthorityListRequest, "merc:GetAppliedUserAuthorityListRequest"))
				{	soap_flag_merc__getAppliedUserAuthorityListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, const struct __ns4__getAppliedUserAuthorityListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getAppliedUserAuthorityListRequest(soap, tag?tag:"-ns4:getAppliedUserAuthorityListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getAppliedUserAuthorityListRequest * SOAP_FMAC4 soap_get___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, struct __ns4__getAppliedUserAuthorityListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getAppliedUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getAppliedUserAuthorityListRequest * FASTCALL soap_instantiate___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getAppliedUserAuthorityListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getAppliedUserAuthorityListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getAppliedUserAuthorityListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getAppliedUserAuthorityListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getAppliedUserAuthorityListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getAppliedUserAuthorityListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getAppliedUserAuthorityListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getAppliedUserAuthorityListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getAppliedUserAuthorityListRequest %p -> %p\n", q, p));
	*(struct __ns4__getAppliedUserAuthorityListRequest*)p = *(struct __ns4__getAppliedUserAuthorityListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__unbindBusinessEntityUserRequest(struct soap *soap, struct __ns4__unbindBusinessEntityUserRequest *a)
{
	a->merc__unbindBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__unbindBusinessEntityUserRequest(struct soap *soap, const struct __ns4__unbindBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTomerc__UnbindBusinessEntityUserRequest(soap, &a->merc__unbindBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__unbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __ns4__unbindBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__UnbindBusinessEntityUserRequest(soap, "merc:unbindBusinessEntityUserRequest", -1, &a->merc__unbindBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__unbindBusinessEntityUserRequest * FASTCALL soap_in___ns4__unbindBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __ns4__unbindBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_merc__unbindBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __ns4__unbindBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__unbindBusinessEntityUserRequest, sizeof(struct __ns4__unbindBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__unbindBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__unbindBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__UnbindBusinessEntityUserRequest(soap, "merc:unbindBusinessEntityUserRequest", &a->merc__unbindBusinessEntityUserRequest, "merc:UnbindBusinessEntityUserRequest"))
				{	soap_flag_merc__unbindBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__unbindBusinessEntityUserRequest(struct soap *soap, const struct __ns4__unbindBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__unbindBusinessEntityUserRequest(soap, tag?tag:"-ns4:unbindBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__unbindBusinessEntityUserRequest * SOAP_FMAC4 soap_get___ns4__unbindBusinessEntityUserRequest(struct soap *soap, struct __ns4__unbindBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__unbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__unbindBusinessEntityUserRequest * FASTCALL soap_instantiate___ns4__unbindBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__unbindBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__unbindBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__unbindBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__unbindBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__unbindBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__unbindBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__unbindBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__unbindBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__unbindBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __ns4__unbindBusinessEntityUserRequest*)p = *(struct __ns4__unbindBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__updateUserWorkingAreasRequest(struct soap *soap, struct __ns4__updateUserWorkingAreasRequest *a)
{
	a->merc__updateUserWorkingAreasRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__updateUserWorkingAreasRequest(struct soap *soap, const struct __ns4__updateUserWorkingAreasRequest *a)
{
	soap_serialize_PointerTomerc__UpdateUserWorkingAreasRequest(soap, &a->merc__updateUserWorkingAreasRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__updateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, const struct __ns4__updateUserWorkingAreasRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__UpdateUserWorkingAreasRequest(soap, "merc:updateUserWorkingAreasRequest", -1, &a->merc__updateUserWorkingAreasRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateUserWorkingAreasRequest * FASTCALL soap_in___ns4__updateUserWorkingAreasRequest(struct soap *soap, const char *tag, struct __ns4__updateUserWorkingAreasRequest *a, const char *type)
{
	size_t soap_flag_merc__updateUserWorkingAreasRequest = 1;
	short soap_flag;
	a = (struct __ns4__updateUserWorkingAreasRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__updateUserWorkingAreasRequest, sizeof(struct __ns4__updateUserWorkingAreasRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__updateUserWorkingAreasRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__updateUserWorkingAreasRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__UpdateUserWorkingAreasRequest(soap, "merc:updateUserWorkingAreasRequest", &a->merc__updateUserWorkingAreasRequest, "merc:UpdateUserWorkingAreasRequest"))
				{	soap_flag_merc__updateUserWorkingAreasRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__updateUserWorkingAreasRequest(struct soap *soap, const struct __ns4__updateUserWorkingAreasRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__updateUserWorkingAreasRequest(soap, tag?tag:"-ns4:updateUserWorkingAreasRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateUserWorkingAreasRequest * SOAP_FMAC4 soap_get___ns4__updateUserWorkingAreasRequest(struct soap *soap, struct __ns4__updateUserWorkingAreasRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__updateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__updateUserWorkingAreasRequest * FASTCALL soap_instantiate___ns4__updateUserWorkingAreasRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__updateUserWorkingAreasRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__updateUserWorkingAreasRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateUserWorkingAreasRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__updateUserWorkingAreasRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateUserWorkingAreasRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__updateUserWorkingAreasRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__updateUserWorkingAreasRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__updateUserWorkingAreasRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__updateUserWorkingAreasRequest %p -> %p\n", q, p));
	*(struct __ns4__updateUserWorkingAreasRequest*)p = *(struct __ns4__updateUserWorkingAreasRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__updateUserAuthoritiesRequest(struct soap *soap, struct __ns4__updateUserAuthoritiesRequest *a)
{
	a->merc__updateUserAuthoritiesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__updateUserAuthoritiesRequest(struct soap *soap, const struct __ns4__updateUserAuthoritiesRequest *a)
{
	soap_serialize_PointerTomerc__UpdateUserAuthoritiesRequest(soap, &a->merc__updateUserAuthoritiesRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__updateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, const struct __ns4__updateUserAuthoritiesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__UpdateUserAuthoritiesRequest(soap, "merc:updateUserAuthoritiesRequest", -1, &a->merc__updateUserAuthoritiesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateUserAuthoritiesRequest * FASTCALL soap_in___ns4__updateUserAuthoritiesRequest(struct soap *soap, const char *tag, struct __ns4__updateUserAuthoritiesRequest *a, const char *type)
{
	size_t soap_flag_merc__updateUserAuthoritiesRequest = 1;
	short soap_flag;
	a = (struct __ns4__updateUserAuthoritiesRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__updateUserAuthoritiesRequest, sizeof(struct __ns4__updateUserAuthoritiesRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__updateUserAuthoritiesRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__updateUserAuthoritiesRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__UpdateUserAuthoritiesRequest(soap, "merc:updateUserAuthoritiesRequest", &a->merc__updateUserAuthoritiesRequest, "merc:UpdateUserAuthoritiesRequest"))
				{	soap_flag_merc__updateUserAuthoritiesRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__updateUserAuthoritiesRequest(struct soap *soap, const struct __ns4__updateUserAuthoritiesRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__updateUserAuthoritiesRequest(soap, tag?tag:"-ns4:updateUserAuthoritiesRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateUserAuthoritiesRequest * SOAP_FMAC4 soap_get___ns4__updateUserAuthoritiesRequest(struct soap *soap, struct __ns4__updateUserAuthoritiesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__updateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__updateUserAuthoritiesRequest * FASTCALL soap_instantiate___ns4__updateUserAuthoritiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__updateUserAuthoritiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__updateUserAuthoritiesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateUserAuthoritiesRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__updateUserAuthoritiesRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateUserAuthoritiesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__updateUserAuthoritiesRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__updateUserAuthoritiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__updateUserAuthoritiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__updateUserAuthoritiesRequest %p -> %p\n", q, p));
	*(struct __ns4__updateUserAuthoritiesRequest*)p = *(struct __ns4__updateUserAuthoritiesRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getBusinessEntityUserRequest(struct soap *soap, struct __ns4__getBusinessEntityUserRequest *a)
{
	a->merc__getBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getBusinessEntityUserRequest(struct soap *soap, const struct __ns4__getBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTomerc__GetBusinessEntityUserRequest(soap, &a->merc__getBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetBusinessEntityUserRequest(soap, "merc:getBusinessEntityUserRequest", -1, &a->merc__getBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getBusinessEntityUserRequest * FASTCALL soap_in___ns4__getBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __ns4__getBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_merc__getBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __ns4__getBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getBusinessEntityUserRequest, sizeof(struct __ns4__getBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetBusinessEntityUserRequest(soap, "merc:getBusinessEntityUserRequest", &a->merc__getBusinessEntityUserRequest, "merc:GetBusinessEntityUserRequest"))
				{	soap_flag_merc__getBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getBusinessEntityUserRequest(struct soap *soap, const struct __ns4__getBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getBusinessEntityUserRequest(soap, tag?tag:"-ns4:getBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getBusinessEntityUserRequest * SOAP_FMAC4 soap_get___ns4__getBusinessEntityUserRequest(struct soap *soap, struct __ns4__getBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getBusinessEntityUserRequest * FASTCALL soap_instantiate___ns4__getBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __ns4__getBusinessEntityUserRequest*)p = *(struct __ns4__getBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getBusinessEntityUserListRequest(struct soap *soap, struct __ns4__getBusinessEntityUserListRequest *a)
{
	a->merc__getBusinessEntityUserListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getBusinessEntityUserListRequest(struct soap *soap, const struct __ns4__getBusinessEntityUserListRequest *a)
{
	soap_serialize_PointerTomerc__GetBusinessEntityUserListRequest(soap, &a->merc__getBusinessEntityUserListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getBusinessEntityUserListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetBusinessEntityUserListRequest(soap, "merc:getBusinessEntityUserListRequest", -1, &a->merc__getBusinessEntityUserListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getBusinessEntityUserListRequest * FASTCALL soap_in___ns4__getBusinessEntityUserListRequest(struct soap *soap, const char *tag, struct __ns4__getBusinessEntityUserListRequest *a, const char *type)
{
	size_t soap_flag_merc__getBusinessEntityUserListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getBusinessEntityUserListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getBusinessEntityUserListRequest, sizeof(struct __ns4__getBusinessEntityUserListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getBusinessEntityUserListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getBusinessEntityUserListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetBusinessEntityUserListRequest(soap, "merc:getBusinessEntityUserListRequest", &a->merc__getBusinessEntityUserListRequest, "merc:GetBusinessEntityUserListRequest"))
				{	soap_flag_merc__getBusinessEntityUserListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getBusinessEntityUserListRequest(struct soap *soap, const struct __ns4__getBusinessEntityUserListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getBusinessEntityUserListRequest(soap, tag?tag:"-ns4:getBusinessEntityUserListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getBusinessEntityUserListRequest * SOAP_FMAC4 soap_get___ns4__getBusinessEntityUserListRequest(struct soap *soap, struct __ns4__getBusinessEntityUserListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getBusinessEntityUserListRequest * FASTCALL soap_instantiate___ns4__getBusinessEntityUserListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getBusinessEntityUserListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getBusinessEntityUserListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getBusinessEntityUserListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getBusinessEntityUserListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getBusinessEntityUserListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getBusinessEntityUserListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getBusinessEntityUserListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getBusinessEntityUserListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getBusinessEntityUserListRequest %p -> %p\n", q, p));
	*(struct __ns4__getBusinessEntityUserListRequest*)p = *(struct __ns4__getBusinessEntityUserListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__addBusinessEntityUserRequest(struct soap *soap, struct __ns4__addBusinessEntityUserRequest *a)
{
	a->merc__addBusinessEntityUserRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__addBusinessEntityUserRequest(struct soap *soap, const struct __ns4__addBusinessEntityUserRequest *a)
{
	soap_serialize_PointerTomerc__AddBusinessEntityUserRequest(soap, &a->merc__addBusinessEntityUserRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__addBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, const struct __ns4__addBusinessEntityUserRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__AddBusinessEntityUserRequest(soap, "merc:addBusinessEntityUserRequest", -1, &a->merc__addBusinessEntityUserRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__addBusinessEntityUserRequest * FASTCALL soap_in___ns4__addBusinessEntityUserRequest(struct soap *soap, const char *tag, struct __ns4__addBusinessEntityUserRequest *a, const char *type)
{
	size_t soap_flag_merc__addBusinessEntityUserRequest = 1;
	short soap_flag;
	a = (struct __ns4__addBusinessEntityUserRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__addBusinessEntityUserRequest, sizeof(struct __ns4__addBusinessEntityUserRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__addBusinessEntityUserRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__addBusinessEntityUserRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__AddBusinessEntityUserRequest(soap, "merc:addBusinessEntityUserRequest", &a->merc__addBusinessEntityUserRequest, "merc:AddBusinessEntityUserRequest"))
				{	soap_flag_merc__addBusinessEntityUserRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__addBusinessEntityUserRequest(struct soap *soap, const struct __ns4__addBusinessEntityUserRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__addBusinessEntityUserRequest(soap, tag?tag:"-ns4:addBusinessEntityUserRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__addBusinessEntityUserRequest * SOAP_FMAC4 soap_get___ns4__addBusinessEntityUserRequest(struct soap *soap, struct __ns4__addBusinessEntityUserRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__addBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__addBusinessEntityUserRequest * FASTCALL soap_instantiate___ns4__addBusinessEntityUserRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__addBusinessEntityUserRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__addBusinessEntityUserRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__addBusinessEntityUserRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__addBusinessEntityUserRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__addBusinessEntityUserRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__addBusinessEntityUserRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__addBusinessEntityUserRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__addBusinessEntityUserRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__addBusinessEntityUserRequest %p -> %p\n", q, p));
	*(struct __ns4__addBusinessEntityUserRequest*)p = *(struct __ns4__addBusinessEntityUserRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__checkShipmentRegionalizationRequest(struct soap *soap, struct __ns4__checkShipmentRegionalizationRequest *a)
{
	a->merc__checkShipmentRegionalizationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__checkShipmentRegionalizationRequest(struct soap *soap, const struct __ns4__checkShipmentRegionalizationRequest *a)
{
	soap_serialize_PointerTomerc__CheckShipmentRegionalizationRequest(soap, &a->merc__checkShipmentRegionalizationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__checkShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, const struct __ns4__checkShipmentRegionalizationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__CheckShipmentRegionalizationRequest(soap, "merc:checkShipmentRegionalizationRequest", -1, &a->merc__checkShipmentRegionalizationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__checkShipmentRegionalizationRequest * FASTCALL soap_in___ns4__checkShipmentRegionalizationRequest(struct soap *soap, const char *tag, struct __ns4__checkShipmentRegionalizationRequest *a, const char *type)
{
	size_t soap_flag_merc__checkShipmentRegionalizationRequest = 1;
	short soap_flag;
	a = (struct __ns4__checkShipmentRegionalizationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__checkShipmentRegionalizationRequest, sizeof(struct __ns4__checkShipmentRegionalizationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__checkShipmentRegionalizationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__checkShipmentRegionalizationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__CheckShipmentRegionalizationRequest(soap, "merc:checkShipmentRegionalizationRequest", &a->merc__checkShipmentRegionalizationRequest, "merc:CheckShipmentRegionalizationRequest"))
				{	soap_flag_merc__checkShipmentRegionalizationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__checkShipmentRegionalizationRequest(struct soap *soap, const struct __ns4__checkShipmentRegionalizationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__checkShipmentRegionalizationRequest(soap, tag?tag:"-ns4:checkShipmentRegionalizationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__checkShipmentRegionalizationRequest * SOAP_FMAC4 soap_get___ns4__checkShipmentRegionalizationRequest(struct soap *soap, struct __ns4__checkShipmentRegionalizationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__checkShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__checkShipmentRegionalizationRequest * FASTCALL soap_instantiate___ns4__checkShipmentRegionalizationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__checkShipmentRegionalizationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__checkShipmentRegionalizationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__checkShipmentRegionalizationRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__checkShipmentRegionalizationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__checkShipmentRegionalizationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__checkShipmentRegionalizationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__checkShipmentRegionalizationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__checkShipmentRegionalizationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__checkShipmentRegionalizationRequest %p -> %p\n", q, p));
	*(struct __ns4__checkShipmentRegionalizationRequest*)p = *(struct __ns4__checkShipmentRegionalizationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__updateVeterinaryEventsRequest(struct soap *soap, struct __ns4__updateVeterinaryEventsRequest *a)
{
	a->merc__updateVeterinaryEventsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__updateVeterinaryEventsRequest(struct soap *soap, const struct __ns4__updateVeterinaryEventsRequest *a)
{
	soap_serialize_PointerTomerc__UpdateVeterinaryEventsRequest(soap, &a->merc__updateVeterinaryEventsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__updateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, const struct __ns4__updateVeterinaryEventsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__UpdateVeterinaryEventsRequest(soap, "merc:updateVeterinaryEventsRequest", -1, &a->merc__updateVeterinaryEventsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateVeterinaryEventsRequest * FASTCALL soap_in___ns4__updateVeterinaryEventsRequest(struct soap *soap, const char *tag, struct __ns4__updateVeterinaryEventsRequest *a, const char *type)
{
	size_t soap_flag_merc__updateVeterinaryEventsRequest = 1;
	short soap_flag;
	a = (struct __ns4__updateVeterinaryEventsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__updateVeterinaryEventsRequest, sizeof(struct __ns4__updateVeterinaryEventsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__updateVeterinaryEventsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__updateVeterinaryEventsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__UpdateVeterinaryEventsRequest(soap, "merc:updateVeterinaryEventsRequest", &a->merc__updateVeterinaryEventsRequest, "merc:UpdateVeterinaryEventsRequest"))
				{	soap_flag_merc__updateVeterinaryEventsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__updateVeterinaryEventsRequest(struct soap *soap, const struct __ns4__updateVeterinaryEventsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__updateVeterinaryEventsRequest(soap, tag?tag:"-ns4:updateVeterinaryEventsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateVeterinaryEventsRequest * SOAP_FMAC4 soap_get___ns4__updateVeterinaryEventsRequest(struct soap *soap, struct __ns4__updateVeterinaryEventsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__updateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__updateVeterinaryEventsRequest * FASTCALL soap_instantiate___ns4__updateVeterinaryEventsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__updateVeterinaryEventsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__updateVeterinaryEventsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateVeterinaryEventsRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__updateVeterinaryEventsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateVeterinaryEventsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__updateVeterinaryEventsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__updateVeterinaryEventsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__updateVeterinaryEventsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__updateVeterinaryEventsRequest %p -> %p\n", q, p));
	*(struct __ns4__updateVeterinaryEventsRequest*)p = *(struct __ns4__updateVeterinaryEventsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__updateTransportMovementDetailsRequest(struct soap *soap, struct __ns4__updateTransportMovementDetailsRequest *a)
{
	a->merc__updateTransportMovementDetailsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__updateTransportMovementDetailsRequest(struct soap *soap, const struct __ns4__updateTransportMovementDetailsRequest *a)
{
	soap_serialize_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, &a->merc__updateTransportMovementDetailsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__updateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, const struct __ns4__updateTransportMovementDetailsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, "merc:updateTransportMovementDetailsRequest", -1, &a->merc__updateTransportMovementDetailsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateTransportMovementDetailsRequest * FASTCALL soap_in___ns4__updateTransportMovementDetailsRequest(struct soap *soap, const char *tag, struct __ns4__updateTransportMovementDetailsRequest *a, const char *type)
{
	size_t soap_flag_merc__updateTransportMovementDetailsRequest = 1;
	short soap_flag;
	a = (struct __ns4__updateTransportMovementDetailsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__updateTransportMovementDetailsRequest, sizeof(struct __ns4__updateTransportMovementDetailsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__updateTransportMovementDetailsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__updateTransportMovementDetailsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, "merc:updateTransportMovementDetailsRequest", &a->merc__updateTransportMovementDetailsRequest, "merc:UpdateTransportMovementDetailsRequest"))
				{	soap_flag_merc__updateTransportMovementDetailsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__updateTransportMovementDetailsRequest(struct soap *soap, const struct __ns4__updateTransportMovementDetailsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__updateTransportMovementDetailsRequest(soap, tag?tag:"-ns4:updateTransportMovementDetailsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__updateTransportMovementDetailsRequest * SOAP_FMAC4 soap_get___ns4__updateTransportMovementDetailsRequest(struct soap *soap, struct __ns4__updateTransportMovementDetailsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__updateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__updateTransportMovementDetailsRequest * FASTCALL soap_instantiate___ns4__updateTransportMovementDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__updateTransportMovementDetailsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__updateTransportMovementDetailsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateTransportMovementDetailsRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__updateTransportMovementDetailsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__updateTransportMovementDetailsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__updateTransportMovementDetailsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__updateTransportMovementDetailsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__updateTransportMovementDetailsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__updateTransportMovementDetailsRequest %p -> %p\n", q, p));
	*(struct __ns4__updateTransportMovementDetailsRequest*)p = *(struct __ns4__updateTransportMovementDetailsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getStockEntryVersionListRequest(struct soap *soap, struct __ns4__getStockEntryVersionListRequest *a)
{
	a->merc__getStockEntryVersionListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getStockEntryVersionListRequest(struct soap *soap, const struct __ns4__getStockEntryVersionListRequest *a)
{
	soap_serialize_PointerTomerc__GetStockEntryVersionListRequest(soap, &a->merc__getStockEntryVersionListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getStockEntryVersionListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetStockEntryVersionListRequest(soap, "merc:getStockEntryVersionListRequest", -1, &a->merc__getStockEntryVersionListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryVersionListRequest * FASTCALL soap_in___ns4__getStockEntryVersionListRequest(struct soap *soap, const char *tag, struct __ns4__getStockEntryVersionListRequest *a, const char *type)
{
	size_t soap_flag_merc__getStockEntryVersionListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getStockEntryVersionListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getStockEntryVersionListRequest, sizeof(struct __ns4__getStockEntryVersionListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getStockEntryVersionListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getStockEntryVersionListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetStockEntryVersionListRequest(soap, "merc:getStockEntryVersionListRequest", &a->merc__getStockEntryVersionListRequest, "merc:GetStockEntryVersionListRequest"))
				{	soap_flag_merc__getStockEntryVersionListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getStockEntryVersionListRequest(struct soap *soap, const struct __ns4__getStockEntryVersionListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getStockEntryVersionListRequest(soap, tag?tag:"-ns4:getStockEntryVersionListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryVersionListRequest * SOAP_FMAC4 soap_get___ns4__getStockEntryVersionListRequest(struct soap *soap, struct __ns4__getStockEntryVersionListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getStockEntryVersionListRequest * FASTCALL soap_instantiate___ns4__getStockEntryVersionListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getStockEntryVersionListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getStockEntryVersionListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryVersionListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getStockEntryVersionListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryVersionListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getStockEntryVersionListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getStockEntryVersionListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getStockEntryVersionListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getStockEntryVersionListRequest %p -> %p\n", q, p));
	*(struct __ns4__getStockEntryVersionListRequest*)p = *(struct __ns4__getStockEntryVersionListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getStockEntryChangesListRequest(struct soap *soap, struct __ns4__getStockEntryChangesListRequest *a)
{
	a->merc__getStockEntryChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getStockEntryChangesListRequest(struct soap *soap, const struct __ns4__getStockEntryChangesListRequest *a)
{
	soap_serialize_PointerTomerc__GetStockEntryChangesListRequest(soap, &a->merc__getStockEntryChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getStockEntryChangesListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetStockEntryChangesListRequest(soap, "merc:getStockEntryChangesListRequest", -1, &a->merc__getStockEntryChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryChangesListRequest * FASTCALL soap_in___ns4__getStockEntryChangesListRequest(struct soap *soap, const char *tag, struct __ns4__getStockEntryChangesListRequest *a, const char *type)
{
	size_t soap_flag_merc__getStockEntryChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getStockEntryChangesListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getStockEntryChangesListRequest, sizeof(struct __ns4__getStockEntryChangesListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getStockEntryChangesListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getStockEntryChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetStockEntryChangesListRequest(soap, "merc:getStockEntryChangesListRequest", &a->merc__getStockEntryChangesListRequest, "merc:GetStockEntryChangesListRequest"))
				{	soap_flag_merc__getStockEntryChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getStockEntryChangesListRequest(struct soap *soap, const struct __ns4__getStockEntryChangesListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getStockEntryChangesListRequest(soap, tag?tag:"-ns4:getStockEntryChangesListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryChangesListRequest * SOAP_FMAC4 soap_get___ns4__getStockEntryChangesListRequest(struct soap *soap, struct __ns4__getStockEntryChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getStockEntryChangesListRequest * FASTCALL soap_instantiate___ns4__getStockEntryChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getStockEntryChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getStockEntryChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryChangesListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getStockEntryChangesListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getStockEntryChangesListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getStockEntryChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getStockEntryChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getStockEntryChangesListRequest %p -> %p\n", q, p));
	*(struct __ns4__getStockEntryChangesListRequest*)p = *(struct __ns4__getStockEntryChangesListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getStockEntryListRequest(struct soap *soap, struct __ns4__getStockEntryListRequest *a)
{
	a->merc__getStockEntryListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getStockEntryListRequest(struct soap *soap, const struct __ns4__getStockEntryListRequest *a)
{
	soap_serialize_PointerTomerc__GetStockEntryListRequest(soap, &a->merc__getStockEntryListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getStockEntryListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getStockEntryListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetStockEntryListRequest(soap, "merc:getStockEntryListRequest", -1, &a->merc__getStockEntryListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryListRequest * FASTCALL soap_in___ns4__getStockEntryListRequest(struct soap *soap, const char *tag, struct __ns4__getStockEntryListRequest *a, const char *type)
{
	size_t soap_flag_merc__getStockEntryListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getStockEntryListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getStockEntryListRequest, sizeof(struct __ns4__getStockEntryListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getStockEntryListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getStockEntryListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetStockEntryListRequest(soap, "merc:getStockEntryListRequest", &a->merc__getStockEntryListRequest, "merc:GetStockEntryListRequest"))
				{	soap_flag_merc__getStockEntryListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getStockEntryListRequest(struct soap *soap, const struct __ns4__getStockEntryListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getStockEntryListRequest(soap, tag?tag:"-ns4:getStockEntryListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryListRequest * SOAP_FMAC4 soap_get___ns4__getStockEntryListRequest(struct soap *soap, struct __ns4__getStockEntryListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getStockEntryListRequest * FASTCALL soap_instantiate___ns4__getStockEntryListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getStockEntryListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getStockEntryListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getStockEntryListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getStockEntryListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getStockEntryListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getStockEntryListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getStockEntryListRequest %p -> %p\n", q, p));
	*(struct __ns4__getStockEntryListRequest*)p = *(struct __ns4__getStockEntryListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getStockEntryByUuidRequest(struct soap *soap, struct __ns4__getStockEntryByUuidRequest *a)
{
	a->merc__getStockEntryByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getStockEntryByUuidRequest(struct soap *soap, const struct __ns4__getStockEntryByUuidRequest *a)
{
	soap_serialize_PointerTomerc__GetStockEntryByUuidRequest(soap, &a->merc__getStockEntryByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getStockEntryByUuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetStockEntryByUuidRequest(soap, "merc:getStockEntryByUuidRequest", -1, &a->merc__getStockEntryByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryByUuidRequest * FASTCALL soap_in___ns4__getStockEntryByUuidRequest(struct soap *soap, const char *tag, struct __ns4__getStockEntryByUuidRequest *a, const char *type)
{
	size_t soap_flag_merc__getStockEntryByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns4__getStockEntryByUuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getStockEntryByUuidRequest, sizeof(struct __ns4__getStockEntryByUuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getStockEntryByUuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getStockEntryByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetStockEntryByUuidRequest(soap, "merc:getStockEntryByUuidRequest", &a->merc__getStockEntryByUuidRequest, "merc:GetStockEntryByUuidRequest"))
				{	soap_flag_merc__getStockEntryByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getStockEntryByUuidRequest(struct soap *soap, const struct __ns4__getStockEntryByUuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getStockEntryByUuidRequest(soap, tag?tag:"-ns4:getStockEntryByUuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryByUuidRequest * SOAP_FMAC4 soap_get___ns4__getStockEntryByUuidRequest(struct soap *soap, struct __ns4__getStockEntryByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getStockEntryByUuidRequest * FASTCALL soap_instantiate___ns4__getStockEntryByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getStockEntryByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getStockEntryByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryByUuidRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getStockEntryByUuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getStockEntryByUuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getStockEntryByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getStockEntryByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getStockEntryByUuidRequest %p -> %p\n", q, p));
	*(struct __ns4__getStockEntryByUuidRequest*)p = *(struct __ns4__getStockEntryByUuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getStockEntryByGuidRequest(struct soap *soap, struct __ns4__getStockEntryByGuidRequest *a)
{
	a->merc__getStockEntryByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getStockEntryByGuidRequest(struct soap *soap, const struct __ns4__getStockEntryByGuidRequest *a)
{
	soap_serialize_PointerTomerc__GetStockEntryByGuidRequest(soap, &a->merc__getStockEntryByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getStockEntryByGuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetStockEntryByGuidRequest(soap, "merc:getStockEntryByGuidRequest", -1, &a->merc__getStockEntryByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryByGuidRequest * FASTCALL soap_in___ns4__getStockEntryByGuidRequest(struct soap *soap, const char *tag, struct __ns4__getStockEntryByGuidRequest *a, const char *type)
{
	size_t soap_flag_merc__getStockEntryByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns4__getStockEntryByGuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getStockEntryByGuidRequest, sizeof(struct __ns4__getStockEntryByGuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getStockEntryByGuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getStockEntryByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetStockEntryByGuidRequest(soap, "merc:getStockEntryByGuidRequest", &a->merc__getStockEntryByGuidRequest, "merc:GetStockEntryByGuidRequest"))
				{	soap_flag_merc__getStockEntryByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getStockEntryByGuidRequest(struct soap *soap, const struct __ns4__getStockEntryByGuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getStockEntryByGuidRequest(soap, tag?tag:"-ns4:getStockEntryByGuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getStockEntryByGuidRequest * SOAP_FMAC4 soap_get___ns4__getStockEntryByGuidRequest(struct soap *soap, struct __ns4__getStockEntryByGuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getStockEntryByGuidRequest * FASTCALL soap_instantiate___ns4__getStockEntryByGuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getStockEntryByGuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getStockEntryByGuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryByGuidRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getStockEntryByGuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getStockEntryByGuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getStockEntryByGuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getStockEntryByGuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getStockEntryByGuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getStockEntryByGuidRequest %p -> %p\n", q, p));
	*(struct __ns4__getStockEntryByGuidRequest*)p = *(struct __ns4__getStockEntryByGuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getVetDocumentChangesListRequest(struct soap *soap, struct __ns4__getVetDocumentChangesListRequest *a)
{
	a->merc__getVetDocumentChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getVetDocumentChangesListRequest(struct soap *soap, const struct __ns4__getVetDocumentChangesListRequest *a)
{
	soap_serialize_PointerTomerc__GetVetDocumentChangesListRequest(soap, &a->merc__getVetDocumentChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getVetDocumentChangesListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetVetDocumentChangesListRequest(soap, "merc:getVetDocumentChangesListRequest", -1, &a->merc__getVetDocumentChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getVetDocumentChangesListRequest * FASTCALL soap_in___ns4__getVetDocumentChangesListRequest(struct soap *soap, const char *tag, struct __ns4__getVetDocumentChangesListRequest *a, const char *type)
{
	size_t soap_flag_merc__getVetDocumentChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getVetDocumentChangesListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getVetDocumentChangesListRequest, sizeof(struct __ns4__getVetDocumentChangesListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getVetDocumentChangesListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getVetDocumentChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetVetDocumentChangesListRequest(soap, "merc:getVetDocumentChangesListRequest", &a->merc__getVetDocumentChangesListRequest, "merc:GetVetDocumentChangesListRequest"))
				{	soap_flag_merc__getVetDocumentChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getVetDocumentChangesListRequest(struct soap *soap, const struct __ns4__getVetDocumentChangesListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getVetDocumentChangesListRequest(soap, tag?tag:"-ns4:getVetDocumentChangesListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getVetDocumentChangesListRequest * SOAP_FMAC4 soap_get___ns4__getVetDocumentChangesListRequest(struct soap *soap, struct __ns4__getVetDocumentChangesListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getVetDocumentChangesListRequest * FASTCALL soap_instantiate___ns4__getVetDocumentChangesListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getVetDocumentChangesListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getVetDocumentChangesListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getVetDocumentChangesListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getVetDocumentChangesListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getVetDocumentChangesListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getVetDocumentChangesListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getVetDocumentChangesListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getVetDocumentChangesListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getVetDocumentChangesListRequest %p -> %p\n", q, p));
	*(struct __ns4__getVetDocumentChangesListRequest*)p = *(struct __ns4__getVetDocumentChangesListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getVetDocumentListRequest(struct soap *soap, struct __ns4__getVetDocumentListRequest *a)
{
	a->merc__getVetDocumentListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getVetDocumentListRequest(struct soap *soap, const struct __ns4__getVetDocumentListRequest *a)
{
	soap_serialize_PointerTomerc__GetVetDocumentListRequest(soap, &a->merc__getVetDocumentListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getVetDocumentListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getVetDocumentListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetVetDocumentListRequest(soap, "merc:getVetDocumentListRequest", -1, &a->merc__getVetDocumentListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getVetDocumentListRequest * FASTCALL soap_in___ns4__getVetDocumentListRequest(struct soap *soap, const char *tag, struct __ns4__getVetDocumentListRequest *a, const char *type)
{
	size_t soap_flag_merc__getVetDocumentListRequest = 1;
	short soap_flag;
	a = (struct __ns4__getVetDocumentListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getVetDocumentListRequest, sizeof(struct __ns4__getVetDocumentListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getVetDocumentListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getVetDocumentListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetVetDocumentListRequest(soap, "merc:getVetDocumentListRequest", &a->merc__getVetDocumentListRequest, "merc:GetVetDocumentListRequest"))
				{	soap_flag_merc__getVetDocumentListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getVetDocumentListRequest(struct soap *soap, const struct __ns4__getVetDocumentListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getVetDocumentListRequest(soap, tag?tag:"-ns4:getVetDocumentListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getVetDocumentListRequest * SOAP_FMAC4 soap_get___ns4__getVetDocumentListRequest(struct soap *soap, struct __ns4__getVetDocumentListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getVetDocumentListRequest * FASTCALL soap_instantiate___ns4__getVetDocumentListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getVetDocumentListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getVetDocumentListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getVetDocumentListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getVetDocumentListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getVetDocumentListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getVetDocumentListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getVetDocumentListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getVetDocumentListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getVetDocumentListRequest %p -> %p\n", q, p));
	*(struct __ns4__getVetDocumentListRequest*)p = *(struct __ns4__getVetDocumentListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__getVetDocumentByUuidRequest(struct soap *soap, struct __ns4__getVetDocumentByUuidRequest *a)
{
	a->merc__getVetDocumentByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__getVetDocumentByUuidRequest(struct soap *soap, const struct __ns4__getVetDocumentByUuidRequest *a)
{
	soap_serialize_PointerTomerc__GetVetDocumentByUuidRequest(soap, &a->merc__getVetDocumentByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__getVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, const struct __ns4__getVetDocumentByUuidRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__GetVetDocumentByUuidRequest(soap, "merc:getVetDocumentByUuidRequest", -1, &a->merc__getVetDocumentByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getVetDocumentByUuidRequest * FASTCALL soap_in___ns4__getVetDocumentByUuidRequest(struct soap *soap, const char *tag, struct __ns4__getVetDocumentByUuidRequest *a, const char *type)
{
	size_t soap_flag_merc__getVetDocumentByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns4__getVetDocumentByUuidRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__getVetDocumentByUuidRequest, sizeof(struct __ns4__getVetDocumentByUuidRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__getVetDocumentByUuidRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__getVetDocumentByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__GetVetDocumentByUuidRequest(soap, "merc:getVetDocumentByUuidRequest", &a->merc__getVetDocumentByUuidRequest, "merc:GetVetDocumentByUuidRequest"))
				{	soap_flag_merc__getVetDocumentByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__getVetDocumentByUuidRequest(struct soap *soap, const struct __ns4__getVetDocumentByUuidRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__getVetDocumentByUuidRequest(soap, tag?tag:"-ns4:getVetDocumentByUuidRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__getVetDocumentByUuidRequest * SOAP_FMAC4 soap_get___ns4__getVetDocumentByUuidRequest(struct soap *soap, struct __ns4__getVetDocumentByUuidRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__getVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__getVetDocumentByUuidRequest * FASTCALL soap_instantiate___ns4__getVetDocumentByUuidRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__getVetDocumentByUuidRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__getVetDocumentByUuidRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getVetDocumentByUuidRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__getVetDocumentByUuidRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__getVetDocumentByUuidRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__getVetDocumentByUuidRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__getVetDocumentByUuidRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__getVetDocumentByUuidRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__getVetDocumentByUuidRequest %p -> %p\n", q, p));
	*(struct __ns4__getVetDocumentByUuidRequest*)p = *(struct __ns4__getVetDocumentByUuidRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__modifyProducerStockListRequest(struct soap *soap, struct __ns4__modifyProducerStockListRequest *a)
{
	a->merc__modifyProducerStockListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__modifyProducerStockListRequest(struct soap *soap, const struct __ns4__modifyProducerStockListRequest *a)
{
	soap_serialize_PointerTomerc__ModifyProducerStockListRequest(soap, &a->merc__modifyProducerStockListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__modifyProducerStockListRequest(struct soap *soap, const char *tag, int id, const struct __ns4__modifyProducerStockListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__ModifyProducerStockListRequest(soap, "merc:modifyProducerStockListRequest", -1, &a->merc__modifyProducerStockListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyProducerStockListRequest * FASTCALL soap_in___ns4__modifyProducerStockListRequest(struct soap *soap, const char *tag, struct __ns4__modifyProducerStockListRequest *a, const char *type)
{
	size_t soap_flag_merc__modifyProducerStockListRequest = 1;
	short soap_flag;
	a = (struct __ns4__modifyProducerStockListRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__modifyProducerStockListRequest, sizeof(struct __ns4__modifyProducerStockListRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__modifyProducerStockListRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__modifyProducerStockListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__ModifyProducerStockListRequest(soap, "merc:modifyProducerStockListRequest", &a->merc__modifyProducerStockListRequest, "merc:ModifyProducerStockListRequest"))
				{	soap_flag_merc__modifyProducerStockListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__modifyProducerStockListRequest(struct soap *soap, const struct __ns4__modifyProducerStockListRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__modifyProducerStockListRequest(soap, tag?tag:"-ns4:modifyProducerStockListRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyProducerStockListRequest * SOAP_FMAC4 soap_get___ns4__modifyProducerStockListRequest(struct soap *soap, struct __ns4__modifyProducerStockListRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__modifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__modifyProducerStockListRequest * FASTCALL soap_instantiate___ns4__modifyProducerStockListRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__modifyProducerStockListRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__modifyProducerStockListRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyProducerStockListRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__modifyProducerStockListRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyProducerStockListRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__modifyProducerStockListRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__modifyProducerStockListRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__modifyProducerStockListRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__modifyProducerStockListRequest %p -> %p\n", q, p));
	*(struct __ns4__modifyProducerStockListRequest*)p = *(struct __ns4__modifyProducerStockListRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__resolveDiscrepancyRequest(struct soap *soap, struct __ns4__resolveDiscrepancyRequest *a)
{
	a->merc__resolveDiscrepancyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__resolveDiscrepancyRequest(struct soap *soap, const struct __ns4__resolveDiscrepancyRequest *a)
{
	soap_serialize_PointerTomerc__ResolveDiscrepancyRequest(soap, &a->merc__resolveDiscrepancyRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__resolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, const struct __ns4__resolveDiscrepancyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__ResolveDiscrepancyRequest(soap, "merc:resolveDiscrepancyRequest", -1, &a->merc__resolveDiscrepancyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__resolveDiscrepancyRequest * FASTCALL soap_in___ns4__resolveDiscrepancyRequest(struct soap *soap, const char *tag, struct __ns4__resolveDiscrepancyRequest *a, const char *type)
{
	size_t soap_flag_merc__resolveDiscrepancyRequest = 1;
	short soap_flag;
	a = (struct __ns4__resolveDiscrepancyRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__resolveDiscrepancyRequest, sizeof(struct __ns4__resolveDiscrepancyRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__resolveDiscrepancyRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__resolveDiscrepancyRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__ResolveDiscrepancyRequest(soap, "merc:resolveDiscrepancyRequest", &a->merc__resolveDiscrepancyRequest, "merc:ResolveDiscrepancyRequest"))
				{	soap_flag_merc__resolveDiscrepancyRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__resolveDiscrepancyRequest(struct soap *soap, const struct __ns4__resolveDiscrepancyRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__resolveDiscrepancyRequest(soap, tag?tag:"-ns4:resolveDiscrepancyRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__resolveDiscrepancyRequest * SOAP_FMAC4 soap_get___ns4__resolveDiscrepancyRequest(struct soap *soap, struct __ns4__resolveDiscrepancyRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__resolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__resolveDiscrepancyRequest * FASTCALL soap_instantiate___ns4__resolveDiscrepancyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__resolveDiscrepancyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__resolveDiscrepancyRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__resolveDiscrepancyRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__resolveDiscrepancyRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__resolveDiscrepancyRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__resolveDiscrepancyRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__resolveDiscrepancyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__resolveDiscrepancyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__resolveDiscrepancyRequest %p -> %p\n", q, p));
	*(struct __ns4__resolveDiscrepancyRequest*)p = *(struct __ns4__resolveDiscrepancyRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__modifyActivityLocationsRequest(struct soap *soap, struct __ns4__modifyActivityLocationsRequest *a)
{
	a->merc__modifyActivityLocationsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__modifyActivityLocationsRequest(struct soap *soap, const struct __ns4__modifyActivityLocationsRequest *a)
{
	soap_serialize_PointerTomerc__ModifyActivityLocationsRequest(soap, &a->merc__modifyActivityLocationsRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__modifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, const struct __ns4__modifyActivityLocationsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__ModifyActivityLocationsRequest(soap, "merc:modifyActivityLocationsRequest", -1, &a->merc__modifyActivityLocationsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyActivityLocationsRequest * FASTCALL soap_in___ns4__modifyActivityLocationsRequest(struct soap *soap, const char *tag, struct __ns4__modifyActivityLocationsRequest *a, const char *type)
{
	size_t soap_flag_merc__modifyActivityLocationsRequest = 1;
	short soap_flag;
	a = (struct __ns4__modifyActivityLocationsRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__modifyActivityLocationsRequest, sizeof(struct __ns4__modifyActivityLocationsRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__modifyActivityLocationsRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__modifyActivityLocationsRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__ModifyActivityLocationsRequest(soap, "merc:modifyActivityLocationsRequest", &a->merc__modifyActivityLocationsRequest, "merc:ModifyActivityLocationsRequest"))
				{	soap_flag_merc__modifyActivityLocationsRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__modifyActivityLocationsRequest(struct soap *soap, const struct __ns4__modifyActivityLocationsRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__modifyActivityLocationsRequest(soap, tag?tag:"-ns4:modifyActivityLocationsRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyActivityLocationsRequest * SOAP_FMAC4 soap_get___ns4__modifyActivityLocationsRequest(struct soap *soap, struct __ns4__modifyActivityLocationsRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__modifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__modifyActivityLocationsRequest * FASTCALL soap_instantiate___ns4__modifyActivityLocationsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__modifyActivityLocationsRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__modifyActivityLocationsRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyActivityLocationsRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__modifyActivityLocationsRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyActivityLocationsRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__modifyActivityLocationsRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__modifyActivityLocationsRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__modifyActivityLocationsRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__modifyActivityLocationsRequest %p -> %p\n", q, p));
	*(struct __ns4__modifyActivityLocationsRequest*)p = *(struct __ns4__modifyActivityLocationsRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__modifyEnterpriseRequest(struct soap *soap, struct __ns4__modifyEnterpriseRequest *a)
{
	a->merc__modifyEnterpriseRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__modifyEnterpriseRequest(struct soap *soap, const struct __ns4__modifyEnterpriseRequest *a)
{
	soap_serialize_PointerTomerc__ModifyEnterpriseRequest(soap, &a->merc__modifyEnterpriseRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__modifyEnterpriseRequest(struct soap *soap, const char *tag, int id, const struct __ns4__modifyEnterpriseRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__ModifyEnterpriseRequest(soap, "merc:modifyEnterpriseRequest", -1, &a->merc__modifyEnterpriseRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyEnterpriseRequest * FASTCALL soap_in___ns4__modifyEnterpriseRequest(struct soap *soap, const char *tag, struct __ns4__modifyEnterpriseRequest *a, const char *type)
{
	size_t soap_flag_merc__modifyEnterpriseRequest = 1;
	short soap_flag;
	a = (struct __ns4__modifyEnterpriseRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__modifyEnterpriseRequest, sizeof(struct __ns4__modifyEnterpriseRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__modifyEnterpriseRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__modifyEnterpriseRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__ModifyEnterpriseRequest(soap, "merc:modifyEnterpriseRequest", &a->merc__modifyEnterpriseRequest, "merc:ModifyEnterpriseRequest"))
				{	soap_flag_merc__modifyEnterpriseRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__modifyEnterpriseRequest(struct soap *soap, const struct __ns4__modifyEnterpriseRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__modifyEnterpriseRequest(soap, tag?tag:"-ns4:modifyEnterpriseRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyEnterpriseRequest * SOAP_FMAC4 soap_get___ns4__modifyEnterpriseRequest(struct soap *soap, struct __ns4__modifyEnterpriseRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__modifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__modifyEnterpriseRequest * FASTCALL soap_instantiate___ns4__modifyEnterpriseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__modifyEnterpriseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__modifyEnterpriseRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyEnterpriseRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__modifyEnterpriseRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyEnterpriseRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__modifyEnterpriseRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__modifyEnterpriseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__modifyEnterpriseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__modifyEnterpriseRequest %p -> %p\n", q, p));
	*(struct __ns4__modifyEnterpriseRequest*)p = *(struct __ns4__modifyEnterpriseRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__modifyBusinessEntityRequest(struct soap *soap, struct __ns4__modifyBusinessEntityRequest *a)
{
	a->merc__modifyBusinessEntityRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__modifyBusinessEntityRequest(struct soap *soap, const struct __ns4__modifyBusinessEntityRequest *a)
{
	soap_serialize_PointerTomerc__ModifyBusinessEntityRequest(soap, &a->merc__modifyBusinessEntityRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__modifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, const struct __ns4__modifyBusinessEntityRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__ModifyBusinessEntityRequest(soap, "merc:modifyBusinessEntityRequest", -1, &a->merc__modifyBusinessEntityRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyBusinessEntityRequest * FASTCALL soap_in___ns4__modifyBusinessEntityRequest(struct soap *soap, const char *tag, struct __ns4__modifyBusinessEntityRequest *a, const char *type)
{
	size_t soap_flag_merc__modifyBusinessEntityRequest = 1;
	short soap_flag;
	a = (struct __ns4__modifyBusinessEntityRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__modifyBusinessEntityRequest, sizeof(struct __ns4__modifyBusinessEntityRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__modifyBusinessEntityRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__modifyBusinessEntityRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__ModifyBusinessEntityRequest(soap, "merc:modifyBusinessEntityRequest", &a->merc__modifyBusinessEntityRequest, "merc:ModifyBusinessEntityRequest"))
				{	soap_flag_merc__modifyBusinessEntityRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__modifyBusinessEntityRequest(struct soap *soap, const struct __ns4__modifyBusinessEntityRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__modifyBusinessEntityRequest(soap, tag?tag:"-ns4:modifyBusinessEntityRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__modifyBusinessEntityRequest * SOAP_FMAC4 soap_get___ns4__modifyBusinessEntityRequest(struct soap *soap, struct __ns4__modifyBusinessEntityRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__modifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__modifyBusinessEntityRequest * FASTCALL soap_instantiate___ns4__modifyBusinessEntityRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__modifyBusinessEntityRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__modifyBusinessEntityRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyBusinessEntityRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__modifyBusinessEntityRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__modifyBusinessEntityRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__modifyBusinessEntityRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__modifyBusinessEntityRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__modifyBusinessEntityRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__modifyBusinessEntityRequest %p -> %p\n", q, p));
	*(struct __ns4__modifyBusinessEntityRequest*)p = *(struct __ns4__modifyBusinessEntityRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__withdrawVetDocumentRequest(struct soap *soap, struct __ns4__withdrawVetDocumentRequest *a)
{
	a->merc__withdrawVetDocumentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__withdrawVetDocumentRequest(struct soap *soap, const struct __ns4__withdrawVetDocumentRequest *a)
{
	soap_serialize_PointerTomerc__WithdrawVetDocumentRequest(soap, &a->merc__withdrawVetDocumentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__withdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, const struct __ns4__withdrawVetDocumentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__WithdrawVetDocumentRequest(soap, "merc:withdrawVetDocumentRequest", -1, &a->merc__withdrawVetDocumentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__withdrawVetDocumentRequest * FASTCALL soap_in___ns4__withdrawVetDocumentRequest(struct soap *soap, const char *tag, struct __ns4__withdrawVetDocumentRequest *a, const char *type)
{
	size_t soap_flag_merc__withdrawVetDocumentRequest = 1;
	short soap_flag;
	a = (struct __ns4__withdrawVetDocumentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__withdrawVetDocumentRequest, sizeof(struct __ns4__withdrawVetDocumentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__withdrawVetDocumentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__withdrawVetDocumentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__WithdrawVetDocumentRequest(soap, "merc:withdrawVetDocumentRequest", &a->merc__withdrawVetDocumentRequest, "merc:WithdrawVetDocumentRequest"))
				{	soap_flag_merc__withdrawVetDocumentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__withdrawVetDocumentRequest(struct soap *soap, const struct __ns4__withdrawVetDocumentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__withdrawVetDocumentRequest(soap, tag?tag:"-ns4:withdrawVetDocumentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__withdrawVetDocumentRequest * SOAP_FMAC4 soap_get___ns4__withdrawVetDocumentRequest(struct soap *soap, struct __ns4__withdrawVetDocumentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__withdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__withdrawVetDocumentRequest * FASTCALL soap_instantiate___ns4__withdrawVetDocumentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__withdrawVetDocumentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__withdrawVetDocumentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__withdrawVetDocumentRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__withdrawVetDocumentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__withdrawVetDocumentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__withdrawVetDocumentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__withdrawVetDocumentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__withdrawVetDocumentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__withdrawVetDocumentRequest %p -> %p\n", q, p));
	*(struct __ns4__withdrawVetDocumentRequest*)p = *(struct __ns4__withdrawVetDocumentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__mergeStockEntriesRequest(struct soap *soap, struct __ns4__mergeStockEntriesRequest *a)
{
	a->merc__mergeStockEntriesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__mergeStockEntriesRequest(struct soap *soap, const struct __ns4__mergeStockEntriesRequest *a)
{
	soap_serialize_PointerTomerc__MergeStockEntriesRequest(soap, &a->merc__mergeStockEntriesRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__mergeStockEntriesRequest(struct soap *soap, const char *tag, int id, const struct __ns4__mergeStockEntriesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__MergeStockEntriesRequest(soap, "merc:mergeStockEntriesRequest", -1, &a->merc__mergeStockEntriesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__mergeStockEntriesRequest * FASTCALL soap_in___ns4__mergeStockEntriesRequest(struct soap *soap, const char *tag, struct __ns4__mergeStockEntriesRequest *a, const char *type)
{
	size_t soap_flag_merc__mergeStockEntriesRequest = 1;
	short soap_flag;
	a = (struct __ns4__mergeStockEntriesRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__mergeStockEntriesRequest, sizeof(struct __ns4__mergeStockEntriesRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__mergeStockEntriesRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__mergeStockEntriesRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__MergeStockEntriesRequest(soap, "merc:mergeStockEntriesRequest", &a->merc__mergeStockEntriesRequest, "merc:MergeStockEntriesRequest"))
				{	soap_flag_merc__mergeStockEntriesRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__mergeStockEntriesRequest(struct soap *soap, const struct __ns4__mergeStockEntriesRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__mergeStockEntriesRequest(soap, tag?tag:"-ns4:mergeStockEntriesRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__mergeStockEntriesRequest * SOAP_FMAC4 soap_get___ns4__mergeStockEntriesRequest(struct soap *soap, struct __ns4__mergeStockEntriesRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__mergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__mergeStockEntriesRequest * FASTCALL soap_instantiate___ns4__mergeStockEntriesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__mergeStockEntriesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__mergeStockEntriesRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__mergeStockEntriesRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__mergeStockEntriesRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__mergeStockEntriesRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__mergeStockEntriesRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__mergeStockEntriesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__mergeStockEntriesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__mergeStockEntriesRequest %p -> %p\n", q, p));
	*(struct __ns4__mergeStockEntriesRequest*)p = *(struct __ns4__mergeStockEntriesRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__registerProductionOperationRequest(struct soap *soap, struct __ns4__registerProductionOperationRequest *a)
{
	a->merc__registerProductionOperationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__registerProductionOperationRequest(struct soap *soap, const struct __ns4__registerProductionOperationRequest *a)
{
	soap_serialize_PointerTomerc__RegisterProductionOperationRequest(soap, &a->merc__registerProductionOperationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__registerProductionOperationRequest(struct soap *soap, const char *tag, int id, const struct __ns4__registerProductionOperationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__RegisterProductionOperationRequest(soap, "merc:registerProductionOperationRequest", -1, &a->merc__registerProductionOperationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__registerProductionOperationRequest * FASTCALL soap_in___ns4__registerProductionOperationRequest(struct soap *soap, const char *tag, struct __ns4__registerProductionOperationRequest *a, const char *type)
{
	size_t soap_flag_merc__registerProductionOperationRequest = 1;
	short soap_flag;
	a = (struct __ns4__registerProductionOperationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__registerProductionOperationRequest, sizeof(struct __ns4__registerProductionOperationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__registerProductionOperationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__registerProductionOperationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__RegisterProductionOperationRequest(soap, "merc:registerProductionOperationRequest", &a->merc__registerProductionOperationRequest, "merc:RegisterProductionOperationRequest"))
				{	soap_flag_merc__registerProductionOperationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__registerProductionOperationRequest(struct soap *soap, const struct __ns4__registerProductionOperationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__registerProductionOperationRequest(soap, tag?tag:"-ns4:registerProductionOperationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__registerProductionOperationRequest * SOAP_FMAC4 soap_get___ns4__registerProductionOperationRequest(struct soap *soap, struct __ns4__registerProductionOperationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__registerProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__registerProductionOperationRequest * FASTCALL soap_instantiate___ns4__registerProductionOperationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__registerProductionOperationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__registerProductionOperationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__registerProductionOperationRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__registerProductionOperationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__registerProductionOperationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__registerProductionOperationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__registerProductionOperationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__registerProductionOperationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__registerProductionOperationRequest %p -> %p\n", q, p));
	*(struct __ns4__registerProductionOperationRequest*)p = *(struct __ns4__registerProductionOperationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, struct __ns4__prepareOutgoingConsignmentRequest *a)
{
	a->merc__prepareOutgoingConsignmentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, const struct __ns4__prepareOutgoingConsignmentRequest *a)
{
	soap_serialize_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, &a->merc__prepareOutgoingConsignmentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, const struct __ns4__prepareOutgoingConsignmentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, "merc:prepareOutgoingConsignmentRequest", -1, &a->merc__prepareOutgoingConsignmentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__prepareOutgoingConsignmentRequest * FASTCALL soap_in___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, struct __ns4__prepareOutgoingConsignmentRequest *a, const char *type)
{
	size_t soap_flag_merc__prepareOutgoingConsignmentRequest = 1;
	short soap_flag;
	a = (struct __ns4__prepareOutgoingConsignmentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__prepareOutgoingConsignmentRequest, sizeof(struct __ns4__prepareOutgoingConsignmentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__prepareOutgoingConsignmentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__prepareOutgoingConsignmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, "merc:prepareOutgoingConsignmentRequest", &a->merc__prepareOutgoingConsignmentRequest, "merc:PrepareOutgoingConsignmentRequest"))
				{	soap_flag_merc__prepareOutgoingConsignmentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, const struct __ns4__prepareOutgoingConsignmentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__prepareOutgoingConsignmentRequest(soap, tag?tag:"-ns4:prepareOutgoingConsignmentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__prepareOutgoingConsignmentRequest * SOAP_FMAC4 soap_get___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, struct __ns4__prepareOutgoingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__prepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__prepareOutgoingConsignmentRequest * FASTCALL soap_instantiate___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__prepareOutgoingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__prepareOutgoingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__prepareOutgoingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__prepareOutgoingConsignmentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__prepareOutgoingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__prepareOutgoingConsignmentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__prepareOutgoingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__prepareOutgoingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__prepareOutgoingConsignmentRequest %p -> %p\n", q, p));
	*(struct __ns4__prepareOutgoingConsignmentRequest*)p = *(struct __ns4__prepareOutgoingConsignmentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__processIncomingConsignmentRequest(struct soap *soap, struct __ns4__processIncomingConsignmentRequest *a)
{
	a->merc__processIncomingConsignmentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__processIncomingConsignmentRequest(struct soap *soap, const struct __ns4__processIncomingConsignmentRequest *a)
{
	soap_serialize_PointerTomerc__ProcessIncomingConsignmentRequest(soap, &a->merc__processIncomingConsignmentRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns4__processIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, const struct __ns4__processIncomingConsignmentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTomerc__ProcessIncomingConsignmentRequest(soap, "merc:processIncomingConsignmentRequest", -1, &a->merc__processIncomingConsignmentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__processIncomingConsignmentRequest * FASTCALL soap_in___ns4__processIncomingConsignmentRequest(struct soap *soap, const char *tag, struct __ns4__processIncomingConsignmentRequest *a, const char *type)
{
	size_t soap_flag_merc__processIncomingConsignmentRequest = 1;
	short soap_flag;
	a = (struct __ns4__processIncomingConsignmentRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__processIncomingConsignmentRequest, sizeof(struct __ns4__processIncomingConsignmentRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns4__processIncomingConsignmentRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_merc__processIncomingConsignmentRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTomerc__ProcessIncomingConsignmentRequest(soap, "merc:processIncomingConsignmentRequest", &a->merc__processIncomingConsignmentRequest, "merc:ProcessIncomingConsignmentRequest"))
				{	soap_flag_merc__processIncomingConsignmentRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__processIncomingConsignmentRequest(struct soap *soap, const struct __ns4__processIncomingConsignmentRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns4__processIncomingConsignmentRequest(soap, tag?tag:"-ns4:processIncomingConsignmentRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns4__processIncomingConsignmentRequest * SOAP_FMAC4 soap_get___ns4__processIncomingConsignmentRequest(struct soap *soap, struct __ns4__processIncomingConsignmentRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns4__processIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__processIncomingConsignmentRequest * FASTCALL soap_instantiate___ns4__processIncomingConsignmentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__processIncomingConsignmentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__processIncomingConsignmentRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__processIncomingConsignmentRequest);
		ASSIGN_PTR(size, sizeof(struct __ns4__processIncomingConsignmentRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns4__processIncomingConsignmentRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns4__processIncomingConsignmentRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__processIncomingConsignmentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__processIncomingConsignmentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__processIncomingConsignmentRequest %p -> %p\n", q, p));
	*(struct __ns4__processIncomingConsignmentRequest*)p = *(struct __ns4__processIncomingConsignmentRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__receiveApplicationResult(struct soap *soap, struct __ns3__receiveApplicationResult *a)
{
	a->ws__receiveApplicationResultRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__receiveApplicationResult(struct soap *soap, const struct __ns3__receiveApplicationResult *a)
{
	soap_serialize_PointerTo_ws__receiveApplicationResultRequest(soap, &a->ws__receiveApplicationResultRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns3__receiveApplicationResult(struct soap *soap, const char *tag, int id, const struct __ns3__receiveApplicationResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ws__receiveApplicationResultRequest(soap, "ws:receiveApplicationResultRequest", -1, &a->ws__receiveApplicationResultRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__receiveApplicationResult * FASTCALL soap_in___ns3__receiveApplicationResult(struct soap *soap, const char *tag, struct __ns3__receiveApplicationResult *a, const char *type)
{
	size_t soap_flag_ws__receiveApplicationResultRequest = 1;
	short soap_flag;
	a = (struct __ns3__receiveApplicationResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__receiveApplicationResult, sizeof(struct __ns3__receiveApplicationResult), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns3__receiveApplicationResult(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ws__receiveApplicationResultRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ws__receiveApplicationResultRequest(soap, "ws:receiveApplicationResultRequest", &a->ws__receiveApplicationResultRequest, ""))
				{	soap_flag_ws__receiveApplicationResultRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__receiveApplicationResult(struct soap *soap, const struct __ns3__receiveApplicationResult *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns3__receiveApplicationResult(soap, tag?tag:"-ns3:receiveApplicationResult", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns3__receiveApplicationResult * SOAP_FMAC4 soap_get___ns3__receiveApplicationResult(struct soap *soap, struct __ns3__receiveApplicationResult *p, const char *tag, const char *type)
{
	if((p = soap_in___ns3__receiveApplicationResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__receiveApplicationResult * FASTCALL soap_instantiate___ns3__receiveApplicationResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__receiveApplicationResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__receiveApplicationResult, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns3__receiveApplicationResult);
		ASSIGN_PTR(size, sizeof(struct __ns3__receiveApplicationResult));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns3__receiveApplicationResult[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns3__receiveApplicationResult));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__receiveApplicationResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__receiveApplicationResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__receiveApplicationResult %p -> %p\n", q, p));
	*(struct __ns3__receiveApplicationResult*)p = *(struct __ns3__receiveApplicationResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__submitApplicationRequest(struct soap *soap, struct __ns3__submitApplicationRequest *a)
{
	a->ws__submitApplicationRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__submitApplicationRequest(struct soap *soap, const struct __ns3__submitApplicationRequest *a)
{
	soap_serialize_PointerTo_ws__submitApplicationRequest(soap, &a->ws__submitApplicationRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns3__submitApplicationRequest(struct soap *soap, const char *tag, int id, const struct __ns3__submitApplicationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ws__submitApplicationRequest(soap, "ws:submitApplicationRequest", -1, &a->ws__submitApplicationRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__submitApplicationRequest * FASTCALL soap_in___ns3__submitApplicationRequest(struct soap *soap, const char *tag, struct __ns3__submitApplicationRequest *a, const char *type)
{
	size_t soap_flag_ws__submitApplicationRequest = 1;
	short soap_flag;
	a = (struct __ns3__submitApplicationRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__submitApplicationRequest, sizeof(struct __ns3__submitApplicationRequest), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns3__submitApplicationRequest(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ws__submitApplicationRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ws__submitApplicationRequest(soap, "ws:submitApplicationRequest", &a->ws__submitApplicationRequest, ""))
				{	soap_flag_ws__submitApplicationRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__submitApplicationRequest(struct soap *soap, const struct __ns3__submitApplicationRequest *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns3__submitApplicationRequest(soap, tag?tag:"-ns3:submitApplicationRequest", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns3__submitApplicationRequest * SOAP_FMAC4 soap_get___ns3__submitApplicationRequest(struct soap *soap, struct __ns3__submitApplicationRequest *p, const char *tag, const char *type)
{
	if((p = soap_in___ns3__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns3__submitApplicationRequest * FASTCALL soap_instantiate___ns3__submitApplicationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__submitApplicationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__submitApplicationRequest, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns3__submitApplicationRequest);
		ASSIGN_PTR(size, sizeof(struct __ns3__submitApplicationRequest));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns3__submitApplicationRequest[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns3__submitApplicationRequest));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__submitApplicationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__submitApplicationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__submitApplicationRequest %p -> %p\n", q, p));
	*(struct __ns3__submitApplicationRequest*)p = *(struct __ns3__submitApplicationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductItemChangesList(struct soap *soap, struct __ns2__GetProductItemChangesList *a)
{
	a->ns8__getProductItemChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductItemChangesList(struct soap *soap, const struct __ns2__GetProductItemChangesList *a)
{
	soap_serialize_PointerTo_ns8__getProductItemChangesListRequest(soap, &a->ns8__getProductItemChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductItemChangesList(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductItemChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductItemChangesListRequest(soap, "ns8:getProductItemChangesListRequest", -1, &a->ns8__getProductItemChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemChangesList * FASTCALL soap_in___ns2__GetProductItemChangesList(struct soap *soap, const char *tag, struct __ns2__GetProductItemChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getProductItemChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductItemChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductItemChangesList, sizeof(struct __ns2__GetProductItemChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductItemChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductItemChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductItemChangesListRequest(soap, "ns8:getProductItemChangesListRequest", &a->ns8__getProductItemChangesListRequest, ""))
				{	soap_flag_ns8__getProductItemChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductItemChangesList(struct soap *soap, const struct __ns2__GetProductItemChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductItemChangesList(soap, tag?tag:"-ns2:GetProductItemChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemChangesList * SOAP_FMAC4 soap_get___ns2__GetProductItemChangesList(struct soap *soap, struct __ns2__GetProductItemChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductItemChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductItemChangesList * FASTCALL soap_instantiate___ns2__GetProductItemChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductItemChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductItemChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductItemChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductItemChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductItemChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductItemChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductItemChangesList %p -> %p\n", q, p));
	*(struct __ns2__GetProductItemChangesList*)p = *(struct __ns2__GetProductItemChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductItemList(struct soap *soap, struct __ns2__GetProductItemList *a)
{
	a->ns8__getProductItemListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductItemList(struct soap *soap, const struct __ns2__GetProductItemList *a)
{
	soap_serialize_PointerTo_ns8__getProductItemListRequest(soap, &a->ns8__getProductItemListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductItemList(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductItemList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductItemListRequest(soap, "ns8:getProductItemListRequest", -1, &a->ns8__getProductItemListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemList * FASTCALL soap_in___ns2__GetProductItemList(struct soap *soap, const char *tag, struct __ns2__GetProductItemList *a, const char *type)
{
	size_t soap_flag_ns8__getProductItemListRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductItemList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductItemList, sizeof(struct __ns2__GetProductItemList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductItemList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductItemListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductItemListRequest(soap, "ns8:getProductItemListRequest", &a->ns8__getProductItemListRequest, ""))
				{	soap_flag_ns8__getProductItemListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductItemList(struct soap *soap, const struct __ns2__GetProductItemList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductItemList(soap, tag?tag:"-ns2:GetProductItemList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemList * SOAP_FMAC4 soap_get___ns2__GetProductItemList(struct soap *soap, struct __ns2__GetProductItemList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductItemList * FASTCALL soap_instantiate___ns2__GetProductItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductItemList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemList);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductItemList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductItemList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductItemList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductItemList %p -> %p\n", q, p));
	*(struct __ns2__GetProductItemList*)p = *(struct __ns2__GetProductItemList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductItemByUuid(struct soap *soap, struct __ns2__GetProductItemByUuid *a)
{
	a->ns8__getProductItemByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductItemByUuid(struct soap *soap, const struct __ns2__GetProductItemByUuid *a)
{
	soap_serialize_PointerTo_ns8__getProductItemByUuidRequest(soap, &a->ns8__getProductItemByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductItemByUuid(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductItemByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductItemByUuidRequest(soap, "ns8:getProductItemByUuidRequest", -1, &a->ns8__getProductItemByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemByUuid * FASTCALL soap_in___ns2__GetProductItemByUuid(struct soap *soap, const char *tag, struct __ns2__GetProductItemByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getProductItemByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductItemByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductItemByUuid, sizeof(struct __ns2__GetProductItemByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductItemByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductItemByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductItemByUuidRequest(soap, "ns8:getProductItemByUuidRequest", &a->ns8__getProductItemByUuidRequest, ""))
				{	soap_flag_ns8__getProductItemByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductItemByUuid(struct soap *soap, const struct __ns2__GetProductItemByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductItemByUuid(soap, tag?tag:"-ns2:GetProductItemByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemByUuid * SOAP_FMAC4 soap_get___ns2__GetProductItemByUuid(struct soap *soap, struct __ns2__GetProductItemByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductItemByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductItemByUuid * FASTCALL soap_instantiate___ns2__GetProductItemByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductItemByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductItemByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductItemByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductItemByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductItemByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductItemByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductItemByUuid %p -> %p\n", q, p));
	*(struct __ns2__GetProductItemByUuid*)p = *(struct __ns2__GetProductItemByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductItemByGuid(struct soap *soap, struct __ns2__GetProductItemByGuid *a)
{
	a->ns8__getProductItemByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductItemByGuid(struct soap *soap, const struct __ns2__GetProductItemByGuid *a)
{
	soap_serialize_PointerTo_ns8__getProductItemByGuidRequest(soap, &a->ns8__getProductItemByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductItemByGuid(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductItemByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductItemByGuidRequest(soap, "ns8:getProductItemByGuidRequest", -1, &a->ns8__getProductItemByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemByGuid * FASTCALL soap_in___ns2__GetProductItemByGuid(struct soap *soap, const char *tag, struct __ns2__GetProductItemByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getProductItemByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductItemByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductItemByGuid, sizeof(struct __ns2__GetProductItemByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductItemByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductItemByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductItemByGuidRequest(soap, "ns8:getProductItemByGuidRequest", &a->ns8__getProductItemByGuidRequest, ""))
				{	soap_flag_ns8__getProductItemByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductItemByGuid(struct soap *soap, const struct __ns2__GetProductItemByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductItemByGuid(soap, tag?tag:"-ns2:GetProductItemByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductItemByGuid * SOAP_FMAC4 soap_get___ns2__GetProductItemByGuid(struct soap *soap, struct __ns2__GetProductItemByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductItemByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductItemByGuid * FASTCALL soap_instantiate___ns2__GetProductItemByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductItemByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductItemByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductItemByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductItemByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductItemByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductItemByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductItemByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductItemByGuid %p -> %p\n", q, p));
	*(struct __ns2__GetProductItemByGuid*)p = *(struct __ns2__GetProductItemByGuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetSubProductChangesList(struct soap *soap, struct __ns2__GetSubProductChangesList *a)
{
	a->ns8__getSubProductChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetSubProductChangesList(struct soap *soap, const struct __ns2__GetSubProductChangesList *a)
{
	soap_serialize_PointerTo_ns8__getSubProductChangesListRequest(soap, &a->ns8__getSubProductChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetSubProductChangesList(struct soap *soap, const char *tag, int id, const struct __ns2__GetSubProductChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getSubProductChangesListRequest(soap, "ns8:getSubProductChangesListRequest", -1, &a->ns8__getSubProductChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductChangesList * FASTCALL soap_in___ns2__GetSubProductChangesList(struct soap *soap, const char *tag, struct __ns2__GetSubProductChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getSubProductChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetSubProductChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetSubProductChangesList, sizeof(struct __ns2__GetSubProductChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetSubProductChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getSubProductChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getSubProductChangesListRequest(soap, "ns8:getSubProductChangesListRequest", &a->ns8__getSubProductChangesListRequest, ""))
				{	soap_flag_ns8__getSubProductChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetSubProductChangesList(struct soap *soap, const struct __ns2__GetSubProductChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetSubProductChangesList(soap, tag?tag:"-ns2:GetSubProductChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductChangesList * SOAP_FMAC4 soap_get___ns2__GetSubProductChangesList(struct soap *soap, struct __ns2__GetSubProductChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetSubProductChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetSubProductChangesList * FASTCALL soap_instantiate___ns2__GetSubProductChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetSubProductChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetSubProductChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetSubProductChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetSubProductChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetSubProductChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetSubProductChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetSubProductChangesList %p -> %p\n", q, p));
	*(struct __ns2__GetSubProductChangesList*)p = *(struct __ns2__GetSubProductChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetSubProductByProductList(struct soap *soap, struct __ns2__GetSubProductByProductList *a)
{
	a->ns8__getSubProductByProductListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetSubProductByProductList(struct soap *soap, const struct __ns2__GetSubProductByProductList *a)
{
	soap_serialize_PointerTo_ns8__getSubProductByProductListRequest(soap, &a->ns8__getSubProductByProductListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetSubProductByProductList(struct soap *soap, const char *tag, int id, const struct __ns2__GetSubProductByProductList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getSubProductByProductListRequest(soap, "ns8:getSubProductByProductListRequest", -1, &a->ns8__getSubProductByProductListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductByProductList * FASTCALL soap_in___ns2__GetSubProductByProductList(struct soap *soap, const char *tag, struct __ns2__GetSubProductByProductList *a, const char *type)
{
	size_t soap_flag_ns8__getSubProductByProductListRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetSubProductByProductList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetSubProductByProductList, sizeof(struct __ns2__GetSubProductByProductList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetSubProductByProductList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getSubProductByProductListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getSubProductByProductListRequest(soap, "ns8:getSubProductByProductListRequest", &a->ns8__getSubProductByProductListRequest, ""))
				{	soap_flag_ns8__getSubProductByProductListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetSubProductByProductList(struct soap *soap, const struct __ns2__GetSubProductByProductList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetSubProductByProductList(soap, tag?tag:"-ns2:GetSubProductByProductList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductByProductList * SOAP_FMAC4 soap_get___ns2__GetSubProductByProductList(struct soap *soap, struct __ns2__GetSubProductByProductList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetSubProductByProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetSubProductByProductList * FASTCALL soap_instantiate___ns2__GetSubProductByProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetSubProductByProductList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetSubProductByProductList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductByProductList);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetSubProductByProductList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductByProductList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetSubProductByProductList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetSubProductByProductList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetSubProductByProductList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetSubProductByProductList %p -> %p\n", q, p));
	*(struct __ns2__GetSubProductByProductList*)p = *(struct __ns2__GetSubProductByProductList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetSubProductByUuid(struct soap *soap, struct __ns2__GetSubProductByUuid *a)
{
	a->ns8__getSubProductByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetSubProductByUuid(struct soap *soap, const struct __ns2__GetSubProductByUuid *a)
{
	soap_serialize_PointerTo_ns8__getSubProductByUuidRequest(soap, &a->ns8__getSubProductByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetSubProductByUuid(struct soap *soap, const char *tag, int id, const struct __ns2__GetSubProductByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getSubProductByUuidRequest(soap, "ns8:getSubProductByUuidRequest", -1, &a->ns8__getSubProductByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductByUuid * FASTCALL soap_in___ns2__GetSubProductByUuid(struct soap *soap, const char *tag, struct __ns2__GetSubProductByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getSubProductByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetSubProductByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetSubProductByUuid, sizeof(struct __ns2__GetSubProductByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetSubProductByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getSubProductByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getSubProductByUuidRequest(soap, "ns8:getSubProductByUuidRequest", &a->ns8__getSubProductByUuidRequest, ""))
				{	soap_flag_ns8__getSubProductByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetSubProductByUuid(struct soap *soap, const struct __ns2__GetSubProductByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetSubProductByUuid(soap, tag?tag:"-ns2:GetSubProductByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductByUuid * SOAP_FMAC4 soap_get___ns2__GetSubProductByUuid(struct soap *soap, struct __ns2__GetSubProductByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetSubProductByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetSubProductByUuid * FASTCALL soap_instantiate___ns2__GetSubProductByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetSubProductByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetSubProductByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetSubProductByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetSubProductByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetSubProductByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetSubProductByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetSubProductByUuid %p -> %p\n", q, p));
	*(struct __ns2__GetSubProductByUuid*)p = *(struct __ns2__GetSubProductByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetSubProductByGuid(struct soap *soap, struct __ns2__GetSubProductByGuid *a)
{
	a->ns8__getSubProductByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetSubProductByGuid(struct soap *soap, const struct __ns2__GetSubProductByGuid *a)
{
	soap_serialize_PointerTo_ns8__getSubProductByGuidRequest(soap, &a->ns8__getSubProductByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetSubProductByGuid(struct soap *soap, const char *tag, int id, const struct __ns2__GetSubProductByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getSubProductByGuidRequest(soap, "ns8:getSubProductByGuidRequest", -1, &a->ns8__getSubProductByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductByGuid * FASTCALL soap_in___ns2__GetSubProductByGuid(struct soap *soap, const char *tag, struct __ns2__GetSubProductByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getSubProductByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetSubProductByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetSubProductByGuid, sizeof(struct __ns2__GetSubProductByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetSubProductByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getSubProductByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getSubProductByGuidRequest(soap, "ns8:getSubProductByGuidRequest", &a->ns8__getSubProductByGuidRequest, ""))
				{	soap_flag_ns8__getSubProductByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetSubProductByGuid(struct soap *soap, const struct __ns2__GetSubProductByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetSubProductByGuid(soap, tag?tag:"-ns2:GetSubProductByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSubProductByGuid * SOAP_FMAC4 soap_get___ns2__GetSubProductByGuid(struct soap *soap, struct __ns2__GetSubProductByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetSubProductByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetSubProductByGuid * FASTCALL soap_instantiate___ns2__GetSubProductByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetSubProductByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetSubProductByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetSubProductByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSubProductByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetSubProductByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetSubProductByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetSubProductByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetSubProductByGuid %p -> %p\n", q, p));
	*(struct __ns2__GetSubProductByGuid*)p = *(struct __ns2__GetSubProductByGuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductChangesList(struct soap *soap, struct __ns2__GetProductChangesList *a)
{
	a->ns8__getProductChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductChangesList(struct soap *soap, const struct __ns2__GetProductChangesList *a)
{
	soap_serialize_PointerTo_ns8__getProductChangesListRequest(soap, &a->ns8__getProductChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductChangesList(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductChangesListRequest(soap, "ns8:getProductChangesListRequest", -1, &a->ns8__getProductChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductChangesList * FASTCALL soap_in___ns2__GetProductChangesList(struct soap *soap, const char *tag, struct __ns2__GetProductChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getProductChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductChangesList, sizeof(struct __ns2__GetProductChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductChangesListRequest(soap, "ns8:getProductChangesListRequest", &a->ns8__getProductChangesListRequest, ""))
				{	soap_flag_ns8__getProductChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductChangesList(struct soap *soap, const struct __ns2__GetProductChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductChangesList(soap, tag?tag:"-ns2:GetProductChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductChangesList * SOAP_FMAC4 soap_get___ns2__GetProductChangesList(struct soap *soap, struct __ns2__GetProductChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductChangesList * FASTCALL soap_instantiate___ns2__GetProductChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductChangesList %p -> %p\n", q, p));
	*(struct __ns2__GetProductChangesList*)p = *(struct __ns2__GetProductChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductByTypeList(struct soap *soap, struct __ns2__GetProductByTypeList *a)
{
	a->ns8__getProductByTypeListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductByTypeList(struct soap *soap, const struct __ns2__GetProductByTypeList *a)
{
	soap_serialize_PointerTo_ns8__getProductByTypeListRequest(soap, &a->ns8__getProductByTypeListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductByTypeList(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductByTypeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductByTypeListRequest(soap, "ns8:getProductByTypeListRequest", -1, &a->ns8__getProductByTypeListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductByTypeList * FASTCALL soap_in___ns2__GetProductByTypeList(struct soap *soap, const char *tag, struct __ns2__GetProductByTypeList *a, const char *type)
{
	size_t soap_flag_ns8__getProductByTypeListRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductByTypeList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductByTypeList, sizeof(struct __ns2__GetProductByTypeList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductByTypeList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductByTypeListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductByTypeListRequest(soap, "ns8:getProductByTypeListRequest", &a->ns8__getProductByTypeListRequest, ""))
				{	soap_flag_ns8__getProductByTypeListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductByTypeList(struct soap *soap, const struct __ns2__GetProductByTypeList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductByTypeList(soap, tag?tag:"-ns2:GetProductByTypeList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductByTypeList * SOAP_FMAC4 soap_get___ns2__GetProductByTypeList(struct soap *soap, struct __ns2__GetProductByTypeList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductByTypeList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductByTypeList * FASTCALL soap_instantiate___ns2__GetProductByTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductByTypeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductByTypeList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductByTypeList);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductByTypeList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductByTypeList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductByTypeList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductByTypeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductByTypeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductByTypeList %p -> %p\n", q, p));
	*(struct __ns2__GetProductByTypeList*)p = *(struct __ns2__GetProductByTypeList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductByUuid(struct soap *soap, struct __ns2__GetProductByUuid *a)
{
	a->ns8__getProductByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductByUuid(struct soap *soap, const struct __ns2__GetProductByUuid *a)
{
	soap_serialize_PointerTo_ns8__getProductByUuidRequest(soap, &a->ns8__getProductByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductByUuid(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductByUuidRequest(soap, "ns8:getProductByUuidRequest", -1, &a->ns8__getProductByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductByUuid * FASTCALL soap_in___ns2__GetProductByUuid(struct soap *soap, const char *tag, struct __ns2__GetProductByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getProductByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductByUuid, sizeof(struct __ns2__GetProductByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductByUuidRequest(soap, "ns8:getProductByUuidRequest", &a->ns8__getProductByUuidRequest, ""))
				{	soap_flag_ns8__getProductByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductByUuid(struct soap *soap, const struct __ns2__GetProductByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductByUuid(soap, tag?tag:"-ns2:GetProductByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductByUuid * SOAP_FMAC4 soap_get___ns2__GetProductByUuid(struct soap *soap, struct __ns2__GetProductByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductByUuid * FASTCALL soap_instantiate___ns2__GetProductByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductByUuid %p -> %p\n", q, p));
	*(struct __ns2__GetProductByUuid*)p = *(struct __ns2__GetProductByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetProductByGuid(struct soap *soap, struct __ns2__GetProductByGuid *a)
{
	a->ns8__getProductByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetProductByGuid(struct soap *soap, const struct __ns2__GetProductByGuid *a)
{
	soap_serialize_PointerTo_ns8__getProductByGuidRequest(soap, &a->ns8__getProductByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns2__GetProductByGuid(struct soap *soap, const char *tag, int id, const struct __ns2__GetProductByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getProductByGuidRequest(soap, "ns8:getProductByGuidRequest", -1, &a->ns8__getProductByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductByGuid * FASTCALL soap_in___ns2__GetProductByGuid(struct soap *soap, const char *tag, struct __ns2__GetProductByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getProductByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns2__GetProductByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetProductByGuid, sizeof(struct __ns2__GetProductByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns2__GetProductByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getProductByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getProductByGuidRequest(soap, "ns8:getProductByGuidRequest", &a->ns8__getProductByGuidRequest, ""))
				{	soap_flag_ns8__getProductByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetProductByGuid(struct soap *soap, const struct __ns2__GetProductByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns2__GetProductByGuid(soap, tag?tag:"-ns2:GetProductByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetProductByGuid * SOAP_FMAC4 soap_get___ns2__GetProductByGuid(struct soap *soap, struct __ns2__GetProductByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns2__GetProductByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetProductByGuid * FASTCALL soap_instantiate___ns2__GetProductByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetProductByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetProductByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns2__GetProductByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns2__GetProductByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns2__GetProductByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetProductByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetProductByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetProductByGuid %p -> %p\n", q, p));
	*(struct __ns2__GetProductByGuid*)p = *(struct __ns2__GetProductByGuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetActivityLocationList(struct soap *soap, struct __ns1__GetActivityLocationList *a)
{
	a->ns8__getActivityLocationListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetActivityLocationList(struct soap *soap, const struct __ns1__GetActivityLocationList *a)
{
	soap_serialize_PointerTo_ns8__getActivityLocationListRequest(soap, &a->ns8__getActivityLocationListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetActivityLocationList(struct soap *soap, const char *tag, int id, const struct __ns1__GetActivityLocationList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getActivityLocationListRequest(soap, "ns8:getActivityLocationListRequest", -1, &a->ns8__getActivityLocationListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetActivityLocationList * FASTCALL soap_in___ns1__GetActivityLocationList(struct soap *soap, const char *tag, struct __ns1__GetActivityLocationList *a, const char *type)
{
	size_t soap_flag_ns8__getActivityLocationListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetActivityLocationList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetActivityLocationList, sizeof(struct __ns1__GetActivityLocationList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetActivityLocationList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getActivityLocationListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getActivityLocationListRequest(soap, "ns8:getActivityLocationListRequest", &a->ns8__getActivityLocationListRequest, ""))
				{	soap_flag_ns8__getActivityLocationListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetActivityLocationList(struct soap *soap, const struct __ns1__GetActivityLocationList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetActivityLocationList(soap, tag?tag:"-ns1:GetActivityLocationList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetActivityLocationList * SOAP_FMAC4 soap_get___ns1__GetActivityLocationList(struct soap *soap, struct __ns1__GetActivityLocationList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetActivityLocationList * FASTCALL soap_instantiate___ns1__GetActivityLocationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetActivityLocationList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetActivityLocationList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetActivityLocationList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetActivityLocationList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetActivityLocationList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetActivityLocationList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetActivityLocationList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetActivityLocationList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetActivityLocationList %p -> %p\n", q, p));
	*(struct __ns1__GetActivityLocationList*)p = *(struct __ns1__GetActivityLocationList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBusinessMemberByGLN(struct soap *soap, struct __ns1__GetBusinessMemberByGLN *a)
{
	a->ns8__getBusinessMemberByGLNRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBusinessMemberByGLN(struct soap *soap, const struct __ns1__GetBusinessMemberByGLN *a)
{
	soap_serialize_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, &a->ns8__getBusinessMemberByGLNRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetBusinessMemberByGLN(struct soap *soap, const char *tag, int id, const struct __ns1__GetBusinessMemberByGLN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, "ns8:getBusinessMemberByGLNRequest", -1, &a->ns8__getBusinessMemberByGLNRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessMemberByGLN * FASTCALL soap_in___ns1__GetBusinessMemberByGLN(struct soap *soap, const char *tag, struct __ns1__GetBusinessMemberByGLN *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessMemberByGLNRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetBusinessMemberByGLN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBusinessMemberByGLN, sizeof(struct __ns1__GetBusinessMemberByGLN), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetBusinessMemberByGLN(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessMemberByGLNRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, "ns8:getBusinessMemberByGLNRequest", &a->ns8__getBusinessMemberByGLNRequest, ""))
				{	soap_flag_ns8__getBusinessMemberByGLNRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBusinessMemberByGLN(struct soap *soap, const struct __ns1__GetBusinessMemberByGLN *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetBusinessMemberByGLN(soap, tag?tag:"-ns1:GetBusinessMemberByGLN", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessMemberByGLN * SOAP_FMAC4 soap_get___ns1__GetBusinessMemberByGLN(struct soap *soap, struct __ns1__GetBusinessMemberByGLN *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetBusinessMemberByGLN(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBusinessMemberByGLN * FASTCALL soap_instantiate___ns1__GetBusinessMemberByGLN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBusinessMemberByGLN(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBusinessMemberByGLN, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessMemberByGLN);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetBusinessMemberByGLN));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessMemberByGLN[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetBusinessMemberByGLN));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBusinessMemberByGLN*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBusinessMemberByGLN(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBusinessMemberByGLN %p -> %p\n", q, p));
	*(struct __ns1__GetBusinessMemberByGLN*)p = *(struct __ns1__GetBusinessMemberByGLN*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRussianEnterpriseChangesList(struct soap *soap, struct __ns1__GetRussianEnterpriseChangesList *a)
{
	a->ns8__getRussianEnterpriseChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRussianEnterpriseChangesList(struct soap *soap, const struct __ns1__GetRussianEnterpriseChangesList *a)
{
	soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, &a->ns8__getRussianEnterpriseChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetRussianEnterpriseChangesList(struct soap *soap, const char *tag, int id, const struct __ns1__GetRussianEnterpriseChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, "ns8:getRussianEnterpriseChangesListRequest", -1, &a->ns8__getRussianEnterpriseChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRussianEnterpriseChangesList * FASTCALL soap_in___ns1__GetRussianEnterpriseChangesList(struct soap *soap, const char *tag, struct __ns1__GetRussianEnterpriseChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getRussianEnterpriseChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetRussianEnterpriseChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRussianEnterpriseChangesList, sizeof(struct __ns1__GetRussianEnterpriseChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetRussianEnterpriseChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getRussianEnterpriseChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, "ns8:getRussianEnterpriseChangesListRequest", &a->ns8__getRussianEnterpriseChangesListRequest, ""))
				{	soap_flag_ns8__getRussianEnterpriseChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRussianEnterpriseChangesList(struct soap *soap, const struct __ns1__GetRussianEnterpriseChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetRussianEnterpriseChangesList(soap, tag?tag:"-ns1:GetRussianEnterpriseChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRussianEnterpriseChangesList * SOAP_FMAC4 soap_get___ns1__GetRussianEnterpriseChangesList(struct soap *soap, struct __ns1__GetRussianEnterpriseChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetRussianEnterpriseChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRussianEnterpriseChangesList * FASTCALL soap_instantiate___ns1__GetRussianEnterpriseChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRussianEnterpriseChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRussianEnterpriseChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRussianEnterpriseChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetRussianEnterpriseChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRussianEnterpriseChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetRussianEnterpriseChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetRussianEnterpriseChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRussianEnterpriseChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRussianEnterpriseChangesList %p -> %p\n", q, p));
	*(struct __ns1__GetRussianEnterpriseChangesList*)p = *(struct __ns1__GetRussianEnterpriseChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetForeignEnterpriseChangesList(struct soap *soap, struct __ns1__GetForeignEnterpriseChangesList *a)
{
	a->ns8__getForeignEnterpriseChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetForeignEnterpriseChangesList(struct soap *soap, const struct __ns1__GetForeignEnterpriseChangesList *a)
{
	soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, &a->ns8__getForeignEnterpriseChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetForeignEnterpriseChangesList(struct soap *soap, const char *tag, int id, const struct __ns1__GetForeignEnterpriseChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, "ns8:getForeignEnterpriseChangesListRequest", -1, &a->ns8__getForeignEnterpriseChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetForeignEnterpriseChangesList * FASTCALL soap_in___ns1__GetForeignEnterpriseChangesList(struct soap *soap, const char *tag, struct __ns1__GetForeignEnterpriseChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getForeignEnterpriseChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetForeignEnterpriseChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetForeignEnterpriseChangesList, sizeof(struct __ns1__GetForeignEnterpriseChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetForeignEnterpriseChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getForeignEnterpriseChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, "ns8:getForeignEnterpriseChangesListRequest", &a->ns8__getForeignEnterpriseChangesListRequest, ""))
				{	soap_flag_ns8__getForeignEnterpriseChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetForeignEnterpriseChangesList(struct soap *soap, const struct __ns1__GetForeignEnterpriseChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetForeignEnterpriseChangesList(soap, tag?tag:"-ns1:GetForeignEnterpriseChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetForeignEnterpriseChangesList * SOAP_FMAC4 soap_get___ns1__GetForeignEnterpriseChangesList(struct soap *soap, struct __ns1__GetForeignEnterpriseChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetForeignEnterpriseChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetForeignEnterpriseChangesList * FASTCALL soap_instantiate___ns1__GetForeignEnterpriseChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetForeignEnterpriseChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetForeignEnterpriseChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetForeignEnterpriseChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetForeignEnterpriseChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetForeignEnterpriseChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetForeignEnterpriseChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetForeignEnterpriseChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetForeignEnterpriseChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetForeignEnterpriseChangesList %p -> %p\n", q, p));
	*(struct __ns1__GetForeignEnterpriseChangesList*)p = *(struct __ns1__GetForeignEnterpriseChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRussianEnterpriseList(struct soap *soap, struct __ns1__GetRussianEnterpriseList *a)
{
	a->ns8__getRussianEnterpriseListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRussianEnterpriseList(struct soap *soap, const struct __ns1__GetRussianEnterpriseList *a)
{
	soap_serialize_PointerTo_ns8__getRussianEnterpriseListRequest(soap, &a->ns8__getRussianEnterpriseListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetRussianEnterpriseList(struct soap *soap, const char *tag, int id, const struct __ns1__GetRussianEnterpriseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(soap, "ns8:getRussianEnterpriseListRequest", -1, &a->ns8__getRussianEnterpriseListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRussianEnterpriseList * FASTCALL soap_in___ns1__GetRussianEnterpriseList(struct soap *soap, const char *tag, struct __ns1__GetRussianEnterpriseList *a, const char *type)
{
	size_t soap_flag_ns8__getRussianEnterpriseListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetRussianEnterpriseList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRussianEnterpriseList, sizeof(struct __ns1__GetRussianEnterpriseList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetRussianEnterpriseList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getRussianEnterpriseListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(soap, "ns8:getRussianEnterpriseListRequest", &a->ns8__getRussianEnterpriseListRequest, ""))
				{	soap_flag_ns8__getRussianEnterpriseListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRussianEnterpriseList(struct soap *soap, const struct __ns1__GetRussianEnterpriseList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetRussianEnterpriseList(soap, tag?tag:"-ns1:GetRussianEnterpriseList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRussianEnterpriseList * SOAP_FMAC4 soap_get___ns1__GetRussianEnterpriseList(struct soap *soap, struct __ns1__GetRussianEnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetRussianEnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRussianEnterpriseList * FASTCALL soap_instantiate___ns1__GetRussianEnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRussianEnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRussianEnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRussianEnterpriseList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetRussianEnterpriseList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRussianEnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetRussianEnterpriseList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetRussianEnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRussianEnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRussianEnterpriseList %p -> %p\n", q, p));
	*(struct __ns1__GetRussianEnterpriseList*)p = *(struct __ns1__GetRussianEnterpriseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetForeignEnterpriseList(struct soap *soap, struct __ns1__GetForeignEnterpriseList *a)
{
	a->ns8__getForeignEnterpriseListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetForeignEnterpriseList(struct soap *soap, const struct __ns1__GetForeignEnterpriseList *a)
{
	soap_serialize_PointerTo_ns8__getForeignEnterpriseListRequest(soap, &a->ns8__getForeignEnterpriseListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetForeignEnterpriseList(struct soap *soap, const char *tag, int id, const struct __ns1__GetForeignEnterpriseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(soap, "ns8:getForeignEnterpriseListRequest", -1, &a->ns8__getForeignEnterpriseListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetForeignEnterpriseList * FASTCALL soap_in___ns1__GetForeignEnterpriseList(struct soap *soap, const char *tag, struct __ns1__GetForeignEnterpriseList *a, const char *type)
{
	size_t soap_flag_ns8__getForeignEnterpriseListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetForeignEnterpriseList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetForeignEnterpriseList, sizeof(struct __ns1__GetForeignEnterpriseList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetForeignEnterpriseList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getForeignEnterpriseListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(soap, "ns8:getForeignEnterpriseListRequest", &a->ns8__getForeignEnterpriseListRequest, ""))
				{	soap_flag_ns8__getForeignEnterpriseListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetForeignEnterpriseList(struct soap *soap, const struct __ns1__GetForeignEnterpriseList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetForeignEnterpriseList(soap, tag?tag:"-ns1:GetForeignEnterpriseList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetForeignEnterpriseList * SOAP_FMAC4 soap_get___ns1__GetForeignEnterpriseList(struct soap *soap, struct __ns1__GetForeignEnterpriseList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetForeignEnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetForeignEnterpriseList * FASTCALL soap_instantiate___ns1__GetForeignEnterpriseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetForeignEnterpriseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetForeignEnterpriseList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetForeignEnterpriseList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetForeignEnterpriseList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetForeignEnterpriseList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetForeignEnterpriseList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetForeignEnterpriseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetForeignEnterpriseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetForeignEnterpriseList %p -> %p\n", q, p));
	*(struct __ns1__GetForeignEnterpriseList*)p = *(struct __ns1__GetForeignEnterpriseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEnterpriseByUuid(struct soap *soap, struct __ns1__GetEnterpriseByUuid *a)
{
	a->ns8__getEnterpriseByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEnterpriseByUuid(struct soap *soap, const struct __ns1__GetEnterpriseByUuid *a)
{
	soap_serialize_PointerTo_ns8__getEnterpriseByUuidRequest(soap, &a->ns8__getEnterpriseByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetEnterpriseByUuid(struct soap *soap, const char *tag, int id, const struct __ns1__GetEnterpriseByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(soap, "ns8:getEnterpriseByUuidRequest", -1, &a->ns8__getEnterpriseByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEnterpriseByUuid * FASTCALL soap_in___ns1__GetEnterpriseByUuid(struct soap *soap, const char *tag, struct __ns1__GetEnterpriseByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getEnterpriseByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetEnterpriseByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEnterpriseByUuid, sizeof(struct __ns1__GetEnterpriseByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetEnterpriseByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getEnterpriseByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(soap, "ns8:getEnterpriseByUuidRequest", &a->ns8__getEnterpriseByUuidRequest, ""))
				{	soap_flag_ns8__getEnterpriseByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEnterpriseByUuid(struct soap *soap, const struct __ns1__GetEnterpriseByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetEnterpriseByUuid(soap, tag?tag:"-ns1:GetEnterpriseByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEnterpriseByUuid * SOAP_FMAC4 soap_get___ns1__GetEnterpriseByUuid(struct soap *soap, struct __ns1__GetEnterpriseByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetEnterpriseByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetEnterpriseByUuid * FASTCALL soap_instantiate___ns1__GetEnterpriseByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEnterpriseByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetEnterpriseByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetEnterpriseByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetEnterpriseByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetEnterpriseByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetEnterpriseByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetEnterpriseByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetEnterpriseByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetEnterpriseByUuid %p -> %p\n", q, p));
	*(struct __ns1__GetEnterpriseByUuid*)p = *(struct __ns1__GetEnterpriseByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEnterpriseByGuid(struct soap *soap, struct __ns1__GetEnterpriseByGuid *a)
{
	a->ns8__getEnterpriseByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEnterpriseByGuid(struct soap *soap, const struct __ns1__GetEnterpriseByGuid *a)
{
	soap_serialize_PointerTo_ns8__getEnterpriseByGuidRequest(soap, &a->ns8__getEnterpriseByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetEnterpriseByGuid(struct soap *soap, const char *tag, int id, const struct __ns1__GetEnterpriseByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(soap, "ns8:getEnterpriseByGuidRequest", -1, &a->ns8__getEnterpriseByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEnterpriseByGuid * FASTCALL soap_in___ns1__GetEnterpriseByGuid(struct soap *soap, const char *tag, struct __ns1__GetEnterpriseByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getEnterpriseByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetEnterpriseByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEnterpriseByGuid, sizeof(struct __ns1__GetEnterpriseByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetEnterpriseByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getEnterpriseByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(soap, "ns8:getEnterpriseByGuidRequest", &a->ns8__getEnterpriseByGuidRequest, ""))
				{	soap_flag_ns8__getEnterpriseByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEnterpriseByGuid(struct soap *soap, const struct __ns1__GetEnterpriseByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetEnterpriseByGuid(soap, tag?tag:"-ns1:GetEnterpriseByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEnterpriseByGuid * SOAP_FMAC4 soap_get___ns1__GetEnterpriseByGuid(struct soap *soap, struct __ns1__GetEnterpriseByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetEnterpriseByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetEnterpriseByGuid * FASTCALL soap_instantiate___ns1__GetEnterpriseByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEnterpriseByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetEnterpriseByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetEnterpriseByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetEnterpriseByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetEnterpriseByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetEnterpriseByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetEnterpriseByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetEnterpriseByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetEnterpriseByGuid %p -> %p\n", q, p));
	*(struct __ns1__GetEnterpriseByGuid*)p = *(struct __ns1__GetEnterpriseByGuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBusinessEntityChangesList(struct soap *soap, struct __ns1__GetBusinessEntityChangesList *a)
{
	a->ns8__getBusinessEntityChangesListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBusinessEntityChangesList(struct soap *soap, const struct __ns1__GetBusinessEntityChangesList *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, &a->ns8__getBusinessEntityChangesListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetBusinessEntityChangesList(struct soap *soap, const char *tag, int id, const struct __ns1__GetBusinessEntityChangesList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, "ns8:getBusinessEntityChangesListRequest", -1, &a->ns8__getBusinessEntityChangesListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityChangesList * FASTCALL soap_in___ns1__GetBusinessEntityChangesList(struct soap *soap, const char *tag, struct __ns1__GetBusinessEntityChangesList *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityChangesListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetBusinessEntityChangesList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBusinessEntityChangesList, sizeof(struct __ns1__GetBusinessEntityChangesList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetBusinessEntityChangesList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityChangesListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, "ns8:getBusinessEntityChangesListRequest", &a->ns8__getBusinessEntityChangesListRequest, ""))
				{	soap_flag_ns8__getBusinessEntityChangesListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBusinessEntityChangesList(struct soap *soap, const struct __ns1__GetBusinessEntityChangesList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetBusinessEntityChangesList(soap, tag?tag:"-ns1:GetBusinessEntityChangesList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityChangesList * SOAP_FMAC4 soap_get___ns1__GetBusinessEntityChangesList(struct soap *soap, struct __ns1__GetBusinessEntityChangesList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetBusinessEntityChangesList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBusinessEntityChangesList * FASTCALL soap_instantiate___ns1__GetBusinessEntityChangesList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBusinessEntityChangesList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBusinessEntityChangesList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityChangesList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetBusinessEntityChangesList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityChangesList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetBusinessEntityChangesList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBusinessEntityChangesList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBusinessEntityChangesList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBusinessEntityChangesList %p -> %p\n", q, p));
	*(struct __ns1__GetBusinessEntityChangesList*)p = *(struct __ns1__GetBusinessEntityChangesList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBusinessEntityList(struct soap *soap, struct __ns1__GetBusinessEntityList *a)
{
	a->ns8__getBusinessEntityListRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBusinessEntityList(struct soap *soap, const struct __ns1__GetBusinessEntityList *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityListRequest(soap, &a->ns8__getBusinessEntityListRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetBusinessEntityList(struct soap *soap, const char *tag, int id, const struct __ns1__GetBusinessEntityList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityListRequest(soap, "ns8:getBusinessEntityListRequest", -1, &a->ns8__getBusinessEntityListRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityList * FASTCALL soap_in___ns1__GetBusinessEntityList(struct soap *soap, const char *tag, struct __ns1__GetBusinessEntityList *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityListRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetBusinessEntityList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBusinessEntityList, sizeof(struct __ns1__GetBusinessEntityList), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetBusinessEntityList(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityListRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityListRequest(soap, "ns8:getBusinessEntityListRequest", &a->ns8__getBusinessEntityListRequest, ""))
				{	soap_flag_ns8__getBusinessEntityListRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBusinessEntityList(struct soap *soap, const struct __ns1__GetBusinessEntityList *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetBusinessEntityList(soap, tag?tag:"-ns1:GetBusinessEntityList", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityList * SOAP_FMAC4 soap_get___ns1__GetBusinessEntityList(struct soap *soap, struct __ns1__GetBusinessEntityList *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetBusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBusinessEntityList * FASTCALL soap_instantiate___ns1__GetBusinessEntityList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBusinessEntityList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBusinessEntityList, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityList);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetBusinessEntityList));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityList[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetBusinessEntityList));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBusinessEntityList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBusinessEntityList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBusinessEntityList %p -> %p\n", q, p));
	*(struct __ns1__GetBusinessEntityList*)p = *(struct __ns1__GetBusinessEntityList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBusinessEntityByUuid(struct soap *soap, struct __ns1__GetBusinessEntityByUuid *a)
{
	a->ns8__getBusinessEntityByUuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBusinessEntityByUuid(struct soap *soap, const struct __ns1__GetBusinessEntityByUuid *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, &a->ns8__getBusinessEntityByUuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetBusinessEntityByUuid(struct soap *soap, const char *tag, int id, const struct __ns1__GetBusinessEntityByUuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, "ns8:getBusinessEntityByUuidRequest", -1, &a->ns8__getBusinessEntityByUuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityByUuid * FASTCALL soap_in___ns1__GetBusinessEntityByUuid(struct soap *soap, const char *tag, struct __ns1__GetBusinessEntityByUuid *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityByUuidRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetBusinessEntityByUuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBusinessEntityByUuid, sizeof(struct __ns1__GetBusinessEntityByUuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetBusinessEntityByUuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityByUuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, "ns8:getBusinessEntityByUuidRequest", &a->ns8__getBusinessEntityByUuidRequest, ""))
				{	soap_flag_ns8__getBusinessEntityByUuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBusinessEntityByUuid(struct soap *soap, const struct __ns1__GetBusinessEntityByUuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetBusinessEntityByUuid(soap, tag?tag:"-ns1:GetBusinessEntityByUuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityByUuid * SOAP_FMAC4 soap_get___ns1__GetBusinessEntityByUuid(struct soap *soap, struct __ns1__GetBusinessEntityByUuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetBusinessEntityByUuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBusinessEntityByUuid * FASTCALL soap_instantiate___ns1__GetBusinessEntityByUuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBusinessEntityByUuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBusinessEntityByUuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityByUuid);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetBusinessEntityByUuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityByUuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetBusinessEntityByUuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBusinessEntityByUuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBusinessEntityByUuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBusinessEntityByUuid %p -> %p\n", q, p));
	*(struct __ns1__GetBusinessEntityByUuid*)p = *(struct __ns1__GetBusinessEntityByUuid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBusinessEntityByGuid(struct soap *soap, struct __ns1__GetBusinessEntityByGuid *a)
{
	a->ns8__getBusinessEntityByGuidRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBusinessEntityByGuid(struct soap *soap, const struct __ns1__GetBusinessEntityByGuid *a)
{
	soap_serialize_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, &a->ns8__getBusinessEntityByGuidRequest);
}

SOAP_FMAC3 int FASTCALL soap_out___ns1__GetBusinessEntityByGuid(struct soap *soap, const char *tag, int id, const struct __ns1__GetBusinessEntityByGuid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, "ns8:getBusinessEntityByGuidRequest", -1, &a->ns8__getBusinessEntityByGuidRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityByGuid * FASTCALL soap_in___ns1__GetBusinessEntityByGuid(struct soap *soap, const char *tag, struct __ns1__GetBusinessEntityByGuid *a, const char *type)
{
	size_t soap_flag_ns8__getBusinessEntityByGuidRequest = 1;
	short soap_flag;
	a = (struct __ns1__GetBusinessEntityByGuid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBusinessEntityByGuid, sizeof(struct __ns1__GetBusinessEntityByGuid), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default___ns1__GetBusinessEntityByGuid(soap, a);
		for(soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns8__getBusinessEntityByGuidRequest && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, "ns8:getBusinessEntityByGuidRequest", &a->ns8__getBusinessEntityByGuidRequest, ""))
				{	soap_flag_ns8__getBusinessEntityByGuidRequest--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				if(soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if(soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBusinessEntityByGuid(struct soap *soap, const struct __ns1__GetBusinessEntityByGuid *a, const char *tag, const char *type)
{
	int id = 0;
	return soap_out___ns1__GetBusinessEntityByGuid(soap, tag?tag:"-ns1:GetBusinessEntityByGuid", id, a, type) ? soap->error : SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBusinessEntityByGuid * SOAP_FMAC4 soap_get___ns1__GetBusinessEntityByGuid(struct soap *soap, struct __ns1__GetBusinessEntityByGuid *p, const char *tag, const char *type)
{
	if((p = soap_in___ns1__GetBusinessEntityByGuid(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBusinessEntityByGuid * FASTCALL soap_instantiate___ns1__GetBusinessEntityByGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBusinessEntityByGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBusinessEntityByGuid, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityByGuid);
		ASSIGN_PTR(size, sizeof(struct __ns1__GetBusinessEntityByGuid));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBusinessEntityByGuid[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct __ns1__GetBusinessEntityByGuid));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBusinessEntityByGuid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBusinessEntityByGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBusinessEntityByGuid %p -> %p\n", q, p));
	*(struct __ns1__GetBusinessEntityByGuid*)p = *(struct __ns1__GetBusinessEntityByGuid*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	a->__any = NULL;
	a->ns2__entityNotFoundFault = NULL;
	a->ns2__incorrectRequestFault = NULL;
	a->ns2__internalServiceFault = NULL;
	a->ns2__offsetOutOfRangeFault = NULL;
	a->ns2__accessDeniedFault = NULL;
	a->ws__unknownServiceIdFault = NULL;
	a->ws__unsupportedApplicationDataTypeFault = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__entityNotFoundFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__incorrectRequestFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__internalServiceFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__offsetOutOfRangeFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ns2__accessDeniedFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ws__unknownServiceIdFault);
	soap_serialize_PointerTobase__FaultInfo(soap, &a->ws__unsupportedApplicationDataTypeFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int FASTCALL soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if(soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:entityNotFoundFault", -1, &a->ns2__entityNotFoundFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:incorrectRequestFault", -1, &a->ns2__incorrectRequestFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:internalServiceFault", -1, &a->ns2__internalServiceFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:offsetOutOfRangeFault", -1, &a->ns2__offsetOutOfRangeFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ns2:accessDeniedFault", -1, &a->ns2__accessDeniedFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ws:unknownServiceIdFault", -1, &a->ws__unknownServiceIdFault, ""))
		return soap->error;
	if(soap_out_PointerTobase__FaultInfo(soap, "ws:unsupportedApplicationDataTypeFault", -1, &a->ws__unsupportedApplicationDataTypeFault, ""))
		return soap->error;
	if(soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * FASTCALL soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns2__entityNotFoundFault = 1;
	size_t soap_flag_ns2__incorrectRequestFault = 1;
	size_t soap_flag_ns2__internalServiceFault = 1;
	size_t soap_flag_ns2__offsetOutOfRangeFault = 1;
	size_t soap_flag_ns2__accessDeniedFault = 1;
	size_t soap_flag_ws__unknownServiceIdFault = 1;
	size_t soap_flag_ws__unsupportedApplicationDataTypeFault = 1;
	size_t soap_flag_fault = 1;
	if(soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if(!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if(soap->body && !*soap->href) {
		for(;;) {
			soap->error = SOAP_TAG_MISMATCH;
			if(soap_flag_ns2__entityNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:entityNotFoundFault", &a->ns2__entityNotFoundFault, "base:FaultInfo"))
				{	soap_flag_ns2__entityNotFoundFault--;
					continue;
				}
			if(soap_flag_ns2__incorrectRequestFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:incorrectRequestFault", &a->ns2__incorrectRequestFault, "base:FaultInfo"))
				{	soap_flag_ns2__incorrectRequestFault--;
					continue;
				}
			if(soap_flag_ns2__internalServiceFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:internalServiceFault", &a->ns2__internalServiceFault, "base:FaultInfo"))
				{	soap_flag_ns2__internalServiceFault--;
					continue;
				}
			if(soap_flag_ns2__offsetOutOfRangeFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:offsetOutOfRangeFault", &a->ns2__offsetOutOfRangeFault, "base:FaultInfo"))
				{	soap_flag_ns2__offsetOutOfRangeFault--;
					continue;
				}
			if(soap_flag_ns2__accessDeniedFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ns2:accessDeniedFault", &a->ns2__accessDeniedFault, "base:FaultInfo"))
				{	soap_flag_ns2__accessDeniedFault--;
					continue;
				}
			if(soap_flag_ws__unknownServiceIdFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ws:unknownServiceIdFault", &a->ws__unknownServiceIdFault, "base:FaultInfo"))
				{	soap_flag_ws__unknownServiceIdFault--;
					continue;
				}
			if(soap_flag_ws__unsupportedApplicationDataTypeFault && soap->error == SOAP_TAG_MISMATCH)
				if(soap_in_PointerTobase__FaultInfo(soap, "ws:unsupportedApplicationDataTypeFault", &a->ws__unsupportedApplicationDataTypeFault, "base:FaultInfo"))
				{	soap_flag_ws__unsupportedApplicationDataTypeFault--;
					continue;
				}
			if(soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if(soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if(soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if(soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if(soap->error == SOAP_NO_TAG)
				break;
			if(soap->error)
				return NULL;
		}
		if(soap_element_end_in(soap, tag))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	return soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * FASTCALL soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, vetisams_fdelete);
	if(!cp)
		return NULL;
	if(n < 0) {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		ASSIGN_PTR(size, sizeof(struct SOAP_ENV__Detail));
	}
	else {
		cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if(!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		ASSIGN_PTR(size, n * sizeof(struct SOAP_ENV__Detail));
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_VetDocument(struct soap *soap, int choice, const union _vd__union_VetDocument *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VetDocument_certifiedBatch:
		soap_serialize_PointerTovd__CertifiedBatch(soap, &a->certifiedBatch);
		break;
	case SOAP_UNION__vd__union_VetDocument_certifiedConsignment:
		soap_serialize_PointerTovd__CertifiedConsignment(soap, &a->certifiedConsignment);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_VetDocument(struct soap *soap, int choice, const union _vd__union_VetDocument *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VetDocument_certifiedBatch:
		return soap_out_PointerTovd__CertifiedBatch(soap, "vd:certifiedBatch", -1, &a->certifiedBatch, "");
	case SOAP_UNION__vd__union_VetDocument_certifiedConsignment:
		return soap_out_PointerTovd__CertifiedConsignment(soap, "vd:certifiedConsignment", -1, &a->certifiedConsignment, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_VetDocument * FASTCALL soap_in__vd__union_VetDocument(struct soap *soap, int *choice, union _vd__union_VetDocument *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->certifiedBatch = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTovd__CertifiedBatch(soap, "vd:certifiedBatch", &a->certifiedBatch, "vd:CertifiedBatch"))
	{	*choice = SOAP_UNION__vd__union_VetDocument_certifiedBatch;
		return a;
	}
	a->certifiedConsignment = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTovd__CertifiedConsignment(soap, "vd:certifiedConsignment", &a->certifiedConsignment, "vd:CertifiedConsignment"))
	{	*choice = SOAP_UNION__vd__union_VetDocument_certifiedConsignment;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_User(struct soap *soap, int choice, const union _vd__union_User *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_User_organization:
		soap_serialize_PointerToent__Organization(soap, &a->organization);
		break;
	case SOAP_UNION__vd__union_User_businessEntity:
		soap_serialize_PointerToent__BusinessEntity(soap, &a->businessEntity);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_User(struct soap *soap, int choice, const union _vd__union_User *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_User_organization:
		return soap_out_PointerToent__Organization(soap, "vd:organization", -1, &a->organization, "");
	case SOAP_UNION__vd__union_User_businessEntity:
		return soap_out_PointerToent__BusinessEntity(soap, "vd:businessEntity", -1, &a->businessEntity, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_User * FASTCALL soap_in__vd__union_User(struct soap *soap, int *choice, union _vd__union_User *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->organization = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Organization(soap, "vd:organization", &a->organization, "ent:Organization"))
	{	*choice = SOAP_UNION__vd__union_User_organization;
		return a;
	}
	a->businessEntity = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__BusinessEntity(soap, "vd:businessEntity", &a->businessEntity, "ent:BusinessEntity"))
	{	*choice = SOAP_UNION__vd__union_User_businessEntity;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_LaboratoryResearchEvent_(struct soap *soap, int choice, const union _vd__union_LaboratoryResearchEvent_ *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__indicator:
		soap_serialize_PointerToent__Indicator(soap, &a->indicator);
		break;
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__disease:
		soap_serialize_PointerToent__AnimalDisease(soap, &a->disease);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_LaboratoryResearchEvent_(struct soap *soap, int choice, const union _vd__union_LaboratoryResearchEvent_ *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__indicator:
		return soap_out_PointerToent__Indicator(soap, "vd:indicator", -1, &a->indicator, "");
	case SOAP_UNION__vd__union_LaboratoryResearchEvent__disease:
		return soap_out_PointerToent__AnimalDisease(soap, "vd:disease", -1, &a->disease, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_LaboratoryResearchEvent_ * FASTCALL soap_in__vd__union_LaboratoryResearchEvent_(struct soap *soap, int *choice, union _vd__union_LaboratoryResearchEvent_ *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->indicator = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Indicator(soap, "vd:indicator", &a->indicator, "ent:Indicator"))
	{	*choice = SOAP_UNION__vd__union_LaboratoryResearchEvent__indicator;
		return a;
	}
	a->disease = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__AnimalDisease(soap, "vd:disease", &a->disease, "ent:AnimalDisease"))
	{	*choice = SOAP_UNION__vd__union_LaboratoryResearchEvent__disease;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_ShipmentRoutePoint(struct soap *soap, int choice, const union _vd__union_ShipmentRoutePoint *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_ShipmentRoutePoint_location:
		soap_serialize_PointerToent__Location(soap, &a->location);
		break;
	case SOAP_UNION__vd__union_ShipmentRoutePoint_enterprise:
		soap_serialize_PointerToent__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_ShipmentRoutePoint(struct soap *soap, int choice, const union _vd__union_ShipmentRoutePoint *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_ShipmentRoutePoint_location:
		return soap_out_PointerToent__Location(soap, "vd:location", -1, &a->location, "");
	case SOAP_UNION__vd__union_ShipmentRoutePoint_enterprise:
		return soap_out_PointerToent__Enterprise(soap, "vd:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_ShipmentRoutePoint * FASTCALL soap_in__vd__union_ShipmentRoutePoint(struct soap *soap, int *choice, union _vd__union_ShipmentRoutePoint *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->location = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Location(soap, "vd:location", &a->location, "ent:Location"))
	{	*choice = SOAP_UNION__vd__union_ShipmentRoutePoint_location;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Enterprise(soap, "vd:enterprise", &a->enterprise, "ent:Enterprise"))
	{	*choice = SOAP_UNION__vd__union_ShipmentRoutePoint_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_WorkingArea(struct soap *soap, int choice, const union _vd__union_WorkingArea *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_WorkingArea_area:
		soap_serialize_PointerToent__Area(soap, &a->area);
		break;
	case SOAP_UNION__vd__union_WorkingArea_enterprise:
		soap_serialize_PointerToent__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_WorkingArea(struct soap *soap, int choice, const union _vd__union_WorkingArea *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_WorkingArea_area:
		return soap_out_PointerToent__Area(soap, "vd:area", -1, &a->area, "");
	case SOAP_UNION__vd__union_WorkingArea_enterprise:
		return soap_out_PointerToent__Enterprise(soap, "vd:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_WorkingArea * FASTCALL soap_in__vd__union_WorkingArea(struct soap *soap, int *choice, union _vd__union_WorkingArea *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->area = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Area(soap, "vd:area", &a->area, "ent:Area"))
	{	*choice = SOAP_UNION__vd__union_WorkingArea_area;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Enterprise(soap, "vd:enterprise", &a->enterprise, "ent:Enterprise"))
	{	*choice = SOAP_UNION__vd__union_WorkingArea_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__vd__union_VeterinaryEvent(struct soap *soap, int choice, const union _vd__union_VeterinaryEvent *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VeterinaryEvent_location:
		soap_serialize_PointerToent__Location(soap, &a->location);
		break;
	case SOAP_UNION__vd__union_VeterinaryEvent_enterprise:
		soap_serialize_PointerToent__Enterprise(soap, &a->enterprise);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int FASTCALL soap_out__vd__union_VeterinaryEvent(struct soap *soap, int choice, const union _vd__union_VeterinaryEvent *a)
{
	switch(choice) {
	
	case SOAP_UNION__vd__union_VeterinaryEvent_location:
		return soap_out_PointerToent__Location(soap, "vd:location", -1, &a->location, "");
	case SOAP_UNION__vd__union_VeterinaryEvent_enterprise:
		return soap_out_PointerToent__Enterprise(soap, "vd:enterprise", -1, &a->enterprise, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _vd__union_VeterinaryEvent * FASTCALL soap_in__vd__union_VeterinaryEvent(struct soap *soap, int *choice, union _vd__union_VeterinaryEvent *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->location = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Location(soap, "vd:location", &a->location, "ent:Location"))
	{	*choice = SOAP_UNION__vd__union_VeterinaryEvent_location;
		return a;
	}
	a->enterprise = NULL;
	if(soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToent__Enterprise(soap, "vd:enterprise", &a->enterprise, "ent:Enterprise"))
	{	*choice = SOAP_UNION__vd__union_VeterinaryEvent_enterprise;
		return a;
	}
	*choice = 0;
	if(!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** FASTCALL soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	return soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** FASTCALL soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	return soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	return (id < 0) ? soap->error : soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** FASTCALL soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	return soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetAppliedUserAuthorityListResponse(struct soap *soap, merc__GetAppliedUserAuthorityListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, int id, merc__GetAppliedUserAuthorityListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListResponse ** FASTCALL soap_in_PointerTomerc__GetAppliedUserAuthorityListResponse(struct soap *soap, const char *tag, merc__GetAppliedUserAuthorityListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetAppliedUserAuthorityListResponse **)soap_malloc(soap, sizeof(merc__GetAppliedUserAuthorityListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetAppliedUserAuthorityListResponse *)soap_instantiate_merc__GetAppliedUserAuthorityListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetAppliedUserAuthorityListResponse ** p = (merc__GetAppliedUserAuthorityListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetAppliedUserAuthorityListResponse, sizeof(merc__GetAppliedUserAuthorityListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetAppliedUserAuthorityListResponse(struct soap *soap, merc__GetAppliedUserAuthorityListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListResponse);
	return soap_out_PointerTomerc__GetAppliedUserAuthorityListResponse(soap, tag?tag:"merc:GetAppliedUserAuthorityListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetAppliedUserAuthorityListResponse(struct soap *soap, merc__GetAppliedUserAuthorityListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetAppliedUserAuthorityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetAppliedUserAuthorityListRequest(struct soap *soap, merc__GetAppliedUserAuthorityListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, int id, merc__GetAppliedUserAuthorityListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListRequest ** FASTCALL soap_in_PointerTomerc__GetAppliedUserAuthorityListRequest(struct soap *soap, const char *tag, merc__GetAppliedUserAuthorityListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetAppliedUserAuthorityListRequest **)soap_malloc(soap, sizeof(merc__GetAppliedUserAuthorityListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetAppliedUserAuthorityListRequest *)soap_instantiate_merc__GetAppliedUserAuthorityListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetAppliedUserAuthorityListRequest ** p = (merc__GetAppliedUserAuthorityListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetAppliedUserAuthorityListRequest, sizeof(merc__GetAppliedUserAuthorityListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetAppliedUserAuthorityListRequest(struct soap *soap, merc__GetAppliedUserAuthorityListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetAppliedUserAuthorityListRequest);
	return soap_out_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, tag?tag:"merc:GetAppliedUserAuthorityListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetAppliedUserAuthorityListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetAppliedUserAuthorityListRequest(struct soap *soap, merc__GetAppliedUserAuthorityListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetAppliedUserAuthorityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UnbindBusinessEntityUserResponse(struct soap *soap, merc__UnbindBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, merc__UnbindBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserResponse ** FASTCALL soap_in_PointerTomerc__UnbindBusinessEntityUserResponse(struct soap *soap, const char *tag, merc__UnbindBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UnbindBusinessEntityUserResponse **)soap_malloc(soap, sizeof(merc__UnbindBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UnbindBusinessEntityUserResponse *)soap_instantiate_merc__UnbindBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UnbindBusinessEntityUserResponse ** p = (merc__UnbindBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UnbindBusinessEntityUserResponse, sizeof(merc__UnbindBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UnbindBusinessEntityUserResponse(struct soap *soap, merc__UnbindBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserResponse);
	return soap_out_PointerTomerc__UnbindBusinessEntityUserResponse(soap, tag?tag:"merc:UnbindBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTomerc__UnbindBusinessEntityUserResponse(struct soap *soap, merc__UnbindBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UnbindBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UnbindBusinessEntityUserRequest(struct soap *soap, merc__UnbindBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, merc__UnbindBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserRequest ** FASTCALL soap_in_PointerTomerc__UnbindBusinessEntityUserRequest(struct soap *soap, const char *tag, merc__UnbindBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UnbindBusinessEntityUserRequest **)soap_malloc(soap, sizeof(merc__UnbindBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UnbindBusinessEntityUserRequest *)soap_instantiate_merc__UnbindBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UnbindBusinessEntityUserRequest ** p = (merc__UnbindBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UnbindBusinessEntityUserRequest, sizeof(merc__UnbindBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UnbindBusinessEntityUserRequest(struct soap *soap, merc__UnbindBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UnbindBusinessEntityUserRequest);
	return soap_out_PointerTomerc__UnbindBusinessEntityUserRequest(soap, tag?tag:"merc:UnbindBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UnbindBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTomerc__UnbindBusinessEntityUserRequest(struct soap *soap, merc__UnbindBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UnbindBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateUserWorkingAreasResponse(struct soap *soap, merc__UpdateUserWorkingAreasResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, int id, merc__UpdateUserWorkingAreasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasResponse ** FASTCALL soap_in_PointerTomerc__UpdateUserWorkingAreasResponse(struct soap *soap, const char *tag, merc__UpdateUserWorkingAreasResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateUserWorkingAreasResponse **)soap_malloc(soap, sizeof(merc__UpdateUserWorkingAreasResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateUserWorkingAreasResponse *)soap_instantiate_merc__UpdateUserWorkingAreasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateUserWorkingAreasResponse ** p = (merc__UpdateUserWorkingAreasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateUserWorkingAreasResponse, sizeof(merc__UpdateUserWorkingAreasResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateUserWorkingAreasResponse(struct soap *soap, merc__UpdateUserWorkingAreasResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasResponse);
	return soap_out_PointerTomerc__UpdateUserWorkingAreasResponse(soap, tag?tag:"merc:UpdateUserWorkingAreasResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasResponse ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateUserWorkingAreasResponse(struct soap *soap, merc__UpdateUserWorkingAreasResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateUserWorkingAreasResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateUserWorkingAreasRequest(struct soap *soap, merc__UpdateUserWorkingAreasRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, int id, merc__UpdateUserWorkingAreasRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasRequest ** FASTCALL soap_in_PointerTomerc__UpdateUserWorkingAreasRequest(struct soap *soap, const char *tag, merc__UpdateUserWorkingAreasRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateUserWorkingAreasRequest **)soap_malloc(soap, sizeof(merc__UpdateUserWorkingAreasRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateUserWorkingAreasRequest *)soap_instantiate_merc__UpdateUserWorkingAreasRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateUserWorkingAreasRequest ** p = (merc__UpdateUserWorkingAreasRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateUserWorkingAreasRequest, sizeof(merc__UpdateUserWorkingAreasRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateUserWorkingAreasRequest(struct soap *soap, merc__UpdateUserWorkingAreasRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateUserWorkingAreasRequest);
	return soap_out_PointerTomerc__UpdateUserWorkingAreasRequest(soap, tag?tag:"merc:UpdateUserWorkingAreasRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateUserWorkingAreasRequest ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateUserWorkingAreasRequest(struct soap *soap, merc__UpdateUserWorkingAreasRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateUserWorkingAreasRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateUserAuthoritiesResponse(struct soap *soap, merc__UpdateUserAuthoritiesResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, int id, merc__UpdateUserAuthoritiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesResponse ** FASTCALL soap_in_PointerTomerc__UpdateUserAuthoritiesResponse(struct soap *soap, const char *tag, merc__UpdateUserAuthoritiesResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateUserAuthoritiesResponse **)soap_malloc(soap, sizeof(merc__UpdateUserAuthoritiesResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateUserAuthoritiesResponse *)soap_instantiate_merc__UpdateUserAuthoritiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateUserAuthoritiesResponse ** p = (merc__UpdateUserAuthoritiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateUserAuthoritiesResponse, sizeof(merc__UpdateUserAuthoritiesResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateUserAuthoritiesResponse(struct soap *soap, merc__UpdateUserAuthoritiesResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesResponse);
	return soap_out_PointerTomerc__UpdateUserAuthoritiesResponse(soap, tag?tag:"merc:UpdateUserAuthoritiesResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesResponse ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateUserAuthoritiesResponse(struct soap *soap, merc__UpdateUserAuthoritiesResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateUserAuthoritiesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateUserAuthoritiesRequest(struct soap *soap, merc__UpdateUserAuthoritiesRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, int id, merc__UpdateUserAuthoritiesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesRequest ** FASTCALL soap_in_PointerTomerc__UpdateUserAuthoritiesRequest(struct soap *soap, const char *tag, merc__UpdateUserAuthoritiesRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateUserAuthoritiesRequest **)soap_malloc(soap, sizeof(merc__UpdateUserAuthoritiesRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateUserAuthoritiesRequest *)soap_instantiate_merc__UpdateUserAuthoritiesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateUserAuthoritiesRequest ** p = (merc__UpdateUserAuthoritiesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateUserAuthoritiesRequest, sizeof(merc__UpdateUserAuthoritiesRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateUserAuthoritiesRequest(struct soap *soap, merc__UpdateUserAuthoritiesRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateUserAuthoritiesRequest);
	return soap_out_PointerTomerc__UpdateUserAuthoritiesRequest(soap, tag?tag:"merc:UpdateUserAuthoritiesRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateUserAuthoritiesRequest ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateUserAuthoritiesRequest(struct soap *soap, merc__UpdateUserAuthoritiesRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateUserAuthoritiesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetBusinessEntityUserResponse(struct soap *soap, merc__GetBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, merc__GetBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserResponse ** FASTCALL soap_in_PointerTomerc__GetBusinessEntityUserResponse(struct soap *soap, const char *tag, merc__GetBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetBusinessEntityUserResponse **)soap_malloc(soap, sizeof(merc__GetBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetBusinessEntityUserResponse *)soap_instantiate_merc__GetBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetBusinessEntityUserResponse ** p = (merc__GetBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetBusinessEntityUserResponse, sizeof(merc__GetBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetBusinessEntityUserResponse(struct soap *soap, merc__GetBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetBusinessEntityUserResponse);
	return soap_out_PointerTomerc__GetBusinessEntityUserResponse(soap, tag?tag:"merc:GetBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetBusinessEntityUserResponse(struct soap *soap, merc__GetBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetBusinessEntityUserRequest(struct soap *soap, merc__GetBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, merc__GetBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserRequest ** FASTCALL soap_in_PointerTomerc__GetBusinessEntityUserRequest(struct soap *soap, const char *tag, merc__GetBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetBusinessEntityUserRequest **)soap_malloc(soap, sizeof(merc__GetBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetBusinessEntityUserRequest *)soap_instantiate_merc__GetBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetBusinessEntityUserRequest ** p = (merc__GetBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetBusinessEntityUserRequest, sizeof(merc__GetBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetBusinessEntityUserRequest(struct soap *soap, merc__GetBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetBusinessEntityUserRequest);
	return soap_out_PointerTomerc__GetBusinessEntityUserRequest(soap, tag?tag:"merc:GetBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetBusinessEntityUserRequest(struct soap *soap, merc__GetBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetBusinessEntityUserListResponse(struct soap *soap, merc__GetBusinessEntityUserListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetBusinessEntityUserListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, int id, merc__GetBusinessEntityUserListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetBusinessEntityUserListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListResponse ** FASTCALL soap_in_PointerTomerc__GetBusinessEntityUserListResponse(struct soap *soap, const char *tag, merc__GetBusinessEntityUserListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetBusinessEntityUserListResponse **)soap_malloc(soap, sizeof(merc__GetBusinessEntityUserListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetBusinessEntityUserListResponse *)soap_instantiate_merc__GetBusinessEntityUserListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetBusinessEntityUserListResponse ** p = (merc__GetBusinessEntityUserListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetBusinessEntityUserListResponse, sizeof(merc__GetBusinessEntityUserListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetBusinessEntityUserListResponse(struct soap *soap, merc__GetBusinessEntityUserListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListResponse);
	return soap_out_PointerTomerc__GetBusinessEntityUserListResponse(soap, tag?tag:"merc:GetBusinessEntityUserListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetBusinessEntityUserListResponse(struct soap *soap, merc__GetBusinessEntityUserListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetBusinessEntityUserListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetBusinessEntityUserListRequest(struct soap *soap, merc__GetBusinessEntityUserListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetBusinessEntityUserListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, int id, merc__GetBusinessEntityUserListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetBusinessEntityUserListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListRequest ** FASTCALL soap_in_PointerTomerc__GetBusinessEntityUserListRequest(struct soap *soap, const char *tag, merc__GetBusinessEntityUserListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetBusinessEntityUserListRequest **)soap_malloc(soap, sizeof(merc__GetBusinessEntityUserListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetBusinessEntityUserListRequest *)soap_instantiate_merc__GetBusinessEntityUserListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetBusinessEntityUserListRequest ** p = (merc__GetBusinessEntityUserListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetBusinessEntityUserListRequest, sizeof(merc__GetBusinessEntityUserListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetBusinessEntityUserListRequest(struct soap *soap, merc__GetBusinessEntityUserListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetBusinessEntityUserListRequest);
	return soap_out_PointerTomerc__GetBusinessEntityUserListRequest(soap, tag?tag:"merc:GetBusinessEntityUserListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetBusinessEntityUserListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetBusinessEntityUserListRequest(struct soap *soap, merc__GetBusinessEntityUserListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetBusinessEntityUserListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__AddBusinessEntityUserResponse(struct soap *soap, merc__AddBusinessEntityUserResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__AddBusinessEntityUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, int id, merc__AddBusinessEntityUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__AddBusinessEntityUserResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__AddBusinessEntityUserResponse ** FASTCALL soap_in_PointerTomerc__AddBusinessEntityUserResponse(struct soap *soap, const char *tag, merc__AddBusinessEntityUserResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__AddBusinessEntityUserResponse **)soap_malloc(soap, sizeof(merc__AddBusinessEntityUserResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__AddBusinessEntityUserResponse *)soap_instantiate_merc__AddBusinessEntityUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__AddBusinessEntityUserResponse ** p = (merc__AddBusinessEntityUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__AddBusinessEntityUserResponse, sizeof(merc__AddBusinessEntityUserResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__AddBusinessEntityUserResponse(struct soap *soap, merc__AddBusinessEntityUserResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__AddBusinessEntityUserResponse);
	return soap_out_PointerTomerc__AddBusinessEntityUserResponse(soap, tag?tag:"merc:AddBusinessEntityUserResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__AddBusinessEntityUserResponse ** SOAP_FMAC4 soap_get_PointerTomerc__AddBusinessEntityUserResponse(struct soap *soap, merc__AddBusinessEntityUserResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__AddBusinessEntityUserResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__AddBusinessEntityUserRequest(struct soap *soap, merc__AddBusinessEntityUserRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__AddBusinessEntityUserRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, int id, merc__AddBusinessEntityUserRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__AddBusinessEntityUserRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__AddBusinessEntityUserRequest ** FASTCALL soap_in_PointerTomerc__AddBusinessEntityUserRequest(struct soap *soap, const char *tag, merc__AddBusinessEntityUserRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__AddBusinessEntityUserRequest **)soap_malloc(soap, sizeof(merc__AddBusinessEntityUserRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__AddBusinessEntityUserRequest *)soap_instantiate_merc__AddBusinessEntityUserRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__AddBusinessEntityUserRequest ** p = (merc__AddBusinessEntityUserRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__AddBusinessEntityUserRequest, sizeof(merc__AddBusinessEntityUserRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__AddBusinessEntityUserRequest(struct soap *soap, merc__AddBusinessEntityUserRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__AddBusinessEntityUserRequest);
	return soap_out_PointerTomerc__AddBusinessEntityUserRequest(soap, tag?tag:"merc:AddBusinessEntityUserRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__AddBusinessEntityUserRequest ** SOAP_FMAC4 soap_get_PointerTomerc__AddBusinessEntityUserRequest(struct soap *soap, merc__AddBusinessEntityUserRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__AddBusinessEntityUserRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__CheckShipmentRegionalizationResponse(struct soap *soap, merc__CheckShipmentRegionalizationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, int id, merc__CheckShipmentRegionalizationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationResponse ** FASTCALL soap_in_PointerTomerc__CheckShipmentRegionalizationResponse(struct soap *soap, const char *tag, merc__CheckShipmentRegionalizationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__CheckShipmentRegionalizationResponse **)soap_malloc(soap, sizeof(merc__CheckShipmentRegionalizationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__CheckShipmentRegionalizationResponse *)soap_instantiate_merc__CheckShipmentRegionalizationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__CheckShipmentRegionalizationResponse ** p = (merc__CheckShipmentRegionalizationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__CheckShipmentRegionalizationResponse, sizeof(merc__CheckShipmentRegionalizationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__CheckShipmentRegionalizationResponse(struct soap *soap, merc__CheckShipmentRegionalizationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationResponse);
	return soap_out_PointerTomerc__CheckShipmentRegionalizationResponse(soap, tag?tag:"merc:CheckShipmentRegionalizationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationResponse ** SOAP_FMAC4 soap_get_PointerTomerc__CheckShipmentRegionalizationResponse(struct soap *soap, merc__CheckShipmentRegionalizationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__CheckShipmentRegionalizationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__CheckShipmentRegionalizationRequest(struct soap *soap, merc__CheckShipmentRegionalizationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, int id, merc__CheckShipmentRegionalizationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationRequest ** FASTCALL soap_in_PointerTomerc__CheckShipmentRegionalizationRequest(struct soap *soap, const char *tag, merc__CheckShipmentRegionalizationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__CheckShipmentRegionalizationRequest **)soap_malloc(soap, sizeof(merc__CheckShipmentRegionalizationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__CheckShipmentRegionalizationRequest *)soap_instantiate_merc__CheckShipmentRegionalizationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__CheckShipmentRegionalizationRequest ** p = (merc__CheckShipmentRegionalizationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__CheckShipmentRegionalizationRequest, sizeof(merc__CheckShipmentRegionalizationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__CheckShipmentRegionalizationRequest(struct soap *soap, merc__CheckShipmentRegionalizationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__CheckShipmentRegionalizationRequest);
	return soap_out_PointerTomerc__CheckShipmentRegionalizationRequest(soap, tag?tag:"merc:CheckShipmentRegionalizationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__CheckShipmentRegionalizationRequest ** SOAP_FMAC4 soap_get_PointerTomerc__CheckShipmentRegionalizationRequest(struct soap *soap, merc__CheckShipmentRegionalizationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__CheckShipmentRegionalizationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateVeterinaryEventsResponse(struct soap *soap, merc__UpdateVeterinaryEventsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, int id, merc__UpdateVeterinaryEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsResponse ** FASTCALL soap_in_PointerTomerc__UpdateVeterinaryEventsResponse(struct soap *soap, const char *tag, merc__UpdateVeterinaryEventsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateVeterinaryEventsResponse **)soap_malloc(soap, sizeof(merc__UpdateVeterinaryEventsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateVeterinaryEventsResponse *)soap_instantiate_merc__UpdateVeterinaryEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateVeterinaryEventsResponse ** p = (merc__UpdateVeterinaryEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateVeterinaryEventsResponse, sizeof(merc__UpdateVeterinaryEventsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateVeterinaryEventsResponse(struct soap *soap, merc__UpdateVeterinaryEventsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsResponse);
	return soap_out_PointerTomerc__UpdateVeterinaryEventsResponse(soap, tag?tag:"merc:UpdateVeterinaryEventsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsResponse ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateVeterinaryEventsResponse(struct soap *soap, merc__UpdateVeterinaryEventsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateVeterinaryEventsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateVeterinaryEventsRequest(struct soap *soap, merc__UpdateVeterinaryEventsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, int id, merc__UpdateVeterinaryEventsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsRequest ** FASTCALL soap_in_PointerTomerc__UpdateVeterinaryEventsRequest(struct soap *soap, const char *tag, merc__UpdateVeterinaryEventsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateVeterinaryEventsRequest **)soap_malloc(soap, sizeof(merc__UpdateVeterinaryEventsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateVeterinaryEventsRequest *)soap_instantiate_merc__UpdateVeterinaryEventsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateVeterinaryEventsRequest ** p = (merc__UpdateVeterinaryEventsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateVeterinaryEventsRequest, sizeof(merc__UpdateVeterinaryEventsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateVeterinaryEventsRequest(struct soap *soap, merc__UpdateVeterinaryEventsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateVeterinaryEventsRequest);
	return soap_out_PointerTomerc__UpdateVeterinaryEventsRequest(soap, tag?tag:"merc:UpdateVeterinaryEventsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateVeterinaryEventsRequest ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateVeterinaryEventsRequest(struct soap *soap, merc__UpdateVeterinaryEventsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateVeterinaryEventsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateTransportMovementDetailsResponse(struct soap *soap, merc__UpdateTransportMovementDetailsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, int id, merc__UpdateTransportMovementDetailsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsResponse ** FASTCALL soap_in_PointerTomerc__UpdateTransportMovementDetailsResponse(struct soap *soap, const char *tag, merc__UpdateTransportMovementDetailsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateTransportMovementDetailsResponse **)soap_malloc(soap, sizeof(merc__UpdateTransportMovementDetailsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateTransportMovementDetailsResponse *)soap_instantiate_merc__UpdateTransportMovementDetailsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateTransportMovementDetailsResponse ** p = (merc__UpdateTransportMovementDetailsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateTransportMovementDetailsResponse, sizeof(merc__UpdateTransportMovementDetailsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateTransportMovementDetailsResponse(struct soap *soap, merc__UpdateTransportMovementDetailsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsResponse);
	return soap_out_PointerTomerc__UpdateTransportMovementDetailsResponse(soap, tag?tag:"merc:UpdateTransportMovementDetailsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsResponse ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateTransportMovementDetailsResponse(struct soap *soap, merc__UpdateTransportMovementDetailsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateTransportMovementDetailsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__UpdateTransportMovementDetailsRequest(struct soap *soap, merc__UpdateTransportMovementDetailsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, int id, merc__UpdateTransportMovementDetailsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsRequest ** FASTCALL soap_in_PointerTomerc__UpdateTransportMovementDetailsRequest(struct soap *soap, const char *tag, merc__UpdateTransportMovementDetailsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__UpdateTransportMovementDetailsRequest **)soap_malloc(soap, sizeof(merc__UpdateTransportMovementDetailsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__UpdateTransportMovementDetailsRequest *)soap_instantiate_merc__UpdateTransportMovementDetailsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__UpdateTransportMovementDetailsRequest ** p = (merc__UpdateTransportMovementDetailsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__UpdateTransportMovementDetailsRequest, sizeof(merc__UpdateTransportMovementDetailsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__UpdateTransportMovementDetailsRequest(struct soap *soap, merc__UpdateTransportMovementDetailsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__UpdateTransportMovementDetailsRequest);
	return soap_out_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, tag?tag:"merc:UpdateTransportMovementDetailsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__UpdateTransportMovementDetailsRequest ** SOAP_FMAC4 soap_get_PointerTomerc__UpdateTransportMovementDetailsRequest(struct soap *soap, merc__UpdateTransportMovementDetailsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__UpdateTransportMovementDetailsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryVersionListResponse(struct soap *soap, merc__GetStockEntryVersionListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryVersionListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, int id, merc__GetStockEntryVersionListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryVersionListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryVersionListResponse ** FASTCALL soap_in_PointerTomerc__GetStockEntryVersionListResponse(struct soap *soap, const char *tag, merc__GetStockEntryVersionListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryVersionListResponse **)soap_malloc(soap, sizeof(merc__GetStockEntryVersionListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryVersionListResponse *)soap_instantiate_merc__GetStockEntryVersionListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryVersionListResponse ** p = (merc__GetStockEntryVersionListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryVersionListResponse, sizeof(merc__GetStockEntryVersionListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryVersionListResponse(struct soap *soap, merc__GetStockEntryVersionListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryVersionListResponse);
	return soap_out_PointerTomerc__GetStockEntryVersionListResponse(soap, tag?tag:"merc:GetStockEntryVersionListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryVersionListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryVersionListResponse(struct soap *soap, merc__GetStockEntryVersionListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryVersionListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryVersionListRequest(struct soap *soap, merc__GetStockEntryVersionListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryVersionListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, int id, merc__GetStockEntryVersionListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryVersionListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryVersionListRequest ** FASTCALL soap_in_PointerTomerc__GetStockEntryVersionListRequest(struct soap *soap, const char *tag, merc__GetStockEntryVersionListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryVersionListRequest **)soap_malloc(soap, sizeof(merc__GetStockEntryVersionListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryVersionListRequest *)soap_instantiate_merc__GetStockEntryVersionListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryVersionListRequest ** p = (merc__GetStockEntryVersionListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryVersionListRequest, sizeof(merc__GetStockEntryVersionListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryVersionListRequest(struct soap *soap, merc__GetStockEntryVersionListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryVersionListRequest);
	return soap_out_PointerTomerc__GetStockEntryVersionListRequest(soap, tag?tag:"merc:GetStockEntryVersionListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryVersionListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryVersionListRequest(struct soap *soap, merc__GetStockEntryVersionListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryVersionListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryChangesListResponse(struct soap *soap, merc__GetStockEntryChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, int id, merc__GetStockEntryChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryChangesListResponse ** FASTCALL soap_in_PointerTomerc__GetStockEntryChangesListResponse(struct soap *soap, const char *tag, merc__GetStockEntryChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryChangesListResponse **)soap_malloc(soap, sizeof(merc__GetStockEntryChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryChangesListResponse *)soap_instantiate_merc__GetStockEntryChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryChangesListResponse ** p = (merc__GetStockEntryChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryChangesListResponse, sizeof(merc__GetStockEntryChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryChangesListResponse(struct soap *soap, merc__GetStockEntryChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryChangesListResponse);
	return soap_out_PointerTomerc__GetStockEntryChangesListResponse(soap, tag?tag:"merc:GetStockEntryChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryChangesListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryChangesListResponse(struct soap *soap, merc__GetStockEntryChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryChangesListRequest(struct soap *soap, merc__GetStockEntryChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, int id, merc__GetStockEntryChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryChangesListRequest ** FASTCALL soap_in_PointerTomerc__GetStockEntryChangesListRequest(struct soap *soap, const char *tag, merc__GetStockEntryChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryChangesListRequest **)soap_malloc(soap, sizeof(merc__GetStockEntryChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryChangesListRequest *)soap_instantiate_merc__GetStockEntryChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryChangesListRequest ** p = (merc__GetStockEntryChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryChangesListRequest, sizeof(merc__GetStockEntryChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryChangesListRequest(struct soap *soap, merc__GetStockEntryChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryChangesListRequest);
	return soap_out_PointerTomerc__GetStockEntryChangesListRequest(soap, tag?tag:"merc:GetStockEntryChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryChangesListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryChangesListRequest(struct soap *soap, merc__GetStockEntryChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryListResponse(struct soap *soap, merc__GetStockEntryListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryListResponse(struct soap *soap, const char *tag, int id, merc__GetStockEntryListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryListResponse ** FASTCALL soap_in_PointerTomerc__GetStockEntryListResponse(struct soap *soap, const char *tag, merc__GetStockEntryListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryListResponse **)soap_malloc(soap, sizeof(merc__GetStockEntryListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryListResponse *)soap_instantiate_merc__GetStockEntryListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryListResponse ** p = (merc__GetStockEntryListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryListResponse, sizeof(merc__GetStockEntryListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryListResponse(struct soap *soap, merc__GetStockEntryListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryListResponse);
	return soap_out_PointerTomerc__GetStockEntryListResponse(soap, tag?tag:"merc:GetStockEntryListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryListResponse(struct soap *soap, merc__GetStockEntryListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryListRequest(struct soap *soap, merc__GetStockEntryListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryListRequest(struct soap *soap, const char *tag, int id, merc__GetStockEntryListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryListRequest ** FASTCALL soap_in_PointerTomerc__GetStockEntryListRequest(struct soap *soap, const char *tag, merc__GetStockEntryListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryListRequest **)soap_malloc(soap, sizeof(merc__GetStockEntryListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryListRequest *)soap_instantiate_merc__GetStockEntryListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryListRequest ** p = (merc__GetStockEntryListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryListRequest, sizeof(merc__GetStockEntryListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryListRequest(struct soap *soap, merc__GetStockEntryListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryListRequest);
	return soap_out_PointerTomerc__GetStockEntryListRequest(soap, tag?tag:"merc:GetStockEntryListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryListRequest(struct soap *soap, merc__GetStockEntryListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryByUuidResponse(struct soap *soap, merc__GetStockEntryByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, int id, merc__GetStockEntryByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryByUuidResponse ** FASTCALL soap_in_PointerTomerc__GetStockEntryByUuidResponse(struct soap *soap, const char *tag, merc__GetStockEntryByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryByUuidResponse **)soap_malloc(soap, sizeof(merc__GetStockEntryByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryByUuidResponse *)soap_instantiate_merc__GetStockEntryByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryByUuidResponse ** p = (merc__GetStockEntryByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryByUuidResponse, sizeof(merc__GetStockEntryByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryByUuidResponse(struct soap *soap, merc__GetStockEntryByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryByUuidResponse);
	return soap_out_PointerTomerc__GetStockEntryByUuidResponse(soap, tag?tag:"merc:GetStockEntryByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryByUuidResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryByUuidResponse(struct soap *soap, merc__GetStockEntryByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryByUuidRequest(struct soap *soap, merc__GetStockEntryByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, int id, merc__GetStockEntryByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryByUuidRequest ** FASTCALL soap_in_PointerTomerc__GetStockEntryByUuidRequest(struct soap *soap, const char *tag, merc__GetStockEntryByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryByUuidRequest **)soap_malloc(soap, sizeof(merc__GetStockEntryByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryByUuidRequest *)soap_instantiate_merc__GetStockEntryByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryByUuidRequest ** p = (merc__GetStockEntryByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryByUuidRequest, sizeof(merc__GetStockEntryByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryByUuidRequest(struct soap *soap, merc__GetStockEntryByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryByUuidRequest);
	return soap_out_PointerTomerc__GetStockEntryByUuidRequest(soap, tag?tag:"merc:GetStockEntryByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryByUuidRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryByUuidRequest(struct soap *soap, merc__GetStockEntryByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryByGuidResponse(struct soap *soap, merc__GetStockEntryByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, int id, merc__GetStockEntryByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryByGuidResponse ** FASTCALL soap_in_PointerTomerc__GetStockEntryByGuidResponse(struct soap *soap, const char *tag, merc__GetStockEntryByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryByGuidResponse **)soap_malloc(soap, sizeof(merc__GetStockEntryByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryByGuidResponse *)soap_instantiate_merc__GetStockEntryByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryByGuidResponse ** p = (merc__GetStockEntryByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryByGuidResponse, sizeof(merc__GetStockEntryByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryByGuidResponse(struct soap *soap, merc__GetStockEntryByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryByGuidResponse);
	return soap_out_PointerTomerc__GetStockEntryByGuidResponse(soap, tag?tag:"merc:GetStockEntryByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryByGuidResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryByGuidResponse(struct soap *soap, merc__GetStockEntryByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetStockEntryByGuidRequest(struct soap *soap, merc__GetStockEntryByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetStockEntryByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, int id, merc__GetStockEntryByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetStockEntryByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetStockEntryByGuidRequest ** FASTCALL soap_in_PointerTomerc__GetStockEntryByGuidRequest(struct soap *soap, const char *tag, merc__GetStockEntryByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetStockEntryByGuidRequest **)soap_malloc(soap, sizeof(merc__GetStockEntryByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetStockEntryByGuidRequest *)soap_instantiate_merc__GetStockEntryByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetStockEntryByGuidRequest ** p = (merc__GetStockEntryByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetStockEntryByGuidRequest, sizeof(merc__GetStockEntryByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetStockEntryByGuidRequest(struct soap *soap, merc__GetStockEntryByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetStockEntryByGuidRequest);
	return soap_out_PointerTomerc__GetStockEntryByGuidRequest(soap, tag?tag:"merc:GetStockEntryByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetStockEntryByGuidRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetStockEntryByGuidRequest(struct soap *soap, merc__GetStockEntryByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetStockEntryByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetVetDocumentChangesListResponse(struct soap *soap, merc__GetVetDocumentChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetVetDocumentChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, int id, merc__GetVetDocumentChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetVetDocumentChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListResponse ** FASTCALL soap_in_PointerTomerc__GetVetDocumentChangesListResponse(struct soap *soap, const char *tag, merc__GetVetDocumentChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetVetDocumentChangesListResponse **)soap_malloc(soap, sizeof(merc__GetVetDocumentChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetVetDocumentChangesListResponse *)soap_instantiate_merc__GetVetDocumentChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetVetDocumentChangesListResponse ** p = (merc__GetVetDocumentChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetVetDocumentChangesListResponse, sizeof(merc__GetVetDocumentChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetVetDocumentChangesListResponse(struct soap *soap, merc__GetVetDocumentChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListResponse);
	return soap_out_PointerTomerc__GetVetDocumentChangesListResponse(soap, tag?tag:"merc:GetVetDocumentChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetVetDocumentChangesListResponse(struct soap *soap, merc__GetVetDocumentChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetVetDocumentChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetVetDocumentChangesListRequest(struct soap *soap, merc__GetVetDocumentChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetVetDocumentChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, int id, merc__GetVetDocumentChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetVetDocumentChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListRequest ** FASTCALL soap_in_PointerTomerc__GetVetDocumentChangesListRequest(struct soap *soap, const char *tag, merc__GetVetDocumentChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetVetDocumentChangesListRequest **)soap_malloc(soap, sizeof(merc__GetVetDocumentChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetVetDocumentChangesListRequest *)soap_instantiate_merc__GetVetDocumentChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetVetDocumentChangesListRequest ** p = (merc__GetVetDocumentChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetVetDocumentChangesListRequest, sizeof(merc__GetVetDocumentChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetVetDocumentChangesListRequest(struct soap *soap, merc__GetVetDocumentChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetVetDocumentChangesListRequest);
	return soap_out_PointerTomerc__GetVetDocumentChangesListRequest(soap, tag?tag:"merc:GetVetDocumentChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetVetDocumentChangesListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetVetDocumentChangesListRequest(struct soap *soap, merc__GetVetDocumentChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetVetDocumentChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetVetDocumentListResponse(struct soap *soap, merc__GetVetDocumentListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetVetDocumentListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetVetDocumentListResponse(struct soap *soap, const char *tag, int id, merc__GetVetDocumentListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetVetDocumentListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetVetDocumentListResponse ** FASTCALL soap_in_PointerTomerc__GetVetDocumentListResponse(struct soap *soap, const char *tag, merc__GetVetDocumentListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetVetDocumentListResponse **)soap_malloc(soap, sizeof(merc__GetVetDocumentListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetVetDocumentListResponse *)soap_instantiate_merc__GetVetDocumentListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetVetDocumentListResponse ** p = (merc__GetVetDocumentListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetVetDocumentListResponse, sizeof(merc__GetVetDocumentListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetVetDocumentListResponse(struct soap *soap, merc__GetVetDocumentListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetVetDocumentListResponse);
	return soap_out_PointerTomerc__GetVetDocumentListResponse(soap, tag?tag:"merc:GetVetDocumentListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetVetDocumentListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetVetDocumentListResponse(struct soap *soap, merc__GetVetDocumentListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetVetDocumentListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetVetDocumentListRequest(struct soap *soap, merc__GetVetDocumentListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetVetDocumentListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetVetDocumentListRequest(struct soap *soap, const char *tag, int id, merc__GetVetDocumentListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetVetDocumentListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetVetDocumentListRequest ** FASTCALL soap_in_PointerTomerc__GetVetDocumentListRequest(struct soap *soap, const char *tag, merc__GetVetDocumentListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetVetDocumentListRequest **)soap_malloc(soap, sizeof(merc__GetVetDocumentListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetVetDocumentListRequest *)soap_instantiate_merc__GetVetDocumentListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetVetDocumentListRequest ** p = (merc__GetVetDocumentListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetVetDocumentListRequest, sizeof(merc__GetVetDocumentListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetVetDocumentListRequest(struct soap *soap, merc__GetVetDocumentListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetVetDocumentListRequest);
	return soap_out_PointerTomerc__GetVetDocumentListRequest(soap, tag?tag:"merc:GetVetDocumentListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetVetDocumentListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetVetDocumentListRequest(struct soap *soap, merc__GetVetDocumentListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetVetDocumentListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetVetDocumentByUuidResponse(struct soap *soap, merc__GetVetDocumentByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetVetDocumentByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, int id, merc__GetVetDocumentByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetVetDocumentByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidResponse ** FASTCALL soap_in_PointerTomerc__GetVetDocumentByUuidResponse(struct soap *soap, const char *tag, merc__GetVetDocumentByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetVetDocumentByUuidResponse **)soap_malloc(soap, sizeof(merc__GetVetDocumentByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetVetDocumentByUuidResponse *)soap_instantiate_merc__GetVetDocumentByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetVetDocumentByUuidResponse ** p = (merc__GetVetDocumentByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetVetDocumentByUuidResponse, sizeof(merc__GetVetDocumentByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetVetDocumentByUuidResponse(struct soap *soap, merc__GetVetDocumentByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidResponse);
	return soap_out_PointerTomerc__GetVetDocumentByUuidResponse(soap, tag?tag:"merc:GetVetDocumentByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidResponse ** SOAP_FMAC4 soap_get_PointerTomerc__GetVetDocumentByUuidResponse(struct soap *soap, merc__GetVetDocumentByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetVetDocumentByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__GetVetDocumentByUuidRequest(struct soap *soap, merc__GetVetDocumentByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__GetVetDocumentByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, int id, merc__GetVetDocumentByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__GetVetDocumentByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidRequest ** FASTCALL soap_in_PointerTomerc__GetVetDocumentByUuidRequest(struct soap *soap, const char *tag, merc__GetVetDocumentByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__GetVetDocumentByUuidRequest **)soap_malloc(soap, sizeof(merc__GetVetDocumentByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__GetVetDocumentByUuidRequest *)soap_instantiate_merc__GetVetDocumentByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__GetVetDocumentByUuidRequest ** p = (merc__GetVetDocumentByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__GetVetDocumentByUuidRequest, sizeof(merc__GetVetDocumentByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__GetVetDocumentByUuidRequest(struct soap *soap, merc__GetVetDocumentByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__GetVetDocumentByUuidRequest);
	return soap_out_PointerTomerc__GetVetDocumentByUuidRequest(soap, tag?tag:"merc:GetVetDocumentByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__GetVetDocumentByUuidRequest ** SOAP_FMAC4 soap_get_PointerTomerc__GetVetDocumentByUuidRequest(struct soap *soap, merc__GetVetDocumentByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__GetVetDocumentByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyProducerStockListResponse(struct soap *soap, merc__ModifyProducerStockListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyProducerStockListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyProducerStockListResponse(struct soap *soap, const char *tag, int id, merc__ModifyProducerStockListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyProducerStockListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyProducerStockListResponse ** FASTCALL soap_in_PointerTomerc__ModifyProducerStockListResponse(struct soap *soap, const char *tag, merc__ModifyProducerStockListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyProducerStockListResponse **)soap_malloc(soap, sizeof(merc__ModifyProducerStockListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyProducerStockListResponse *)soap_instantiate_merc__ModifyProducerStockListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyProducerStockListResponse ** p = (merc__ModifyProducerStockListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyProducerStockListResponse, sizeof(merc__ModifyProducerStockListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyProducerStockListResponse(struct soap *soap, merc__ModifyProducerStockListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyProducerStockListResponse);
	return soap_out_PointerTomerc__ModifyProducerStockListResponse(soap, tag?tag:"merc:ModifyProducerStockListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyProducerStockListResponse ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyProducerStockListResponse(struct soap *soap, merc__ModifyProducerStockListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyProducerStockListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyProducerStockListRequest(struct soap *soap, merc__ModifyProducerStockListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyProducerStockListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyProducerStockListRequest(struct soap *soap, const char *tag, int id, merc__ModifyProducerStockListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyProducerStockListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyProducerStockListRequest ** FASTCALL soap_in_PointerTomerc__ModifyProducerStockListRequest(struct soap *soap, const char *tag, merc__ModifyProducerStockListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyProducerStockListRequest **)soap_malloc(soap, sizeof(merc__ModifyProducerStockListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyProducerStockListRequest *)soap_instantiate_merc__ModifyProducerStockListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyProducerStockListRequest ** p = (merc__ModifyProducerStockListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyProducerStockListRequest, sizeof(merc__ModifyProducerStockListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyProducerStockListRequest(struct soap *soap, merc__ModifyProducerStockListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyProducerStockListRequest);
	return soap_out_PointerTomerc__ModifyProducerStockListRequest(soap, tag?tag:"merc:ModifyProducerStockListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyProducerStockListRequest ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyProducerStockListRequest(struct soap *soap, merc__ModifyProducerStockListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyProducerStockListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ResolveDiscrepancyResponse(struct soap *soap, merc__ResolveDiscrepancyResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ResolveDiscrepancyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, int id, merc__ResolveDiscrepancyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ResolveDiscrepancyResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ResolveDiscrepancyResponse ** FASTCALL soap_in_PointerTomerc__ResolveDiscrepancyResponse(struct soap *soap, const char *tag, merc__ResolveDiscrepancyResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ResolveDiscrepancyResponse **)soap_malloc(soap, sizeof(merc__ResolveDiscrepancyResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ResolveDiscrepancyResponse *)soap_instantiate_merc__ResolveDiscrepancyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ResolveDiscrepancyResponse ** p = (merc__ResolveDiscrepancyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ResolveDiscrepancyResponse, sizeof(merc__ResolveDiscrepancyResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ResolveDiscrepancyResponse(struct soap *soap, merc__ResolveDiscrepancyResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ResolveDiscrepancyResponse);
	return soap_out_PointerTomerc__ResolveDiscrepancyResponse(soap, tag?tag:"merc:ResolveDiscrepancyResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ResolveDiscrepancyResponse ** SOAP_FMAC4 soap_get_PointerTomerc__ResolveDiscrepancyResponse(struct soap *soap, merc__ResolveDiscrepancyResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ResolveDiscrepancyResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ResolveDiscrepancyRequest(struct soap *soap, merc__ResolveDiscrepancyRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ResolveDiscrepancyRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, int id, merc__ResolveDiscrepancyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ResolveDiscrepancyRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ResolveDiscrepancyRequest ** FASTCALL soap_in_PointerTomerc__ResolveDiscrepancyRequest(struct soap *soap, const char *tag, merc__ResolveDiscrepancyRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ResolveDiscrepancyRequest **)soap_malloc(soap, sizeof(merc__ResolveDiscrepancyRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ResolveDiscrepancyRequest *)soap_instantiate_merc__ResolveDiscrepancyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ResolveDiscrepancyRequest ** p = (merc__ResolveDiscrepancyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ResolveDiscrepancyRequest, sizeof(merc__ResolveDiscrepancyRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ResolveDiscrepancyRequest(struct soap *soap, merc__ResolveDiscrepancyRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ResolveDiscrepancyRequest);
	return soap_out_PointerTomerc__ResolveDiscrepancyRequest(soap, tag?tag:"merc:ResolveDiscrepancyRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ResolveDiscrepancyRequest ** SOAP_FMAC4 soap_get_PointerTomerc__ResolveDiscrepancyRequest(struct soap *soap, merc__ResolveDiscrepancyRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ResolveDiscrepancyRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyActivityLocationsResponse(struct soap *soap, merc__ModifyActivityLocationsResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyActivityLocationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, int id, merc__ModifyActivityLocationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyActivityLocationsResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyActivityLocationsResponse ** FASTCALL soap_in_PointerTomerc__ModifyActivityLocationsResponse(struct soap *soap, const char *tag, merc__ModifyActivityLocationsResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyActivityLocationsResponse **)soap_malloc(soap, sizeof(merc__ModifyActivityLocationsResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyActivityLocationsResponse *)soap_instantiate_merc__ModifyActivityLocationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyActivityLocationsResponse ** p = (merc__ModifyActivityLocationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyActivityLocationsResponse, sizeof(merc__ModifyActivityLocationsResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyActivityLocationsResponse(struct soap *soap, merc__ModifyActivityLocationsResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyActivityLocationsResponse);
	return soap_out_PointerTomerc__ModifyActivityLocationsResponse(soap, tag?tag:"merc:ModifyActivityLocationsResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyActivityLocationsResponse ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyActivityLocationsResponse(struct soap *soap, merc__ModifyActivityLocationsResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyActivityLocationsResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyActivityLocationsRequest(struct soap *soap, merc__ModifyActivityLocationsRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyActivityLocationsRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, int id, merc__ModifyActivityLocationsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyActivityLocationsRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyActivityLocationsRequest ** FASTCALL soap_in_PointerTomerc__ModifyActivityLocationsRequest(struct soap *soap, const char *tag, merc__ModifyActivityLocationsRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyActivityLocationsRequest **)soap_malloc(soap, sizeof(merc__ModifyActivityLocationsRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyActivityLocationsRequest *)soap_instantiate_merc__ModifyActivityLocationsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyActivityLocationsRequest ** p = (merc__ModifyActivityLocationsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyActivityLocationsRequest, sizeof(merc__ModifyActivityLocationsRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyActivityLocationsRequest(struct soap *soap, merc__ModifyActivityLocationsRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyActivityLocationsRequest);
	return soap_out_PointerTomerc__ModifyActivityLocationsRequest(soap, tag?tag:"merc:ModifyActivityLocationsRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyActivityLocationsRequest ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyActivityLocationsRequest(struct soap *soap, merc__ModifyActivityLocationsRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyActivityLocationsRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyEnterpriseResponse(struct soap *soap, merc__ModifyEnterpriseResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyEnterpriseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyEnterpriseResponse(struct soap *soap, const char *tag, int id, merc__ModifyEnterpriseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyEnterpriseResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyEnterpriseResponse ** FASTCALL soap_in_PointerTomerc__ModifyEnterpriseResponse(struct soap *soap, const char *tag, merc__ModifyEnterpriseResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyEnterpriseResponse **)soap_malloc(soap, sizeof(merc__ModifyEnterpriseResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyEnterpriseResponse *)soap_instantiate_merc__ModifyEnterpriseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyEnterpriseResponse ** p = (merc__ModifyEnterpriseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyEnterpriseResponse, sizeof(merc__ModifyEnterpriseResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyEnterpriseResponse(struct soap *soap, merc__ModifyEnterpriseResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyEnterpriseResponse);
	return soap_out_PointerTomerc__ModifyEnterpriseResponse(soap, tag?tag:"merc:ModifyEnterpriseResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyEnterpriseResponse ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyEnterpriseResponse(struct soap *soap, merc__ModifyEnterpriseResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyEnterpriseResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyEnterpriseRequest(struct soap *soap, merc__ModifyEnterpriseRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyEnterpriseRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyEnterpriseRequest(struct soap *soap, const char *tag, int id, merc__ModifyEnterpriseRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyEnterpriseRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyEnterpriseRequest ** FASTCALL soap_in_PointerTomerc__ModifyEnterpriseRequest(struct soap *soap, const char *tag, merc__ModifyEnterpriseRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyEnterpriseRequest **)soap_malloc(soap, sizeof(merc__ModifyEnterpriseRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyEnterpriseRequest *)soap_instantiate_merc__ModifyEnterpriseRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyEnterpriseRequest ** p = (merc__ModifyEnterpriseRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyEnterpriseRequest, sizeof(merc__ModifyEnterpriseRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyEnterpriseRequest(struct soap *soap, merc__ModifyEnterpriseRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyEnterpriseRequest);
	return soap_out_PointerTomerc__ModifyEnterpriseRequest(soap, tag?tag:"merc:ModifyEnterpriseRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyEnterpriseRequest ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyEnterpriseRequest(struct soap *soap, merc__ModifyEnterpriseRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyEnterpriseRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyBusinessEntityResponse(struct soap *soap, merc__ModifyBusinessEntityResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyBusinessEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, int id, merc__ModifyBusinessEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyBusinessEntityResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyBusinessEntityResponse ** FASTCALL soap_in_PointerTomerc__ModifyBusinessEntityResponse(struct soap *soap, const char *tag, merc__ModifyBusinessEntityResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyBusinessEntityResponse **)soap_malloc(soap, sizeof(merc__ModifyBusinessEntityResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyBusinessEntityResponse *)soap_instantiate_merc__ModifyBusinessEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyBusinessEntityResponse ** p = (merc__ModifyBusinessEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyBusinessEntityResponse, sizeof(merc__ModifyBusinessEntityResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyBusinessEntityResponse(struct soap *soap, merc__ModifyBusinessEntityResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyBusinessEntityResponse);
	return soap_out_PointerTomerc__ModifyBusinessEntityResponse(soap, tag?tag:"merc:ModifyBusinessEntityResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyBusinessEntityResponse ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyBusinessEntityResponse(struct soap *soap, merc__ModifyBusinessEntityResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyBusinessEntityResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ModifyBusinessEntityRequest(struct soap *soap, merc__ModifyBusinessEntityRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ModifyBusinessEntityRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, int id, merc__ModifyBusinessEntityRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ModifyBusinessEntityRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ModifyBusinessEntityRequest ** FASTCALL soap_in_PointerTomerc__ModifyBusinessEntityRequest(struct soap *soap, const char *tag, merc__ModifyBusinessEntityRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ModifyBusinessEntityRequest **)soap_malloc(soap, sizeof(merc__ModifyBusinessEntityRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ModifyBusinessEntityRequest *)soap_instantiate_merc__ModifyBusinessEntityRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ModifyBusinessEntityRequest ** p = (merc__ModifyBusinessEntityRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ModifyBusinessEntityRequest, sizeof(merc__ModifyBusinessEntityRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ModifyBusinessEntityRequest(struct soap *soap, merc__ModifyBusinessEntityRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ModifyBusinessEntityRequest);
	return soap_out_PointerTomerc__ModifyBusinessEntityRequest(soap, tag?tag:"merc:ModifyBusinessEntityRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ModifyBusinessEntityRequest ** SOAP_FMAC4 soap_get_PointerTomerc__ModifyBusinessEntityRequest(struct soap *soap, merc__ModifyBusinessEntityRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ModifyBusinessEntityRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__WithdrawVetDocumentResponse(struct soap *soap, merc__WithdrawVetDocumentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__WithdrawVetDocumentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, int id, merc__WithdrawVetDocumentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__WithdrawVetDocumentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__WithdrawVetDocumentResponse ** FASTCALL soap_in_PointerTomerc__WithdrawVetDocumentResponse(struct soap *soap, const char *tag, merc__WithdrawVetDocumentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__WithdrawVetDocumentResponse **)soap_malloc(soap, sizeof(merc__WithdrawVetDocumentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__WithdrawVetDocumentResponse *)soap_instantiate_merc__WithdrawVetDocumentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__WithdrawVetDocumentResponse ** p = (merc__WithdrawVetDocumentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__WithdrawVetDocumentResponse, sizeof(merc__WithdrawVetDocumentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__WithdrawVetDocumentResponse(struct soap *soap, merc__WithdrawVetDocumentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__WithdrawVetDocumentResponse);
	return soap_out_PointerTomerc__WithdrawVetDocumentResponse(soap, tag?tag:"merc:WithdrawVetDocumentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__WithdrawVetDocumentResponse ** SOAP_FMAC4 soap_get_PointerTomerc__WithdrawVetDocumentResponse(struct soap *soap, merc__WithdrawVetDocumentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__WithdrawVetDocumentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__WithdrawVetDocumentRequest(struct soap *soap, merc__WithdrawVetDocumentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__WithdrawVetDocumentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, int id, merc__WithdrawVetDocumentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__WithdrawVetDocumentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__WithdrawVetDocumentRequest ** FASTCALL soap_in_PointerTomerc__WithdrawVetDocumentRequest(struct soap *soap, const char *tag, merc__WithdrawVetDocumentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__WithdrawVetDocumentRequest **)soap_malloc(soap, sizeof(merc__WithdrawVetDocumentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__WithdrawVetDocumentRequest *)soap_instantiate_merc__WithdrawVetDocumentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__WithdrawVetDocumentRequest ** p = (merc__WithdrawVetDocumentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__WithdrawVetDocumentRequest, sizeof(merc__WithdrawVetDocumentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__WithdrawVetDocumentRequest(struct soap *soap, merc__WithdrawVetDocumentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__WithdrawVetDocumentRequest);
	return soap_out_PointerTomerc__WithdrawVetDocumentRequest(soap, tag?tag:"merc:WithdrawVetDocumentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__WithdrawVetDocumentRequest ** SOAP_FMAC4 soap_get_PointerTomerc__WithdrawVetDocumentRequest(struct soap *soap, merc__WithdrawVetDocumentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__WithdrawVetDocumentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__MergeStockEntriesResponse(struct soap *soap, merc__MergeStockEntriesResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__MergeStockEntriesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__MergeStockEntriesResponse(struct soap *soap, const char *tag, int id, merc__MergeStockEntriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__MergeStockEntriesResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__MergeStockEntriesResponse ** FASTCALL soap_in_PointerTomerc__MergeStockEntriesResponse(struct soap *soap, const char *tag, merc__MergeStockEntriesResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__MergeStockEntriesResponse **)soap_malloc(soap, sizeof(merc__MergeStockEntriesResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__MergeStockEntriesResponse *)soap_instantiate_merc__MergeStockEntriesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__MergeStockEntriesResponse ** p = (merc__MergeStockEntriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__MergeStockEntriesResponse, sizeof(merc__MergeStockEntriesResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__MergeStockEntriesResponse(struct soap *soap, merc__MergeStockEntriesResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__MergeStockEntriesResponse);
	return soap_out_PointerTomerc__MergeStockEntriesResponse(soap, tag?tag:"merc:MergeStockEntriesResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__MergeStockEntriesResponse ** SOAP_FMAC4 soap_get_PointerTomerc__MergeStockEntriesResponse(struct soap *soap, merc__MergeStockEntriesResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__MergeStockEntriesResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__MergeStockEntriesRequest(struct soap *soap, merc__MergeStockEntriesRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__MergeStockEntriesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__MergeStockEntriesRequest(struct soap *soap, const char *tag, int id, merc__MergeStockEntriesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__MergeStockEntriesRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__MergeStockEntriesRequest ** FASTCALL soap_in_PointerTomerc__MergeStockEntriesRequest(struct soap *soap, const char *tag, merc__MergeStockEntriesRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__MergeStockEntriesRequest **)soap_malloc(soap, sizeof(merc__MergeStockEntriesRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__MergeStockEntriesRequest *)soap_instantiate_merc__MergeStockEntriesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__MergeStockEntriesRequest ** p = (merc__MergeStockEntriesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__MergeStockEntriesRequest, sizeof(merc__MergeStockEntriesRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__MergeStockEntriesRequest(struct soap *soap, merc__MergeStockEntriesRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__MergeStockEntriesRequest);
	return soap_out_PointerTomerc__MergeStockEntriesRequest(soap, tag?tag:"merc:MergeStockEntriesRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__MergeStockEntriesRequest ** SOAP_FMAC4 soap_get_PointerTomerc__MergeStockEntriesRequest(struct soap *soap, merc__MergeStockEntriesRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__MergeStockEntriesRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__RegisterProductionOperationResponse(struct soap *soap, merc__RegisterProductionOperationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__RegisterProductionOperationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__RegisterProductionOperationResponse(struct soap *soap, const char *tag, int id, merc__RegisterProductionOperationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__RegisterProductionOperationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__RegisterProductionOperationResponse ** FASTCALL soap_in_PointerTomerc__RegisterProductionOperationResponse(struct soap *soap, const char *tag, merc__RegisterProductionOperationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__RegisterProductionOperationResponse **)soap_malloc(soap, sizeof(merc__RegisterProductionOperationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__RegisterProductionOperationResponse *)soap_instantiate_merc__RegisterProductionOperationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__RegisterProductionOperationResponse ** p = (merc__RegisterProductionOperationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__RegisterProductionOperationResponse, sizeof(merc__RegisterProductionOperationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__RegisterProductionOperationResponse(struct soap *soap, merc__RegisterProductionOperationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__RegisterProductionOperationResponse);
	return soap_out_PointerTomerc__RegisterProductionOperationResponse(soap, tag?tag:"merc:RegisterProductionOperationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__RegisterProductionOperationResponse ** SOAP_FMAC4 soap_get_PointerTomerc__RegisterProductionOperationResponse(struct soap *soap, merc__RegisterProductionOperationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__RegisterProductionOperationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__RegisterProductionOperationRequest(struct soap *soap, merc__RegisterProductionOperationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__RegisterProductionOperationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__RegisterProductionOperationRequest(struct soap *soap, const char *tag, int id, merc__RegisterProductionOperationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__RegisterProductionOperationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__RegisterProductionOperationRequest ** FASTCALL soap_in_PointerTomerc__RegisterProductionOperationRequest(struct soap *soap, const char *tag, merc__RegisterProductionOperationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__RegisterProductionOperationRequest **)soap_malloc(soap, sizeof(merc__RegisterProductionOperationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__RegisterProductionOperationRequest *)soap_instantiate_merc__RegisterProductionOperationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__RegisterProductionOperationRequest ** p = (merc__RegisterProductionOperationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__RegisterProductionOperationRequest, sizeof(merc__RegisterProductionOperationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__RegisterProductionOperationRequest(struct soap *soap, merc__RegisterProductionOperationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__RegisterProductionOperationRequest);
	return soap_out_PointerTomerc__RegisterProductionOperationRequest(soap, tag?tag:"merc:RegisterProductionOperationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__RegisterProductionOperationRequest ** SOAP_FMAC4 soap_get_PointerTomerc__RegisterProductionOperationRequest(struct soap *soap, merc__RegisterProductionOperationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__RegisterProductionOperationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__PrepareOutgoingConsignmentResponse(struct soap *soap, merc__PrepareOutgoingConsignmentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, int id, merc__PrepareOutgoingConsignmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentResponse ** FASTCALL soap_in_PointerTomerc__PrepareOutgoingConsignmentResponse(struct soap *soap, const char *tag, merc__PrepareOutgoingConsignmentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__PrepareOutgoingConsignmentResponse **)soap_malloc(soap, sizeof(merc__PrepareOutgoingConsignmentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__PrepareOutgoingConsignmentResponse *)soap_instantiate_merc__PrepareOutgoingConsignmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__PrepareOutgoingConsignmentResponse ** p = (merc__PrepareOutgoingConsignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__PrepareOutgoingConsignmentResponse, sizeof(merc__PrepareOutgoingConsignmentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__PrepareOutgoingConsignmentResponse(struct soap *soap, merc__PrepareOutgoingConsignmentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentResponse);
	return soap_out_PointerTomerc__PrepareOutgoingConsignmentResponse(soap, tag?tag:"merc:PrepareOutgoingConsignmentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentResponse ** SOAP_FMAC4 soap_get_PointerTomerc__PrepareOutgoingConsignmentResponse(struct soap *soap, merc__PrepareOutgoingConsignmentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__PrepareOutgoingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__PrepareOutgoingConsignmentRequest(struct soap *soap, merc__PrepareOutgoingConsignmentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, int id, merc__PrepareOutgoingConsignmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentRequest ** FASTCALL soap_in_PointerTomerc__PrepareOutgoingConsignmentRequest(struct soap *soap, const char *tag, merc__PrepareOutgoingConsignmentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__PrepareOutgoingConsignmentRequest **)soap_malloc(soap, sizeof(merc__PrepareOutgoingConsignmentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__PrepareOutgoingConsignmentRequest *)soap_instantiate_merc__PrepareOutgoingConsignmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__PrepareOutgoingConsignmentRequest ** p = (merc__PrepareOutgoingConsignmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__PrepareOutgoingConsignmentRequest, sizeof(merc__PrepareOutgoingConsignmentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__PrepareOutgoingConsignmentRequest(struct soap *soap, merc__PrepareOutgoingConsignmentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__PrepareOutgoingConsignmentRequest);
	return soap_out_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, tag?tag:"merc:PrepareOutgoingConsignmentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__PrepareOutgoingConsignmentRequest ** SOAP_FMAC4 soap_get_PointerTomerc__PrepareOutgoingConsignmentRequest(struct soap *soap, merc__PrepareOutgoingConsignmentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__PrepareOutgoingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ProcessIncomingConsignmentResponse(struct soap *soap, merc__ProcessIncomingConsignmentResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, int id, merc__ProcessIncomingConsignmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentResponse ** FASTCALL soap_in_PointerTomerc__ProcessIncomingConsignmentResponse(struct soap *soap, const char *tag, merc__ProcessIncomingConsignmentResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ProcessIncomingConsignmentResponse **)soap_malloc(soap, sizeof(merc__ProcessIncomingConsignmentResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ProcessIncomingConsignmentResponse *)soap_instantiate_merc__ProcessIncomingConsignmentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ProcessIncomingConsignmentResponse ** p = (merc__ProcessIncomingConsignmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ProcessIncomingConsignmentResponse, sizeof(merc__ProcessIncomingConsignmentResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ProcessIncomingConsignmentResponse(struct soap *soap, merc__ProcessIncomingConsignmentResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentResponse);
	return soap_out_PointerTomerc__ProcessIncomingConsignmentResponse(soap, tag?tag:"merc:ProcessIncomingConsignmentResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentResponse ** SOAP_FMAC4 soap_get_PointerTomerc__ProcessIncomingConsignmentResponse(struct soap *soap, merc__ProcessIncomingConsignmentResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ProcessIncomingConsignmentResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomerc__ProcessIncomingConsignmentRequest(struct soap *soap, merc__ProcessIncomingConsignmentRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTomerc__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, int id, merc__ProcessIncomingConsignmentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentRequest ** FASTCALL soap_in_PointerTomerc__ProcessIncomingConsignmentRequest(struct soap *soap, const char *tag, merc__ProcessIncomingConsignmentRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (merc__ProcessIncomingConsignmentRequest **)soap_malloc(soap, sizeof(merc__ProcessIncomingConsignmentRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (merc__ProcessIncomingConsignmentRequest *)soap_instantiate_merc__ProcessIncomingConsignmentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		merc__ProcessIncomingConsignmentRequest ** p = (merc__ProcessIncomingConsignmentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_merc__ProcessIncomingConsignmentRequest, sizeof(merc__ProcessIncomingConsignmentRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomerc__ProcessIncomingConsignmentRequest(struct soap *soap, merc__ProcessIncomingConsignmentRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomerc__ProcessIncomingConsignmentRequest);
	return soap_out_PointerTomerc__ProcessIncomingConsignmentRequest(soap, tag?tag:"merc:ProcessIncomingConsignmentRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 merc__ProcessIncomingConsignmentRequest ** SOAP_FMAC4 soap_get_PointerTomerc__ProcessIncomingConsignmentRequest(struct soap *soap, merc__ProcessIncomingConsignmentRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTomerc__ProcessIncomingConsignmentRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__receiveApplicationResultResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, int id, _ws__receiveApplicationResultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__receiveApplicationResultResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse ** FASTCALL soap_in_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, const char *tag, _ws__receiveApplicationResultResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__receiveApplicationResultResponse **)soap_malloc(soap, sizeof(_ws__receiveApplicationResultResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__receiveApplicationResultResponse *)soap_instantiate__ws__receiveApplicationResultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__receiveApplicationResultResponse ** p = (_ws__receiveApplicationResultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__receiveApplicationResultResponse, sizeof(_ws__receiveApplicationResultResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__receiveApplicationResultResponse);
	return soap_out_PointerTo_ws__receiveApplicationResultResponse(soap, tag?tag:"ws:receiveApplicationResultResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__receiveApplicationResultResponse ** SOAP_FMAC4 soap_get_PointerTo_ws__receiveApplicationResultResponse(struct soap *soap, _ws__receiveApplicationResultResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__receiveApplicationResultResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__receiveApplicationResultRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, int id, _ws__receiveApplicationResultRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__receiveApplicationResultRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest ** FASTCALL soap_in_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, const char *tag, _ws__receiveApplicationResultRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__receiveApplicationResultRequest **)soap_malloc(soap, sizeof(_ws__receiveApplicationResultRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__receiveApplicationResultRequest *)soap_instantiate__ws__receiveApplicationResultRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__receiveApplicationResultRequest ** p = (_ws__receiveApplicationResultRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__receiveApplicationResultRequest, sizeof(_ws__receiveApplicationResultRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__receiveApplicationResultRequest);
	return soap_out_PointerTo_ws__receiveApplicationResultRequest(soap, tag?tag:"ws:receiveApplicationResultRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__receiveApplicationResultRequest ** SOAP_FMAC4 soap_get_PointerTo_ws__receiveApplicationResultRequest(struct soap *soap, _ws__receiveApplicationResultRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__receiveApplicationResultRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__submitApplicationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__submitApplicationResponse(struct soap *soap, const char *tag, int id, _ws__submitApplicationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__submitApplicationResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__submitApplicationResponse ** FASTCALL soap_in_PointerTo_ws__submitApplicationResponse(struct soap *soap, const char *tag, _ws__submitApplicationResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__submitApplicationResponse **)soap_malloc(soap, sizeof(_ws__submitApplicationResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__submitApplicationResponse *)soap_instantiate__ws__submitApplicationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__submitApplicationResponse ** p = (_ws__submitApplicationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__submitApplicationResponse, sizeof(_ws__submitApplicationResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__submitApplicationResponse);
	return soap_out_PointerTo_ws__submitApplicationResponse(soap, tag?tag:"ws:submitApplicationResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__submitApplicationResponse ** SOAP_FMAC4 soap_get_PointerTo_ws__submitApplicationResponse(struct soap *soap, _ws__submitApplicationResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__submitApplicationResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ws__submitApplicationRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ws__submitApplicationRequest(struct soap *soap, const char *tag, int id, _ws__submitApplicationRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ws__submitApplicationRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ws__submitApplicationRequest ** FASTCALL soap_in_PointerTo_ws__submitApplicationRequest(struct soap *soap, const char *tag, _ws__submitApplicationRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ws__submitApplicationRequest **)soap_malloc(soap, sizeof(_ws__submitApplicationRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ws__submitApplicationRequest *)soap_instantiate__ws__submitApplicationRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ws__submitApplicationRequest ** p = (_ws__submitApplicationRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ws__submitApplicationRequest, sizeof(_ws__submitApplicationRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ws__submitApplicationRequest);
	return soap_out_PointerTo_ws__submitApplicationRequest(soap, tag?tag:"ws:submitApplicationRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ws__submitApplicationRequest ** SOAP_FMAC4 soap_get_PointerTo_ws__submitApplicationRequest(struct soap *soap, _ws__submitApplicationRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ws__submitApplicationRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemChangesListResponse(struct soap *soap, _ns8__getProductItemChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getProductItemChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getProductItemChangesListResponse(struct soap *soap, const char *tag, _ns8__getProductItemChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getProductItemChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemChangesListResponse *)soap_instantiate__ns8__getProductItemChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemChangesListResponse ** p = (_ns8__getProductItemChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemChangesListResponse, sizeof(_ns8__getProductItemChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemChangesListResponse(struct soap *soap, _ns8__getProductItemChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemChangesListResponse);
	return soap_out_PointerTo_ns8__getProductItemChangesListResponse(soap, tag?tag:"ns8:getProductItemChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemChangesListResponse(struct soap *soap, _ns8__getProductItemChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemChangesListRequest(struct soap *soap, _ns8__getProductItemChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getProductItemChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getProductItemChangesListRequest(struct soap *soap, const char *tag, _ns8__getProductItemChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getProductItemChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemChangesListRequest *)soap_instantiate__ns8__getProductItemChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemChangesListRequest ** p = (_ns8__getProductItemChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemChangesListRequest, sizeof(_ns8__getProductItemChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemChangesListRequest(struct soap *soap, _ns8__getProductItemChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemChangesListRequest);
	return soap_out_PointerTo_ns8__getProductItemChangesListRequest(soap, tag?tag:"ns8:getProductItemChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemChangesListRequest(struct soap *soap, _ns8__getProductItemChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemListResponse(struct soap *soap, _ns8__getProductItemListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemListResponse(struct soap *soap, const char *tag, int id, _ns8__getProductItemListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemListResponse ** FASTCALL soap_in_PointerTo_ns8__getProductItemListResponse(struct soap *soap, const char *tag, _ns8__getProductItemListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemListResponse **)soap_malloc(soap, sizeof(_ns8__getProductItemListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemListResponse *)soap_instantiate__ns8__getProductItemListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemListResponse ** p = (_ns8__getProductItemListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemListResponse, sizeof(_ns8__getProductItemListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemListResponse(struct soap *soap, _ns8__getProductItemListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemListResponse);
	return soap_out_PointerTo_ns8__getProductItemListResponse(soap, tag?tag:"ns8:getProductItemListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemListResponse(struct soap *soap, _ns8__getProductItemListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemListRequest(struct soap *soap, _ns8__getProductItemListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemListRequest(struct soap *soap, const char *tag, int id, _ns8__getProductItemListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemListRequest ** FASTCALL soap_in_PointerTo_ns8__getProductItemListRequest(struct soap *soap, const char *tag, _ns8__getProductItemListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemListRequest **)soap_malloc(soap, sizeof(_ns8__getProductItemListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemListRequest *)soap_instantiate__ns8__getProductItemListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemListRequest ** p = (_ns8__getProductItemListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemListRequest, sizeof(_ns8__getProductItemListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemListRequest(struct soap *soap, _ns8__getProductItemListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemListRequest);
	return soap_out_PointerTo_ns8__getProductItemListRequest(soap, tag?tag:"ns8:getProductItemListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemListRequest(struct soap *soap, _ns8__getProductItemListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemByUuidResponse(struct soap *soap, _ns8__getProductItemByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getProductItemByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getProductItemByUuidResponse(struct soap *soap, const char *tag, _ns8__getProductItemByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getProductItemByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemByUuidResponse *)soap_instantiate__ns8__getProductItemByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemByUuidResponse ** p = (_ns8__getProductItemByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemByUuidResponse, sizeof(_ns8__getProductItemByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemByUuidResponse(struct soap *soap, _ns8__getProductItemByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemByUuidResponse);
	return soap_out_PointerTo_ns8__getProductItemByUuidResponse(soap, tag?tag:"ns8:getProductItemByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemByUuidResponse(struct soap *soap, _ns8__getProductItemByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemByUuidRequest(struct soap *soap, _ns8__getProductItemByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getProductItemByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getProductItemByUuidRequest(struct soap *soap, const char *tag, _ns8__getProductItemByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getProductItemByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemByUuidRequest *)soap_instantiate__ns8__getProductItemByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemByUuidRequest ** p = (_ns8__getProductItemByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemByUuidRequest, sizeof(_ns8__getProductItemByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemByUuidRequest(struct soap *soap, _ns8__getProductItemByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemByUuidRequest);
	return soap_out_PointerTo_ns8__getProductItemByUuidRequest(soap, tag?tag:"ns8:getProductItemByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemByUuidRequest(struct soap *soap, _ns8__getProductItemByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemByGuidResponse(struct soap *soap, _ns8__getProductItemByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getProductItemByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getProductItemByGuidResponse(struct soap *soap, const char *tag, _ns8__getProductItemByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getProductItemByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemByGuidResponse *)soap_instantiate__ns8__getProductItemByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemByGuidResponse ** p = (_ns8__getProductItemByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemByGuidResponse, sizeof(_ns8__getProductItemByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemByGuidResponse(struct soap *soap, _ns8__getProductItemByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemByGuidResponse);
	return soap_out_PointerTo_ns8__getProductItemByGuidResponse(soap, tag?tag:"ns8:getProductItemByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemByGuidResponse(struct soap *soap, _ns8__getProductItemByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductItemByGuidRequest(struct soap *soap, _ns8__getProductItemByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductItemByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductItemByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getProductItemByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductItemByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductItemByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getProductItemByGuidRequest(struct soap *soap, const char *tag, _ns8__getProductItemByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductItemByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getProductItemByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductItemByGuidRequest *)soap_instantiate__ns8__getProductItemByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductItemByGuidRequest ** p = (_ns8__getProductItemByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductItemByGuidRequest, sizeof(_ns8__getProductItemByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductItemByGuidRequest(struct soap *soap, _ns8__getProductItemByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductItemByGuidRequest);
	return soap_out_PointerTo_ns8__getProductItemByGuidRequest(soap, tag?tag:"ns8:getProductItemByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductItemByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductItemByGuidRequest(struct soap *soap, _ns8__getProductItemByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductItemByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductChangesListResponse(struct soap *soap, _ns8__getSubProductChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getSubProductChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getSubProductChangesListResponse(struct soap *soap, const char *tag, _ns8__getSubProductChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getSubProductChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductChangesListResponse *)soap_instantiate__ns8__getSubProductChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductChangesListResponse ** p = (_ns8__getSubProductChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductChangesListResponse, sizeof(_ns8__getSubProductChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductChangesListResponse(struct soap *soap, _ns8__getSubProductChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductChangesListResponse);
	return soap_out_PointerTo_ns8__getSubProductChangesListResponse(soap, tag?tag:"ns8:getSubProductChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductChangesListResponse(struct soap *soap, _ns8__getSubProductChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductChangesListRequest(struct soap *soap, _ns8__getSubProductChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getSubProductChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getSubProductChangesListRequest(struct soap *soap, const char *tag, _ns8__getSubProductChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getSubProductChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductChangesListRequest *)soap_instantiate__ns8__getSubProductChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductChangesListRequest ** p = (_ns8__getSubProductChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductChangesListRequest, sizeof(_ns8__getSubProductChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductChangesListRequest(struct soap *soap, _ns8__getSubProductChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductChangesListRequest);
	return soap_out_PointerTo_ns8__getSubProductChangesListRequest(soap, tag?tag:"ns8:getSubProductChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductChangesListRequest(struct soap *soap, _ns8__getSubProductChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductByProductListResponse(struct soap *soap, _ns8__getSubProductByProductListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductByProductListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductByProductListResponse(struct soap *soap, const char *tag, int id, _ns8__getSubProductByProductListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductByProductListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListResponse ** FASTCALL soap_in_PointerTo_ns8__getSubProductByProductListResponse(struct soap *soap, const char *tag, _ns8__getSubProductByProductListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductByProductListResponse **)soap_malloc(soap, sizeof(_ns8__getSubProductByProductListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductByProductListResponse *)soap_instantiate__ns8__getSubProductByProductListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductByProductListResponse ** p = (_ns8__getSubProductByProductListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductByProductListResponse, sizeof(_ns8__getSubProductByProductListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductByProductListResponse(struct soap *soap, _ns8__getSubProductByProductListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductByProductListResponse);
	return soap_out_PointerTo_ns8__getSubProductByProductListResponse(soap, tag?tag:"ns8:getSubProductByProductListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductByProductListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductByProductListResponse(struct soap *soap, _ns8__getSubProductByProductListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductByProductListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductByProductListRequest(struct soap *soap, _ns8__getSubProductByProductListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductByProductListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductByProductListRequest(struct soap *soap, const char *tag, int id, _ns8__getSubProductByProductListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductByProductListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductByProductListRequest ** FASTCALL soap_in_PointerTo_ns8__getSubProductByProductListRequest(struct soap *soap, const char *tag, _ns8__getSubProductByProductListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductByProductListRequest **)soap_malloc(soap, sizeof(_ns8__getSubProductByProductListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductByProductListRequest *)soap_instantiate__ns8__getSubProductByProductListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductByProductListRequest ** p = (_ns8__getSubProductByProductListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductByProductListRequest, sizeof(_ns8__getSubProductByProductListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductByProductListRequest(struct soap *soap, _ns8__getSubProductByProductListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductByProductListRequest);
	return soap_out_PointerTo_ns8__getSubProductByProductListRequest(soap, tag?tag:"ns8:getSubProductByProductListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductByProductListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductByProductListRequest(struct soap *soap, _ns8__getSubProductByProductListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductByProductListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductByUuidResponse(struct soap *soap, _ns8__getSubProductByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getSubProductByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getSubProductByUuidResponse(struct soap *soap, const char *tag, _ns8__getSubProductByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getSubProductByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductByUuidResponse *)soap_instantiate__ns8__getSubProductByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductByUuidResponse ** p = (_ns8__getSubProductByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductByUuidResponse, sizeof(_ns8__getSubProductByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductByUuidResponse(struct soap *soap, _ns8__getSubProductByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductByUuidResponse);
	return soap_out_PointerTo_ns8__getSubProductByUuidResponse(soap, tag?tag:"ns8:getSubProductByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductByUuidResponse(struct soap *soap, _ns8__getSubProductByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductByUuidRequest(struct soap *soap, _ns8__getSubProductByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getSubProductByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getSubProductByUuidRequest(struct soap *soap, const char *tag, _ns8__getSubProductByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getSubProductByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductByUuidRequest *)soap_instantiate__ns8__getSubProductByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductByUuidRequest ** p = (_ns8__getSubProductByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductByUuidRequest, sizeof(_ns8__getSubProductByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductByUuidRequest(struct soap *soap, _ns8__getSubProductByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductByUuidRequest);
	return soap_out_PointerTo_ns8__getSubProductByUuidRequest(soap, tag?tag:"ns8:getSubProductByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductByUuidRequest(struct soap *soap, _ns8__getSubProductByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductByGuidResponse(struct soap *soap, _ns8__getSubProductByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getSubProductByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getSubProductByGuidResponse(struct soap *soap, const char *tag, _ns8__getSubProductByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getSubProductByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductByGuidResponse *)soap_instantiate__ns8__getSubProductByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductByGuidResponse ** p = (_ns8__getSubProductByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductByGuidResponse, sizeof(_ns8__getSubProductByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductByGuidResponse(struct soap *soap, _ns8__getSubProductByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductByGuidResponse);
	return soap_out_PointerTo_ns8__getSubProductByGuidResponse(soap, tag?tag:"ns8:getSubProductByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductByGuidResponse(struct soap *soap, _ns8__getSubProductByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getSubProductByGuidRequest(struct soap *soap, _ns8__getSubProductByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getSubProductByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getSubProductByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getSubProductByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getSubProductByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getSubProductByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getSubProductByGuidRequest(struct soap *soap, const char *tag, _ns8__getSubProductByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getSubProductByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getSubProductByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getSubProductByGuidRequest *)soap_instantiate__ns8__getSubProductByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getSubProductByGuidRequest ** p = (_ns8__getSubProductByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getSubProductByGuidRequest, sizeof(_ns8__getSubProductByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getSubProductByGuidRequest(struct soap *soap, _ns8__getSubProductByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getSubProductByGuidRequest);
	return soap_out_PointerTo_ns8__getSubProductByGuidRequest(soap, tag?tag:"ns8:getSubProductByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getSubProductByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getSubProductByGuidRequest(struct soap *soap, _ns8__getSubProductByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getSubProductByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductChangesListResponse(struct soap *soap, _ns8__getProductChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getProductChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getProductChangesListResponse(struct soap *soap, const char *tag, _ns8__getProductChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getProductChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductChangesListResponse *)soap_instantiate__ns8__getProductChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductChangesListResponse ** p = (_ns8__getProductChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductChangesListResponse, sizeof(_ns8__getProductChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductChangesListResponse(struct soap *soap, _ns8__getProductChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductChangesListResponse);
	return soap_out_PointerTo_ns8__getProductChangesListResponse(soap, tag?tag:"ns8:getProductChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductChangesListResponse(struct soap *soap, _ns8__getProductChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductChangesListRequest(struct soap *soap, _ns8__getProductChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getProductChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getProductChangesListRequest(struct soap *soap, const char *tag, _ns8__getProductChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getProductChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductChangesListRequest *)soap_instantiate__ns8__getProductChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductChangesListRequest ** p = (_ns8__getProductChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductChangesListRequest, sizeof(_ns8__getProductChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductChangesListRequest(struct soap *soap, _ns8__getProductChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductChangesListRequest);
	return soap_out_PointerTo_ns8__getProductChangesListRequest(soap, tag?tag:"ns8:getProductChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductChangesListRequest(struct soap *soap, _ns8__getProductChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductByTypeListResponse(struct soap *soap, _ns8__getProductByTypeListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductByTypeListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductByTypeListResponse(struct soap *soap, const char *tag, int id, _ns8__getProductByTypeListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductByTypeListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListResponse ** FASTCALL soap_in_PointerTo_ns8__getProductByTypeListResponse(struct soap *soap, const char *tag, _ns8__getProductByTypeListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductByTypeListResponse **)soap_malloc(soap, sizeof(_ns8__getProductByTypeListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductByTypeListResponse *)soap_instantiate__ns8__getProductByTypeListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductByTypeListResponse ** p = (_ns8__getProductByTypeListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductByTypeListResponse, sizeof(_ns8__getProductByTypeListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductByTypeListResponse(struct soap *soap, _ns8__getProductByTypeListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductByTypeListResponse);
	return soap_out_PointerTo_ns8__getProductByTypeListResponse(soap, tag?tag:"ns8:getProductByTypeListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductByTypeListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductByTypeListResponse(struct soap *soap, _ns8__getProductByTypeListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductByTypeListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductByTypeListRequest(struct soap *soap, _ns8__getProductByTypeListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductByTypeListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductByTypeListRequest(struct soap *soap, const char *tag, int id, _ns8__getProductByTypeListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductByTypeListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductByTypeListRequest ** FASTCALL soap_in_PointerTo_ns8__getProductByTypeListRequest(struct soap *soap, const char *tag, _ns8__getProductByTypeListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductByTypeListRequest **)soap_malloc(soap, sizeof(_ns8__getProductByTypeListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductByTypeListRequest *)soap_instantiate__ns8__getProductByTypeListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductByTypeListRequest ** p = (_ns8__getProductByTypeListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductByTypeListRequest, sizeof(_ns8__getProductByTypeListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductByTypeListRequest(struct soap *soap, _ns8__getProductByTypeListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductByTypeListRequest);
	return soap_out_PointerTo_ns8__getProductByTypeListRequest(soap, tag?tag:"ns8:getProductByTypeListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductByTypeListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductByTypeListRequest(struct soap *soap, _ns8__getProductByTypeListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductByTypeListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductByUuidResponse(struct soap *soap, _ns8__getProductByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getProductByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getProductByUuidResponse(struct soap *soap, const char *tag, _ns8__getProductByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getProductByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductByUuidResponse *)soap_instantiate__ns8__getProductByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductByUuidResponse ** p = (_ns8__getProductByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductByUuidResponse, sizeof(_ns8__getProductByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductByUuidResponse(struct soap *soap, _ns8__getProductByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductByUuidResponse);
	return soap_out_PointerTo_ns8__getProductByUuidResponse(soap, tag?tag:"ns8:getProductByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductByUuidResponse(struct soap *soap, _ns8__getProductByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductByUuidRequest(struct soap *soap, _ns8__getProductByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getProductByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getProductByUuidRequest(struct soap *soap, const char *tag, _ns8__getProductByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getProductByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductByUuidRequest *)soap_instantiate__ns8__getProductByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductByUuidRequest ** p = (_ns8__getProductByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductByUuidRequest, sizeof(_ns8__getProductByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductByUuidRequest(struct soap *soap, _ns8__getProductByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductByUuidRequest);
	return soap_out_PointerTo_ns8__getProductByUuidRequest(soap, tag?tag:"ns8:getProductByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductByUuidRequest(struct soap *soap, _ns8__getProductByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductByGuidResponse(struct soap *soap, _ns8__getProductByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getProductByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getProductByGuidResponse(struct soap *soap, const char *tag, _ns8__getProductByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getProductByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductByGuidResponse *)soap_instantiate__ns8__getProductByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductByGuidResponse ** p = (_ns8__getProductByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductByGuidResponse, sizeof(_ns8__getProductByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductByGuidResponse(struct soap *soap, _ns8__getProductByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductByGuidResponse);
	return soap_out_PointerTo_ns8__getProductByGuidResponse(soap, tag?tag:"ns8:getProductByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductByGuidResponse(struct soap *soap, _ns8__getProductByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getProductByGuidRequest(struct soap *soap, _ns8__getProductByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getProductByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getProductByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getProductByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getProductByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getProductByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getProductByGuidRequest(struct soap *soap, const char *tag, _ns8__getProductByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getProductByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getProductByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getProductByGuidRequest *)soap_instantiate__ns8__getProductByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getProductByGuidRequest ** p = (_ns8__getProductByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getProductByGuidRequest, sizeof(_ns8__getProductByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getProductByGuidRequest(struct soap *soap, _ns8__getProductByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getProductByGuidRequest);
	return soap_out_PointerTo_ns8__getProductByGuidRequest(soap, tag?tag:"ns8:getProductByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getProductByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getProductByGuidRequest(struct soap *soap, _ns8__getProductByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getProductByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getActivityLocationListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, int id, _ns8__getActivityLocationListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getActivityLocationListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse ** FASTCALL soap_in_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, const char *tag, _ns8__getActivityLocationListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getActivityLocationListResponse **)soap_malloc(soap, sizeof(_ns8__getActivityLocationListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getActivityLocationListResponse *)soap_instantiate__ns8__getActivityLocationListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getActivityLocationListResponse ** p = (_ns8__getActivityLocationListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getActivityLocationListResponse, sizeof(_ns8__getActivityLocationListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getActivityLocationListResponse);
	return soap_out_PointerTo_ns8__getActivityLocationListResponse(soap, tag?tag:"ns8:getActivityLocationListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getActivityLocationListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getActivityLocationListResponse(struct soap *soap, _ns8__getActivityLocationListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getActivityLocationListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getActivityLocationListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, int id, _ns8__getActivityLocationListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getActivityLocationListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest ** FASTCALL soap_in_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, const char *tag, _ns8__getActivityLocationListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getActivityLocationListRequest **)soap_malloc(soap, sizeof(_ns8__getActivityLocationListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getActivityLocationListRequest *)soap_instantiate__ns8__getActivityLocationListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getActivityLocationListRequest ** p = (_ns8__getActivityLocationListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getActivityLocationListRequest, sizeof(_ns8__getActivityLocationListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getActivityLocationListRequest);
	return soap_out_PointerTo_ns8__getActivityLocationListRequest(soap, tag?tag:"ns8:getActivityLocationListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getActivityLocationListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getActivityLocationListRequest(struct soap *soap, _ns8__getActivityLocationListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getActivityLocationListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessMemberByGLNResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessMemberByGLNResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessMemberByGLNResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessMemberByGLNResponse *)soap_instantiate__ns8__getBusinessMemberByGLNResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessMemberByGLNResponse ** p = (_ns8__getBusinessMemberByGLNResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessMemberByGLNResponse, sizeof(_ns8__getBusinessMemberByGLNResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNResponse);
	return soap_out_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, tag?tag:"ns8:getBusinessMemberByGLNResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessMemberByGLNResponse(struct soap *soap, _ns8__getBusinessMemberByGLNResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessMemberByGLNResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessMemberByGLNRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, const char *tag, _ns8__getBusinessMemberByGLNRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessMemberByGLNRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessMemberByGLNRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessMemberByGLNRequest *)soap_instantiate__ns8__getBusinessMemberByGLNRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessMemberByGLNRequest ** p = (_ns8__getBusinessMemberByGLNRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessMemberByGLNRequest, sizeof(_ns8__getBusinessMemberByGLNRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessMemberByGLNRequest);
	return soap_out_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, tag?tag:"ns8:getBusinessMemberByGLNRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessMemberByGLNRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessMemberByGLNRequest(struct soap *soap, _ns8__getBusinessMemberByGLNRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessMemberByGLNRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseChangesListResponse *)soap_instantiate__ns8__getRussianEnterpriseChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseChangesListResponse ** p = (_ns8__getRussianEnterpriseChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListResponse, sizeof(_ns8__getRussianEnterpriseChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListResponse);
	return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, tag?tag:"ns8:getRussianEnterpriseChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseChangesListResponse(struct soap *soap, _ns8__getRussianEnterpriseChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseChangesListRequest *)soap_instantiate__ns8__getRussianEnterpriseChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseChangesListRequest ** p = (_ns8__getRussianEnterpriseChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseChangesListRequest, sizeof(_ns8__getRussianEnterpriseChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseChangesListRequest);
	return soap_out_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, tag?tag:"ns8:getRussianEnterpriseChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseChangesListRequest(struct soap *soap, _ns8__getRussianEnterpriseChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseChangesListResponse *)soap_instantiate__ns8__getForeignEnterpriseChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseChangesListResponse ** p = (_ns8__getForeignEnterpriseChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListResponse, sizeof(_ns8__getForeignEnterpriseChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListResponse);
	return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, tag?tag:"ns8:getForeignEnterpriseChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseChangesListResponse(struct soap *soap, _ns8__getForeignEnterpriseChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseChangesListRequest *)soap_instantiate__ns8__getForeignEnterpriseChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseChangesListRequest ** p = (_ns8__getForeignEnterpriseChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseChangesListRequest, sizeof(_ns8__getForeignEnterpriseChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseChangesListRequest);
	return soap_out_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, tag?tag:"ns8:getForeignEnterpriseChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseChangesListRequest(struct soap *soap, _ns8__getForeignEnterpriseChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseListResponse **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseListResponse *)soap_instantiate__ns8__getRussianEnterpriseListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseListResponse ** p = (_ns8__getRussianEnterpriseListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseListResponse, sizeof(_ns8__getRussianEnterpriseListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListResponse);
	return soap_out_PointerTo_ns8__getRussianEnterpriseListResponse(soap, tag?tag:"ns8:getRussianEnterpriseListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseListResponse(struct soap *soap, _ns8__getRussianEnterpriseListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, int id, _ns8__getRussianEnterpriseListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getRussianEnterpriseListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest ** FASTCALL soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getRussianEnterpriseListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getRussianEnterpriseListRequest **)soap_malloc(soap, sizeof(_ns8__getRussianEnterpriseListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getRussianEnterpriseListRequest *)soap_instantiate__ns8__getRussianEnterpriseListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getRussianEnterpriseListRequest ** p = (_ns8__getRussianEnterpriseListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getRussianEnterpriseListRequest, sizeof(_ns8__getRussianEnterpriseListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getRussianEnterpriseListRequest);
	return soap_out_PointerTo_ns8__getRussianEnterpriseListRequest(soap, tag?tag:"ns8:getRussianEnterpriseListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getRussianEnterpriseListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getRussianEnterpriseListRequest(struct soap *soap, _ns8__getRussianEnterpriseListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getRussianEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseListResponse **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseListResponse *)soap_instantiate__ns8__getForeignEnterpriseListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseListResponse ** p = (_ns8__getForeignEnterpriseListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseListResponse, sizeof(_ns8__getForeignEnterpriseListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListResponse);
	return soap_out_PointerTo_ns8__getForeignEnterpriseListResponse(soap, tag?tag:"ns8:getForeignEnterpriseListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseListResponse(struct soap *soap, _ns8__getForeignEnterpriseListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, int id, _ns8__getForeignEnterpriseListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getForeignEnterpriseListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest ** FASTCALL soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, const char *tag, _ns8__getForeignEnterpriseListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getForeignEnterpriseListRequest **)soap_malloc(soap, sizeof(_ns8__getForeignEnterpriseListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getForeignEnterpriseListRequest *)soap_instantiate__ns8__getForeignEnterpriseListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getForeignEnterpriseListRequest ** p = (_ns8__getForeignEnterpriseListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getForeignEnterpriseListRequest, sizeof(_ns8__getForeignEnterpriseListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getForeignEnterpriseListRequest);
	return soap_out_PointerTo_ns8__getForeignEnterpriseListRequest(soap, tag?tag:"ns8:getForeignEnterpriseListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getForeignEnterpriseListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getForeignEnterpriseListRequest(struct soap *soap, _ns8__getForeignEnterpriseListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getForeignEnterpriseListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByUuidResponse *)soap_instantiate__ns8__getEnterpriseByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByUuidResponse ** p = (_ns8__getEnterpriseByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByUuidResponse, sizeof(_ns8__getEnterpriseByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidResponse);
	return soap_out_PointerTo_ns8__getEnterpriseByUuidResponse(soap, tag?tag:"ns8:getEnterpriseByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByUuidResponse(struct soap *soap, _ns8__getEnterpriseByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByUuidRequest *)soap_instantiate__ns8__getEnterpriseByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByUuidRequest ** p = (_ns8__getEnterpriseByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByUuidRequest, sizeof(_ns8__getEnterpriseByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByUuidRequest);
	return soap_out_PointerTo_ns8__getEnterpriseByUuidRequest(soap, tag?tag:"ns8:getEnterpriseByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByUuidRequest(struct soap *soap, _ns8__getEnterpriseByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByGuidResponse *)soap_instantiate__ns8__getEnterpriseByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByGuidResponse ** p = (_ns8__getEnterpriseByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByGuidResponse, sizeof(_ns8__getEnterpriseByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidResponse);
	return soap_out_PointerTo_ns8__getEnterpriseByGuidResponse(soap, tag?tag:"ns8:getEnterpriseByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByGuidResponse(struct soap *soap, _ns8__getEnterpriseByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getEnterpriseByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getEnterpriseByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, const char *tag, _ns8__getEnterpriseByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getEnterpriseByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getEnterpriseByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getEnterpriseByGuidRequest *)soap_instantiate__ns8__getEnterpriseByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getEnterpriseByGuidRequest ** p = (_ns8__getEnterpriseByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getEnterpriseByGuidRequest, sizeof(_ns8__getEnterpriseByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getEnterpriseByGuidRequest);
	return soap_out_PointerTo_ns8__getEnterpriseByGuidRequest(soap, tag?tag:"ns8:getEnterpriseByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getEnterpriseByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getEnterpriseByGuidRequest(struct soap *soap, _ns8__getEnterpriseByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getEnterpriseByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityChangesListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityChangesListResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityChangesListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityChangesListResponse *)soap_instantiate__ns8__getBusinessEntityChangesListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityChangesListResponse ** p = (_ns8__getBusinessEntityChangesListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityChangesListResponse, sizeof(_ns8__getBusinessEntityChangesListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, tag?tag:"ns8:getBusinessEntityChangesListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityChangesListResponse(struct soap *soap, _ns8__getBusinessEntityChangesListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityChangesListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityChangesListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityChangesListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityChangesListRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityChangesListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityChangesListRequest *)soap_instantiate__ns8__getBusinessEntityChangesListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityChangesListRequest ** p = (_ns8__getBusinessEntityChangesListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityChangesListRequest, sizeof(_ns8__getBusinessEntityChangesListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityChangesListRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, tag?tag:"ns8:getBusinessEntityChangesListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityChangesListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityChangesListRequest(struct soap *soap, _ns8__getBusinessEntityChangesListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityChangesListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityListResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityListResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityListResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityListResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityListResponse *)soap_instantiate__ns8__getBusinessEntityListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityListResponse ** p = (_ns8__getBusinessEntityListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityListResponse, sizeof(_ns8__getBusinessEntityListResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityListResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityListResponse(soap, tag?tag:"ns8:getBusinessEntityListResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityListResponse(struct soap *soap, _ns8__getBusinessEntityListResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityListResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityListRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityListRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityListRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityListRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityListRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityListRequest *)soap_instantiate__ns8__getBusinessEntityListRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityListRequest ** p = (_ns8__getBusinessEntityListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityListRequest, sizeof(_ns8__getBusinessEntityListRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityListRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityListRequest(soap, tag?tag:"ns8:getBusinessEntityListRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityListRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityListRequest(struct soap *soap, _ns8__getBusinessEntityListRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityListRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByUuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByUuidResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByUuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByUuidResponse *)soap_instantiate__ns8__getBusinessEntityByUuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByUuidResponse ** p = (_ns8__getBusinessEntityByUuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByUuidResponse, sizeof(_ns8__getBusinessEntityByUuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, tag?tag:"ns8:getBusinessEntityByUuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByUuidResponse(struct soap *soap, _ns8__getBusinessEntityByUuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByUuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByUuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByUuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByUuidRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByUuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByUuidRequest *)soap_instantiate__ns8__getBusinessEntityByUuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByUuidRequest ** p = (_ns8__getBusinessEntityByUuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByUuidRequest, sizeof(_ns8__getBusinessEntityByUuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByUuidRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, tag?tag:"ns8:getBusinessEntityByUuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByUuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByUuidRequest(struct soap *soap, _ns8__getBusinessEntityByUuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByUuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByGuidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidResponse **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByGuidResponse **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByGuidResponse *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByGuidResponse *)soap_instantiate__ns8__getBusinessEntityByGuidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByGuidResponse ** p = (_ns8__getBusinessEntityByGuidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByGuidResponse, sizeof(_ns8__getBusinessEntityByGuidResponse), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidResponse);
	return soap_out_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, tag?tag:"ns8:getBusinessEntityByGuidResponse", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidResponse ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByGuidResponse(struct soap *soap, _ns8__getBusinessEntityByGuidResponse **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByGuidResponse(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, int id, _ns8__getBusinessEntityByGuidRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest ** FASTCALL soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, const char *tag, _ns8__getBusinessEntityByGuidRequest **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ns8__getBusinessEntityByGuidRequest **)soap_malloc(soap, sizeof(_ns8__getBusinessEntityByGuidRequest *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ns8__getBusinessEntityByGuidRequest *)soap_instantiate__ns8__getBusinessEntityByGuidRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ns8__getBusinessEntityByGuidRequest ** p = (_ns8__getBusinessEntityByGuidRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns8__getBusinessEntityByGuidRequest, sizeof(_ns8__getBusinessEntityByGuidRequest), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns8__getBusinessEntityByGuidRequest);
	return soap_out_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, tag?tag:"ns8:getBusinessEntityByGuidRequest", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ns8__getBusinessEntityByGuidRequest ** SOAP_FMAC4 soap_get_PointerTo_ns8__getBusinessEntityByGuidRequest(struct soap *soap, _ns8__getBusinessEntityByGuidRequest **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ns8__getBusinessEntityByGuidRequest(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__FaultInfo(struct soap *soap, base__FaultInfo *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__FaultInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__FaultInfo(struct soap *soap, const char *tag, int id, base__FaultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__FaultInfo);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__FaultInfo ** FASTCALL soap_in_PointerTobase__FaultInfo(struct soap *soap, const char *tag, base__FaultInfo **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__FaultInfo **)soap_malloc(soap, sizeof(base__FaultInfo *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__FaultInfo *)soap_instantiate_base__FaultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__FaultInfo ** p = (base__FaultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__FaultInfo, sizeof(base__FaultInfo), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__FaultInfo(struct soap *soap, base__FaultInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__FaultInfo);
	return soap_out_PointerTobase__FaultInfo(soap, tag?tag:"base:FaultInfo", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__FaultInfo ** SOAP_FMAC4 soap_get_PointerTobase__FaultInfo(struct soap *soap, base__FaultInfo **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__FaultInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__StockEntryBlankFilter);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntryBlankFilter(struct soap *soap, const char *tag, int id, enum vd__StockEntryBlankFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntryBlankFilter);
	return (id < 0) ? soap->error : soap_out_vd__StockEntryBlankFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter ** FASTCALL soap_in_PointerTovd__StockEntryBlankFilter(struct soap *soap, const char *tag, enum vd__StockEntryBlankFilter **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__StockEntryBlankFilter **)soap_malloc(soap, sizeof(enum vd__StockEntryBlankFilter *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__StockEntryBlankFilter(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__StockEntryBlankFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntryBlankFilter, sizeof(enum vd__StockEntryBlankFilter), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntryBlankFilter);
	return soap_out_PointerTovd__StockEntryBlankFilter(soap, tag?tag:"vd:StockEntryBlankFilter", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__StockEntryBlankFilter ** SOAP_FMAC4 soap_get_PointerTovd__StockEntryBlankFilter(struct soap *soap, enum vd__StockEntryBlankFilter **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntryBlankFilter(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntryEventList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntryEventList(struct soap *soap, const char *tag, int id, vd__StockEntryEventList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntryEventList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntryEventList ** FASTCALL soap_in_PointerTovd__StockEntryEventList(struct soap *soap, const char *tag, vd__StockEntryEventList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntryEventList **)soap_malloc(soap, sizeof(vd__StockEntryEventList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntryEventList *)soap_instantiate_vd__StockEntryEventList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntryEventList ** p = (vd__StockEntryEventList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntryEventList, sizeof(vd__StockEntryEventList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntryEventList);
	return soap_out_PointerTovd__StockEntryEventList(soap, tag?tag:"vd:StockEntryEventList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntryEventList ** SOAP_FMAC4 soap_get_PointerTovd__StockEntryEventList(struct soap *soap, vd__StockEntryEventList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntryEventList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DiscrepancyReason))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DiscrepancyReason(struct soap *soap, const char *tag, int id, vd__DiscrepancyReason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DiscrepancyReason);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DiscrepancyReason ** FASTCALL soap_in_PointerTovd__DiscrepancyReason(struct soap *soap, const char *tag, vd__DiscrepancyReason **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DiscrepancyReason **)soap_malloc(soap, sizeof(vd__DiscrepancyReason *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DiscrepancyReason *)soap_instantiate_vd__DiscrepancyReason(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DiscrepancyReason ** p = (vd__DiscrepancyReason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DiscrepancyReason, sizeof(vd__DiscrepancyReason), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DiscrepancyReason);
	return soap_out_PointerTovd__DiscrepancyReason(soap, tag?tag:"vd:DiscrepancyReason", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DiscrepancyReason ** SOAP_FMAC4 soap_get_PointerTovd__DiscrepancyReason(struct soap *soap, vd__DiscrepancyReason **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DiscrepancyReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__VetDocumentStatusChange))
		soap_serialize_PointerTovd__VetDocumentStatusChange(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, vd__VetDocumentStatusChange **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__VetDocumentStatusChange);
	return (id < 0) ? soap->error : soap_out_PointerTovd__VetDocumentStatusChange(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange *** FASTCALL soap_in_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, vd__VetDocumentStatusChange ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocumentStatusChange ***)soap_malloc(soap, sizeof(vd__VetDocumentStatusChange **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__VetDocumentStatusChange(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__VetDocumentStatusChange ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__VetDocumentStatusChange, sizeof(vd__VetDocumentStatusChange *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__VetDocumentStatusChange);
	return soap_out_PointerToPointerTovd__VetDocumentStatusChange(soap, tag?tag:"vd:VetDocumentStatusChange", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocumentStatusChange *** SOAP_FMAC4 soap_get_PointerToPointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentStatusChange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, int id, vd__VetDocumentStatusChange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentStatusChange);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VetDocumentStatusChange ** FASTCALL soap_in_PointerTovd__VetDocumentStatusChange(struct soap *soap, const char *tag, vd__VetDocumentStatusChange **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocumentStatusChange **)soap_malloc(soap, sizeof(vd__VetDocumentStatusChange *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VetDocumentStatusChange *)soap_instantiate_vd__VetDocumentStatusChange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VetDocumentStatusChange ** p = (vd__VetDocumentStatusChange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentStatusChange, sizeof(vd__VetDocumentStatusChange), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentStatusChange);
	return soap_out_PointerTovd__VetDocumentStatusChange(soap, tag?tag:"vd:VetDocumentStatusChange", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocumentStatusChange ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentStatusChange(struct soap *soap, vd__VetDocumentStatusChange **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentStatusChange(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VeterinaryAuthentication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VeterinaryAuthentication(struct soap *soap, const char *tag, int id, vd__VeterinaryAuthentication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VeterinaryAuthentication);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VeterinaryAuthentication ** FASTCALL soap_in_PointerTovd__VeterinaryAuthentication(struct soap *soap, const char *tag, vd__VeterinaryAuthentication **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VeterinaryAuthentication **)soap_malloc(soap, sizeof(vd__VeterinaryAuthentication *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VeterinaryAuthentication *)soap_instantiate_vd__VeterinaryAuthentication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VeterinaryAuthentication ** p = (vd__VeterinaryAuthentication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VeterinaryAuthentication, sizeof(vd__VeterinaryAuthentication), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VeterinaryAuthentication);
	return soap_out_PointerTovd__VeterinaryAuthentication(soap, tag?tag:"vd:VeterinaryAuthentication", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VeterinaryAuthentication ** SOAP_FMAC4 soap_get_PointerTovd__VeterinaryAuthentication(struct soap *soap, vd__VeterinaryAuthentication **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VeterinaryAuthentication(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__CertifiedConsignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__CertifiedConsignment(struct soap *soap, const char *tag, int id, vd__CertifiedConsignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__CertifiedConsignment);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__CertifiedConsignment ** FASTCALL soap_in_PointerTovd__CertifiedConsignment(struct soap *soap, const char *tag, vd__CertifiedConsignment **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__CertifiedConsignment **)soap_malloc(soap, sizeof(vd__CertifiedConsignment *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__CertifiedConsignment *)soap_instantiate_vd__CertifiedConsignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__CertifiedConsignment ** p = (vd__CertifiedConsignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__CertifiedConsignment, sizeof(vd__CertifiedConsignment), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__CertifiedConsignment);
	return soap_out_PointerTovd__CertifiedConsignment(soap, tag?tag:"vd:CertifiedConsignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__CertifiedConsignment ** SOAP_FMAC4 soap_get_PointerTovd__CertifiedConsignment(struct soap *soap, vd__CertifiedConsignment **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__CertifiedConsignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__CertifiedBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__CertifiedBatch(struct soap *soap, const char *tag, int id, vd__CertifiedBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__CertifiedBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__CertifiedBatch ** FASTCALL soap_in_PointerTovd__CertifiedBatch(struct soap *soap, const char *tag, vd__CertifiedBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__CertifiedBatch **)soap_malloc(soap, sizeof(vd__CertifiedBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__CertifiedBatch *)soap_instantiate_vd__CertifiedBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__CertifiedBatch ** p = (vd__CertifiedBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__CertifiedBatch, sizeof(vd__CertifiedBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__CertifiedBatch);
	return soap_out_PointerTovd__CertifiedBatch(soap, tag?tag:"vd:CertifiedBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__CertifiedBatch ** SOAP_FMAC4 soap_get_PointerTovd__CertifiedBatch(struct soap *soap, vd__CertifiedBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__CertifiedBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentForm);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentForm(struct soap *soap, const char *tag, int id, enum vd__VetDocumentForm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentForm);
	return (id < 0) ? soap->error : soap_out_vd__VetDocumentForm(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VetDocumentForm ** FASTCALL soap_in_PointerTovd__VetDocumentForm(struct soap *soap, const char *tag, enum vd__VetDocumentForm **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VetDocumentForm **)soap_malloc(soap, sizeof(enum vd__VetDocumentForm *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VetDocumentForm(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentForm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentForm, sizeof(enum vd__VetDocumentForm), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentForm);
	return soap_out_PointerTovd__VetDocumentForm(soap, tag?tag:"vd:VetDocumentForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentForm ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentForm(struct soap *soap, enum vd__VetDocumentForm **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__RegionalizationStatus))
		soap_serialize_PointerToent__RegionalizationStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__RegionalizationStatus(struct soap *soap, const char *tag, int id, ent__RegionalizationStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__RegionalizationStatus);
	return (id < 0) ? soap->error : soap_out_PointerToent__RegionalizationStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__RegionalizationStatus *** FASTCALL soap_in_PointerToPointerToent__RegionalizationStatus(struct soap *soap, const char *tag, ent__RegionalizationStatus ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationStatus ***)soap_malloc(soap, sizeof(ent__RegionalizationStatus **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__RegionalizationStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__RegionalizationStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__RegionalizationStatus, sizeof(ent__RegionalizationStatus *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__RegionalizationStatus);
	return soap_out_PointerToPointerToent__RegionalizationStatus(soap, tag?tag:"ent:RegionalizationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationStatus *** SOAP_FMAC4 soap_get_PointerToPointerToent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Area(struct soap *soap, ent__Area **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Area))
		soap_serialize_PointerToent__Area(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Area(struct soap *soap, const char *tag, int id, ent__Area **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Area);
	return (id < 0) ? soap->error : soap_out_PointerToent__Area(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Area *** FASTCALL soap_in_PointerToPointerToent__Area(struct soap *soap, const char *tag, ent__Area ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Area ***)soap_malloc(soap, sizeof(ent__Area **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Area(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Area ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Area, sizeof(ent__Area *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Area(struct soap *soap, ent__Area **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Area);
	return soap_out_PointerToPointerToent__Area(soap, tag?tag:"ent:Area", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Area *** SOAP_FMAC4 soap_get_PointerToPointerToent__Area(struct soap *soap, ent__Area ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__RegionalizationRequirement))
		soap_serialize_PointerToent__RegionalizationRequirement(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__RegionalizationRequirement(struct soap *soap, const char *tag, int id, ent__RegionalizationRequirement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__RegionalizationRequirement);
	return (id < 0) ? soap->error : soap_out_PointerToent__RegionalizationRequirement(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__RegionalizationRequirement *** FASTCALL soap_in_PointerToPointerToent__RegionalizationRequirement(struct soap *soap, const char *tag, ent__RegionalizationRequirement ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationRequirement ***)soap_malloc(soap, sizeof(ent__RegionalizationRequirement **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__RegionalizationRequirement(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__RegionalizationRequirement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__RegionalizationRequirement, sizeof(ent__RegionalizationRequirement *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__RegionalizationRequirement);
	return soap_out_PointerToPointerToent__RegionalizationRequirement(soap, tag?tag:"ent:RegionalizationRequirement", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationRequirement *** SOAP_FMAC4 soap_get_PointerToPointerToent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationRequirement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationRequirement(struct soap *soap, const char *tag, int id, ent__RegionalizationRequirement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationRequirement);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationRequirement ** FASTCALL soap_in_PointerToent__RegionalizationRequirement(struct soap *soap, const char *tag, ent__RegionalizationRequirement **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationRequirement **)soap_malloc(soap, sizeof(ent__RegionalizationRequirement *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationRequirement *)soap_instantiate_ent__RegionalizationRequirement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationRequirement ** p = (ent__RegionalizationRequirement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationRequirement, sizeof(ent__RegionalizationRequirement), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationRequirement);
	return soap_out_PointerToent__RegionalizationRequirement(soap, tag?tag:"ent:RegionalizationRequirement", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationRequirement ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationRequirement(struct soap *soap, ent__RegionalizationRequirement **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationRequirement(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationDecision(struct soap *soap, enum ent__RegionalizationDecision *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationDecision);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationDecision(struct soap *soap, const char *tag, int id, enum ent__RegionalizationDecision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationDecision);
	return (id < 0) ? soap->error : soap_out_ent__RegionalizationDecision(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__RegionalizationDecision ** FASTCALL soap_in_PointerToent__RegionalizationDecision(struct soap *soap, const char *tag, enum ent__RegionalizationDecision **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__RegionalizationDecision **)soap_malloc(soap, sizeof(enum ent__RegionalizationDecision *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__RegionalizationDecision(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__RegionalizationDecision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationDecision, sizeof(enum ent__RegionalizationDecision), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationDecision(struct soap *soap, enum ent__RegionalizationDecision *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationDecision);
	return soap_out_PointerToent__RegionalizationDecision(soap, tag?tag:"ent:RegionalizationDecision", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__RegionalizationDecision ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationDecision(struct soap *soap, enum ent__RegionalizationDecision **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationDecision(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationStatus(struct soap *soap, const char *tag, int id, ent__RegionalizationStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationStatus);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationStatus ** FASTCALL soap_in_PointerToent__RegionalizationStatus(struct soap *soap, const char *tag, ent__RegionalizationStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationStatus **)soap_malloc(soap, sizeof(ent__RegionalizationStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationStatus *)soap_instantiate_ent__RegionalizationStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationStatus ** p = (ent__RegionalizationStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationStatus, sizeof(ent__RegionalizationStatus), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationStatus);
	return soap_out_PointerToent__RegionalizationStatus(soap, tag?tag:"ent:RegionalizationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationStatus ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationStatus(struct soap *soap, ent__RegionalizationStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Packaging(struct soap *soap, ent__Packaging *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Packaging))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Packaging(struct soap *soap, const char *tag, int id, ent__Packaging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Packaging);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Packaging ** FASTCALL soap_in_PointerToent__Packaging(struct soap *soap, const char *tag, ent__Packaging **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Packaging **)soap_malloc(soap, sizeof(ent__Packaging *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Packaging *)soap_instantiate_ent__Packaging(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Packaging ** p = (ent__Packaging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Packaging, sizeof(ent__Packaging), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Packaging(struct soap *soap, ent__Packaging *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Packaging);
	return soap_out_PointerToent__Packaging(soap, tag?tag:"ent:Packaging", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Packaging ** SOAP_FMAC4 soap_get_PointerToent__Packaging(struct soap *soap, ent__Packaging **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Packaging(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__ProductItemProducing))
		soap_serialize_PointerToent__ProductItemProducing(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__ProductItemProducing(struct soap *soap, const char *tag, int id, ent__ProductItemProducing **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__ProductItemProducing);
	return (id < 0) ? soap->error : soap_out_PointerToent__ProductItemProducing(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__ProductItemProducing *** FASTCALL soap_in_PointerToPointerToent__ProductItemProducing(struct soap *soap, const char *tag, ent__ProductItemProducing ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductItemProducing ***)soap_malloc(soap, sizeof(ent__ProductItemProducing **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__ProductItemProducing(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__ProductItemProducing ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__ProductItemProducing, sizeof(ent__ProductItemProducing *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__ProductItemProducing);
	return soap_out_PointerToPointerToent__ProductItemProducing(soap, tag?tag:"ent:ProductItemProducing", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductItemProducing *** SOAP_FMAC4 soap_get_PointerToPointerToent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ProductItemProducing))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ProductItemProducing(struct soap *soap, const char *tag, int id, ent__ProductItemProducing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ProductItemProducing);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ProductItemProducing ** FASTCALL soap_in_PointerToent__ProductItemProducing(struct soap *soap, const char *tag, ent__ProductItemProducing **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductItemProducing **)soap_malloc(soap, sizeof(ent__ProductItemProducing *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ProductItemProducing *)soap_instantiate_ent__ProductItemProducing(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ProductItemProducing ** p = (ent__ProductItemProducing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ProductItemProducing, sizeof(ent__ProductItemProducing), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ProductItemProducing);
	return soap_out_PointerToent__ProductItemProducing(soap, tag?tag:"ent:ProductItemProducing", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductItemProducing ** SOAP_FMAC4 soap_get_PointerToent__ProductItemProducing(struct soap *soap, ent__ProductItemProducing **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ProductItemProducing(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ent__BusinessEntity_activityLocation(struct soap *soap, _ent__BusinessEntity_activityLocation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__ent__BusinessEntity_activityLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_ent__BusinessEntity_activityLocation(struct soap *soap, const char *tag, int id, _ent__BusinessEntity_activityLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ent__BusinessEntity_activityLocation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ent__BusinessEntity_activityLocation ** FASTCALL soap_in_PointerTo_ent__BusinessEntity_activityLocation(struct soap *soap, const char *tag, _ent__BusinessEntity_activityLocation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_ent__BusinessEntity_activityLocation **)soap_malloc(soap, sizeof(_ent__BusinessEntity_activityLocation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_ent__BusinessEntity_activityLocation *)soap_instantiate__ent__BusinessEntity_activityLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_ent__BusinessEntity_activityLocation ** p = (_ent__BusinessEntity_activityLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ent__BusinessEntity_activityLocation, sizeof(_ent__BusinessEntity_activityLocation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ent__BusinessEntity_activityLocation(struct soap *soap, _ent__BusinessEntity_activityLocation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ent__BusinessEntity_activityLocation);
	return soap_out_PointerTo_ent__BusinessEntity_activityLocation(soap, tag?tag:"ent:BusinessEntity-activityLocation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _ent__BusinessEntity_activityLocation ** SOAP_FMAC4 soap_get_PointerTo_ent__BusinessEntity_activityLocation(struct soap *soap, _ent__BusinessEntity_activityLocation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_ent__BusinessEntity_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__IncorporationForm(struct soap *soap, ent__IncorporationForm *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__IncorporationForm))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__IncorporationForm(struct soap *soap, const char *tag, int id, ent__IncorporationForm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__IncorporationForm);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__IncorporationForm ** FASTCALL soap_in_PointerToent__IncorporationForm(struct soap *soap, const char *tag, ent__IncorporationForm **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__IncorporationForm **)soap_malloc(soap, sizeof(ent__IncorporationForm *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__IncorporationForm *)soap_instantiate_ent__IncorporationForm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__IncorporationForm ** p = (ent__IncorporationForm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__IncorporationForm, sizeof(ent__IncorporationForm), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__IncorporationForm(struct soap *soap, ent__IncorporationForm *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__IncorporationForm);
	return soap_out_PointerToent__IncorporationForm(soap, tag?tag:"ent:IncorporationForm", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__IncorporationForm ** SOAP_FMAC4 soap_get_PointerToent__IncorporationForm(struct soap *soap, ent__IncorporationForm **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__IncorporationForm(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__BusinessEntityType(struct soap *soap, enum ent__BusinessEntityType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__BusinessEntityType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__BusinessEntityType(struct soap *soap, const char *tag, int id, enum ent__BusinessEntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__BusinessEntityType);
	return (id < 0) ? soap->error : soap_out_ent__BusinessEntityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__BusinessEntityType ** FASTCALL soap_in_PointerToent__BusinessEntityType(struct soap *soap, const char *tag, enum ent__BusinessEntityType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__BusinessEntityType **)soap_malloc(soap, sizeof(enum ent__BusinessEntityType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__BusinessEntityType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__BusinessEntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__BusinessEntityType, sizeof(enum ent__BusinessEntityType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__BusinessEntityType(struct soap *soap, enum ent__BusinessEntityType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__BusinessEntityType);
	return soap_out_PointerToent__BusinessEntityType(soap, tag?tag:"ent:BusinessEntityType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__BusinessEntityType ** SOAP_FMAC4 soap_get_PointerToent__BusinessEntityType(struct soap *soap, enum ent__BusinessEntityType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__BusinessEntityType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration))
		soap_serialize_PointerToent__EnterpriseOfficialRegistration(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, ent__EnterpriseOfficialRegistration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration);
	return (id < 0) ? soap->error : soap_out_PointerToent__EnterpriseOfficialRegistration(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__EnterpriseOfficialRegistration *** FASTCALL soap_in_PointerToPointerToent__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, ent__EnterpriseOfficialRegistration ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseOfficialRegistration ***)soap_malloc(soap, sizeof(ent__EnterpriseOfficialRegistration **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__EnterpriseOfficialRegistration(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__EnterpriseOfficialRegistration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration, sizeof(ent__EnterpriseOfficialRegistration *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__EnterpriseOfficialRegistration);
	return soap_out_PointerToPointerToent__EnterpriseOfficialRegistration(soap, tag?tag:"ent:EnterpriseOfficialRegistration", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseOfficialRegistration *** SOAP_FMAC4 soap_get_PointerToPointerToent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseOfficialRegistration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, int id, ent__EnterpriseOfficialRegistration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseOfficialRegistration);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__EnterpriseOfficialRegistration ** FASTCALL soap_in_PointerToent__EnterpriseOfficialRegistration(struct soap *soap, const char *tag, ent__EnterpriseOfficialRegistration **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseOfficialRegistration **)soap_malloc(soap, sizeof(ent__EnterpriseOfficialRegistration *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__EnterpriseOfficialRegistration *)soap_instantiate_ent__EnterpriseOfficialRegistration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__EnterpriseOfficialRegistration ** p = (ent__EnterpriseOfficialRegistration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseOfficialRegistration, sizeof(ent__EnterpriseOfficialRegistration), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseOfficialRegistration);
	return soap_out_PointerToent__EnterpriseOfficialRegistration(soap, tag?tag:"ent:EnterpriseOfficialRegistration", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseOfficialRegistration ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseOfficialRegistration(struct soap *soap, ent__EnterpriseOfficialRegistration **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseOfficialRegistration(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseActivityList(struct soap *soap, ent__EnterpriseActivityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseActivityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseActivityList(struct soap *soap, const char *tag, int id, ent__EnterpriseActivityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseActivityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__EnterpriseActivityList ** FASTCALL soap_in_PointerToent__EnterpriseActivityList(struct soap *soap, const char *tag, ent__EnterpriseActivityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseActivityList **)soap_malloc(soap, sizeof(ent__EnterpriseActivityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__EnterpriseActivityList *)soap_instantiate_ent__EnterpriseActivityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__EnterpriseActivityList ** p = (ent__EnterpriseActivityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseActivityList, sizeof(ent__EnterpriseActivityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseActivityList(struct soap *soap, ent__EnterpriseActivityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseActivityList);
	return soap_out_PointerToent__EnterpriseActivityList(soap, tag?tag:"ent:EnterpriseActivityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseActivityList ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseActivityList(struct soap *soap, ent__EnterpriseActivityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseActivityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseNumberList(struct soap *soap, ent__EnterpriseNumberList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseNumberList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseNumberList(struct soap *soap, const char *tag, int id, ent__EnterpriseNumberList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseNumberList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__EnterpriseNumberList ** FASTCALL soap_in_PointerToent__EnterpriseNumberList(struct soap *soap, const char *tag, ent__EnterpriseNumberList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseNumberList **)soap_malloc(soap, sizeof(ent__EnterpriseNumberList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__EnterpriseNumberList *)soap_instantiate_ent__EnterpriseNumberList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__EnterpriseNumberList ** p = (ent__EnterpriseNumberList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseNumberList, sizeof(ent__EnterpriseNumberList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseNumberList(struct soap *soap, ent__EnterpriseNumberList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseNumberList);
	return soap_out_PointerToent__EnterpriseNumberList(soap, tag?tag:"ent:EnterpriseNumberList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseNumberList ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseNumberList(struct soap *soap, ent__EnterpriseNumberList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseNumberList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseType))
		soap_serialize_ent__EnterpriseType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseType);
	return (id < 0) ? soap->error : soap_out_ent__EnterpriseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerToent__EnterpriseType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__EnterpriseType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseType);
	return soap_out_PointerToent__EnterpriseType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToent__EnterpriseType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__PackingCodeType(struct soap *soap, enum ent__PackingCodeType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__PackingCodeType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__PackingCodeType(struct soap *soap, const char *tag, int id, enum ent__PackingCodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__PackingCodeType);
	return (id < 0) ? soap->error : soap_out_ent__PackingCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__PackingCodeType ** FASTCALL soap_in_PointerToent__PackingCodeType(struct soap *soap, const char *tag, enum ent__PackingCodeType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__PackingCodeType **)soap_malloc(soap, sizeof(enum ent__PackingCodeType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__PackingCodeType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__PackingCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__PackingCodeType, sizeof(enum ent__PackingCodeType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__PackingCodeType(struct soap *soap, enum ent__PackingCodeType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__PackingCodeType);
	return soap_out_PointerToent__PackingCodeType(soap, tag?tag:"ent:PackingCodeType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__PackingCodeType ** SOAP_FMAC4 soap_get_PointerToent__PackingCodeType(struct soap *soap, enum ent__PackingCodeType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__PackingCodeType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__UUID(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__UUID))
		soap_serialize_base__UUID(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__UUID(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__UUID);
	return (id < 0) ? soap->error : soap_out_base__UUID(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__UUID(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__UUID(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__UUID, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__UUID(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__UUID);
	return soap_out_PointerTobase__UUID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__UUID(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__UUID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntrySearchPattern))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntrySearchPattern(struct soap *soap, const char *tag, int id, vd__StockEntrySearchPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntrySearchPattern);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntrySearchPattern ** FASTCALL soap_in_PointerTovd__StockEntrySearchPattern(struct soap *soap, const char *tag, vd__StockEntrySearchPattern **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntrySearchPattern **)soap_malloc(soap, sizeof(vd__StockEntrySearchPattern *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntrySearchPattern *)soap_instantiate_vd__StockEntrySearchPattern(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntrySearchPattern ** p = (vd__StockEntrySearchPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntrySearchPattern, sizeof(vd__StockEntrySearchPattern), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntrySearchPattern);
	return soap_out_PointerTovd__StockEntrySearchPattern(soap, tag?tag:"vd:StockEntrySearchPattern", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntrySearchPattern ** SOAP_FMAC4 soap_get_PointerTovd__StockEntrySearchPattern(struct soap *soap, vd__StockEntrySearchPattern **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntrySearchPattern(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentStatus);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentStatus(struct soap *soap, const char *tag, int id, enum vd__VetDocumentStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentStatus);
	return (id < 0) ? soap->error : soap_out_vd__VetDocumentStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VetDocumentStatus ** FASTCALL soap_in_PointerTovd__VetDocumentStatus(struct soap *soap, const char *tag, enum vd__VetDocumentStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VetDocumentStatus **)soap_malloc(soap, sizeof(enum vd__VetDocumentStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VetDocumentStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentStatus, sizeof(enum vd__VetDocumentStatus), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentStatus);
	return soap_out_PointerTovd__VetDocumentStatus(soap, tag?tag:"vd:VetDocumentStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentStatus ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentStatus(struct soap *soap, enum vd__VetDocumentStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentType(struct soap *soap, const char *tag, int id, enum vd__VetDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentType);
	return (id < 0) ? soap->error : soap_out_vd__VetDocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VetDocumentType ** FASTCALL soap_in_PointerTovd__VetDocumentType(struct soap *soap, const char *tag, enum vd__VetDocumentType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VetDocumentType **)soap_malloc(soap, sizeof(enum vd__VetDocumentType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VetDocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VetDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentType, sizeof(enum vd__VetDocumentType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentType);
	return soap_out_PointerTovd__VetDocumentType(soap, tag?tag:"vd:VetDocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VetDocumentType ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentType(struct soap *soap, enum vd__VetDocumentType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__PSLModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__PSLModificationOperation(struct soap *soap, const char *tag, int id, vd__PSLModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__PSLModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__PSLModificationOperation ** FASTCALL soap_in_PointerTovd__PSLModificationOperation(struct soap *soap, const char *tag, vd__PSLModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__PSLModificationOperation **)soap_malloc(soap, sizeof(vd__PSLModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__PSLModificationOperation *)soap_instantiate_vd__PSLModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__PSLModificationOperation ** p = (vd__PSLModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__PSLModificationOperation, sizeof(vd__PSLModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__PSLModificationOperation);
	return soap_out_PointerTovd__PSLModificationOperation(soap, tag?tag:"vd:PSLModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__PSLModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__PSLModificationOperation(struct soap *soap, vd__PSLModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__PSLModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__StockDiscrepancy))
		soap_serialize_PointerTovd__StockDiscrepancy(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, int id, vd__StockDiscrepancy **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__StockDiscrepancy);
	return (id < 0) ? soap->error : soap_out_PointerTovd__StockDiscrepancy(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__StockDiscrepancy *** FASTCALL soap_in_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, vd__StockDiscrepancy ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockDiscrepancy ***)soap_malloc(soap, sizeof(vd__StockDiscrepancy **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__StockDiscrepancy(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__StockDiscrepancy ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__StockDiscrepancy, sizeof(vd__StockDiscrepancy *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__StockDiscrepancy);
	return soap_out_PointerToPointerTovd__StockDiscrepancy(soap, tag?tag:"vd:StockDiscrepancy", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockDiscrepancy *** SOAP_FMAC4 soap_get_PointerToPointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockDiscrepancy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, int id, vd__StockDiscrepancy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockDiscrepancy);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockDiscrepancy ** FASTCALL soap_in_PointerTovd__StockDiscrepancy(struct soap *soap, const char *tag, vd__StockDiscrepancy **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockDiscrepancy **)soap_malloc(soap, sizeof(vd__StockDiscrepancy *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockDiscrepancy *)soap_instantiate_vd__StockDiscrepancy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockDiscrepancy ** p = (vd__StockDiscrepancy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockDiscrepancy, sizeof(vd__StockDiscrepancy), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockDiscrepancy);
	return soap_out_PointerTovd__StockDiscrepancy(soap, tag?tag:"vd:StockDiscrepancy", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockDiscrepancy ** SOAP_FMAC4 soap_get_PointerTovd__StockDiscrepancy(struct soap *soap, vd__StockDiscrepancy **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockDiscrepancy(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, int id, vd__BEActivityLocationsModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__BEActivityLocationsModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation ** FASTCALL soap_in_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, const char *tag, vd__BEActivityLocationsModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__BEActivityLocationsModificationOperation **)soap_malloc(soap, sizeof(vd__BEActivityLocationsModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__BEActivityLocationsModificationOperation *)soap_instantiate_vd__BEActivityLocationsModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__BEActivityLocationsModificationOperation ** p = (vd__BEActivityLocationsModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__BEActivityLocationsModificationOperation, sizeof(vd__BEActivityLocationsModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__BEActivityLocationsModificationOperation);
	return soap_out_PointerTovd__BEActivityLocationsModificationOperation(soap, tag?tag:"vd:BEActivityLocationsModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__BEActivityLocationsModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__BEActivityLocationsModificationOperation(struct soap *soap, vd__BEActivityLocationsModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__BEActivityLocationsModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ENTModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ENTModificationOperation(struct soap *soap, const char *tag, int id, vd__ENTModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ENTModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ENTModificationOperation ** FASTCALL soap_in_PointerTovd__ENTModificationOperation(struct soap *soap, const char *tag, vd__ENTModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ENTModificationOperation **)soap_malloc(soap, sizeof(vd__ENTModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ENTModificationOperation *)soap_instantiate_vd__ENTModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ENTModificationOperation ** p = (vd__ENTModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ENTModificationOperation, sizeof(vd__ENTModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ENTModificationOperation);
	return soap_out_PointerTovd__ENTModificationOperation(soap, tag?tag:"vd:ENTModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ENTModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__ENTModificationOperation(struct soap *soap, vd__ENTModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ENTModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__BEModificationOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__BEModificationOperation(struct soap *soap, const char *tag, int id, vd__BEModificationOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__BEModificationOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__BEModificationOperation ** FASTCALL soap_in_PointerTovd__BEModificationOperation(struct soap *soap, const char *tag, vd__BEModificationOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__BEModificationOperation **)soap_malloc(soap, sizeof(vd__BEModificationOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__BEModificationOperation *)soap_instantiate_vd__BEModificationOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__BEModificationOperation ** p = (vd__BEModificationOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__BEModificationOperation, sizeof(vd__BEModificationOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__BEModificationOperation);
	return soap_out_PointerTovd__BEModificationOperation(soap, tag?tag:"vd:BEModificationOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__BEModificationOperation ** SOAP_FMAC4 soap_get_PointerTovd__BEModificationOperation(struct soap *soap, vd__BEModificationOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__BEModificationOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__MergeStockEntriesOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__MergeStockEntriesOperation(struct soap *soap, const char *tag, int id, vd__MergeStockEntriesOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__MergeStockEntriesOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation ** FASTCALL soap_in_PointerTovd__MergeStockEntriesOperation(struct soap *soap, const char *tag, vd__MergeStockEntriesOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__MergeStockEntriesOperation **)soap_malloc(soap, sizeof(vd__MergeStockEntriesOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__MergeStockEntriesOperation *)soap_instantiate_vd__MergeStockEntriesOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__MergeStockEntriesOperation ** p = (vd__MergeStockEntriesOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__MergeStockEntriesOperation, sizeof(vd__MergeStockEntriesOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__MergeStockEntriesOperation);
	return soap_out_PointerTovd__MergeStockEntriesOperation(soap, tag?tag:"vd:MergeStockEntriesOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__MergeStockEntriesOperation ** SOAP_FMAC4 soap_get_PointerTovd__MergeStockEntriesOperation(struct soap *soap, vd__MergeStockEntriesOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__MergeStockEntriesOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ProductionOperation(struct soap *soap, vd__ProductionOperation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ProductionOperation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ProductionOperation(struct soap *soap, const char *tag, int id, vd__ProductionOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ProductionOperation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ProductionOperation ** FASTCALL soap_in_PointerTovd__ProductionOperation(struct soap *soap, const char *tag, vd__ProductionOperation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProductionOperation **)soap_malloc(soap, sizeof(vd__ProductionOperation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ProductionOperation *)soap_instantiate_vd__ProductionOperation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ProductionOperation ** p = (vd__ProductionOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProductionOperation, sizeof(vd__ProductionOperation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ProductionOperation(struct soap *soap, vd__ProductionOperation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ProductionOperation);
	return soap_out_PointerTovd__ProductionOperation(soap, tag?tag:"vd:ProductionOperation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProductionOperation ** SOAP_FMAC4 soap_get_PointerTovd__ProductionOperation(struct soap *soap, vd__ProductionOperation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ProductionOperation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__Delivery(struct soap *soap, vd__Delivery **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__Delivery))
		soap_serialize_PointerTovd__Delivery(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__Delivery(struct soap *soap, const char *tag, int id, vd__Delivery **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__Delivery);
	return (id < 0) ? soap->error : soap_out_PointerTovd__Delivery(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__Delivery *** FASTCALL soap_in_PointerToPointerTovd__Delivery(struct soap *soap, const char *tag, vd__Delivery ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Delivery ***)soap_malloc(soap, sizeof(vd__Delivery **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__Delivery(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__Delivery ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__Delivery, sizeof(vd__Delivery *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__Delivery(struct soap *soap, vd__Delivery **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__Delivery);
	return soap_out_PointerToPointerTovd__Delivery(soap, tag?tag:"vd:Delivery", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Delivery *** SOAP_FMAC4 soap_get_PointerToPointerTovd__Delivery(struct soap *soap, vd__Delivery ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__DiscrepancyReport))
		soap_serialize_PointerTovd__DiscrepancyReport(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, int id, vd__DiscrepancyReport **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__DiscrepancyReport);
	return (id < 0) ? soap->error : soap_out_PointerTovd__DiscrepancyReport(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__DiscrepancyReport *** FASTCALL soap_in_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, vd__DiscrepancyReport ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DiscrepancyReport ***)soap_malloc(soap, sizeof(vd__DiscrepancyReport **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__DiscrepancyReport(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__DiscrepancyReport ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__DiscrepancyReport, sizeof(vd__DiscrepancyReport *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__DiscrepancyReport);
	return soap_out_PointerToPointerTovd__DiscrepancyReport(soap, tag?tag:"vd:DiscrepancyReport", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DiscrepancyReport *** SOAP_FMAC4 soap_get_PointerToPointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DiscrepancyReport))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, int id, vd__DiscrepancyReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DiscrepancyReport);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DiscrepancyReport ** FASTCALL soap_in_PointerTovd__DiscrepancyReport(struct soap *soap, const char *tag, vd__DiscrepancyReport **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DiscrepancyReport **)soap_malloc(soap, sizeof(vd__DiscrepancyReport *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DiscrepancyReport *)soap_instantiate_vd__DiscrepancyReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DiscrepancyReport ** p = (vd__DiscrepancyReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DiscrepancyReport, sizeof(vd__DiscrepancyReport), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DiscrepancyReport);
	return soap_out_PointerTovd__DiscrepancyReport(soap, tag?tag:"vd:DiscrepancyReport", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DiscrepancyReport ** SOAP_FMAC4 soap_get_PointerTovd__DiscrepancyReport(struct soap *soap, vd__DiscrepancyReport **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DiscrepancyReport(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DeliveryFactList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DeliveryFactList(struct soap *soap, const char *tag, int id, vd__DeliveryFactList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DeliveryFactList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DeliveryFactList ** FASTCALL soap_in_PointerTovd__DeliveryFactList(struct soap *soap, const char *tag, vd__DeliveryFactList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DeliveryFactList **)soap_malloc(soap, sizeof(vd__DeliveryFactList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DeliveryFactList *)soap_instantiate_vd__DeliveryFactList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DeliveryFactList ** p = (vd__DeliveryFactList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DeliveryFactList, sizeof(vd__DeliveryFactList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DeliveryFactList);
	return soap_out_PointerTovd__DeliveryFactList(soap, tag?tag:"vd:DeliveryFactList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DeliveryFactList ** SOAP_FMAC4 soap_get_PointerTovd__DeliveryFactList(struct soap *soap, vd__DeliveryFactList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DeliveryFactList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Delivery(struct soap *soap, vd__Delivery *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Delivery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Delivery(struct soap *soap, const char *tag, int id, vd__Delivery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Delivery);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Delivery ** FASTCALL soap_in_PointerTovd__Delivery(struct soap *soap, const char *tag, vd__Delivery **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Delivery **)soap_malloc(soap, sizeof(vd__Delivery *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Delivery *)soap_instantiate_vd__Delivery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Delivery ** p = (vd__Delivery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Delivery, sizeof(vd__Delivery), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Delivery(struct soap *soap, vd__Delivery *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Delivery);
	return soap_out_PointerTovd__Delivery(soap, tag?tag:"vd:Delivery", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Delivery ** SOAP_FMAC4 soap_get_PointerTovd__Delivery(struct soap *soap, vd__Delivery **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Delivery(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__WorkingArea))
		soap_serialize_PointerTovd__WorkingArea(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__WorkingArea(struct soap *soap, const char *tag, int id, vd__WorkingArea **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__WorkingArea);
	return (id < 0) ? soap->error : soap_out_PointerTovd__WorkingArea(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__WorkingArea *** FASTCALL soap_in_PointerToPointerTovd__WorkingArea(struct soap *soap, const char *tag, vd__WorkingArea ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__WorkingArea ***)soap_malloc(soap, sizeof(vd__WorkingArea **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__WorkingArea(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__WorkingArea ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__WorkingArea, sizeof(vd__WorkingArea *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__WorkingArea);
	return soap_out_PointerToPointerTovd__WorkingArea(soap, tag?tag:"vd:WorkingArea", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__WorkingArea *** SOAP_FMAC4 soap_get_PointerToPointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__WorkingArea))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__WorkingArea(struct soap *soap, const char *tag, int id, vd__WorkingArea *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__WorkingArea);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__WorkingArea ** FASTCALL soap_in_PointerTovd__WorkingArea(struct soap *soap, const char *tag, vd__WorkingArea **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__WorkingArea **)soap_malloc(soap, sizeof(vd__WorkingArea *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__WorkingArea *)soap_instantiate_vd__WorkingArea(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__WorkingArea ** p = (vd__WorkingArea **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__WorkingArea, sizeof(vd__WorkingArea), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__WorkingArea);
	return soap_out_PointerTovd__WorkingArea(soap, tag?tag:"vd:WorkingArea", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__WorkingArea ** SOAP_FMAC4 soap_get_PointerTovd__WorkingArea(struct soap *soap, vd__WorkingArea **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__WorkingArea(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__WorkingAreaList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__WorkingAreaList(struct soap *soap, const char *tag, int id, vd__WorkingAreaList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__WorkingAreaList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__WorkingAreaList ** FASTCALL soap_in_PointerTovd__WorkingAreaList(struct soap *soap, const char *tag, vd__WorkingAreaList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__WorkingAreaList **)soap_malloc(soap, sizeof(vd__WorkingAreaList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__WorkingAreaList *)soap_instantiate_vd__WorkingAreaList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__WorkingAreaList ** p = (vd__WorkingAreaList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__WorkingAreaList, sizeof(vd__WorkingAreaList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__WorkingAreaList);
	return soap_out_PointerTovd__WorkingAreaList(soap, tag?tag:"vd:WorkingAreaList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__WorkingAreaList ** SOAP_FMAC4 soap_get_PointerTovd__WorkingAreaList(struct soap *soap, vd__WorkingAreaList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__WorkingAreaList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__SNILSType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__SNILSType))
		soap_serialize_vd__SNILSType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__SNILSType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__SNILSType);
	return (id < 0) ? soap->error : soap_out_vd__SNILSType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTovd__SNILSType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__SNILSType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__SNILSType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__SNILSType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__SNILSType);
	return soap_out_PointerTovd__SNILSType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTovd__SNILSType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__SNILSType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__MedicinalDrug(struct soap *soap, ent__MedicinalDrug *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__MedicinalDrug))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__MedicinalDrug(struct soap *soap, const char *tag, int id, ent__MedicinalDrug *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__MedicinalDrug);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__MedicinalDrug ** FASTCALL soap_in_PointerToent__MedicinalDrug(struct soap *soap, const char *tag, ent__MedicinalDrug **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__MedicinalDrug **)soap_malloc(soap, sizeof(ent__MedicinalDrug *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__MedicinalDrug *)soap_instantiate_ent__MedicinalDrug(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__MedicinalDrug ** p = (ent__MedicinalDrug **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__MedicinalDrug, sizeof(ent__MedicinalDrug), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__MedicinalDrug(struct soap *soap, ent__MedicinalDrug *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__MedicinalDrug);
	return soap_out_PointerToent__MedicinalDrug(soap, tag?tag:"ent:MedicinalDrug", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__MedicinalDrug ** SOAP_FMAC4 soap_get_PointerToent__MedicinalDrug(struct soap *soap, ent__MedicinalDrug **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__MedicinalDrug(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Indicator(struct soap *soap, ent__Indicator *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Indicator))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Indicator(struct soap *soap, const char *tag, int id, ent__Indicator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Indicator);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Indicator ** FASTCALL soap_in_PointerToent__Indicator(struct soap *soap, const char *tag, ent__Indicator **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Indicator **)soap_malloc(soap, sizeof(ent__Indicator *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Indicator *)soap_instantiate_ent__Indicator(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Indicator ** p = (ent__Indicator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Indicator, sizeof(ent__Indicator), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Indicator(struct soap *soap, ent__Indicator *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Indicator);
	return soap_out_PointerToent__Indicator(soap, tag?tag:"ent:Indicator", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Indicator ** SOAP_FMAC4 soap_get_PointerToent__Indicator(struct soap *soap, ent__Indicator **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Indicator(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__DocumentType(struct soap *soap, enum ent__DocumentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__DocumentType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__DocumentType(struct soap *soap, const char *tag, int id, enum ent__DocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__DocumentType);
	return (id < 0) ? soap->error : soap_out_ent__DocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__DocumentType ** FASTCALL soap_in_PointerToent__DocumentType(struct soap *soap, const char *tag, enum ent__DocumentType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__DocumentType **)soap_malloc(soap, sizeof(enum ent__DocumentType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__DocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__DocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__DocumentType, sizeof(enum ent__DocumentType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__DocumentType(struct soap *soap, enum ent__DocumentType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__DocumentType);
	return soap_out_PointerToent__DocumentType(soap, tag?tag:"ent:DocumentType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__DocumentType ** SOAP_FMAC4 soap_get_PointerToent__DocumentType(struct soap *soap, enum ent__DocumentType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__DocumentType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ConsignmentDocumentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ConsignmentDocumentList(struct soap *soap, const char *tag, int id, vd__ConsignmentDocumentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ConsignmentDocumentList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ConsignmentDocumentList ** FASTCALL soap_in_PointerTovd__ConsignmentDocumentList(struct soap *soap, const char *tag, vd__ConsignmentDocumentList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ConsignmentDocumentList **)soap_malloc(soap, sizeof(vd__ConsignmentDocumentList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ConsignmentDocumentList *)soap_instantiate_vd__ConsignmentDocumentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ConsignmentDocumentList ** p = (vd__ConsignmentDocumentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ConsignmentDocumentList, sizeof(vd__ConsignmentDocumentList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ConsignmentDocumentList);
	return soap_out_PointerTovd__ConsignmentDocumentList(soap, tag?tag:"vd:ConsignmentDocumentList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ConsignmentDocumentList ** SOAP_FMAC4 soap_get_PointerTovd__ConsignmentDocumentList(struct soap *soap, vd__ConsignmentDocumentList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ConsignmentDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__Consignment(struct soap *soap, vd__Consignment **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__Consignment))
		soap_serialize_PointerTovd__Consignment(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__Consignment(struct soap *soap, const char *tag, int id, vd__Consignment **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__Consignment);
	return (id < 0) ? soap->error : soap_out_PointerTovd__Consignment(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__Consignment *** FASTCALL soap_in_PointerToPointerTovd__Consignment(struct soap *soap, const char *tag, vd__Consignment ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Consignment ***)soap_malloc(soap, sizeof(vd__Consignment **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__Consignment(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__Consignment ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__Consignment, sizeof(vd__Consignment *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__Consignment(struct soap *soap, vd__Consignment **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__Consignment);
	return soap_out_PointerToPointerTovd__Consignment(soap, tag?tag:"vd:Consignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Consignment *** SOAP_FMAC4 soap_get_PointerToPointerTovd__Consignment(struct soap *soap, vd__Consignment ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Consignment(struct soap *soap, vd__Consignment *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Consignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Consignment(struct soap *soap, const char *tag, int id, vd__Consignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Consignment);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Consignment ** FASTCALL soap_in_PointerTovd__Consignment(struct soap *soap, const char *tag, vd__Consignment **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Consignment **)soap_malloc(soap, sizeof(vd__Consignment *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Consignment *)soap_instantiate_vd__Consignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Consignment ** p = (vd__Consignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Consignment, sizeof(vd__Consignment), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Consignment(struct soap *soap, vd__Consignment *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Consignment);
	return soap_out_PointerTovd__Consignment(soap, tag?tag:"vd:Consignment", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Consignment ** SOAP_FMAC4 soap_get_PointerTovd__Consignment(struct soap *soap, vd__Consignment **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Consignment(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__BusinessMember(struct soap *soap, ent__BusinessMember **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__BusinessMember))
		soap_serialize_PointerToent__BusinessMember(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__BusinessMember(struct soap *soap, const char *tag, int id, ent__BusinessMember **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__BusinessMember);
	return (id < 0) ? soap->error : soap_out_PointerToent__BusinessMember(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__BusinessMember *** FASTCALL soap_in_PointerToPointerToent__BusinessMember(struct soap *soap, const char *tag, ent__BusinessMember ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__BusinessMember ***)soap_malloc(soap, sizeof(ent__BusinessMember **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__BusinessMember(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__BusinessMember ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__BusinessMember, sizeof(ent__BusinessMember *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__BusinessMember(struct soap *soap, ent__BusinessMember **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__BusinessMember);
	return soap_out_PointerToPointerToent__BusinessMember(soap, tag?tag:"ent:BusinessMember", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__BusinessMember *** SOAP_FMAC4 soap_get_PointerToPointerToent__BusinessMember(struct soap *soap, ent__BusinessMember ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__ResearchMethod(struct soap *soap, ent__ResearchMethod **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__ResearchMethod))
		soap_serialize_PointerToent__ResearchMethod(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__ResearchMethod(struct soap *soap, const char *tag, int id, ent__ResearchMethod **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__ResearchMethod);
	return (id < 0) ? soap->error : soap_out_PointerToent__ResearchMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__ResearchMethod *** FASTCALL soap_in_PointerToPointerToent__ResearchMethod(struct soap *soap, const char *tag, ent__ResearchMethod ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ResearchMethod ***)soap_malloc(soap, sizeof(ent__ResearchMethod **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__ResearchMethod(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__ResearchMethod ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__ResearchMethod, sizeof(ent__ResearchMethod *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__ResearchMethod(struct soap *soap, ent__ResearchMethod **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__ResearchMethod);
	return soap_out_PointerToPointerToent__ResearchMethod(soap, tag?tag:"ent:ResearchMethod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ResearchMethod *** SOAP_FMAC4 soap_get_PointerToPointerToent__ResearchMethod(struct soap *soap, ent__ResearchMethod ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__AnimalDisease(struct soap *soap, ent__AnimalDisease **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__AnimalDisease))
		soap_serialize_PointerToent__AnimalDisease(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__AnimalDisease(struct soap *soap, const char *tag, int id, ent__AnimalDisease **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__AnimalDisease);
	return (id < 0) ? soap->error : soap_out_PointerToent__AnimalDisease(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__AnimalDisease *** FASTCALL soap_in_PointerToPointerToent__AnimalDisease(struct soap *soap, const char *tag, ent__AnimalDisease ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__AnimalDisease ***)soap_malloc(soap, sizeof(ent__AnimalDisease **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__AnimalDisease(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__AnimalDisease ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__AnimalDisease, sizeof(ent__AnimalDisease *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__AnimalDisease(struct soap *soap, ent__AnimalDisease **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__AnimalDisease);
	return soap_out_PointerToPointerToent__AnimalDisease(soap, tag?tag:"ent:AnimalDisease", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__AnimalDisease *** SOAP_FMAC4 soap_get_PointerToPointerToent__AnimalDisease(struct soap *soap, ent__AnimalDisease ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__RegionalizationRegionStatus))
		soap_serialize_PointerToent__RegionalizationRegionStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, ent__RegionalizationRegionStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__RegionalizationRegionStatus);
	return (id < 0) ? soap->error : soap_out_PointerToent__RegionalizationRegionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatus *** FASTCALL soap_in_PointerToPointerToent__RegionalizationRegionStatus(struct soap *soap, const char *tag, ent__RegionalizationRegionStatus ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationRegionStatus ***)soap_malloc(soap, sizeof(ent__RegionalizationRegionStatus **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__RegionalizationRegionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__RegionalizationRegionStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__RegionalizationRegionStatus, sizeof(ent__RegionalizationRegionStatus *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__RegionalizationRegionStatus);
	return soap_out_PointerToPointerToent__RegionalizationRegionStatus(soap, tag?tag:"ent:RegionalizationRegionStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationRegionStatus *** SOAP_FMAC4 soap_get_PointerToPointerToent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationRegionStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationRegionStatus(struct soap *soap, const char *tag, int id, ent__RegionalizationRegionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationRegionStatus);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatus ** FASTCALL soap_in_PointerToent__RegionalizationRegionStatus(struct soap *soap, const char *tag, ent__RegionalizationRegionStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationRegionStatus **)soap_malloc(soap, sizeof(ent__RegionalizationRegionStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationRegionStatus *)soap_instantiate_ent__RegionalizationRegionStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationRegionStatus ** p = (ent__RegionalizationRegionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationRegionStatus, sizeof(ent__RegionalizationRegionStatus), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationRegionStatus);
	return soap_out_PointerToent__RegionalizationRegionStatus(soap, tag?tag:"ent:RegionalizationRegionStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationRegionStatus ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationRegionStatus(struct soap *soap, ent__RegionalizationRegionStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationRegionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__ProductItem(struct soap *soap, ent__ProductItem **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__ProductItem))
		soap_serialize_PointerToent__ProductItem(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__ProductItem(struct soap *soap, const char *tag, int id, ent__ProductItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__ProductItem);
	return (id < 0) ? soap->error : soap_out_PointerToent__ProductItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__ProductItem *** FASTCALL soap_in_PointerToPointerToent__ProductItem(struct soap *soap, const char *tag, ent__ProductItem ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductItem ***)soap_malloc(soap, sizeof(ent__ProductItem **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__ProductItem(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__ProductItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__ProductItem, sizeof(ent__ProductItem *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__ProductItem(struct soap *soap, ent__ProductItem **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__ProductItem);
	return soap_out_PointerToPointerToent__ProductItem(soap, tag?tag:"ent:ProductItem", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductItem *** SOAP_FMAC4 soap_get_PointerToPointerToent__ProductItem(struct soap *soap, ent__ProductItem ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__SubProduct(struct soap *soap, ent__SubProduct **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__SubProduct))
		soap_serialize_PointerToent__SubProduct(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__SubProduct(struct soap *soap, const char *tag, int id, ent__SubProduct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__SubProduct);
	return (id < 0) ? soap->error : soap_out_PointerToent__SubProduct(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__SubProduct *** FASTCALL soap_in_PointerToPointerToent__SubProduct(struct soap *soap, const char *tag, ent__SubProduct ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__SubProduct ***)soap_malloc(soap, sizeof(ent__SubProduct **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__SubProduct(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__SubProduct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__SubProduct, sizeof(ent__SubProduct *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__SubProduct(struct soap *soap, ent__SubProduct **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__SubProduct);
	return soap_out_PointerToPointerToent__SubProduct(soap, tag?tag:"ent:SubProduct", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__SubProduct *** SOAP_FMAC4 soap_get_PointerToPointerToent__SubProduct(struct soap *soap, ent__SubProduct ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Product(struct soap *soap, ent__Product **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Product))
		soap_serialize_PointerToent__Product(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Product(struct soap *soap, const char *tag, int id, ent__Product **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Product);
	return (id < 0) ? soap->error : soap_out_PointerToent__Product(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Product *** FASTCALL soap_in_PointerToPointerToent__Product(struct soap *soap, const char *tag, ent__Product ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Product ***)soap_malloc(soap, sizeof(ent__Product **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Product(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Product ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Product, sizeof(ent__Product *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Product(struct soap *soap, ent__Product **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Product);
	return soap_out_PointerToPointerToent__Product(soap, tag?tag:"ent:Product", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Product *** SOAP_FMAC4 soap_get_PointerToPointerToent__Product(struct soap *soap, ent__Product ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__EnterpriseActivity))
		soap_serialize_PointerToent__EnterpriseActivity(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__EnterpriseActivity(struct soap *soap, const char *tag, int id, ent__EnterpriseActivity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__EnterpriseActivity);
	return (id < 0) ? soap->error : soap_out_PointerToent__EnterpriseActivity(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__EnterpriseActivity *** FASTCALL soap_in_PointerToPointerToent__EnterpriseActivity(struct soap *soap, const char *tag, ent__EnterpriseActivity ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseActivity ***)soap_malloc(soap, sizeof(ent__EnterpriseActivity **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__EnterpriseActivity(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__EnterpriseActivity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__EnterpriseActivity, sizeof(ent__EnterpriseActivity *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__EnterpriseActivity);
	return soap_out_PointerToPointerToent__EnterpriseActivity(soap, tag?tag:"ent:EnterpriseActivity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseActivity *** SOAP_FMAC4 soap_get_PointerToPointerToent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseActivity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseActivity(struct soap *soap, const char *tag, int id, ent__EnterpriseActivity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseActivity);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__EnterpriseActivity ** FASTCALL soap_in_PointerToent__EnterpriseActivity(struct soap *soap, const char *tag, ent__EnterpriseActivity **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseActivity **)soap_malloc(soap, sizeof(ent__EnterpriseActivity *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__EnterpriseActivity *)soap_instantiate_ent__EnterpriseActivity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__EnterpriseActivity ** p = (ent__EnterpriseActivity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseActivity, sizeof(ent__EnterpriseActivity), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseActivity);
	return soap_out_PointerToent__EnterpriseActivity(soap, tag?tag:"ent:EnterpriseActivity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseActivity ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseActivity(struct soap *soap, ent__EnterpriseActivity **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseActivity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Street(struct soap *soap, ent__Street **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Street))
		soap_serialize_PointerToent__Street(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Street(struct soap *soap, const char *tag, int id, ent__Street **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Street);
	return (id < 0) ? soap->error : soap_out_PointerToent__Street(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Street *** FASTCALL soap_in_PointerToPointerToent__Street(struct soap *soap, const char *tag, ent__Street ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Street ***)soap_malloc(soap, sizeof(ent__Street **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Street(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Street ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Street, sizeof(ent__Street *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Street(struct soap *soap, ent__Street **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Street);
	return soap_out_PointerToPointerToent__Street(soap, tag?tag:"ent:Street", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Street *** SOAP_FMAC4 soap_get_PointerToPointerToent__Street(struct soap *soap, ent__Street ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Locality(struct soap *soap, ent__Locality **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Locality))
		soap_serialize_PointerToent__Locality(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Locality(struct soap *soap, const char *tag, int id, ent__Locality **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Locality);
	return (id < 0) ? soap->error : soap_out_PointerToent__Locality(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Locality *** FASTCALL soap_in_PointerToPointerToent__Locality(struct soap *soap, const char *tag, ent__Locality ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Locality ***)soap_malloc(soap, sizeof(ent__Locality **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Locality(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Locality ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Locality, sizeof(ent__Locality *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Locality(struct soap *soap, ent__Locality **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Locality);
	return soap_out_PointerToPointerToent__Locality(soap, tag?tag:"ent:Locality", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Locality *** SOAP_FMAC4 soap_get_PointerToPointerToent__Locality(struct soap *soap, ent__Locality ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__District(struct soap *soap, ent__District **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__District))
		soap_serialize_PointerToent__District(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__District(struct soap *soap, const char *tag, int id, ent__District **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__District);
	return (id < 0) ? soap->error : soap_out_PointerToent__District(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__District *** FASTCALL soap_in_PointerToPointerToent__District(struct soap *soap, const char *tag, ent__District ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__District ***)soap_malloc(soap, sizeof(ent__District **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__District(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__District ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__District, sizeof(ent__District *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__District(struct soap *soap, ent__District **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__District);
	return soap_out_PointerToPointerToent__District(soap, tag?tag:"ent:District", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__District *** SOAP_FMAC4 soap_get_PointerToPointerToent__District(struct soap *soap, ent__District ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Region(struct soap *soap, ent__Region **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Region))
		soap_serialize_PointerToent__Region(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Region(struct soap *soap, const char *tag, int id, ent__Region **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Region);
	return (id < 0) ? soap->error : soap_out_PointerToent__Region(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Region *** FASTCALL soap_in_PointerToPointerToent__Region(struct soap *soap, const char *tag, ent__Region ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Region ***)soap_malloc(soap, sizeof(ent__Region **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Region(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Region ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Region, sizeof(ent__Region *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Region(struct soap *soap, ent__Region **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Region);
	return soap_out_PointerToPointerToent__Region(soap, tag?tag:"ent:Region", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Region *** SOAP_FMAC4 soap_get_PointerToPointerToent__Region(struct soap *soap, ent__Region ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Country(struct soap *soap, ent__Country **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Country))
		soap_serialize_PointerToent__Country(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Country(struct soap *soap, const char *tag, int id, ent__Country **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Country);
	return (id < 0) ? soap->error : soap_out_PointerToent__Country(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Country *** FASTCALL soap_in_PointerToPointerToent__Country(struct soap *soap, const char *tag, ent__Country ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Country ***)soap_malloc(soap, sizeof(ent__Country **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Country(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Country ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Country, sizeof(ent__Country *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Country(struct soap *soap, ent__Country **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Country);
	return soap_out_PointerToPointerToent__Country(soap, tag?tag:"ent:Country", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Country *** SOAP_FMAC4 soap_get_PointerToPointerToent__Country(struct soap *soap, ent__Country ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Unit(struct soap *soap, ent__Unit **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Unit))
		soap_serialize_PointerToent__Unit(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Unit(struct soap *soap, const char *tag, int id, ent__Unit **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Unit);
	return (id < 0) ? soap->error : soap_out_PointerToent__Unit(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Unit *** FASTCALL soap_in_PointerToPointerToent__Unit(struct soap *soap, const char *tag, ent__Unit ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Unit ***)soap_malloc(soap, sizeof(ent__Unit **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Unit(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Unit ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Unit, sizeof(ent__Unit *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Unit(struct soap *soap, ent__Unit **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Unit);
	return soap_out_PointerToPointerToent__Unit(soap, tag?tag:"ent:Unit", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Unit *** SOAP_FMAC4 soap_get_PointerToPointerToent__Unit(struct soap *soap, ent__Unit ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Purpose(struct soap *soap, ent__Purpose **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Purpose))
		soap_serialize_PointerToent__Purpose(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Purpose(struct soap *soap, const char *tag, int id, ent__Purpose **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Purpose);
	return (id < 0) ? soap->error : soap_out_PointerToent__Purpose(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Purpose *** FASTCALL soap_in_PointerToPointerToent__Purpose(struct soap *soap, const char *tag, ent__Purpose ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Purpose ***)soap_malloc(soap, sizeof(ent__Purpose **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Purpose(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Purpose ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Purpose, sizeof(ent__Purpose *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Purpose(struct soap *soap, ent__Purpose **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Purpose);
	return soap_out_PointerToPointerToent__Purpose(soap, tag?tag:"ent:Purpose", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Purpose *** SOAP_FMAC4 soap_get_PointerToPointerToent__Purpose(struct soap *soap, ent__Purpose ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__AuthorityList(struct soap *soap, vd__AuthorityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__AuthorityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__AuthorityList(struct soap *soap, const char *tag, int id, vd__AuthorityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__AuthorityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__AuthorityList ** FASTCALL soap_in_PointerTovd__AuthorityList(struct soap *soap, const char *tag, vd__AuthorityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__AuthorityList **)soap_malloc(soap, sizeof(vd__AuthorityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__AuthorityList *)soap_instantiate_vd__AuthorityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__AuthorityList ** p = (vd__AuthorityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AuthorityList, sizeof(vd__AuthorityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__AuthorityList(struct soap *soap, vd__AuthorityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__AuthorityList);
	return soap_out_PointerTovd__AuthorityList(soap, tag?tag:"vd:AuthorityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__AuthorityList ** SOAP_FMAC4 soap_get_PointerTovd__AuthorityList(struct soap *soap, vd__AuthorityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__AuthorityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__UserList(struct soap *soap, vd__UserList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__UserList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__UserList(struct soap *soap, const char *tag, int id, vd__UserList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__UserList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__UserList ** FASTCALL soap_in_PointerTovd__UserList(struct soap *soap, const char *tag, vd__UserList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__UserList **)soap_malloc(soap, sizeof(vd__UserList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__UserList *)soap_instantiate_vd__UserList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__UserList ** p = (vd__UserList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__UserList, sizeof(vd__UserList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__UserList(struct soap *soap, vd__UserList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__UserList);
	return soap_out_PointerTovd__UserList(soap, tag?tag:"vd:UserList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__UserList ** SOAP_FMAC4 soap_get_PointerTovd__UserList(struct soap *soap, vd__UserList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__UserList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__User(struct soap *soap, vd__User **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__User))
		soap_serialize_PointerTovd__User(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__User(struct soap *soap, const char *tag, int id, vd__User **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__User);
	return (id < 0) ? soap->error : soap_out_PointerTovd__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__User *** FASTCALL soap_in_PointerToPointerTovd__User(struct soap *soap, const char *tag, vd__User ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__User ***)soap_malloc(soap, sizeof(vd__User **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__User(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__User ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__User, sizeof(vd__User *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__User(struct soap *soap, vd__User **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__User);
	return soap_out_PointerToPointerTovd__User(soap, tag?tag:"vd:User", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__User *** SOAP_FMAC4 soap_get_PointerToPointerTovd__User(struct soap *soap, vd__User ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__RouteSectionR13nRules))
		soap_serialize_PointerTovd__RouteSectionR13nRules(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, vd__RouteSectionR13nRules **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__RouteSectionR13nRules);
	return (id < 0) ? soap->error : soap_out_PointerTovd__RouteSectionR13nRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules *** FASTCALL soap_in_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, vd__RouteSectionR13nRules ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RouteSectionR13nRules ***)soap_malloc(soap, sizeof(vd__RouteSectionR13nRules **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__RouteSectionR13nRules(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__RouteSectionR13nRules ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__RouteSectionR13nRules, sizeof(vd__RouteSectionR13nRules *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__RouteSectionR13nRules);
	return soap_out_PointerToPointerTovd__RouteSectionR13nRules(soap, tag?tag:"vd:RouteSectionR13nRules", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RouteSectionR13nRules *** SOAP_FMAC4 soap_get_PointerToPointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__RouteSectionR13nRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, int id, vd__RouteSectionR13nRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__RouteSectionR13nRules);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__RouteSectionR13nRules ** FASTCALL soap_in_PointerTovd__RouteSectionR13nRules(struct soap *soap, const char *tag, vd__RouteSectionR13nRules **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RouteSectionR13nRules **)soap_malloc(soap, sizeof(vd__RouteSectionR13nRules *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__RouteSectionR13nRules *)soap_instantiate_vd__RouteSectionR13nRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__RouteSectionR13nRules ** p = (vd__RouteSectionR13nRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__RouteSectionR13nRules, sizeof(vd__RouteSectionR13nRules), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__RouteSectionR13nRules);
	return soap_out_PointerTovd__RouteSectionR13nRules(soap, tag?tag:"vd:RouteSectionR13nRules", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RouteSectionR13nRules ** SOAP_FMAC4 soap_get_PointerTovd__RouteSectionR13nRules(struct soap *soap, vd__RouteSectionR13nRules **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__RouteSectionR13nRules(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocumentList(struct soap *soap, vd__VetDocumentList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VetDocumentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocumentList(struct soap *soap, const char *tag, int id, vd__VetDocumentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocumentList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VetDocumentList ** FASTCALL soap_in_PointerTovd__VetDocumentList(struct soap *soap, const char *tag, vd__VetDocumentList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocumentList **)soap_malloc(soap, sizeof(vd__VetDocumentList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VetDocumentList *)soap_instantiate_vd__VetDocumentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VetDocumentList ** p = (vd__VetDocumentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocumentList, sizeof(vd__VetDocumentList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocumentList(struct soap *soap, vd__VetDocumentList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocumentList);
	return soap_out_PointerTovd__VetDocumentList(soap, tag?tag:"vd:VetDocumentList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocumentList ** SOAP_FMAC4 soap_get_PointerTovd__VetDocumentList(struct soap *soap, vd__VetDocumentList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocumentList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Enterprise(struct soap *soap, ent__Enterprise **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Enterprise))
		soap_serialize_PointerToent__Enterprise(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Enterprise(struct soap *soap, const char *tag, int id, ent__Enterprise **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Enterprise);
	return (id < 0) ? soap->error : soap_out_PointerToent__Enterprise(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Enterprise *** FASTCALL soap_in_PointerToPointerToent__Enterprise(struct soap *soap, const char *tag, ent__Enterprise ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Enterprise ***)soap_malloc(soap, sizeof(ent__Enterprise **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Enterprise(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Enterprise ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Enterprise, sizeof(ent__Enterprise *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Enterprise(struct soap *soap, ent__Enterprise **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Enterprise);
	return soap_out_PointerToPointerToent__Enterprise(soap, tag?tag:"ent:Enterprise", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Enterprise *** SOAP_FMAC4 soap_get_PointerToPointerToent__Enterprise(struct soap *soap, ent__Enterprise ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__BusinessEntity(struct soap *soap, ent__BusinessEntity **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__BusinessEntity))
		soap_serialize_PointerToent__BusinessEntity(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__BusinessEntity(struct soap *soap, const char *tag, int id, ent__BusinessEntity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__BusinessEntity);
	return (id < 0) ? soap->error : soap_out_PointerToent__BusinessEntity(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__BusinessEntity *** FASTCALL soap_in_PointerToPointerToent__BusinessEntity(struct soap *soap, const char *tag, ent__BusinessEntity ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__BusinessEntity ***)soap_malloc(soap, sizeof(ent__BusinessEntity **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__BusinessEntity(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__BusinessEntity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__BusinessEntity, sizeof(ent__BusinessEntity *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__BusinessEntity(struct soap *soap, ent__BusinessEntity **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__BusinessEntity);
	return soap_out_PointerToPointerToent__BusinessEntity(soap, tag?tag:"ent:BusinessEntity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__BusinessEntity *** SOAP_FMAC4 soap_get_PointerToPointerToent__BusinessEntity(struct soap *soap, ent__BusinessEntity ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__OTPToken(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__OTPToken))
		soap_serialize_ent__OTPToken(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__OTPToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__OTPToken);
	return (id < 0) ? soap->error : soap_out_ent__OTPToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerToent__OTPToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__OTPToken(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__OTPToken, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__OTPToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__OTPToken);
	return soap_out_PointerToent__OTPToken(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToent__OTPToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__OTPToken(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__VersionStatus(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__VersionStatus))
		soap_serialize_base__VersionStatus(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__VersionStatus(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__VersionStatus);
	return (id < 0) ? soap->error : soap_out_base__VersionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__VersionStatus(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__VersionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__VersionStatus, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__VersionStatus(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__VersionStatus);
	return soap_out_PointerTobase__VersionStatus(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__VersionStatus(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__VersionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ResearchMethodList(struct soap *soap, ent__ResearchMethodList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ResearchMethodList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ResearchMethodList(struct soap *soap, const char *tag, int id, ent__ResearchMethodList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ResearchMethodList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ResearchMethodList ** FASTCALL soap_in_PointerToent__ResearchMethodList(struct soap *soap, const char *tag, ent__ResearchMethodList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ResearchMethodList **)soap_malloc(soap, sizeof(ent__ResearchMethodList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ResearchMethodList *)soap_instantiate_ent__ResearchMethodList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ResearchMethodList ** p = (ent__ResearchMethodList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ResearchMethodList, sizeof(ent__ResearchMethodList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ResearchMethodList(struct soap *soap, ent__ResearchMethodList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ResearchMethodList);
	return soap_out_PointerToent__ResearchMethodList(soap, tag?tag:"ent:ResearchMethodList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ResearchMethodList ** SOAP_FMAC4 soap_get_PointerToent__ResearchMethodList(struct soap *soap, ent__ResearchMethodList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ResearchMethodList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ResearchMethod(struct soap *soap, ent__ResearchMethod *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ResearchMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ResearchMethod(struct soap *soap, const char *tag, int id, ent__ResearchMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ResearchMethod);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ResearchMethod ** FASTCALL soap_in_PointerToent__ResearchMethod(struct soap *soap, const char *tag, ent__ResearchMethod **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ResearchMethod **)soap_malloc(soap, sizeof(ent__ResearchMethod *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ResearchMethod *)soap_instantiate_ent__ResearchMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ResearchMethod ** p = (ent__ResearchMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ResearchMethod, sizeof(ent__ResearchMethod), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ResearchMethod(struct soap *soap, ent__ResearchMethod *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ResearchMethod);
	return soap_out_PointerToent__ResearchMethod(soap, tag?tag:"ent:ResearchMethod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ResearchMethod ** SOAP_FMAC4 soap_get_PointerToent__ResearchMethod(struct soap *soap, ent__ResearchMethod **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ResearchMethod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__AnimalDiseaseList(struct soap *soap, ent__AnimalDiseaseList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__AnimalDiseaseList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__AnimalDiseaseList(struct soap *soap, const char *tag, int id, ent__AnimalDiseaseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__AnimalDiseaseList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__AnimalDiseaseList ** FASTCALL soap_in_PointerToent__AnimalDiseaseList(struct soap *soap, const char *tag, ent__AnimalDiseaseList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__AnimalDiseaseList **)soap_malloc(soap, sizeof(ent__AnimalDiseaseList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__AnimalDiseaseList *)soap_instantiate_ent__AnimalDiseaseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__AnimalDiseaseList ** p = (ent__AnimalDiseaseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__AnimalDiseaseList, sizeof(ent__AnimalDiseaseList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__AnimalDiseaseList(struct soap *soap, ent__AnimalDiseaseList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__AnimalDiseaseList);
	return soap_out_PointerToent__AnimalDiseaseList(soap, tag?tag:"ent:AnimalDiseaseList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__AnimalDiseaseList ** SOAP_FMAC4 soap_get_PointerToent__AnimalDiseaseList(struct soap *soap, ent__AnimalDiseaseList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__AnimalDiseaseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationShippingRuleList(struct soap *soap, ent__RegionalizationShippingRuleList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationShippingRuleList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationShippingRuleList(struct soap *soap, const char *tag, int id, ent__RegionalizationShippingRuleList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationShippingRuleList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRuleList ** FASTCALL soap_in_PointerToent__RegionalizationShippingRuleList(struct soap *soap, const char *tag, ent__RegionalizationShippingRuleList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationShippingRuleList **)soap_malloc(soap, sizeof(ent__RegionalizationShippingRuleList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationShippingRuleList *)soap_instantiate_ent__RegionalizationShippingRuleList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationShippingRuleList ** p = (ent__RegionalizationShippingRuleList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationShippingRuleList, sizeof(ent__RegionalizationShippingRuleList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationShippingRuleList(struct soap *soap, ent__RegionalizationShippingRuleList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationShippingRuleList);
	return soap_out_PointerToent__RegionalizationShippingRuleList(soap, tag?tag:"ent:RegionalizationShippingRuleList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationShippingRuleList ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationShippingRuleList(struct soap *soap, ent__RegionalizationShippingRuleList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationShippingRuleList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationRegionStatusList(struct soap *soap, ent__RegionalizationRegionStatusList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationRegionStatusList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationRegionStatusList(struct soap *soap, const char *tag, int id, ent__RegionalizationRegionStatusList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationRegionStatusList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationRegionStatusList ** FASTCALL soap_in_PointerToent__RegionalizationRegionStatusList(struct soap *soap, const char *tag, ent__RegionalizationRegionStatusList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationRegionStatusList **)soap_malloc(soap, sizeof(ent__RegionalizationRegionStatusList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationRegionStatusList *)soap_instantiate_ent__RegionalizationRegionStatusList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationRegionStatusList ** p = (ent__RegionalizationRegionStatusList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationRegionStatusList, sizeof(ent__RegionalizationRegionStatusList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationRegionStatusList(struct soap *soap, ent__RegionalizationRegionStatusList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationRegionStatusList);
	return soap_out_PointerToent__RegionalizationRegionStatusList(soap, tag?tag:"ent:RegionalizationRegionStatusList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationRegionStatusList ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationRegionStatusList(struct soap *soap, ent__RegionalizationRegionStatusList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationRegionStatusList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationConditionList(struct soap *soap, ent__RegionalizationConditionList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationConditionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationConditionList(struct soap *soap, const char *tag, int id, ent__RegionalizationConditionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationConditionList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationConditionList ** FASTCALL soap_in_PointerToent__RegionalizationConditionList(struct soap *soap, const char *tag, ent__RegionalizationConditionList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationConditionList **)soap_malloc(soap, sizeof(ent__RegionalizationConditionList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationConditionList *)soap_instantiate_ent__RegionalizationConditionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationConditionList ** p = (ent__RegionalizationConditionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationConditionList, sizeof(ent__RegionalizationConditionList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationConditionList(struct soap *soap, ent__RegionalizationConditionList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationConditionList);
	return soap_out_PointerToent__RegionalizationConditionList(soap, tag?tag:"ent:RegionalizationConditionList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationConditionList ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationConditionList(struct soap *soap, ent__RegionalizationConditionList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationConditionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ActivityLocationList(struct soap *soap, ent__ActivityLocationList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ActivityLocationList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ActivityLocationList(struct soap *soap, const char *tag, int id, ent__ActivityLocationList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ActivityLocationList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ActivityLocationList ** FASTCALL soap_in_PointerToent__ActivityLocationList(struct soap *soap, const char *tag, ent__ActivityLocationList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ActivityLocationList **)soap_malloc(soap, sizeof(ent__ActivityLocationList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ActivityLocationList *)soap_instantiate_ent__ActivityLocationList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ActivityLocationList ** p = (ent__ActivityLocationList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ActivityLocationList, sizeof(ent__ActivityLocationList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ActivityLocationList(struct soap *soap, ent__ActivityLocationList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ActivityLocationList);
	return soap_out_PointerToent__ActivityLocationList(soap, tag?tag:"ent:ActivityLocationList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ActivityLocationList ** SOAP_FMAC4 soap_get_PointerToent__ActivityLocationList(struct soap *soap, ent__ActivityLocationList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ActivityLocationList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseGroup(struct soap *soap, enum ent__EnterpriseGroup *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseGroup);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseGroup(struct soap *soap, const char *tag, int id, enum ent__EnterpriseGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseGroup);
	return (id < 0) ? soap->error : soap_out_ent__EnterpriseGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__EnterpriseGroup ** FASTCALL soap_in_PointerToent__EnterpriseGroup(struct soap *soap, const char *tag, enum ent__EnterpriseGroup **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__EnterpriseGroup **)soap_malloc(soap, sizeof(enum ent__EnterpriseGroup *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__EnterpriseGroup(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__EnterpriseGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseGroup, sizeof(enum ent__EnterpriseGroup), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseGroup(struct soap *soap, enum ent__EnterpriseGroup *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseGroup);
	return soap_out_PointerToent__EnterpriseGroup(soap, tag?tag:"ent:EnterpriseGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__EnterpriseGroup ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseGroup(struct soap *soap, enum ent__EnterpriseGroup **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__StreetList(struct soap *soap, ent__StreetList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__StreetList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__StreetList(struct soap *soap, const char *tag, int id, ent__StreetList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__StreetList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__StreetList ** FASTCALL soap_in_PointerToent__StreetList(struct soap *soap, const char *tag, ent__StreetList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__StreetList **)soap_malloc(soap, sizeof(ent__StreetList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__StreetList *)soap_instantiate_ent__StreetList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__StreetList ** p = (ent__StreetList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__StreetList, sizeof(ent__StreetList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__StreetList(struct soap *soap, ent__StreetList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__StreetList);
	return soap_out_PointerToent__StreetList(soap, tag?tag:"ent:StreetList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__StreetList ** SOAP_FMAC4 soap_get_PointerToent__StreetList(struct soap *soap, ent__StreetList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__StreetList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__LocalityList(struct soap *soap, ent__LocalityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__LocalityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__LocalityList(struct soap *soap, const char *tag, int id, ent__LocalityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__LocalityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__LocalityList ** FASTCALL soap_in_PointerToent__LocalityList(struct soap *soap, const char *tag, ent__LocalityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__LocalityList **)soap_malloc(soap, sizeof(ent__LocalityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__LocalityList *)soap_instantiate_ent__LocalityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__LocalityList ** p = (ent__LocalityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__LocalityList, sizeof(ent__LocalityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__LocalityList(struct soap *soap, ent__LocalityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__LocalityList);
	return soap_out_PointerToent__LocalityList(soap, tag?tag:"ent:LocalityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__LocalityList ** SOAP_FMAC4 soap_get_PointerToent__LocalityList(struct soap *soap, ent__LocalityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__LocalityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__DistrictList(struct soap *soap, ent__DistrictList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__DistrictList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__DistrictList(struct soap *soap, const char *tag, int id, ent__DistrictList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__DistrictList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__DistrictList ** FASTCALL soap_in_PointerToent__DistrictList(struct soap *soap, const char *tag, ent__DistrictList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__DistrictList **)soap_malloc(soap, sizeof(ent__DistrictList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__DistrictList *)soap_instantiate_ent__DistrictList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__DistrictList ** p = (ent__DistrictList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__DistrictList, sizeof(ent__DistrictList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__DistrictList(struct soap *soap, ent__DistrictList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__DistrictList);
	return soap_out_PointerToent__DistrictList(soap, tag?tag:"ent:DistrictList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__DistrictList ** SOAP_FMAC4 soap_get_PointerToent__DistrictList(struct soap *soap, ent__DistrictList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__DistrictList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionList(struct soap *soap, ent__RegionList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionList(struct soap *soap, const char *tag, int id, ent__RegionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionList ** FASTCALL soap_in_PointerToent__RegionList(struct soap *soap, const char *tag, ent__RegionList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionList **)soap_malloc(soap, sizeof(ent__RegionList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionList *)soap_instantiate_ent__RegionList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionList ** p = (ent__RegionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionList, sizeof(ent__RegionList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionList(struct soap *soap, ent__RegionList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionList);
	return soap_out_PointerToent__RegionList(soap, tag?tag:"ent:RegionList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionList ** SOAP_FMAC4 soap_get_PointerToent__RegionList(struct soap *soap, ent__RegionList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__CountryList(struct soap *soap, ent__CountryList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__CountryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__CountryList(struct soap *soap, const char *tag, int id, ent__CountryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__CountryList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__CountryList ** FASTCALL soap_in_PointerToent__CountryList(struct soap *soap, const char *tag, ent__CountryList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__CountryList **)soap_malloc(soap, sizeof(ent__CountryList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__CountryList *)soap_instantiate_ent__CountryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__CountryList ** p = (ent__CountryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__CountryList, sizeof(ent__CountryList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__CountryList(struct soap *soap, ent__CountryList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__CountryList);
	return soap_out_PointerToent__CountryList(soap, tag?tag:"ent:CountryList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__CountryList ** SOAP_FMAC4 soap_get_PointerToent__CountryList(struct soap *soap, ent__CountryList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__CountryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__SubProductList(struct soap *soap, ent__SubProductList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__SubProductList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__SubProductList(struct soap *soap, const char *tag, int id, ent__SubProductList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__SubProductList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__SubProductList ** FASTCALL soap_in_PointerToent__SubProductList(struct soap *soap, const char *tag, ent__SubProductList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__SubProductList **)soap_malloc(soap, sizeof(ent__SubProductList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__SubProductList *)soap_instantiate_ent__SubProductList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__SubProductList ** p = (ent__SubProductList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__SubProductList, sizeof(ent__SubProductList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__SubProductList(struct soap *soap, ent__SubProductList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__SubProductList);
	return soap_out_PointerToent__SubProductList(soap, tag?tag:"ent:SubProductList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__SubProductList ** SOAP_FMAC4 soap_get_PointerToent__SubProductList(struct soap *soap, ent__SubProductList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__SubProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ProductList(struct soap *soap, ent__ProductList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ProductList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ProductList(struct soap *soap, const char *tag, int id, ent__ProductList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ProductList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ProductList ** FASTCALL soap_in_PointerToent__ProductList(struct soap *soap, const char *tag, ent__ProductList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductList **)soap_malloc(soap, sizeof(ent__ProductList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ProductList *)soap_instantiate_ent__ProductList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ProductList ** p = (ent__ProductList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ProductList, sizeof(ent__ProductList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ProductList(struct soap *soap, ent__ProductList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ProductList);
	return soap_out_PointerToent__ProductList(soap, tag?tag:"ent:ProductList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductList ** SOAP_FMAC4 soap_get_PointerToent__ProductList(struct soap *soap, ent__ProductList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ProductList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__UnitList(struct soap *soap, ent__UnitList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__UnitList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__UnitList(struct soap *soap, const char *tag, int id, ent__UnitList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__UnitList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__UnitList ** FASTCALL soap_in_PointerToent__UnitList(struct soap *soap, const char *tag, ent__UnitList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__UnitList **)soap_malloc(soap, sizeof(ent__UnitList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__UnitList *)soap_instantiate_ent__UnitList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__UnitList ** p = (ent__UnitList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__UnitList, sizeof(ent__UnitList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__UnitList(struct soap *soap, ent__UnitList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__UnitList);
	return soap_out_PointerToent__UnitList(soap, tag?tag:"ent:UnitList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__UnitList ** SOAP_FMAC4 soap_get_PointerToent__UnitList(struct soap *soap, ent__UnitList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__UnitList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__DateInterval(struct soap *soap, base__DateInterval *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__DateInterval))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__DateInterval(struct soap *soap, const char *tag, int id, base__DateInterval *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__DateInterval);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__DateInterval ** FASTCALL soap_in_PointerTobase__DateInterval(struct soap *soap, const char *tag, base__DateInterval **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__DateInterval **)soap_malloc(soap, sizeof(base__DateInterval *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__DateInterval *)soap_instantiate_base__DateInterval(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__DateInterval ** p = (base__DateInterval **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__DateInterval, sizeof(base__DateInterval), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__DateInterval(struct soap *soap, base__DateInterval *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__DateInterval);
	return soap_out_PointerTobase__DateInterval(soap, tag?tag:"base:DateInterval", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__DateInterval ** SOAP_FMAC4 soap_get_PointerTobase__DateInterval(struct soap *soap, base__DateInterval **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__DateInterval(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__PurposeList(struct soap *soap, ent__PurposeList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__PurposeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__PurposeList(struct soap *soap, const char *tag, int id, ent__PurposeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__PurposeList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__PurposeList ** FASTCALL soap_in_PointerToent__PurposeList(struct soap *soap, const char *tag, ent__PurposeList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__PurposeList **)soap_malloc(soap, sizeof(ent__PurposeList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__PurposeList *)soap_instantiate_ent__PurposeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__PurposeList ** p = (ent__PurposeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__PurposeList, sizeof(ent__PurposeList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__PurposeList(struct soap *soap, ent__PurposeList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__PurposeList);
	return soap_out_PointerToent__PurposeList(soap, tag?tag:"ent:PurposeList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__PurposeList ** SOAP_FMAC4 soap_get_PointerToent__PurposeList(struct soap *soap, ent__PurposeList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__PurposeList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__ListOptions(struct soap *soap, base__ListOptions *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__ListOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__ListOptions(struct soap *soap, const char *tag, int id, base__ListOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__ListOptions);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__ListOptions ** FASTCALL soap_in_PointerTobase__ListOptions(struct soap *soap, const char *tag, base__ListOptions **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__ListOptions **)soap_malloc(soap, sizeof(base__ListOptions *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__ListOptions *)soap_instantiate_base__ListOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__ListOptions ** p = (base__ListOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__ListOptions, sizeof(base__ListOptions), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__ListOptions(struct soap *soap, base__ListOptions *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__ListOptions);
	return soap_out_PointerTobase__ListOptions(soap, tag?tag:"base:ListOptions", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__ListOptions ** SOAP_FMAC4 soap_get_PointerTobase__ListOptions(struct soap *soap, base__ListOptions **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__ListOptions(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Area(struct soap *soap, ent__Area *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Area))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Area(struct soap *soap, const char *tag, int id, ent__Area *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Area);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Area ** FASTCALL soap_in_PointerToent__Area(struct soap *soap, const char *tag, ent__Area **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Area **)soap_malloc(soap, sizeof(ent__Area *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Area *)soap_instantiate_ent__Area(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Area ** p = (ent__Area **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Area, sizeof(ent__Area), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Area(struct soap *soap, ent__Area *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Area);
	return soap_out_PointerToent__Area(soap, tag?tag:"ent:Area", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Area ** SOAP_FMAC4 soap_get_PointerToent__Area(struct soap *soap, ent__Area **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Area(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__UserAuthority))
		soap_serialize_PointerTovd__UserAuthority(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__UserAuthority(struct soap *soap, const char *tag, int id, vd__UserAuthority **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__UserAuthority);
	return (id < 0) ? soap->error : soap_out_PointerTovd__UserAuthority(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__UserAuthority *** FASTCALL soap_in_PointerToPointerTovd__UserAuthority(struct soap *soap, const char *tag, vd__UserAuthority ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__UserAuthority ***)soap_malloc(soap, sizeof(vd__UserAuthority **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__UserAuthority(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__UserAuthority ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__UserAuthority, sizeof(vd__UserAuthority *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__UserAuthority);
	return soap_out_PointerToPointerTovd__UserAuthority(soap, tag?tag:"vd:UserAuthority", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__UserAuthority *** SOAP_FMAC4 soap_get_PointerToPointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__UserAuthority))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__UserAuthority(struct soap *soap, const char *tag, int id, vd__UserAuthority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__UserAuthority);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__UserAuthority ** FASTCALL soap_in_PointerTovd__UserAuthority(struct soap *soap, const char *tag, vd__UserAuthority **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__UserAuthority **)soap_malloc(soap, sizeof(vd__UserAuthority *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__UserAuthority *)soap_instantiate_vd__UserAuthority(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__UserAuthority ** p = (vd__UserAuthority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__UserAuthority, sizeof(vd__UserAuthority), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__UserAuthority);
	return soap_out_PointerTovd__UserAuthority(soap, tag?tag:"vd:UserAuthority", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__UserAuthority ** SOAP_FMAC4 soap_get_PointerTovd__UserAuthority(struct soap *soap, vd__UserAuthority **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__UserAuthority(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__RegionalizationShippingRule))
		soap_serialize_PointerToent__RegionalizationShippingRule(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, ent__RegionalizationShippingRule **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__RegionalizationShippingRule);
	return (id < 0) ? soap->error : soap_out_PointerToent__RegionalizationShippingRule(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRule *** FASTCALL soap_in_PointerToPointerToent__RegionalizationShippingRule(struct soap *soap, const char *tag, ent__RegionalizationShippingRule ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationShippingRule ***)soap_malloc(soap, sizeof(ent__RegionalizationShippingRule **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__RegionalizationShippingRule(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__RegionalizationShippingRule ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__RegionalizationShippingRule, sizeof(ent__RegionalizationShippingRule *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__RegionalizationShippingRule);
	return soap_out_PointerToPointerToent__RegionalizationShippingRule(soap, tag?tag:"ent:RegionalizationShippingRule", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationShippingRule *** SOAP_FMAC4 soap_get_PointerToPointerToent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationShippingRule))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationShippingRule(struct soap *soap, const char *tag, int id, ent__RegionalizationShippingRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationShippingRule);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationShippingRule ** FASTCALL soap_in_PointerToent__RegionalizationShippingRule(struct soap *soap, const char *tag, ent__RegionalizationShippingRule **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationShippingRule **)soap_malloc(soap, sizeof(ent__RegionalizationShippingRule *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationShippingRule *)soap_instantiate_ent__RegionalizationShippingRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationShippingRule ** p = (ent__RegionalizationShippingRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationShippingRule, sizeof(ent__RegionalizationShippingRule), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationShippingRule);
	return soap_out_PointerToent__RegionalizationShippingRule(soap, tag?tag:"ent:RegionalizationShippingRule", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationShippingRule ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationShippingRule(struct soap *soap, ent__RegionalizationShippingRule **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationShippingRule(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__SequenceNumber(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__SequenceNumber))
		soap_serialize_base__SequenceNumber(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__SequenceNumber(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__SequenceNumber);
	return (id < 0) ? soap->error : soap_out_base__SequenceNumber(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__SequenceNumber(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__SequenceNumber(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__SequenceNumber, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__SequenceNumber(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__SequenceNumber);
	return soap_out_PointerTobase__SequenceNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__SequenceNumber(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__SequenceNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__QuarantineEvent))
		soap_serialize_PointerTovd__QuarantineEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__QuarantineEvent(struct soap *soap, const char *tag, int id, vd__QuarantineEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__QuarantineEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__QuarantineEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__QuarantineEvent *** FASTCALL soap_in_PointerToPointerTovd__QuarantineEvent(struct soap *soap, const char *tag, vd__QuarantineEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__QuarantineEvent ***)soap_malloc(soap, sizeof(vd__QuarantineEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__QuarantineEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__QuarantineEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__QuarantineEvent, sizeof(vd__QuarantineEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__QuarantineEvent);
	return soap_out_PointerToPointerTovd__QuarantineEvent(soap, tag?tag:"vd:QuarantineEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__QuarantineEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__RegionalizationClause))
		soap_serialize_PointerTovd__RegionalizationClause(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__RegionalizationClause(struct soap *soap, const char *tag, int id, vd__RegionalizationClause **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__RegionalizationClause);
	return (id < 0) ? soap->error : soap_out_PointerTovd__RegionalizationClause(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__RegionalizationClause *** FASTCALL soap_in_PointerToPointerTovd__RegionalizationClause(struct soap *soap, const char *tag, vd__RegionalizationClause ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RegionalizationClause ***)soap_malloc(soap, sizeof(vd__RegionalizationClause **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__RegionalizationClause(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__RegionalizationClause ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__RegionalizationClause, sizeof(vd__RegionalizationClause *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__RegionalizationClause);
	return soap_out_PointerToPointerTovd__RegionalizationClause(soap, tag?tag:"vd:RegionalizationClause", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RegionalizationClause *** SOAP_FMAC4 soap_get_PointerToPointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__RegionalizationClause))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__RegionalizationClause(struct soap *soap, const char *tag, int id, vd__RegionalizationClause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__RegionalizationClause);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__RegionalizationClause ** FASTCALL soap_in_PointerTovd__RegionalizationClause(struct soap *soap, const char *tag, vd__RegionalizationClause **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RegionalizationClause **)soap_malloc(soap, sizeof(vd__RegionalizationClause *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__RegionalizationClause *)soap_instantiate_vd__RegionalizationClause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__RegionalizationClause ** p = (vd__RegionalizationClause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__RegionalizationClause, sizeof(vd__RegionalizationClause), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__RegionalizationClause);
	return soap_out_PointerTovd__RegionalizationClause(soap, tag?tag:"vd:RegionalizationClause", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RegionalizationClause ** SOAP_FMAC4 soap_get_PointerTovd__RegionalizationClause(struct soap *soap, vd__RegionalizationClause **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__RegionalizationClause(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__VeterinaryEvent))
		soap_serialize_PointerTovd__VeterinaryEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, int id, vd__VeterinaryEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__VeterinaryEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__VeterinaryEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__VeterinaryEvent *** FASTCALL soap_in_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, vd__VeterinaryEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VeterinaryEvent ***)soap_malloc(soap, sizeof(vd__VeterinaryEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__VeterinaryEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__VeterinaryEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__VeterinaryEvent, sizeof(vd__VeterinaryEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__VeterinaryEvent);
	return soap_out_PointerToPointerTovd__VeterinaryEvent(soap, tag?tag:"vd:VeterinaryEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VeterinaryEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VeterinaryEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, int id, vd__VeterinaryEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VeterinaryEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VeterinaryEvent ** FASTCALL soap_in_PointerTovd__VeterinaryEvent(struct soap *soap, const char *tag, vd__VeterinaryEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VeterinaryEvent **)soap_malloc(soap, sizeof(vd__VeterinaryEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VeterinaryEvent *)soap_instantiate_vd__VeterinaryEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VeterinaryEvent ** p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VeterinaryEvent, sizeof(vd__VeterinaryEvent), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__VeterinaryEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__QuarantineEvent, sizeof(vd__QuarantineEvent), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VeterinaryEvent);
	return soap_out_PointerTovd__VeterinaryEvent(soap, tag?tag:"vd:VeterinaryEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VeterinaryEvent ** SOAP_FMAC4 soap_get_PointerTovd__VeterinaryEvent(struct soap *soap, vd__VeterinaryEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VeterinaryEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__AnimalMedicationEvent))
		soap_serialize_PointerTovd__AnimalMedicationEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, vd__AnimalMedicationEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__AnimalMedicationEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__AnimalMedicationEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent *** FASTCALL soap_in_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, vd__AnimalMedicationEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__AnimalMedicationEvent ***)soap_malloc(soap, sizeof(vd__AnimalMedicationEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__AnimalMedicationEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__AnimalMedicationEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__AnimalMedicationEvent);
	return soap_out_PointerToPointerTovd__AnimalMedicationEvent(soap, tag?tag:"vd:AnimalMedicationEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__AnimalMedicationEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__AnimalMedicationEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, int id, vd__AnimalMedicationEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__AnimalMedicationEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__AnimalMedicationEvent ** FASTCALL soap_in_PointerTovd__AnimalMedicationEvent(struct soap *soap, const char *tag, vd__AnimalMedicationEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__AnimalMedicationEvent **)soap_malloc(soap, sizeof(vd__AnimalMedicationEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__AnimalMedicationEvent *)soap_instantiate_vd__AnimalMedicationEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__AnimalMedicationEvent ** p = (vd__AnimalMedicationEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AnimalMedicationEvent, sizeof(vd__AnimalMedicationEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__AnimalMedicationEvent);
	return soap_out_PointerTovd__AnimalMedicationEvent(soap, tag?tag:"vd:AnimalMedicationEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__AnimalMedicationEvent ** SOAP_FMAC4 soap_get_PointerTovd__AnimalMedicationEvent(struct soap *soap, vd__AnimalMedicationEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__AnimalMedicationEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__QuarantineEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__QuarantineEvent(struct soap *soap, const char *tag, int id, vd__QuarantineEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__QuarantineEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__QuarantineEvent ** FASTCALL soap_in_PointerTovd__QuarantineEvent(struct soap *soap, const char *tag, vd__QuarantineEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__QuarantineEvent **)soap_malloc(soap, sizeof(vd__QuarantineEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__QuarantineEvent *)soap_instantiate_vd__QuarantineEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__QuarantineEvent ** p = (vd__QuarantineEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__QuarantineEvent, sizeof(vd__QuarantineEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__QuarantineEvent);
	return soap_out_PointerTovd__QuarantineEvent(soap, tag?tag:"vd:QuarantineEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__QuarantineEvent ** SOAP_FMAC4 soap_get_PointerTovd__QuarantineEvent(struct soap *soap, vd__QuarantineEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__QuarantineEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent))
		soap_serialize_PointerTovd__LaboratoryResearchEvent(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, vd__LaboratoryResearchEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent);
	return (id < 0) ? soap->error : soap_out_PointerTovd__LaboratoryResearchEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent *** FASTCALL soap_in_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, vd__LaboratoryResearchEvent ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__LaboratoryResearchEvent ***)soap_malloc(soap, sizeof(vd__LaboratoryResearchEvent **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__LaboratoryResearchEvent(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__LaboratoryResearchEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__LaboratoryResearchEvent);
	return soap_out_PointerToPointerTovd__LaboratoryResearchEvent(soap, tag?tag:"vd:LaboratoryResearchEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent *** SOAP_FMAC4 soap_get_PointerToPointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__LaboratoryResearchEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, int id, vd__LaboratoryResearchEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__LaboratoryResearchEvent);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent ** FASTCALL soap_in_PointerTovd__LaboratoryResearchEvent(struct soap *soap, const char *tag, vd__LaboratoryResearchEvent **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__LaboratoryResearchEvent **)soap_malloc(soap, sizeof(vd__LaboratoryResearchEvent *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__LaboratoryResearchEvent *)soap_instantiate_vd__LaboratoryResearchEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__LaboratoryResearchEvent ** p = (vd__LaboratoryResearchEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__LaboratoryResearchEvent, sizeof(vd__LaboratoryResearchEvent), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__LaboratoryResearchEvent);
	return soap_out_PointerTovd__LaboratoryResearchEvent(soap, tag?tag:"vd:LaboratoryResearchEvent", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__LaboratoryResearchEvent ** SOAP_FMAC4 soap_get_PointerTovd__LaboratoryResearchEvent(struct soap *soap, vd__LaboratoryResearchEvent **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__LaboratoryResearchEvent(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__AnimalSpentPeriod);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__AnimalSpentPeriod(struct soap *soap, const char *tag, int id, enum vd__AnimalSpentPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__AnimalSpentPeriod);
	return (id < 0) ? soap->error : soap_out_vd__AnimalSpentPeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod ** FASTCALL soap_in_PointerTovd__AnimalSpentPeriod(struct soap *soap, const char *tag, enum vd__AnimalSpentPeriod **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__AnimalSpentPeriod **)soap_malloc(soap, sizeof(enum vd__AnimalSpentPeriod *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__AnimalSpentPeriod(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__AnimalSpentPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__AnimalSpentPeriod, sizeof(enum vd__AnimalSpentPeriod), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__AnimalSpentPeriod);
	return soap_out_PointerTovd__AnimalSpentPeriod(soap, tag?tag:"vd:AnimalSpentPeriod", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__AnimalSpentPeriod ** SOAP_FMAC4 soap_get_PointerTovd__AnimalSpentPeriod(struct soap *soap, enum vd__AnimalSpentPeriod **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__AnimalSpentPeriod(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ResearchResult(struct soap *soap, enum ent__ResearchResult *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__ResearchResult);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ResearchResult(struct soap *soap, const char *tag, int id, enum ent__ResearchResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ResearchResult);
	return (id < 0) ? soap->error : soap_out_ent__ResearchResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__ResearchResult ** FASTCALL soap_in_PointerToent__ResearchResult(struct soap *soap, const char *tag, enum ent__ResearchResult **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__ResearchResult **)soap_malloc(soap, sizeof(enum ent__ResearchResult *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__ResearchResult(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__ResearchResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ResearchResult, sizeof(enum ent__ResearchResult), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ResearchResult(struct soap *soap, enum ent__ResearchResult *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ResearchResult);
	return soap_out_PointerToent__ResearchResult(soap, tag?tag:"ent:ResearchResult", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ResearchResult ** SOAP_FMAC4 soap_get_PointerToent__ResearchResult(struct soap *soap, enum ent__ResearchResult **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ResearchResult(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Purpose(struct soap *soap, ent__Purpose *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Purpose))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Purpose(struct soap *soap, const char *tag, int id, ent__Purpose *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Purpose);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Purpose ** FASTCALL soap_in_PointerToent__Purpose(struct soap *soap, const char *tag, ent__Purpose **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Purpose **)soap_malloc(soap, sizeof(ent__Purpose *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Purpose *)soap_instantiate_ent__Purpose(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Purpose ** p = (ent__Purpose **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Purpose, sizeof(ent__Purpose), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Purpose(struct soap *soap, ent__Purpose *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Purpose);
	return soap_out_PointerToent__Purpose(soap, tag?tag:"ent:Purpose", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Purpose ** SOAP_FMAC4 soap_get_PointerToent__Purpose(struct soap *soap, ent__Purpose **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Purpose(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__Document(struct soap *soap, vd__Document **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__Document))
		soap_serialize_PointerTovd__Document(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__Document(struct soap *soap, const char *tag, int id, vd__Document **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__Document);
	return (id < 0) ? soap->error : soap_out_PointerTovd__Document(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__Document *** FASTCALL soap_in_PointerToPointerTovd__Document(struct soap *soap, const char *tag, vd__Document ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Document ***)soap_malloc(soap, sizeof(vd__Document **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__Document(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__Document ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__Document, sizeof(vd__Document *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__Document(struct soap *soap, vd__Document **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__Document);
	return soap_out_PointerToPointerTovd__Document(soap, tag?tag:"vd:Document", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Document *** SOAP_FMAC4 soap_get_PointerToPointerTovd__Document(struct soap *soap, vd__Document ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Document(struct soap *soap, vd__Document *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Document))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Document(struct soap *soap, const char *tag, int id, vd__Document *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Document);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Document ** FASTCALL soap_in_PointerTovd__Document(struct soap *soap, const char *tag, vd__Document **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Document **)soap_malloc(soap, sizeof(vd__Document *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Document *)soap_instantiate_vd__Document(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Document ** p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Document, sizeof(vd__Document), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocument, sizeof(vd__VetDocument), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DiscrepancyReport, sizeof(vd__DiscrepancyReport), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Waybill, sizeof(vd__Waybill), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Document **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ReferencedDocument, sizeof(vd__ReferencedDocument), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Document(struct soap *soap, vd__Document *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Document);
	return soap_out_PointerTovd__Document(soap, tag?tag:"vd:Document", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Document ** SOAP_FMAC4 soap_get_PointerTovd__Document(struct soap *soap, vd__Document **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Document(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Organization(struct soap *soap, ent__Organization *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Organization))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Organization(struct soap *soap, const char *tag, int id, ent__Organization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Organization);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Organization ** FASTCALL soap_in_PointerToent__Organization(struct soap *soap, const char *tag, ent__Organization **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Organization **)soap_malloc(soap, sizeof(ent__Organization *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Organization *)soap_instantiate_ent__Organization(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Organization ** p = (ent__Organization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Organization, sizeof(ent__Organization), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Organization(struct soap *soap, ent__Organization *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Organization);
	return soap_out_PointerToent__Organization(soap, tag?tag:"ent:Organization", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Organization ** SOAP_FMAC4 soap_get_PointerToent__Organization(struct soap *soap, ent__Organization **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Organization(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Location(struct soap *soap, ent__Location *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Location))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Location(struct soap *soap, const char *tag, int id, ent__Location *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Location);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Location ** FASTCALL soap_in_PointerToent__Location(struct soap *soap, const char *tag, ent__Location **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Location **)soap_malloc(soap, sizeof(ent__Location *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Location *)soap_instantiate_ent__Location(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Location ** p = (ent__Location **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Location, sizeof(ent__Location), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Location(struct soap *soap, ent__Location *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Location);
	return soap_out_PointerToent__Location(soap, tag?tag:"ent:Location", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Location ** SOAP_FMAC4 soap_get_PointerToent__Location(struct soap *soap, ent__Location **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Location(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vd__VeterinaryEventType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VeterinaryEventType(struct soap *soap, const char *tag, int id, enum vd__VeterinaryEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VeterinaryEventType);
	return (id < 0) ? soap->error : soap_out_vd__VeterinaryEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vd__VeterinaryEventType ** FASTCALL soap_in_PointerTovd__VeterinaryEventType(struct soap *soap, const char *tag, enum vd__VeterinaryEventType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum vd__VeterinaryEventType **)soap_malloc(soap, sizeof(enum vd__VeterinaryEventType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_vd__VeterinaryEventType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum vd__VeterinaryEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VeterinaryEventType, sizeof(enum vd__VeterinaryEventType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VeterinaryEventType);
	return soap_out_PointerTovd__VeterinaryEventType(soap, tag?tag:"vd:VeterinaryEventType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum vd__VeterinaryEventType ** SOAP_FMAC4 soap_get_PointerTovd__VeterinaryEventType(struct soap *soap, enum vd__VeterinaryEventType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VeterinaryEventType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ShipmentRoute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ShipmentRoute(struct soap *soap, const char *tag, int id, vd__ShipmentRoute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ShipmentRoute);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ShipmentRoute ** FASTCALL soap_in_PointerTovd__ShipmentRoute(struct soap *soap, const char *tag, vd__ShipmentRoute **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ShipmentRoute **)soap_malloc(soap, sizeof(vd__ShipmentRoute *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ShipmentRoute *)soap_instantiate_vd__ShipmentRoute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ShipmentRoute ** p = (vd__ShipmentRoute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ShipmentRoute, sizeof(vd__ShipmentRoute), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ShipmentRoute);
	return soap_out_PointerTovd__ShipmentRoute(soap, tag?tag:"vd:ShipmentRoute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ShipmentRoute ** SOAP_FMAC4 soap_get_PointerTovd__ShipmentRoute(struct soap *soap, vd__ShipmentRoute **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ShipmentRoute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__TransportationStorageType(struct soap *soap, enum ent__TransportationStorageType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__TransportationStorageType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__TransportationStorageType(struct soap *soap, const char *tag, int id, enum ent__TransportationStorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__TransportationStorageType);
	return (id < 0) ? soap->error : soap_out_ent__TransportationStorageType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__TransportationStorageType ** FASTCALL soap_in_PointerToent__TransportationStorageType(struct soap *soap, const char *tag, enum ent__TransportationStorageType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__TransportationStorageType **)soap_malloc(soap, sizeof(enum ent__TransportationStorageType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__TransportationStorageType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__TransportationStorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__TransportationStorageType, sizeof(enum ent__TransportationStorageType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__TransportationStorageType(struct soap *soap, enum ent__TransportationStorageType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__TransportationStorageType);
	return soap_out_PointerToent__TransportationStorageType(soap, tag?tag:"ent:TransportationStorageType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__TransportationStorageType ** SOAP_FMAC4 soap_get_PointerToent__TransportationStorageType(struct soap *soap, enum ent__TransportationStorageType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__TransportationStorageType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__TransportInfo(struct soap *soap, vd__TransportInfo *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__TransportInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__TransportInfo(struct soap *soap, const char *tag, int id, vd__TransportInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__TransportInfo);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__TransportInfo ** FASTCALL soap_in_PointerTovd__TransportInfo(struct soap *soap, const char *tag, vd__TransportInfo **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__TransportInfo **)soap_malloc(soap, sizeof(vd__TransportInfo *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__TransportInfo *)soap_instantiate_vd__TransportInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__TransportInfo ** p = (vd__TransportInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__TransportInfo, sizeof(vd__TransportInfo), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__TransportInfo(struct soap *soap, vd__TransportInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__TransportInfo);
	return soap_out_PointerTovd__TransportInfo(soap, tag?tag:"vd:TransportInfo", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__TransportInfo ** SOAP_FMAC4 soap_get_PointerTovd__TransportInfo(struct soap *soap, vd__TransportInfo **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__TransportInfo(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Batch(struct soap *soap, vd__Batch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Batch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Batch(struct soap *soap, const char *tag, int id, vd__Batch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Batch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Batch ** FASTCALL soap_in_PointerTovd__Batch(struct soap *soap, const char *tag, vd__Batch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Batch **)soap_malloc(soap, sizeof(vd__Batch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Batch *)soap_instantiate_vd__Batch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Batch ** p = (vd__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Batch, sizeof(vd__Batch), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Consignment, sizeof(vd__Consignment), 0);
		}
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProductiveBatch, sizeof(vd__ProductiveBatch), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Batch(struct soap *soap, vd__Batch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Batch);
	return soap_out_PointerTovd__Batch(soap, tag?tag:"vd:Batch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Batch ** SOAP_FMAC4 soap_get_PointerTovd__Batch(struct soap *soap, vd__Batch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Batch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseList(struct soap *soap, ent__EnterpriseList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseList(struct soap *soap, const char *tag, int id, ent__EnterpriseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__EnterpriseList ** FASTCALL soap_in_PointerToent__EnterpriseList(struct soap *soap, const char *tag, ent__EnterpriseList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__EnterpriseList **)soap_malloc(soap, sizeof(ent__EnterpriseList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__EnterpriseList *)soap_instantiate_ent__EnterpriseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__EnterpriseList ** p = (ent__EnterpriseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseList, sizeof(ent__EnterpriseList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseList(struct soap *soap, ent__EnterpriseList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseList);
	return soap_out_PointerToent__EnterpriseList(soap, tag?tag:"ent:EnterpriseList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__EnterpriseList ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseList(struct soap *soap, ent__EnterpriseList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, int id, _vd__BEActivityLocationsModificationOperation_activityLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation ** FASTCALL soap_in_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, const char *tag, _vd__BEActivityLocationsModificationOperation_activityLocation **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (_vd__BEActivityLocationsModificationOperation_activityLocation **)soap_malloc(soap, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (_vd__BEActivityLocationsModificationOperation_activityLocation *)soap_instantiate__vd__BEActivityLocationsModificationOperation_activityLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		_vd__BEActivityLocationsModificationOperation_activityLocation ** p = (_vd__BEActivityLocationsModificationOperation_activityLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__vd__BEActivityLocationsModificationOperation_activityLocation, sizeof(_vd__BEActivityLocationsModificationOperation_activityLocation), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation);
	return soap_out_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag?tag:"vd:BEActivityLocationsModificationOperation-activityLocation", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 _vd__BEActivityLocationsModificationOperation_activityLocation ** SOAP_FMAC4 soap_get_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(struct soap *soap, _vd__BEActivityLocationsModificationOperation_activityLocation **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTo_vd__BEActivityLocationsModificationOperation_activityLocation(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__GLNType(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__GLNType))
		soap_serialize_ent__GLNType(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__GLNType(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__GLNType);
	return (id < 0) ? soap->error : soap_out_ent__GLNType(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerToent__GLNType(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__GLNType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__GLNType, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__GLNType(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__GLNType);
	return soap_out_PointerToent__GLNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToent__GLNType(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__GLNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__BusinessEntityList(struct soap *soap, ent__BusinessEntityList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__BusinessEntityList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__BusinessEntityList(struct soap *soap, const char *tag, int id, ent__BusinessEntityList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__BusinessEntityList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__BusinessEntityList ** FASTCALL soap_in_PointerToent__BusinessEntityList(struct soap *soap, const char *tag, ent__BusinessEntityList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__BusinessEntityList **)soap_malloc(soap, sizeof(ent__BusinessEntityList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__BusinessEntityList *)soap_instantiate_ent__BusinessEntityList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__BusinessEntityList ** p = (ent__BusinessEntityList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__BusinessEntityList, sizeof(ent__BusinessEntityList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__BusinessEntityList(struct soap *soap, ent__BusinessEntityList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__BusinessEntityList);
	return soap_out_PointerToent__BusinessEntityList(soap, tag?tag:"ent:BusinessEntityList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__BusinessEntityList ** SOAP_FMAC4 soap_get_PointerToent__BusinessEntityList(struct soap *soap, ent__BusinessEntityList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__BusinessEntityList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ProductItemList(struct soap *soap, ent__ProductItemList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ProductItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ProductItemList(struct soap *soap, const char *tag, int id, ent__ProductItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ProductItemList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ProductItemList ** FASTCALL soap_in_PointerToent__ProductItemList(struct soap *soap, const char *tag, ent__ProductItemList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductItemList **)soap_malloc(soap, sizeof(ent__ProductItemList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ProductItemList *)soap_instantiate_ent__ProductItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ProductItemList ** p = (ent__ProductItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ProductItemList, sizeof(ent__ProductItemList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ProductItemList(struct soap *soap, ent__ProductItemList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ProductItemList);
	return soap_out_PointerToent__ProductItemList(soap, tag?tag:"ent:ProductItemList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductItemList ** SOAP_FMAC4 soap_get_PointerToent__ProductItemList(struct soap *soap, ent__ProductItemList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ProductItemList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__StockEntry(struct soap *soap, vd__StockEntry **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__StockEntry))
		soap_serialize_PointerTovd__StockEntry(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__StockEntry(struct soap *soap, const char *tag, int id, vd__StockEntry **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__StockEntry);
	return (id < 0) ? soap->error : soap_out_PointerTovd__StockEntry(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__StockEntry *** FASTCALL soap_in_PointerToPointerTovd__StockEntry(struct soap *soap, const char *tag, vd__StockEntry ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntry ***)soap_malloc(soap, sizeof(vd__StockEntry **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__StockEntry(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__StockEntry ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__StockEntry, sizeof(vd__StockEntry *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__StockEntry(struct soap *soap, vd__StockEntry **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__StockEntry);
	return soap_out_PointerToPointerTovd__StockEntry(soap, tag?tag:"vd:StockEntry", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntry *** SOAP_FMAC4 soap_get_PointerToPointerTovd__StockEntry(struct soap *soap, vd__StockEntry ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_base__RegisterModificationType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__RegisterModificationType(struct soap *soap, const char *tag, int id, enum base__RegisterModificationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__RegisterModificationType);
	return (id < 0) ? soap->error : soap_out_base__RegisterModificationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum base__RegisterModificationType ** FASTCALL soap_in_PointerTobase__RegisterModificationType(struct soap *soap, const char *tag, enum base__RegisterModificationType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum base__RegisterModificationType **)soap_malloc(soap, sizeof(enum base__RegisterModificationType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__RegisterModificationType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum base__RegisterModificationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__RegisterModificationType, sizeof(enum base__RegisterModificationType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__RegisterModificationType);
	return soap_out_PointerTobase__RegisterModificationType(soap, tag?tag:"base:RegisterModificationType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum base__RegisterModificationType ** SOAP_FMAC4 soap_get_PointerTobase__RegisterModificationType(struct soap *soap, enum base__RegisterModificationType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__RegisterModificationType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ProcessingProcedure))
		soap_serialize_PointerTovd__ProcessingProcedure(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, int id, vd__ProcessingProcedure **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ProcessingProcedure);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ProcessingProcedure(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ProcessingProcedure *** FASTCALL soap_in_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, vd__ProcessingProcedure ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProcessingProcedure ***)soap_malloc(soap, sizeof(vd__ProcessingProcedure **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ProcessingProcedure(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ProcessingProcedure ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ProcessingProcedure, sizeof(vd__ProcessingProcedure *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ProcessingProcedure);
	return soap_out_PointerToPointerTovd__ProcessingProcedure(soap, tag?tag:"vd:ProcessingProcedure", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProcessingProcedure *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ProcessingProcedure))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, int id, vd__ProcessingProcedure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ProcessingProcedure);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ProcessingProcedure ** FASTCALL soap_in_PointerTovd__ProcessingProcedure(struct soap *soap, const char *tag, vd__ProcessingProcedure **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProcessingProcedure **)soap_malloc(soap, sizeof(vd__ProcessingProcedure *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ProcessingProcedure *)soap_instantiate_vd__ProcessingProcedure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ProcessingProcedure ** p = (vd__ProcessingProcedure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProcessingProcedure, sizeof(vd__ProcessingProcedure), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ProcessingProcedure);
	return soap_out_PointerTovd__ProcessingProcedure(soap, tag?tag:"vd:ProcessingProcedure", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProcessingProcedure ** SOAP_FMAC4 soap_get_PointerTovd__ProcessingProcedure(struct soap *soap, vd__ProcessingProcedure **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ProcessingProcedure(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ProductiveBatch))
		soap_serialize_PointerTovd__ProductiveBatch(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ProductiveBatch(struct soap *soap, const char *tag, int id, vd__ProductiveBatch **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ProductiveBatch);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ProductiveBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ProductiveBatch *** FASTCALL soap_in_PointerToPointerTovd__ProductiveBatch(struct soap *soap, const char *tag, vd__ProductiveBatch ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProductiveBatch ***)soap_malloc(soap, sizeof(vd__ProductiveBatch **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ProductiveBatch(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ProductiveBatch ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ProductiveBatch, sizeof(vd__ProductiveBatch *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ProductiveBatch);
	return soap_out_PointerToPointerTovd__ProductiveBatch(soap, tag?tag:"vd:ProductiveBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProductiveBatch *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ProductiveBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ProductiveBatch(struct soap *soap, const char *tag, int id, vd__ProductiveBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ProductiveBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ProductiveBatch ** FASTCALL soap_in_PointerTovd__ProductiveBatch(struct soap *soap, const char *tag, vd__ProductiveBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ProductiveBatch **)soap_malloc(soap, sizeof(vd__ProductiveBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ProductiveBatch *)soap_instantiate_vd__ProductiveBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ProductiveBatch ** p = (vd__ProductiveBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ProductiveBatch, sizeof(vd__ProductiveBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ProductiveBatch);
	return soap_out_PointerTovd__ProductiveBatch(soap, tag?tag:"vd:ProductiveBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ProductiveBatch ** SOAP_FMAC4 soap_get_PointerTovd__ProductiveBatch(struct soap *soap, vd__ProductiveBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ProductiveBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__RawBatch(struct soap *soap, vd__RawBatch **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__RawBatch))
		soap_serialize_PointerTovd__RawBatch(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__RawBatch(struct soap *soap, const char *tag, int id, vd__RawBatch **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__RawBatch);
	return (id < 0) ? soap->error : soap_out_PointerTovd__RawBatch(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__RawBatch *** FASTCALL soap_in_PointerToPointerTovd__RawBatch(struct soap *soap, const char *tag, vd__RawBatch ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RawBatch ***)soap_malloc(soap, sizeof(vd__RawBatch **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__RawBatch(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__RawBatch ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__RawBatch, sizeof(vd__RawBatch *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__RawBatch(struct soap *soap, vd__RawBatch **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__RawBatch);
	return soap_out_PointerToPointerTovd__RawBatch(soap, tag?tag:"vd:RawBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RawBatch *** SOAP_FMAC4 soap_get_PointerToPointerTovd__RawBatch(struct soap *soap, vd__RawBatch ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__RawBatch(struct soap *soap, vd__RawBatch *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__RawBatch))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__RawBatch(struct soap *soap, const char *tag, int id, vd__RawBatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__RawBatch);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__RawBatch ** FASTCALL soap_in_PointerTovd__RawBatch(struct soap *soap, const char *tag, vd__RawBatch **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__RawBatch **)soap_malloc(soap, sizeof(vd__RawBatch *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__RawBatch *)soap_instantiate_vd__RawBatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__RawBatch ** p = (vd__RawBatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__RawBatch, sizeof(vd__RawBatch), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__RawBatch(struct soap *soap, vd__RawBatch *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__RawBatch);
	return soap_out_PointerTovd__RawBatch(soap, tag?tag:"vd:RawBatch", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__RawBatch ** SOAP_FMAC4 soap_get_PointerTovd__RawBatch(struct soap *soap, vd__RawBatch **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__RawBatch(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ShipmentRoutePoint))
		soap_serialize_PointerTovd__ShipmentRoutePoint(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, vd__ShipmentRoutePoint **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ShipmentRoutePoint);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ShipmentRoutePoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint *** FASTCALL soap_in_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, vd__ShipmentRoutePoint ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ShipmentRoutePoint ***)soap_malloc(soap, sizeof(vd__ShipmentRoutePoint **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ShipmentRoutePoint(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ShipmentRoutePoint ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ShipmentRoutePoint, sizeof(vd__ShipmentRoutePoint *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ShipmentRoutePoint);
	return soap_out_PointerToPointerTovd__ShipmentRoutePoint(soap, tag?tag:"vd:ShipmentRoutePoint", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ShipmentRoutePoint *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ShipmentRoutePoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, int id, vd__ShipmentRoutePoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ShipmentRoutePoint);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ShipmentRoutePoint ** FASTCALL soap_in_PointerTovd__ShipmentRoutePoint(struct soap *soap, const char *tag, vd__ShipmentRoutePoint **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ShipmentRoutePoint **)soap_malloc(soap, sizeof(vd__ShipmentRoutePoint *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ShipmentRoutePoint *)soap_instantiate_vd__ShipmentRoutePoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ShipmentRoutePoint ** p = (vd__ShipmentRoutePoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ShipmentRoutePoint, sizeof(vd__ShipmentRoutePoint), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ShipmentRoutePoint);
	return soap_out_PointerTovd__ShipmentRoutePoint(soap, tag?tag:"vd:ShipmentRoutePoint", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ShipmentRoutePoint ** SOAP_FMAC4 soap_get_PointerTovd__ShipmentRoutePoint(struct soap *soap, vd__ShipmentRoutePoint **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ShipmentRoutePoint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__TransportNumber(struct soap *soap, vd__TransportNumber *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__TransportNumber))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__TransportNumber(struct soap *soap, const char *tag, int id, vd__TransportNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__TransportNumber);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__TransportNumber ** FASTCALL soap_in_PointerTovd__TransportNumber(struct soap *soap, const char *tag, vd__TransportNumber **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__TransportNumber **)soap_malloc(soap, sizeof(vd__TransportNumber *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__TransportNumber *)soap_instantiate_vd__TransportNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__TransportNumber ** p = (vd__TransportNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__TransportNumber, sizeof(vd__TransportNumber), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__TransportNumber(struct soap *soap, vd__TransportNumber *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__TransportNumber);
	return soap_out_PointerTovd__TransportNumber(soap, tag?tag:"vd:TransportNumber", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__TransportNumber ** SOAP_FMAC4 soap_get_PointerTovd__TransportNumber(struct soap *soap, vd__TransportNumber **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__TransportNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__TransportType(struct soap *soap, enum ent__TransportType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__TransportType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__TransportType(struct soap *soap, const char *tag, int id, enum ent__TransportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__TransportType);
	return (id < 0) ? soap->error : soap_out_ent__TransportType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__TransportType ** FASTCALL soap_in_PointerToent__TransportType(struct soap *soap, const char *tag, enum ent__TransportType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__TransportType **)soap_malloc(soap, sizeof(enum ent__TransportType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__TransportType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__TransportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__TransportType, sizeof(enum ent__TransportType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__TransportType(struct soap *soap, enum ent__TransportType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__TransportType);
	return soap_out_PointerToent__TransportType(soap, tag?tag:"ent:TransportType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__TransportType ** SOAP_FMAC4 soap_get_PointerToent__TransportType(struct soap *soap, enum ent__TransportType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__TransportType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntryList(struct soap *soap, vd__StockEntryList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntryList(struct soap *soap, const char *tag, int id, vd__StockEntryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntryList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntryList ** FASTCALL soap_in_PointerTovd__StockEntryList(struct soap *soap, const char *tag, vd__StockEntryList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntryList **)soap_malloc(soap, sizeof(vd__StockEntryList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntryList *)soap_instantiate_vd__StockEntryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntryList ** p = (vd__StockEntryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntryList, sizeof(vd__StockEntryList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntryList(struct soap *soap, vd__StockEntryList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntryList);
	return soap_out_PointerTovd__StockEntryList(soap, tag?tag:"vd:StockEntryList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntryList ** SOAP_FMAC4 soap_get_PointerTovd__StockEntryList(struct soap *soap, vd__StockEntryList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntryList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ComplexDate(struct soap *soap, ent__ComplexDate *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ComplexDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ComplexDate(struct soap *soap, const char *tag, int id, ent__ComplexDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ComplexDate);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ComplexDate ** FASTCALL soap_in_PointerToent__ComplexDate(struct soap *soap, const char *tag, ent__ComplexDate **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ComplexDate **)soap_malloc(soap, sizeof(ent__ComplexDate *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ComplexDate *)soap_instantiate_ent__ComplexDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ComplexDate ** p = (ent__ComplexDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ComplexDate, sizeof(ent__ComplexDate), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ComplexDate(struct soap *soap, ent__ComplexDate *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ComplexDate);
	return soap_out_PointerToent__ComplexDate(soap, tag?tag:"ent:ComplexDate", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ComplexDate ** SOAP_FMAC4 soap_get_PointerToent__ComplexDate(struct soap *soap, ent__ComplexDate **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ComplexDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__ReferencedDocument))
		soap_serialize_PointerTovd__ReferencedDocument(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__ReferencedDocument(struct soap *soap, const char *tag, int id, vd__ReferencedDocument **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__ReferencedDocument);
	return (id < 0) ? soap->error : soap_out_PointerTovd__ReferencedDocument(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__ReferencedDocument *** FASTCALL soap_in_PointerToPointerTovd__ReferencedDocument(struct soap *soap, const char *tag, vd__ReferencedDocument ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ReferencedDocument ***)soap_malloc(soap, sizeof(vd__ReferencedDocument **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__ReferencedDocument(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__ReferencedDocument ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__ReferencedDocument, sizeof(vd__ReferencedDocument *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__ReferencedDocument);
	return soap_out_PointerToPointerTovd__ReferencedDocument(soap, tag?tag:"vd:ReferencedDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ReferencedDocument *** SOAP_FMAC4 soap_get_PointerToPointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__ReferencedDocument))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__ReferencedDocument(struct soap *soap, const char *tag, int id, vd__ReferencedDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__ReferencedDocument);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__ReferencedDocument ** FASTCALL soap_in_PointerTovd__ReferencedDocument(struct soap *soap, const char *tag, vd__ReferencedDocument **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__ReferencedDocument **)soap_malloc(soap, sizeof(vd__ReferencedDocument *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__ReferencedDocument *)soap_instantiate_vd__ReferencedDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__ReferencedDocument ** p = (vd__ReferencedDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__ReferencedDocument, sizeof(vd__ReferencedDocument), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__ReferencedDocument);
	return soap_out_PointerTovd__ReferencedDocument(soap, tag?tag:"vd:ReferencedDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__ReferencedDocument ** SOAP_FMAC4 soap_get_PointerTovd__ReferencedDocument(struct soap *soap, vd__ReferencedDocument **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__ReferencedDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovd__VetDocument(struct soap *soap, vd__VetDocument **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTovd__VetDocument))
		soap_serialize_PointerTovd__VetDocument(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTovd__VetDocument(struct soap *soap, const char *tag, int id, vd__VetDocument **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovd__VetDocument);
	return (id < 0) ? soap->error : soap_out_PointerTovd__VetDocument(soap, tag, id, *a, type);
}

SOAP_FMAC3 vd__VetDocument *** FASTCALL soap_in_PointerToPointerTovd__VetDocument(struct soap *soap, const char *tag, vd__VetDocument ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocument ***)soap_malloc(soap, sizeof(vd__VetDocument **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTovd__VetDocument(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (vd__VetDocument ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovd__VetDocument, sizeof(vd__VetDocument *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovd__VetDocument(struct soap *soap, vd__VetDocument **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovd__VetDocument);
	return soap_out_PointerToPointerTovd__VetDocument(soap, tag?tag:"vd:VetDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocument *** SOAP_FMAC4 soap_get_PointerToPointerTovd__VetDocument(struct soap *soap, vd__VetDocument ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTovd__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__VetDocument(struct soap *soap, vd__VetDocument *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__VetDocument))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__VetDocument(struct soap *soap, const char *tag, int id, vd__VetDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__VetDocument);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__VetDocument ** FASTCALL soap_in_PointerTovd__VetDocument(struct soap *soap, const char *tag, vd__VetDocument **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__VetDocument **)soap_malloc(soap, sizeof(vd__VetDocument *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__VetDocument *)soap_instantiate_vd__VetDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__VetDocument ** p = (vd__VetDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__VetDocument, sizeof(vd__VetDocument), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__VetDocument(struct soap *soap, vd__VetDocument *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__VetDocument);
	return soap_out_PointerTovd__VetDocument(soap, tag?tag:"vd:VetDocument", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__VetDocument ** SOAP_FMAC4 soap_get_PointerTovd__VetDocument(struct soap *soap, vd__VetDocument **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__VetDocument(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__Waybill(struct soap *soap, vd__Waybill *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__Waybill))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__Waybill(struct soap *soap, const char *tag, int id, vd__Waybill *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__Waybill);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__Waybill ** FASTCALL soap_in_PointerTovd__Waybill(struct soap *soap, const char *tag, vd__Waybill **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__Waybill **)soap_malloc(soap, sizeof(vd__Waybill *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__Waybill *)soap_instantiate_vd__Waybill(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__Waybill ** p = (vd__Waybill **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__Waybill, sizeof(vd__Waybill), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__Waybill(struct soap *soap, vd__Waybill *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__Waybill);
	return soap_out_PointerTovd__Waybill(soap, tag?tag:"vd:Waybill", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__Waybill ** SOAP_FMAC4 soap_get_PointerTovd__Waybill(struct soap *soap, vd__Waybill **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__Waybill(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__User(struct soap *soap, vd__User *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__User))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__User(struct soap *soap, const char *tag, int id, vd__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__User);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__User ** FASTCALL soap_in_PointerTovd__User(struct soap *soap, const char *tag, vd__User **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__User **)soap_malloc(soap, sizeof(vd__User *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__User *)soap_instantiate_vd__User(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__User ** p = (vd__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__User, sizeof(vd__User), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__User(struct soap *soap, vd__User *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__User);
	return soap_out_PointerTovd__User(soap, tag?tag:"vd:User", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__User ** SOAP_FMAC4 soap_get_PointerTovd__User(struct soap *soap, vd__User **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__User(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__DeliveryInspection))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__DeliveryInspection(struct soap *soap, const char *tag, int id, vd__DeliveryInspection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__DeliveryInspection);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__DeliveryInspection ** FASTCALL soap_in_PointerTovd__DeliveryInspection(struct soap *soap, const char *tag, vd__DeliveryInspection **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__DeliveryInspection **)soap_malloc(soap, sizeof(vd__DeliveryInspection *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__DeliveryInspection *)soap_instantiate_vd__DeliveryInspection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__DeliveryInspection ** p = (vd__DeliveryInspection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__DeliveryInspection, sizeof(vd__DeliveryInspection), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__DeliveryInspection);
	return soap_out_PointerTovd__DeliveryInspection(soap, tag?tag:"vd:DeliveryInspection", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__DeliveryInspection ** SOAP_FMAC4 soap_get_PointerTovd__DeliveryInspection(struct soap *soap, vd__DeliveryInspection **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__DeliveryInspection(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__StockEntry(struct soap *soap, vd__StockEntry *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__StockEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__StockEntry(struct soap *soap, const char *tag, int id, vd__StockEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__StockEntry);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__StockEntry ** FASTCALL soap_in_PointerTovd__StockEntry(struct soap *soap, const char *tag, vd__StockEntry **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__StockEntry **)soap_malloc(soap, sizeof(vd__StockEntry *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__StockEntry *)soap_instantiate_vd__StockEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__StockEntry ** p = (vd__StockEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntry, sizeof(vd__StockEntry), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (vd__StockEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__StockEntrySearchPattern, sizeof(vd__StockEntrySearchPattern), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__StockEntry(struct soap *soap, vd__StockEntry *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__StockEntry);
	return soap_out_PointerTovd__StockEntry(soap, tag?tag:"vd:StockEntry", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__StockEntry ** SOAP_FMAC4 soap_get_PointerTovd__StockEntry(struct soap *soap, vd__StockEntry **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__StockEntry(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__PackageList(struct soap *soap, ent__PackageList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__PackageList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__PackageList(struct soap *soap, const char *tag, int id, ent__PackageList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__PackageList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__PackageList ** FASTCALL soap_in_PointerToent__PackageList(struct soap *soap, const char *tag, ent__PackageList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__PackageList **)soap_malloc(soap, sizeof(ent__PackageList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__PackageList *)soap_instantiate_ent__PackageList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__PackageList ** p = (ent__PackageList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__PackageList, sizeof(ent__PackageList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__PackageList(struct soap *soap, ent__PackageList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__PackageList);
	return soap_out_PointerToent__PackageList(soap, tag?tag:"ent:PackageList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__PackageList ** SOAP_FMAC4 soap_get_PointerToent__PackageList(struct soap *soap, ent__PackageList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__PackageList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__BatchOrigin(struct soap *soap, vd__BatchOrigin *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__BatchOrigin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__BatchOrigin(struct soap *soap, const char *tag, int id, vd__BatchOrigin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__BatchOrigin);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__BatchOrigin ** FASTCALL soap_in_PointerTovd__BatchOrigin(struct soap *soap, const char *tag, vd__BatchOrigin **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__BatchOrigin **)soap_malloc(soap, sizeof(vd__BatchOrigin *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__BatchOrigin *)soap_instantiate_vd__BatchOrigin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__BatchOrigin ** p = (vd__BatchOrigin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__BatchOrigin, sizeof(vd__BatchOrigin), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__BatchOrigin(struct soap *soap, vd__BatchOrigin *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__BatchOrigin);
	return soap_out_PointerTovd__BatchOrigin(soap, tag?tag:"vd:BatchOrigin", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__BatchOrigin ** SOAP_FMAC4 soap_get_PointerTovd__BatchOrigin(struct soap *soap, vd__BatchOrigin **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__BatchOrigin(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovd__GoodsDate(struct soap *soap, vd__GoodsDate *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_vd__GoodsDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTovd__GoodsDate(struct soap *soap, const char *tag, int id, vd__GoodsDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vd__GoodsDate);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 vd__GoodsDate ** FASTCALL soap_in_PointerTovd__GoodsDate(struct soap *soap, const char *tag, vd__GoodsDate **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (vd__GoodsDate **)soap_malloc(soap, sizeof(vd__GoodsDate *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (vd__GoodsDate *)soap_instantiate_vd__GoodsDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		vd__GoodsDate ** p = (vd__GoodsDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vd__GoodsDate, sizeof(vd__GoodsDate), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovd__GoodsDate(struct soap *soap, vd__GoodsDate *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovd__GoodsDate);
	return soap_out_PointerTovd__GoodsDate(soap, tag?tag:"vd:GoodsDate", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 vd__GoodsDate ** SOAP_FMAC4 soap_get_PointerTovd__GoodsDate(struct soap *soap, vd__GoodsDate **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTovd__GoodsDate(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ProductItem(struct soap *soap, ent__ProductItem *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ProductItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ProductItem(struct soap *soap, const char *tag, int id, ent__ProductItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ProductItem);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ProductItem ** FASTCALL soap_in_PointerToent__ProductItem(struct soap *soap, const char *tag, ent__ProductItem **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductItem **)soap_malloc(soap, sizeof(ent__ProductItem *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ProductItem *)soap_instantiate_ent__ProductItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ProductItem ** p = (ent__ProductItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ProductItem, sizeof(ent__ProductItem), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ProductItem(struct soap *soap, ent__ProductItem *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ProductItem);
	return soap_out_PointerToent__ProductItem(soap, tag?tag:"ent:ProductItem", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductItem ** SOAP_FMAC4 soap_get_PointerToent__ProductItem(struct soap *soap, ent__ProductItem **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ProductItem(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__SubProduct(struct soap *soap, ent__SubProduct *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__SubProduct))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__SubProduct(struct soap *soap, const char *tag, int id, ent__SubProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__SubProduct);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__SubProduct ** FASTCALL soap_in_PointerToent__SubProduct(struct soap *soap, const char *tag, ent__SubProduct **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__SubProduct **)soap_malloc(soap, sizeof(ent__SubProduct *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__SubProduct *)soap_instantiate_ent__SubProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__SubProduct ** p = (ent__SubProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__SubProduct, sizeof(ent__SubProduct), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__SubProduct(struct soap *soap, ent__SubProduct *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__SubProduct);
	return soap_out_PointerToent__SubProduct(soap, tag?tag:"ent:SubProduct", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__SubProduct ** SOAP_FMAC4 soap_get_PointerToent__SubProduct(struct soap *soap, ent__SubProduct **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__SubProduct(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Product(struct soap *soap, ent__Product *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Product))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Product(struct soap *soap, const char *tag, int id, ent__Product *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Product);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Product ** FASTCALL soap_in_PointerToent__Product(struct soap *soap, const char *tag, ent__Product **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Product **)soap_malloc(soap, sizeof(ent__Product *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Product *)soap_instantiate_ent__Product(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Product ** p = (ent__Product **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Product, sizeof(ent__Product), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Product(struct soap *soap, ent__Product *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Product);
	return soap_out_PointerToent__Product(soap, tag?tag:"ent:Product", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Product ** SOAP_FMAC4 soap_get_PointerToent__Product(struct soap *soap, ent__Product **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Product(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ProductType(struct soap *soap, enum ent__ProductType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__ProductType);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ProductType(struct soap *soap, const char *tag, int id, enum ent__ProductType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ProductType);
	return (id < 0) ? soap->error : soap_out_ent__ProductType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__ProductType ** FASTCALL soap_in_PointerToent__ProductType(struct soap *soap, const char *tag, enum ent__ProductType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__ProductType **)soap_malloc(soap, sizeof(enum ent__ProductType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__ProductType(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__ProductType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ProductType, sizeof(enum ent__ProductType), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ProductType(struct soap *soap, enum ent__ProductType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ProductType);
	return soap_out_PointerToent__ProductType(soap, tag?tag:"ent:ProductType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__ProductType ** SOAP_FMAC4 soap_get_PointerToent__ProductType(struct soap *soap, enum ent__ProductType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ProductType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__RegionalizationConditionGroup))
		soap_serialize_PointerToent__RegionalizationConditionGroup(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, ent__RegionalizationConditionGroup **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__RegionalizationConditionGroup);
	return (id < 0) ? soap->error : soap_out_PointerToent__RegionalizationConditionGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__RegionalizationConditionGroup *** FASTCALL soap_in_PointerToPointerToent__RegionalizationConditionGroup(struct soap *soap, const char *tag, ent__RegionalizationConditionGroup ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationConditionGroup ***)soap_malloc(soap, sizeof(ent__RegionalizationConditionGroup **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__RegionalizationConditionGroup(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__RegionalizationConditionGroup ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__RegionalizationConditionGroup, sizeof(ent__RegionalizationConditionGroup *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__RegionalizationConditionGroup);
	return soap_out_PointerToPointerToent__RegionalizationConditionGroup(soap, tag?tag:"ent:RegionalizationConditionGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationConditionGroup *** SOAP_FMAC4 soap_get_PointerToPointerToent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationConditionGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationConditionGroup(struct soap *soap, const char *tag, int id, ent__RegionalizationConditionGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationConditionGroup);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationConditionGroup ** FASTCALL soap_in_PointerToent__RegionalizationConditionGroup(struct soap *soap, const char *tag, ent__RegionalizationConditionGroup **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationConditionGroup **)soap_malloc(soap, sizeof(ent__RegionalizationConditionGroup *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationConditionGroup *)soap_instantiate_ent__RegionalizationConditionGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationConditionGroup ** p = (ent__RegionalizationConditionGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationConditionGroup, sizeof(ent__RegionalizationConditionGroup), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationConditionGroup);
	return soap_out_PointerToent__RegionalizationConditionGroup(soap, tag?tag:"ent:RegionalizationConditionGroup", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationConditionGroup ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationConditionGroup(struct soap *soap, ent__RegionalizationConditionGroup **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationConditionGroup(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__AnimalDisease(struct soap *soap, ent__AnimalDisease *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__AnimalDisease))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__AnimalDisease(struct soap *soap, const char *tag, int id, ent__AnimalDisease *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__AnimalDisease);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__AnimalDisease ** FASTCALL soap_in_PointerToent__AnimalDisease(struct soap *soap, const char *tag, ent__AnimalDisease **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__AnimalDisease **)soap_malloc(soap, sizeof(ent__AnimalDisease *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__AnimalDisease *)soap_instantiate_ent__AnimalDisease(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__AnimalDisease ** p = (ent__AnimalDisease **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__AnimalDisease, sizeof(ent__AnimalDisease), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__AnimalDisease(struct soap *soap, ent__AnimalDisease *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__AnimalDisease);
	return soap_out_PointerToent__AnimalDisease(soap, tag?tag:"ent:AnimalDisease", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__AnimalDisease ** SOAP_FMAC4 soap_get_PointerToent__AnimalDisease(struct soap *soap, ent__AnimalDisease **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__AnimalDisease(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__RegionalizationCondition))
		soap_serialize_PointerToent__RegionalizationCondition(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__RegionalizationCondition(struct soap *soap, const char *tag, int id, ent__RegionalizationCondition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__RegionalizationCondition);
	return (id < 0) ? soap->error : soap_out_PointerToent__RegionalizationCondition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__RegionalizationCondition *** FASTCALL soap_in_PointerToPointerToent__RegionalizationCondition(struct soap *soap, const char *tag, ent__RegionalizationCondition ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationCondition ***)soap_malloc(soap, sizeof(ent__RegionalizationCondition **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__RegionalizationCondition(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__RegionalizationCondition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__RegionalizationCondition, sizeof(ent__RegionalizationCondition *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__RegionalizationCondition);
	return soap_out_PointerToPointerToent__RegionalizationCondition(soap, tag?tag:"ent:RegionalizationCondition", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationCondition *** SOAP_FMAC4 soap_get_PointerToPointerToent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__RegionalizationCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__RegionalizationCondition(struct soap *soap, const char *tag, int id, ent__RegionalizationCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__RegionalizationCondition);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__RegionalizationCondition ** FASTCALL soap_in_PointerToent__RegionalizationCondition(struct soap *soap, const char *tag, ent__RegionalizationCondition **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__RegionalizationCondition **)soap_malloc(soap, sizeof(ent__RegionalizationCondition *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__RegionalizationCondition *)soap_instantiate_ent__RegionalizationCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__RegionalizationCondition ** p = (ent__RegionalizationCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__RegionalizationCondition, sizeof(ent__RegionalizationCondition), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__RegionalizationCondition);
	return soap_out_PointerToent__RegionalizationCondition(soap, tag?tag:"ent:RegionalizationCondition", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__RegionalizationCondition ** SOAP_FMAC4 soap_get_PointerToent__RegionalizationCondition(struct soap *soap, ent__RegionalizationCondition **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__RegionalizationCondition(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__BusinessMember(struct soap *soap, ent__BusinessMember *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__BusinessMember))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__BusinessMember(struct soap *soap, const char *tag, int id, ent__BusinessMember *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__BusinessMember);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__BusinessMember ** FASTCALL soap_in_PointerToent__BusinessMember(struct soap *soap, const char *tag, ent__BusinessMember **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__BusinessMember **)soap_malloc(soap, sizeof(ent__BusinessMember *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__BusinessMember *)soap_instantiate_ent__BusinessMember(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__BusinessMember ** p = (ent__BusinessMember **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__BusinessMember, sizeof(ent__BusinessMember), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__BusinessMember(struct soap *soap, ent__BusinessMember *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__BusinessMember);
	return soap_out_PointerToent__BusinessMember(soap, tag?tag:"ent:BusinessMember", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__BusinessMember ** SOAP_FMAC4 soap_get_PointerToent__BusinessMember(struct soap *soap, ent__BusinessMember **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__BusinessMember(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Identifier(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__Identifier))
		soap_serialize_base__Identifier(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Identifier(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Identifier);
	return (id < 0) ? soap->error : soap_out_base__Identifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__Identifier(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Identifier(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Identifier, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Identifier(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Identifier);
	return soap_out_PointerTobase__Identifier(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__Identifier(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Identifier(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Address(struct soap *soap, ent__Address *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Address))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Address(struct soap *soap, const char *tag, int id, ent__Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Address);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Address ** FASTCALL soap_in_PointerToent__Address(struct soap *soap, const char *tag, ent__Address **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Address **)soap_malloc(soap, sizeof(ent__Address *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Address *)soap_instantiate_ent__Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Address ** p = (ent__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Address, sizeof(ent__Address), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ent__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Area, sizeof(ent__Area), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Address(struct soap *soap, ent__Address *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Address);
	return soap_out_PointerToent__Address(soap, tag?tag:"ent:Address", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Address ** SOAP_FMAC4 soap_get_PointerToent__Address(struct soap *soap, ent__Address **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Address(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Unit(struct soap *soap, ent__Unit *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Unit))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Unit(struct soap *soap, const char *tag, int id, ent__Unit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Unit);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Unit ** FASTCALL soap_in_PointerToent__Unit(struct soap *soap, const char *tag, ent__Unit **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Unit **)soap_malloc(soap, sizeof(ent__Unit *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Unit *)soap_instantiate_ent__Unit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Unit ** p = (ent__Unit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Unit, sizeof(ent__Unit), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Unit(struct soap *soap, ent__Unit *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Unit);
	return soap_out_PointerToent__Unit(soap, tag?tag:"ent:Unit", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Unit ** SOAP_FMAC4 soap_get_PointerToent__Unit(struct soap *soap, ent__Unit **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Unit(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Decimal(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__Decimal))
		soap_serialize_base__Decimal(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Decimal(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Decimal);
	return (id < 0) ? soap->error : soap_out_base__Decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__Decimal(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__Decimal(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Decimal, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Decimal(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Decimal);
	return soap_out_PointerTobase__Decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__Decimal(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Minute(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__Minute);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Minute(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Minute);
	return (id < 0) ? soap->error : soap_out_ent__Minute(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToent__Minute(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__Minute(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Minute, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Minute(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Minute);
	return soap_out_PointerToent__Minute(soap, tag?tag:"ent:Minute", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToent__Minute(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Minute(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Hour(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__Hour);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Hour(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Hour);
	return (id < 0) ? soap->error : soap_out_ent__Hour(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToent__Hour(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__Hour(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Hour, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Hour(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Hour);
	return soap_out_PointerToent__Hour(soap, tag?tag:"ent:Hour", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToent__Hour(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Hour(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Day(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__Day);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Day(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Day);
	return (id < 0) ? soap->error : soap_out_ent__Day(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToent__Day(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__Day(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Day, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Day(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Day);
	return soap_out_PointerToent__Day(soap, tag?tag:"ent:Day", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToent__Day(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Day(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Month(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__Month);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Month(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Month);
	return (id < 0) ? soap->error : soap_out_ent__Month(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToent__Month(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__Month(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Month, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Month(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Month);
	return soap_out_PointerToent__Month(soap, tag?tag:"ent:Month", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToent__Month(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Month(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Year(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__Year);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Year(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Year);
	return (id < 0) ? soap->error : soap_out_ent__Year(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToent__Year(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__Year(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Year, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Year(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Year);
	return soap_out_PointerToent__Year(soap, tag?tag:"ent:Year", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToent__Year(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Year(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Package(struct soap *soap, ent__Package **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Package))
		soap_serialize_PointerToent__Package(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Package(struct soap *soap, const char *tag, int id, ent__Package **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Package);
	return (id < 0) ? soap->error : soap_out_PointerToent__Package(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Package *** FASTCALL soap_in_PointerToPointerToent__Package(struct soap *soap, const char *tag, ent__Package ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Package ***)soap_malloc(soap, sizeof(ent__Package **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Package(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Package ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Package, sizeof(ent__Package *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Package(struct soap *soap, ent__Package **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Package);
	return soap_out_PointerToPointerToent__Package(soap, tag?tag:"ent:Package", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Package *** SOAP_FMAC4 soap_get_PointerToPointerToent__Package(struct soap *soap, ent__Package ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Package(struct soap *soap, ent__Package *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Package))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Package(struct soap *soap, const char *tag, int id, ent__Package *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Package);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Package ** FASTCALL soap_in_PointerToent__Package(struct soap *soap, const char *tag, ent__Package **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Package **)soap_malloc(soap, sizeof(ent__Package *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Package *)soap_instantiate_ent__Package(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Package ** p = (ent__Package **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Package, sizeof(ent__Package), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Package(struct soap *soap, ent__Package *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Package);
	return soap_out_PointerToent__Package(soap, tag?tag:"ent:Package", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Package ** SOAP_FMAC4 soap_get_PointerToent__Package(struct soap *soap, ent__Package **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Package(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__ProductMarks(struct soap *soap, ent__ProductMarks **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__ProductMarks))
		soap_serialize_PointerToent__ProductMarks(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__ProductMarks(struct soap *soap, const char *tag, int id, ent__ProductMarks **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__ProductMarks);
	return (id < 0) ? soap->error : soap_out_PointerToent__ProductMarks(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__ProductMarks *** FASTCALL soap_in_PointerToPointerToent__ProductMarks(struct soap *soap, const char *tag, ent__ProductMarks ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductMarks ***)soap_malloc(soap, sizeof(ent__ProductMarks **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__ProductMarks(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__ProductMarks ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__ProductMarks, sizeof(ent__ProductMarks *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__ProductMarks(struct soap *soap, ent__ProductMarks **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__ProductMarks);
	return soap_out_PointerToPointerToent__ProductMarks(soap, tag?tag:"ent:ProductMarks", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductMarks *** SOAP_FMAC4 soap_get_PointerToPointerToent__ProductMarks(struct soap *soap, ent__ProductMarks ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__ProductMarks(struct soap *soap, ent__ProductMarks *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__ProductMarks))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__ProductMarks(struct soap *soap, const char *tag, int id, ent__ProductMarks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__ProductMarks);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__ProductMarks ** FASTCALL soap_in_PointerToent__ProductMarks(struct soap *soap, const char *tag, ent__ProductMarks **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__ProductMarks **)soap_malloc(soap, sizeof(ent__ProductMarks *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__ProductMarks *)soap_instantiate_ent__ProductMarks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__ProductMarks ** p = (ent__ProductMarks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__ProductMarks, sizeof(ent__ProductMarks), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__ProductMarks(struct soap *soap, ent__ProductMarks *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__ProductMarks);
	return soap_out_PointerToent__ProductMarks(soap, tag?tag:"ent:ProductMarks", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__ProductMarks ** SOAP_FMAC4 soap_get_PointerToent__ProductMarks(struct soap *soap, ent__ProductMarks **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__ProductMarks(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__PackingType(struct soap *soap, ent__PackingType *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__PackingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__PackingType(struct soap *soap, const char *tag, int id, ent__PackingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__PackingType);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__PackingType ** FASTCALL soap_in_PointerToent__PackingType(struct soap *soap, const char *tag, ent__PackingType **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__PackingType **)soap_malloc(soap, sizeof(ent__PackingType *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__PackingType *)soap_instantiate_ent__PackingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__PackingType ** p = (ent__PackingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__PackingType, sizeof(ent__PackingType), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__PackingType(struct soap *soap, ent__PackingType *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__PackingType);
	return soap_out_PointerToent__PackingType(soap, tag?tag:"ent:PackingType", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__PackingType ** SOAP_FMAC4 soap_get_PointerToent__PackingType(struct soap *soap, ent__PackingType **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__PackingType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__BusinessEntity(struct soap *soap, ent__BusinessEntity *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__BusinessEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__BusinessEntity(struct soap *soap, const char *tag, int id, ent__BusinessEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__BusinessEntity);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__BusinessEntity ** FASTCALL soap_in_PointerToent__BusinessEntity(struct soap *soap, const char *tag, ent__BusinessEntity **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__BusinessEntity **)soap_malloc(soap, sizeof(ent__BusinessEntity *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__BusinessEntity *)soap_instantiate_ent__BusinessEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__BusinessEntity ** p = (ent__BusinessEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__BusinessEntity, sizeof(ent__BusinessEntity), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__BusinessEntity(struct soap *soap, ent__BusinessEntity *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__BusinessEntity);
	return soap_out_PointerToent__BusinessEntity(soap, tag?tag:"ent:BusinessEntity", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__BusinessEntity ** SOAP_FMAC4 soap_get_PointerToent__BusinessEntity(struct soap *soap, ent__BusinessEntity **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__BusinessEntity(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__String255(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__String255))
		soap_serialize_base__String255(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__String255(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__String255);
	return (id < 0) ? soap->error : soap_out_base__String255(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__String255(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__String255(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__String255, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__String255(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__String255);
	return soap_out_PointerTobase__String255(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__String255(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__String255(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToent__Producer(struct soap *soap, ent__Producer **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToent__Producer))
		soap_serialize_PointerToent__Producer(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToent__Producer(struct soap *soap, const char *tag, int id, ent__Producer **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToent__Producer);
	return (id < 0) ? soap->error : soap_out_PointerToent__Producer(soap, tag, id, *a, type);
}

SOAP_FMAC3 ent__Producer *** FASTCALL soap_in_PointerToPointerToent__Producer(struct soap *soap, const char *tag, ent__Producer ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Producer ***)soap_malloc(soap, sizeof(ent__Producer **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToent__Producer(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (ent__Producer ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToent__Producer, sizeof(ent__Producer *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToent__Producer(struct soap *soap, ent__Producer **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToent__Producer);
	return soap_out_PointerToPointerToent__Producer(soap, tag?tag:"ent:Producer", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Producer *** SOAP_FMAC4 soap_get_PointerToPointerToent__Producer(struct soap *soap, ent__Producer ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToent__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Producer(struct soap *soap, ent__Producer *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Producer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Producer(struct soap *soap, const char *tag, int id, ent__Producer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Producer);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Producer ** FASTCALL soap_in_PointerToent__Producer(struct soap *soap, const char *tag, ent__Producer **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Producer **)soap_malloc(soap, sizeof(ent__Producer *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Producer *)soap_instantiate_ent__Producer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Producer ** p = (ent__Producer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Producer, sizeof(ent__Producer), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Producer(struct soap *soap, ent__Producer *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Producer);
	return soap_out_PointerToent__Producer(soap, tag?tag:"ent:Producer", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Producer ** SOAP_FMAC4 soap_get_PointerToent__Producer(struct soap *soap, ent__Producer **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Producer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__EnterpriseRole(struct soap *soap, enum ent__EnterpriseRole *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ent__EnterpriseRole);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__EnterpriseRole(struct soap *soap, const char *tag, int id, enum ent__EnterpriseRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__EnterpriseRole);
	return (id < 0) ? soap->error : soap_out_ent__EnterpriseRole(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ent__EnterpriseRole ** FASTCALL soap_in_PointerToent__EnterpriseRole(struct soap *soap, const char *tag, enum ent__EnterpriseRole **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum ent__EnterpriseRole **)soap_malloc(soap, sizeof(enum ent__EnterpriseRole *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_ent__EnterpriseRole(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum ent__EnterpriseRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__EnterpriseRole, sizeof(enum ent__EnterpriseRole), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__EnterpriseRole(struct soap *soap, enum ent__EnterpriseRole *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__EnterpriseRole);
	return soap_out_PointerToent__EnterpriseRole(soap, tag?tag:"ent:EnterpriseRole", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum ent__EnterpriseRole ** SOAP_FMAC4 soap_get_PointerToent__EnterpriseRole(struct soap *soap, enum ent__EnterpriseRole **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__EnterpriseRole(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Enterprise(struct soap *soap, ent__Enterprise *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Enterprise))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Enterprise(struct soap *soap, const char *tag, int id, ent__Enterprise *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Enterprise);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Enterprise ** FASTCALL soap_in_PointerToent__Enterprise(struct soap *soap, const char *tag, ent__Enterprise **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Enterprise **)soap_malloc(soap, sizeof(ent__Enterprise *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Enterprise *)soap_instantiate_ent__Enterprise(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Enterprise ** p = (ent__Enterprise **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Enterprise, sizeof(ent__Enterprise), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Enterprise(struct soap *soap, ent__Enterprise *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Enterprise);
	return soap_out_PointerToent__Enterprise(soap, tag?tag:"ent:Enterprise", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Enterprise ** SOAP_FMAC4 soap_get_PointerToent__Enterprise(struct soap *soap, ent__Enterprise **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Enterprise(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__NText(struct soap *soap, char **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__NText))
		soap_serialize_base__NText(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__NText(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__NText);
	return (id < 0) ? soap->error : soap_out_base__NText(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** FASTCALL soap_in_PointerTobase__NText(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_base__NText(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__NText, sizeof(char *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__NText(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__NText);
	return soap_out_PointerTobase__NText(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTobase__NText(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__NText(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Street(struct soap *soap, ent__Street *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Street))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Street(struct soap *soap, const char *tag, int id, ent__Street *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Street);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Street ** FASTCALL soap_in_PointerToent__Street(struct soap *soap, const char *tag, ent__Street **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Street **)soap_malloc(soap, sizeof(ent__Street *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Street *)soap_instantiate_ent__Street(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Street ** p = (ent__Street **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Street, sizeof(ent__Street), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Street(struct soap *soap, ent__Street *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Street);
	return soap_out_PointerToent__Street(soap, tag?tag:"ent:Street", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Street ** SOAP_FMAC4 soap_get_PointerToent__Street(struct soap *soap, ent__Street **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Street(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Locality(struct soap *soap, ent__Locality *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Locality))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Locality(struct soap *soap, const char *tag, int id, ent__Locality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Locality);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Locality ** FASTCALL soap_in_PointerToent__Locality(struct soap *soap, const char *tag, ent__Locality **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Locality **)soap_malloc(soap, sizeof(ent__Locality *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Locality *)soap_instantiate_ent__Locality(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Locality ** p = (ent__Locality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Locality, sizeof(ent__Locality), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Locality(struct soap *soap, ent__Locality *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Locality);
	return soap_out_PointerToent__Locality(soap, tag?tag:"ent:Locality", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Locality ** SOAP_FMAC4 soap_get_PointerToent__Locality(struct soap *soap, ent__Locality **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Locality(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__District(struct soap *soap, ent__District *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__District))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__District(struct soap *soap, const char *tag, int id, ent__District *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__District);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__District ** FASTCALL soap_in_PointerToent__District(struct soap *soap, const char *tag, ent__District **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__District **)soap_malloc(soap, sizeof(ent__District *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__District *)soap_instantiate_ent__District(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__District ** p = (ent__District **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__District, sizeof(ent__District), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__District(struct soap *soap, ent__District *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__District);
	return soap_out_PointerToent__District(soap, tag?tag:"ent:District", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__District ** SOAP_FMAC4 soap_get_PointerToent__District(struct soap *soap, ent__District **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__District(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Region(struct soap *soap, ent__Region *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Region))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Region(struct soap *soap, const char *tag, int id, ent__Region *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Region);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Region ** FASTCALL soap_in_PointerToent__Region(struct soap *soap, const char *tag, ent__Region **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Region **)soap_malloc(soap, sizeof(ent__Region *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Region *)soap_instantiate_ent__Region(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Region ** p = (ent__Region **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Region, sizeof(ent__Region), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Region(struct soap *soap, ent__Region *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Region);
	return soap_out_PointerToent__Region(soap, tag?tag:"ent:Region", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Region ** SOAP_FMAC4 soap_get_PointerToent__Region(struct soap *soap, ent__Region **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Region(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__FederalDistrict(struct soap *soap, ent__FederalDistrict *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__FederalDistrict))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__FederalDistrict(struct soap *soap, const char *tag, int id, ent__FederalDistrict *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__FederalDistrict);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__FederalDistrict ** FASTCALL soap_in_PointerToent__FederalDistrict(struct soap *soap, const char *tag, ent__FederalDistrict **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__FederalDistrict **)soap_malloc(soap, sizeof(ent__FederalDistrict *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__FederalDistrict *)soap_instantiate_ent__FederalDistrict(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__FederalDistrict ** p = (ent__FederalDistrict **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__FederalDistrict, sizeof(ent__FederalDistrict), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__FederalDistrict(struct soap *soap, ent__FederalDistrict *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__FederalDistrict);
	return soap_out_PointerToent__FederalDistrict(soap, tag?tag:"ent:FederalDistrict", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__FederalDistrict ** SOAP_FMAC4 soap_get_PointerToent__FederalDistrict(struct soap *soap, ent__FederalDistrict **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__FederalDistrict(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__Country(struct soap *soap, ent__Country *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_ent__Country))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToent__Country(struct soap *soap, const char *tag, int id, ent__Country *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__Country);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ent__Country ** FASTCALL soap_in_PointerToent__Country(struct soap *soap, const char *tag, ent__Country **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (ent__Country **)soap_malloc(soap, sizeof(ent__Country *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (ent__Country *)soap_instantiate_ent__Country(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		ent__Country ** p = (ent__Country **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__Country, sizeof(ent__Country), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__Country(struct soap *soap, ent__Country *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__Country);
	return soap_out_PointerToent__Country(soap, tag?tag:"ent:Country", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 ent__Country ** SOAP_FMAC4 soap_get_PointerToent__Country(struct soap *soap, ent__Country **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToent__Country(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToapp__BusinessError(struct soap *soap, app__BusinessError **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerToapp__BusinessError))
		soap_serialize_PointerToapp__BusinessError(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerToapp__BusinessError(struct soap *soap, const char *tag, int id, app__BusinessError **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToapp__BusinessError);
	return (id < 0) ? soap->error : soap_out_PointerToapp__BusinessError(soap, tag, id, *a, type);
}

SOAP_FMAC3 app__BusinessError *** FASTCALL soap_in_PointerToPointerToapp__BusinessError(struct soap *soap, const char *tag, app__BusinessError ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__BusinessError ***)soap_malloc(soap, sizeof(app__BusinessError **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerToapp__BusinessError(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (app__BusinessError ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToapp__BusinessError, sizeof(app__BusinessError *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToapp__BusinessError(struct soap *soap, app__BusinessError **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToapp__BusinessError);
	return soap_out_PointerToPointerToapp__BusinessError(soap, tag?tag:"app:BusinessError", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__BusinessError *** SOAP_FMAC4 soap_get_PointerToPointerToapp__BusinessError(struct soap *soap, app__BusinessError ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerToapp__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__BusinessError(struct soap *soap, app__BusinessError *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__BusinessError))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__BusinessError(struct soap *soap, const char *tag, int id, app__BusinessError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__BusinessError);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__BusinessError ** FASTCALL soap_in_PointerToapp__BusinessError(struct soap *soap, const char *tag, app__BusinessError **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__BusinessError **)soap_malloc(soap, sizeof(app__BusinessError *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__BusinessError *)soap_instantiate_app__BusinessError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__BusinessError ** p = (app__BusinessError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__BusinessError, sizeof(app__BusinessError), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__BusinessError(struct soap *soap, app__BusinessError *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__BusinessError);
	return soap_out_PointerToapp__BusinessError(soap, tag?tag:"app:BusinessError", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__BusinessError ** SOAP_FMAC4 soap_get_PointerToapp__BusinessError(struct soap *soap, app__BusinessError **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__BusinessError(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ContentEncoding(struct soap *soap, enum app__ContentEncoding *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_app__ContentEncoding);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ContentEncoding(struct soap *soap, const char *tag, int id, enum app__ContentEncoding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ContentEncoding);
	return (id < 0) ? soap->error : soap_out_app__ContentEncoding(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum app__ContentEncoding ** FASTCALL soap_in_PointerToapp__ContentEncoding(struct soap *soap, const char *tag, enum app__ContentEncoding **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum app__ContentEncoding **)soap_malloc(soap, sizeof(enum app__ContentEncoding *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_app__ContentEncoding(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum app__ContentEncoding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ContentEncoding, sizeof(enum app__ContentEncoding), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ContentEncoding(struct soap *soap, enum app__ContentEncoding *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ContentEncoding);
	return soap_out_PointerToapp__ContentEncoding(soap, tag?tag:"app:ContentEncoding", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ContentEncoding ** SOAP_FMAC4 soap_get_PointerToapp__ContentEncoding(struct soap *soap, enum app__ContentEncoding **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ContentEncoding(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__BusinessErrorList(struct soap *soap, app__BusinessErrorList *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__BusinessErrorList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__BusinessErrorList(struct soap *soap, const char *tag, int id, app__BusinessErrorList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__BusinessErrorList);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__BusinessErrorList ** FASTCALL soap_in_PointerToapp__BusinessErrorList(struct soap *soap, const char *tag, app__BusinessErrorList **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__BusinessErrorList **)soap_malloc(soap, sizeof(app__BusinessErrorList *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__BusinessErrorList *)soap_instantiate_app__BusinessErrorList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__BusinessErrorList ** p = (app__BusinessErrorList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__BusinessErrorList, sizeof(app__BusinessErrorList), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__BusinessErrorList(struct soap *soap, app__BusinessErrorList *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__BusinessErrorList);
	return soap_out_PointerToapp__BusinessErrorList(soap, tag?tag:"app:BusinessErrorList", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__BusinessErrorList ** SOAP_FMAC4 soap_get_PointerToapp__BusinessErrorList(struct soap *soap, app__BusinessErrorList **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__BusinessErrorList(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__ApplicationResultWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ApplicationResultWrapper(struct soap *soap, const char *tag, int id, app__ApplicationResultWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ApplicationResultWrapper);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__ApplicationResultWrapper ** FASTCALL soap_in_PointerToapp__ApplicationResultWrapper(struct soap *soap, const char *tag, app__ApplicationResultWrapper **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__ApplicationResultWrapper **)soap_malloc(soap, sizeof(app__ApplicationResultWrapper *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__ApplicationResultWrapper *)soap_instantiate_app__ApplicationResultWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__ApplicationResultWrapper ** p = (app__ApplicationResultWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ApplicationResultWrapper, sizeof(app__ApplicationResultWrapper), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ApplicationResultWrapper);
	return soap_out_PointerToapp__ApplicationResultWrapper(soap, tag?tag:"app:ApplicationResultWrapper", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__ApplicationResultWrapper ** SOAP_FMAC4 soap_get_PointerToapp__ApplicationResultWrapper(struct soap *soap, app__ApplicationResultWrapper **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ApplicationResultWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__ApplicationDataWrapper))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ApplicationDataWrapper(struct soap *soap, const char *tag, int id, app__ApplicationDataWrapper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ApplicationDataWrapper);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__ApplicationDataWrapper ** FASTCALL soap_in_PointerToapp__ApplicationDataWrapper(struct soap *soap, const char *tag, app__ApplicationDataWrapper **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__ApplicationDataWrapper **)soap_malloc(soap, sizeof(app__ApplicationDataWrapper *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__ApplicationDataWrapper *)soap_instantiate_app__ApplicationDataWrapper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__ApplicationDataWrapper ** p = (app__ApplicationDataWrapper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ApplicationDataWrapper, sizeof(app__ApplicationDataWrapper), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ApplicationDataWrapper);
	return soap_out_PointerToapp__ApplicationDataWrapper(soap, tag?tag:"app:ApplicationDataWrapper", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__ApplicationDataWrapper ** SOAP_FMAC4 soap_get_PointerToapp__ApplicationDataWrapper(struct soap *soap, app__ApplicationDataWrapper **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ApplicationDataWrapper(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_app__ApplicationStatus);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__ApplicationStatus(struct soap *soap, const char *tag, int id, enum app__ApplicationStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__ApplicationStatus);
	return (id < 0) ? soap->error : soap_out_app__ApplicationStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum app__ApplicationStatus ** FASTCALL soap_in_PointerToapp__ApplicationStatus(struct soap *soap, const char *tag, enum app__ApplicationStatus **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (enum app__ApplicationStatus **)soap_malloc(soap, sizeof(enum app__ApplicationStatus *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_app__ApplicationStatus(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (enum app__ApplicationStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__ApplicationStatus, sizeof(enum app__ApplicationStatus), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__ApplicationStatus);
	return soap_out_PointerToapp__ApplicationStatus(soap, tag?tag:"app:ApplicationStatus", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 enum app__ApplicationStatus ** SOAP_FMAC4 soap_get_PointerToapp__ApplicationStatus(struct soap *soap, enum app__ApplicationStatus **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__ApplicationStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobase__Error(struct soap *soap, base__Error **const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_PointerTobase__Error))
		soap_serialize_PointerTobase__Error(soap, *a);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToPointerTobase__Error(struct soap *soap, const char *tag, int id, base__Error **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobase__Error);
	return (id < 0) ? soap->error : soap_out_PointerTobase__Error(soap, tag, id, *a, type);
}

SOAP_FMAC3 base__Error *** FASTCALL soap_in_PointerToPointerTobase__Error(struct soap *soap, const char *tag, base__Error ***a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__Error ***)soap_malloc(soap, sizeof(base__Error **))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_PointerTobase__Error(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (base__Error ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobase__Error, sizeof(base__Error *), 1);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobase__Error(struct soap *soap, base__Error **const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobase__Error);
	return soap_out_PointerToPointerTobase__Error(soap, tag?tag:"base:Error", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__Error *** SOAP_FMAC4 soap_get_PointerToPointerTobase__Error(struct soap *soap, base__Error ***p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToPointerTobase__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobase__Error(struct soap *soap, base__Error *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_base__Error))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobase__Error(struct soap *soap, const char *tag, int id, base__Error *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_base__Error);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 base__Error ** FASTCALL soap_in_PointerTobase__Error(struct soap *soap, const char *tag, base__Error **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (base__Error **)soap_malloc(soap, sizeof(base__Error *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (base__Error *)soap_instantiate_base__Error(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		base__Error ** p = (base__Error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_base__Error, sizeof(base__Error), 0);
		if(!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (base__Error **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__BusinessError, sizeof(app__BusinessError), 0);
		}
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobase__Error(struct soap *soap, base__Error *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobase__Error);
	return soap_out_PointerTobase__Error(soap, tag?tag:"base:Error", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 base__Error ** SOAP_FMAC4 soap_get_PointerTobase__Error(struct soap *soap, base__Error **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobase__Error(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	return (id < 0) ? soap->error : soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** FASTCALL soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	return soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTobool(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	return (id < 0) ? soap->error : soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** FASTCALL soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	return soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	return (id < 0) ? soap->error : soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** FASTCALL soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	return soap_out_PointerToint(soap, tag?tag:"int", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToint(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	return (id < 0) ? soap->error : soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** FASTCALL soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	return soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTotime(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__Application(struct soap *soap, app__Application *const*a)
{
	if(!soap_reference(soap, *a, SOAP_TYPE_app__Application))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerToapp__Application(struct soap *soap, const char *tag, int id, app__Application *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__Application);
	return (id < 0) ? soap->error : (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 app__Application ** FASTCALL soap_in_PointerToapp__Application(struct soap *soap, const char *tag, app__Application **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (app__Application **)soap_malloc(soap, sizeof(app__Application *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = (app__Application *)soap_instantiate_app__Application(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if(!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else {
		app__Application ** p = (app__Application **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__Application, sizeof(app__Application), 0);
		a = p;
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__Application(struct soap *soap, app__Application *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__Application);
	return soap_out_PointerToapp__Application(soap, tag?tag:"app:Application", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 app__Application ** SOAP_FMAC4 soap_get_PointerToapp__Application(struct soap *soap, app__Application **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerToapp__Application(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_vd__VetDocumentStatusChangeReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_vd__VetDocumentStatusChangeReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_vd__VetDocumentStatusChangeReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_vd__VetDocumentStatusChangeReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__VetDocumentStatusChangeReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__VetDocumentStatusChangeReason);
	return soap_out_vd__VetDocumentStatusChangeReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_vd__VetDocumentStatusChangeReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_vd__VetDocumentStatusChangeReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__GRNType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__GRNType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__GRNType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__GRNType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__GRNType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__GRNType);
	return soap_out_ent__GRNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__GRNType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__GRNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_vd__SNILSType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_vd__SNILSType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_vd__SNILSType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_vd__SNILSType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__SNILSType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__SNILSType);
	return soap_out_vd__SNILSType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_vd__SNILSType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_vd__SNILSType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_vd__StockEntryNumber(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_vd__StockEntryNumber);
}

SOAP_FMAC3 char * * FASTCALL soap_in_vd__StockEntryNumber(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_vd__StockEntryNumber, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vd__StockEntryNumber(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vd__StockEntryNumber);
	return soap_out_vd__StockEntryNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_vd__StockEntryNumber(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_vd__StockEntryNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__OTPToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__OTPToken);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__OTPToken(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__OTPToken, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__OTPToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__OTPToken);
	return soap_out_ent__OTPToken(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__OTPToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__OTPToken(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__GTINType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__GTINType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__GTINType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__GTINType, 1, 8, 14);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__GTINType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__GTINType);
	return soap_out_ent__GTINType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__GTINType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__GTINType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__GLNType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__GLNType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__GLNType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__GLNType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__GLNType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__GLNType);
	return soap_out_ent__GLNType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__GLNType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__GLNType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__ENTModificationReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__ENTModificationReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__ENTModificationReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__ENTModificationReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__ENTModificationReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__ENTModificationReason);
	return soap_out_ent__ENTModificationReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__ENTModificationReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__ENTModificationReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__BEModificationReason(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__BEModificationReason);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__BEModificationReason(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__BEModificationReason, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__BEModificationReason(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__BEModificationReason);
	return soap_out_ent__BEModificationReason(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__BEModificationReason(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__BEModificationReason(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__EnterpriseType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__EnterpriseType);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__EnterpriseType(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__EnterpriseType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__EnterpriseType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__EnterpriseType);
	return soap_out_ent__EnterpriseType(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__EnterpriseType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__EnterpriseType(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Code3(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__Code3);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__Code3(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__Code3, 1, 0, 3);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Code3(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Code3);
	return soap_out_ent__Code3(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__Code3(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Code3(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_ent__Code(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ent__Code);
}

SOAP_FMAC3 char * * FASTCALL soap_in_ent__Code(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_ent__Code, 1, 0, 2);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__Code(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__Code);
	return soap_out_ent__Code(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ent__Code(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_ent__Code(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_app__APIKey(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_app__APIKey);
}

SOAP_FMAC3 char * * FASTCALL soap_in_app__APIKey(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_app__APIKey, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__APIKey(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__APIKey);
	return soap_out_app__APIKey(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_app__APIKey(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_app__APIKey(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__SequenceNumber(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__SequenceNumber);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__SequenceNumber(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__SequenceNumber, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__SequenceNumber(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__SequenceNumber);
	return soap_out_base__SequenceNumber(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__SequenceNumber(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__SequenceNumber(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Identifier(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__Identifier);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__Identifier(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__Identifier, 1, 0, 100);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Identifier(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Identifier);
	return soap_out_base__Identifier(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__Identifier(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__Identifier(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__VersionStatus(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__VersionStatus);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__VersionStatus(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__VersionStatus, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__VersionStatus(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__VersionStatus);
	return soap_out_base__VersionStatus(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__VersionStatus(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__VersionStatus(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__Decimal);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__Decimal(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__Decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Decimal);
	return soap_out_base__Decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__Decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__Decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__String32(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__String32);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__String32(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__String32, 1, 0, 32);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__String32(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__String32);
	return soap_out_base__String32(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__String32(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__String32(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__String255(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__String255);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__String255(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__String255, 1, 0, 255);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__String255(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__String255);
	return soap_out_base__String255(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__String255(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__String255(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__NText(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__NText);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__NText(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__NText, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__NText(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__NText);
	return soap_out_base__NText(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__NText(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__NText(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__Text(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__Text);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__Text(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__Text, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__Text(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__Text);
	return soap_out_base__Text(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__Text(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__Text(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_base__UUID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_base__UUID);
}

SOAP_FMAC3 char * * FASTCALL soap_in_base__UUID(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_base__UUID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_base__UUID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_base__UUID);
	return soap_out_base__UUID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_base__UUID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_base__UUID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	return soap_out_xsd__token(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__token(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	return soap_out_xsd__positiveInteger(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	return soap_out_xsd__nonNegativeInteger(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	return soap_out_xsd__integer(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__integer(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	return soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	return soap_out_xsd__date(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__date(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int FASTCALL soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	return (id < 0) ? soap->error : soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** FASTCALL soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if(soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if(!a)
		if(!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if(!soap->null && *soap->href != '#') {
		soap_revert(soap);
		if(!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else {
		a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if(soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	return soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__Name);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__Name(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__Name, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__Name);
	return soap_out_xsd__Name(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__Name(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	return soap_out_xsd__NCName(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__IDREF);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__IDREF(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__IDREF, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	return soap_out_xsd__IDREF(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char * * FASTCALL soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	return soap_out_xsd__ID(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_xsd__ID(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int FASTCALL soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * FASTCALL soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	return soap_out__QName(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in__QName(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int FASTCALL soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * FASTCALL soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{;
	char ** p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	return soap_out_string(soap, tag?tag:"byte", id, a, type) ? soap->error : soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if((p = soap_in_string(soap, tag, p, type)))
		if(soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of vetisamsC.cpp */
